"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __reflectGet = Reflect.get;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step2(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step2((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/core-js/internals/global-this.js
  var require_global_this = __commonJS({
    "node_modules/core-js/internals/global-this.js"(exports, module) {
      "use strict";
      var check2 = function(it) {
        return it && it.Math === Math && it;
      };
      module.exports = // eslint-disable-next-line es/no-global-this -- safe
      check2(typeof globalThis == "object" && globalThis) || check2(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      check2(typeof self == "object" && self) || check2(typeof global == "object" && global) || check2(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
      /* @__PURE__ */ (function() {
        return this;
      })() || Function("return this")();
    }
  });

  // node_modules/core-js/internals/fails.js
  var require_fails = __commonJS({
    "node_modules/core-js/internals/fails.js"(exports, module) {
      "use strict";
      module.exports = function(exec) {
        try {
          return !!exec();
        } catch (error) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/internals/descriptors.js
  var require_descriptors = __commonJS({
    "node_modules/core-js/internals/descriptors.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = !fails(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    }
  });

  // node_modules/core-js/internals/function-bind-native.js
  var require_function_bind_native = __commonJS({
    "node_modules/core-js/internals/function-bind-native.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = !fails(function() {
        var test = (function() {
        }).bind();
        return typeof test != "function" || test.hasOwnProperty("prototype");
      });
    }
  });

  // node_modules/core-js/internals/function-call.js
  var require_function_call = __commonJS({
    "node_modules/core-js/internals/function-call.js"(exports, module) {
      "use strict";
      var NATIVE_BIND = require_function_bind_native();
      var call = Function.prototype.call;
      module.exports = NATIVE_BIND ? call.bind(call) : function() {
        return call.apply(call, arguments);
      };
    }
  });

  // node_modules/core-js/internals/object-property-is-enumerable.js
  var require_object_property_is_enumerable = __commonJS({
    "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
      "use strict";
      var $propertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
      exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
        var descriptor = getOwnPropertyDescriptor(this, V);
        return !!descriptor && descriptor.enumerable;
      } : $propertyIsEnumerable;
    }
  });

  // node_modules/core-js/internals/create-property-descriptor.js
  var require_create_property_descriptor = __commonJS({
    "node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
      "use strict";
      module.exports = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
    }
  });

  // node_modules/core-js/internals/function-uncurry-this.js
  var require_function_uncurry_this = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
      "use strict";
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var call = FunctionPrototype.call;
      var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
      module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
        return function() {
          return call.apply(fn, arguments);
        };
      };
    }
  });

  // node_modules/core-js/internals/classof-raw.js
  var require_classof_raw = __commonJS({
    "node_modules/core-js/internals/classof-raw.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toString = uncurryThis({}.toString);
      var stringSlice = uncurryThis("".slice);
      module.exports = function(it) {
        return stringSlice(toString(it), 8, -1);
      };
    }
  });

  // node_modules/core-js/internals/indexed-object.js
  var require_indexed_object = __commonJS({
    "node_modules/core-js/internals/indexed-object.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var classof = require_classof_raw();
      var $Object = Object;
      var split = uncurryThis("".split);
      module.exports = fails(function() {
        return !$Object("z").propertyIsEnumerable(0);
      }) ? function(it) {
        return classof(it) === "String" ? split(it, "") : $Object(it);
      } : $Object;
    }
  });

  // node_modules/core-js/internals/is-null-or-undefined.js
  var require_is_null_or_undefined = __commonJS({
    "node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
      "use strict";
      module.exports = function(it) {
        return it === null || it === void 0;
      };
    }
  });

  // node_modules/core-js/internals/require-object-coercible.js
  var require_require_object_coercible = __commonJS({
    "node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
      "use strict";
      var isNullOrUndefined = require_is_null_or_undefined();
      var $TypeError = TypeError;
      module.exports = function(it) {
        if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
        return it;
      };
    }
  });

  // node_modules/core-js/internals/to-indexed-object.js
  var require_to_indexed_object = __commonJS({
    "node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
      "use strict";
      var IndexedObject = require_indexed_object();
      var requireObjectCoercible = require_require_object_coercible();
      module.exports = function(it) {
        return IndexedObject(requireObjectCoercible(it));
      };
    }
  });

  // node_modules/core-js/internals/is-callable.js
  var require_is_callable = __commonJS({
    "node_modules/core-js/internals/is-callable.js"(exports, module) {
      "use strict";
      var documentAll = typeof document == "object" && document.all;
      module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
        return typeof argument == "function" || argument === documentAll;
      } : function(argument) {
        return typeof argument == "function";
      };
    }
  });

  // node_modules/core-js/internals/is-object.js
  var require_is_object = __commonJS({
    "node_modules/core-js/internals/is-object.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      module.exports = function(it) {
        return typeof it == "object" ? it !== null : isCallable(it);
      };
    }
  });

  // node_modules/core-js/internals/get-built-in.js
  var require_get_built_in = __commonJS({
    "node_modules/core-js/internals/get-built-in.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var isCallable = require_is_callable();
      var aFunction = function(argument) {
        return isCallable(argument) ? argument : void 0;
      };
      module.exports = function(namespace2, method) {
        return arguments.length < 2 ? aFunction(globalThis2[namespace2]) : globalThis2[namespace2] && globalThis2[namespace2][method];
      };
    }
  });

  // node_modules/core-js/internals/object-is-prototype-of.js
  var require_object_is_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis({}.isPrototypeOf);
    }
  });

  // node_modules/core-js/internals/environment-user-agent.js
  var require_environment_user_agent = __commonJS({
    "node_modules/core-js/internals/environment-user-agent.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var navigator2 = globalThis2.navigator;
      var userAgent = navigator2 && navigator2.userAgent;
      module.exports = userAgent ? String(userAgent) : "";
    }
  });

  // node_modules/core-js/internals/environment-v8-version.js
  var require_environment_v8_version = __commonJS({
    "node_modules/core-js/internals/environment-v8-version.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var userAgent = require_environment_user_agent();
      var process = globalThis2.process;
      var Deno2 = globalThis2.Deno;
      var versions = process && process.versions || Deno2 && Deno2.version;
      var v8 = versions && versions.v8;
      var match;
      var version;
      if (v8) {
        match = v8.split(".");
        version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
      }
      if (!version && userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match) version = +match[1];
        }
      }
      module.exports = version;
    }
  });

  // node_modules/core-js/internals/symbol-constructor-detection.js
  var require_symbol_constructor_detection = __commonJS({
    "node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
      "use strict";
      var V8_VERSION = require_environment_v8_version();
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var $String = globalThis2.String;
      module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
        var symbol = Symbol("symbol detection");
        return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && V8_VERSION && V8_VERSION < 41;
      });
    }
  });

  // node_modules/core-js/internals/use-symbol-as-uid.js
  var require_use_symbol_as_uid = __commonJS({
    "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
      "use strict";
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  });

  // node_modules/core-js/internals/is-symbol.js
  var require_is_symbol = __commonJS({
    "node_modules/core-js/internals/is-symbol.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var $Object = Object;
      module.exports = USE_SYMBOL_AS_UID ? function(it) {
        return typeof it == "symbol";
      } : function(it) {
        var $Symbol = getBuiltIn("Symbol");
        return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
      };
    }
  });

  // node_modules/core-js/internals/try-to-string.js
  var require_try_to_string = __commonJS({
    "node_modules/core-js/internals/try-to-string.js"(exports, module) {
      "use strict";
      var $String = String;
      module.exports = function(argument) {
        try {
          return $String(argument);
        } catch (error) {
          return "Object";
        }
      };
    }
  });

  // node_modules/core-js/internals/a-callable.js
  var require_a_callable = __commonJS({
    "node_modules/core-js/internals/a-callable.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isCallable(argument)) return argument;
        throw new $TypeError(tryToString(argument) + " is not a function");
      };
    }
  });

  // node_modules/core-js/internals/get-method.js
  var require_get_method = __commonJS({
    "node_modules/core-js/internals/get-method.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var isNullOrUndefined = require_is_null_or_undefined();
      module.exports = function(V, P) {
        var func = V[P];
        return isNullOrUndefined(func) ? void 0 : aCallable(func);
      };
    }
  });

  // node_modules/core-js/internals/ordinary-to-primitive.js
  var require_ordinary_to_primitive = __commonJS({
    "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var isCallable = require_is_callable();
      var isObject4 = require_is_object();
      var $TypeError = TypeError;
      module.exports = function(input, pref) {
        var fn, val;
        if (pref === "string" && isCallable(fn = input.toString) && !isObject4(val = call(fn, input))) return val;
        if (isCallable(fn = input.valueOf) && !isObject4(val = call(fn, input))) return val;
        if (pref !== "string" && isCallable(fn = input.toString) && !isObject4(val = call(fn, input))) return val;
        throw new $TypeError("Can't convert object to primitive value");
      };
    }
  });

  // node_modules/core-js/internals/is-pure.js
  var require_is_pure = __commonJS({
    "node_modules/core-js/internals/is-pure.js"(exports, module) {
      "use strict";
      module.exports = false;
    }
  });

  // node_modules/core-js/internals/define-global-property.js
  var require_define_global_property = __commonJS({
    "node_modules/core-js/internals/define-global-property.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var defineProperty = Object.defineProperty;
      module.exports = function(key, value) {
        try {
          defineProperty(globalThis2, key, { value, configurable: true, writable: true });
        } catch (error) {
          globalThis2[key] = value;
        }
        return value;
      };
    }
  });

  // node_modules/core-js/internals/shared-store.js
  var require_shared_store = __commonJS({
    "node_modules/core-js/internals/shared-store.js"(exports, module) {
      "use strict";
      var IS_PURE = require_is_pure();
      var globalThis2 = require_global_this();
      var defineGlobalProperty = require_define_global_property();
      var SHARED = "__core-js_shared__";
      var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
      (store.versions || (store.versions = [])).push({
        version: "3.46.0",
        mode: IS_PURE ? "pure" : "global",
        copyright: "\xA9 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)",
        license: "https://github.com/zloirock/core-js/blob/v3.46.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  });

  // node_modules/core-js/internals/shared.js
  var require_shared = __commonJS({
    "node_modules/core-js/internals/shared.js"(exports, module) {
      "use strict";
      var store = require_shared_store();
      module.exports = function(key, value) {
        return store[key] || (store[key] = value || {});
      };
    }
  });

  // node_modules/core-js/internals/to-object.js
  var require_to_object = __commonJS({
    "node_modules/core-js/internals/to-object.js"(exports, module) {
      "use strict";
      var requireObjectCoercible = require_require_object_coercible();
      var $Object = Object;
      module.exports = function(argument) {
        return $Object(requireObjectCoercible(argument));
      };
    }
  });

  // node_modules/core-js/internals/has-own-property.js
  var require_has_own_property = __commonJS({
    "node_modules/core-js/internals/has-own-property.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var hasOwnProperty = uncurryThis({}.hasOwnProperty);
      module.exports = Object.hasOwn || function hasOwn(it, key) {
        return hasOwnProperty(toObject(it), key);
      };
    }
  });

  // node_modules/core-js/internals/uid.js
  var require_uid = __commonJS({
    "node_modules/core-js/internals/uid.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var id = 0;
      var postfix = Math.random();
      var toString = uncurryThis(1.1.toString);
      module.exports = function(key) {
        return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
      };
    }
  });

  // node_modules/core-js/internals/well-known-symbol.js
  var require_well_known_symbol = __commonJS({
    "node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var shared = require_shared();
      var hasOwn = require_has_own_property();
      var uid = require_uid();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var Symbol2 = globalThis2.Symbol;
      var WellKnownSymbolsStore = shared("wks");
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
      module.exports = function(name) {
        if (!hasOwn(WellKnownSymbolsStore, name)) {
          WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
        }
        return WellKnownSymbolsStore[name];
      };
    }
  });

  // node_modules/core-js/internals/to-primitive.js
  var require_to_primitive = __commonJS({
    "node_modules/core-js/internals/to-primitive.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var isObject4 = require_is_object();
      var isSymbol = require_is_symbol();
      var getMethod = require_get_method();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var $TypeError = TypeError;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      module.exports = function(input, pref) {
        if (!isObject4(input) || isSymbol(input)) return input;
        var exoticToPrim = getMethod(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
          if (pref === void 0) pref = "default";
          result = call(exoticToPrim, input, pref);
          if (!isObject4(result) || isSymbol(result)) return result;
          throw new $TypeError("Can't convert object to primitive value");
        }
        if (pref === void 0) pref = "number";
        return ordinaryToPrimitive(input, pref);
      };
    }
  });

  // node_modules/core-js/internals/to-property-key.js
  var require_to_property_key = __commonJS({
    "node_modules/core-js/internals/to-property-key.js"(exports, module) {
      "use strict";
      var toPrimitive = require_to_primitive();
      var isSymbol = require_is_symbol();
      module.exports = function(argument) {
        var key = toPrimitive(argument, "string");
        return isSymbol(key) ? key : key + "";
      };
    }
  });

  // node_modules/core-js/internals/document-create-element.js
  var require_document_create_element = __commonJS({
    "node_modules/core-js/internals/document-create-element.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var isObject4 = require_is_object();
      var document2 = globalThis2.document;
      var EXISTS = isObject4(document2) && isObject4(document2.createElement);
      module.exports = function(it) {
        return EXISTS ? document2.createElement(it) : {};
      };
    }
  });

  // node_modules/core-js/internals/ie8-dom-define.js
  var require_ie8_dom_define = __commonJS({
    "node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var createElement = require_document_create_element();
      module.exports = !DESCRIPTORS && !fails(function() {
        return Object.defineProperty(createElement("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    }
  });

  // node_modules/core-js/internals/object-get-own-property-descriptor.js
  var require_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var call = require_function_call();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var createPropertyDescriptor = require_create_property_descriptor();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
        O = toIndexedObject(O);
        P = toPropertyKey(P);
        if (IE8_DOM_DEFINE) try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
        if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
      };
    }
  });

  // node_modules/core-js/internals/v8-prototype-define-bug.js
  var require_v8_prototype_define_bug = __commonJS({
    "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      module.exports = DESCRIPTORS && fails(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: false
        }).prototype !== 42;
      });
    }
  });

  // node_modules/core-js/internals/an-object.js
  var require_an_object = __commonJS({
    "node_modules/core-js/internals/an-object.js"(exports, module) {
      "use strict";
      var isObject4 = require_is_object();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isObject4(argument)) return argument;
        throw new $TypeError($String(argument) + " is not an object");
      };
    }
  });

  // node_modules/core-js/internals/object-define-property.js
  var require_object_define_property = __commonJS({
    "node_modules/core-js/internals/object-define-property.js"(exports) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var $TypeError = TypeError;
      var $defineProperty = Object.defineProperty;
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var ENUMERABLE = "enumerable";
      var CONFIGURABLE = "configurable";
      var WRITABLE = "writable";
      exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPropertyKey(P);
        anObject(Attributes);
        if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
          var current = $getOwnPropertyDescriptor(O, P);
          if (current && current[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = {
              configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
              enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
              writable: false
            };
          }
        }
        return $defineProperty(O, P, Attributes);
      } : $defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPropertyKey(P);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
        if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
        if ("value" in Attributes) O[P] = Attributes.value;
        return O;
      };
    }
  });

  // node_modules/core-js/internals/create-non-enumerable-property.js
  var require_create_non_enumerable_property = __commonJS({
    "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = DESCRIPTORS ? function(object, key, value) {
        return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
    }
  });

  // node_modules/core-js/internals/function-name.js
  var require_function_name = __commonJS({
    "node_modules/core-js/internals/function-name.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var hasOwn = require_has_own_property();
      var FunctionPrototype = Function.prototype;
      var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
      var EXISTS = hasOwn(FunctionPrototype, "name");
      var PROPER = EXISTS && (function something() {
      }).name === "something";
      var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
      module.exports = {
        EXISTS,
        PROPER,
        CONFIGURABLE
      };
    }
  });

  // node_modules/core-js/internals/inspect-source.js
  var require_inspect_source = __commonJS({
    "node_modules/core-js/internals/inspect-source.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var isCallable = require_is_callable();
      var store = require_shared_store();
      var functionToString = uncurryThis(Function.toString);
      if (!isCallable(store.inspectSource)) {
        store.inspectSource = function(it) {
          return functionToString(it);
        };
      }
      module.exports = store.inspectSource;
    }
  });

  // node_modules/core-js/internals/weak-map-basic-detection.js
  var require_weak_map_basic_detection = __commonJS({
    "node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var isCallable = require_is_callable();
      var WeakMap2 = globalThis2.WeakMap;
      module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
    }
  });

  // node_modules/core-js/internals/shared-key.js
  var require_shared_key = __commonJS({
    "node_modules/core-js/internals/shared-key.js"(exports, module) {
      "use strict";
      var shared = require_shared();
      var uid = require_uid();
      var keys = shared("keys");
      module.exports = function(key) {
        return keys[key] || (keys[key] = uid(key));
      };
    }
  });

  // node_modules/core-js/internals/hidden-keys.js
  var require_hidden_keys = __commonJS({
    "node_modules/core-js/internals/hidden-keys.js"(exports, module) {
      "use strict";
      module.exports = {};
    }
  });

  // node_modules/core-js/internals/internal-state.js
  var require_internal_state = __commonJS({
    "node_modules/core-js/internals/internal-state.js"(exports, module) {
      "use strict";
      var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
      var globalThis2 = require_global_this();
      var isObject4 = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var hasOwn = require_has_own_property();
      var shared = require_shared_store();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
      var TypeError2 = globalThis2.TypeError;
      var WeakMap2 = globalThis2.WeakMap;
      var set;
      var get;
      var has;
      var enforce = function(it) {
        return has(it) ? get(it) : set(it, {});
      };
      var getterFor = function(TYPE) {
        return function(it) {
          var state3;
          if (!isObject4(it) || (state3 = get(it)).type !== TYPE) {
            throw new TypeError2("Incompatible receiver, " + TYPE + " required");
          }
          return state3;
        };
      };
      if (NATIVE_WEAK_MAP || shared.state) {
        store = shared.state || (shared.state = new WeakMap2());
        store.get = store.get;
        store.has = store.has;
        store.set = store.set;
        set = function(it, metadata2) {
          if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata2.facade = it;
          store.set(it, metadata2);
          return metadata2;
        };
        get = function(it) {
          return store.get(it) || {};
        };
        has = function(it) {
          return store.has(it);
        };
      } else {
        STATE = sharedKey("state");
        hiddenKeys[STATE] = true;
        set = function(it, metadata2) {
          if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata2.facade = it;
          createNonEnumerableProperty(it, STATE, metadata2);
          return metadata2;
        };
        get = function(it) {
          return hasOwn(it, STATE) ? it[STATE] : {};
        };
        has = function(it) {
          return hasOwn(it, STATE);
        };
      }
      var store;
      var STATE;
      module.exports = {
        set,
        get,
        has,
        enforce,
        getterFor
      };
    }
  });

  // node_modules/core-js/internals/make-built-in.js
  var require_make_built_in = __commonJS({
    "node_modules/core-js/internals/make-built-in.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var DESCRIPTORS = require_descriptors();
      var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
      var inspectSource = require_inspect_source();
      var InternalStateModule = require_internal_state();
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var $String = String;
      var defineProperty = Object.defineProperty;
      var stringSlice = uncurryThis("".slice);
      var replace = uncurryThis("".replace);
      var join = uncurryThis([].join);
      var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
        return defineProperty(function() {
        }, "length", { value: 8 }).length !== 8;
      });
      var TEMPLATE = String(String).split("String");
      var makeBuiltIn = module.exports = function(value, name, options) {
        if (stringSlice($String(name), 0, 7) === "Symbol(") {
          name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
        }
        if (options && options.getter) name = "get " + name;
        if (options && options.setter) name = "set " + name;
        if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
          if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
          else value.name = name;
        }
        if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
          defineProperty(value, "length", { value: options.arity });
        }
        try {
          if (options && hasOwn(options, "constructor") && options.constructor) {
            if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
          } else if (value.prototype) value.prototype = void 0;
        } catch (error) {
        }
        var state3 = enforceInternalState(value);
        if (!hasOwn(state3, "source")) {
          state3.source = join(TEMPLATE, typeof name == "string" ? name : "");
        }
        return value;
      };
      Function.prototype.toString = makeBuiltIn(function toString() {
        return isCallable(this) && getInternalState(this).source || inspectSource(this);
      }, "toString");
    }
  });

  // node_modules/core-js/internals/define-built-in.js
  var require_define_built_in = __commonJS({
    "node_modules/core-js/internals/define-built-in.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var definePropertyModule = require_object_define_property();
      var makeBuiltIn = require_make_built_in();
      var defineGlobalProperty = require_define_global_property();
      module.exports = function(O, key, value, options) {
        if (!options) options = {};
        var simple = options.enumerable;
        var name = options.name !== void 0 ? options.name : key;
        if (isCallable(value)) makeBuiltIn(value, name, options);
        if (options.global) {
          if (simple) O[key] = value;
          else defineGlobalProperty(key, value);
        } else {
          try {
            if (!options.unsafe) delete O[key];
            else if (O[key]) simple = true;
          } catch (error) {
          }
          if (simple) O[key] = value;
          else definePropertyModule.f(O, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
        }
        return O;
      };
    }
  });

  // node_modules/core-js/internals/math-trunc.js
  var require_math_trunc = __commonJS({
    "node_modules/core-js/internals/math-trunc.js"(exports, module) {
      "use strict";
      var ceil = Math.ceil;
      var floor = Math.floor;
      module.exports = Math.trunc || function trunc(x) {
        var n = +x;
        return (n > 0 ? floor : ceil)(n);
      };
    }
  });

  // node_modules/core-js/internals/to-integer-or-infinity.js
  var require_to_integer_or_infinity = __commonJS({
    "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
      "use strict";
      var trunc = require_math_trunc();
      module.exports = function(argument) {
        var number = +argument;
        return number !== number || number === 0 ? 0 : trunc(number);
      };
    }
  });

  // node_modules/core-js/internals/to-absolute-index.js
  var require_to_absolute_index = __commonJS({
    "node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var max = Math.max;
      var min = Math.min;
      module.exports = function(index, length) {
        var integer = toIntegerOrInfinity(index);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
      };
    }
  });

  // node_modules/core-js/internals/to-length.js
  var require_to_length = __commonJS({
    "node_modules/core-js/internals/to-length.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var min = Math.min;
      module.exports = function(argument) {
        var len = toIntegerOrInfinity(argument);
        return len > 0 ? min(len, 9007199254740991) : 0;
      };
    }
  });

  // node_modules/core-js/internals/length-of-array-like.js
  var require_length_of_array_like = __commonJS({
    "node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
      "use strict";
      var toLength = require_to_length();
      module.exports = function(obj) {
        return toLength(obj.length);
      };
    }
  });

  // node_modules/core-js/internals/array-includes.js
  var require_array_includes = __commonJS({
    "node_modules/core-js/internals/array-includes.js"(exports, module) {
      "use strict";
      var toIndexedObject = require_to_indexed_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var createMethod = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = toIndexedObject($this);
          var length = lengthOfArrayLike(O);
          if (length === 0) return !IS_INCLUDES && -1;
          var index = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el !== el) while (length > index) {
            value = O[index++];
            if (value !== value) return true;
          }
          else for (; length > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
          }
          return !IS_INCLUDES && -1;
        };
      };
      module.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false)
      };
    }
  });

  // node_modules/core-js/internals/object-keys-internal.js
  var require_object_keys_internal = __commonJS({
    "node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var toIndexedObject = require_to_indexed_object();
      var indexOf = require_array_includes().indexOf;
      var hiddenKeys = require_hidden_keys();
      var push = uncurryThis([].push);
      module.exports = function(object, names) {
        var O = toIndexedObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
        while (names.length > i) if (hasOwn(O, key = names[i++])) {
          ~indexOf(result, key) || push(result, key);
        }
        return result;
      };
    }
  });

  // node_modules/core-js/internals/enum-bug-keys.js
  var require_enum_bug_keys = __commonJS({
    "node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
      "use strict";
      module.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  });

  // node_modules/core-js/internals/object-get-own-property-names.js
  var require_object_get_own_property_names = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
      "use strict";
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return internalObjectKeys(O, hiddenKeys);
      };
    }
  });

  // node_modules/core-js/internals/object-get-own-property-symbols.js
  var require_object_get_own_property_symbols = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
      "use strict";
      exports.f = Object.getOwnPropertySymbols;
    }
  });

  // node_modules/core-js/internals/own-keys.js
  var require_own_keys = __commonJS({
    "node_modules/core-js/internals/own-keys.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var anObject = require_an_object();
      var concat = uncurryThis([].concat);
      module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
        var keys = getOwnPropertyNamesModule.f(anObject(it));
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
      };
    }
  });

  // node_modules/core-js/internals/copy-constructor-properties.js
  var require_copy_constructor_properties = __commonJS({
    "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
      "use strict";
      var hasOwn = require_has_own_property();
      var ownKeys = require_own_keys();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      module.exports = function(target, source, exceptions) {
        var keys = ownKeys(source);
        var defineProperty = definePropertyModule.f;
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
    }
  });

  // node_modules/core-js/internals/is-forced.js
  var require_is_forced = __commonJS({
    "node_modules/core-js/internals/is-forced.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var isCallable = require_is_callable();
      var replacement = /#|\.prototype\./;
      var isForced = function(feature, detection) {
        var value = data[normalize(feature)];
        return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
      };
      var normalize = isForced.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data = isForced.data = {};
      var NATIVE = isForced.NATIVE = "N";
      var POLYFILL = isForced.POLYFILL = "P";
      module.exports = isForced;
    }
  });

  // node_modules/core-js/internals/export.js
  var require_export = __commonJS({
    "node_modules/core-js/internals/export.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var defineGlobalProperty = require_define_global_property();
      var copyConstructorProperties = require_copy_constructor_properties();
      var isForced = require_is_forced();
      module.exports = function(options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = globalThis2;
        } else if (STATIC) {
          target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
        } else {
          target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
        }
        if (target) for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty) continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options);
        }
      };
    }
  });

  // node_modules/core-js/internals/to-string-tag-support.js
  var require_to_string_tag_support = __commonJS({
    "node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var test = {};
      test[TO_STRING_TAG] = "z";
      module.exports = String(test) === "[object z]";
    }
  });

  // node_modules/core-js/internals/classof.js
  var require_classof = __commonJS({
    "node_modules/core-js/internals/classof.js"(exports, module) {
      "use strict";
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var isCallable = require_is_callable();
      var classofRaw = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Object = Object;
      var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ (function() {
        return arguments;
      })()) === "Arguments";
      var tryGet = function(it, key) {
        try {
          return it[key];
        } catch (error) {
        }
      };
      module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
        var O, tag, result;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
      };
    }
  });

  // node_modules/core-js/internals/to-string.js
  var require_to_string = __commonJS({
    "node_modules/core-js/internals/to-string.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      var $String = String;
      module.exports = function(argument) {
        if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
        return $String(argument);
      };
    }
  });

  // node_modules/core-js/internals/object-keys.js
  var require_object_keys = __commonJS({
    "node_modules/core-js/internals/object-keys.js"(exports, module) {
      "use strict";
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      module.exports = Object.keys || function keys(O) {
        return internalObjectKeys(O, enumBugKeys);
      };
    }
  });

  // node_modules/core-js/internals/object-define-properties.js
  var require_object_define_properties = __commonJS({
    "node_modules/core-js/internals/object-define-properties.js"(exports) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var definePropertyModule = require_object_define_property();
      var anObject = require_an_object();
      var toIndexedObject = require_to_indexed_object();
      var objectKeys = require_object_keys();
      exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties2(O, Properties) {
        anObject(O);
        var props = toIndexedObject(Properties);
        var keys = objectKeys(Properties);
        var length = keys.length;
        var index = 0;
        var key;
        while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
        return O;
      };
    }
  });

  // node_modules/core-js/internals/html.js
  var require_html = __commonJS({
    "node_modules/core-js/internals/html.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      module.exports = getBuiltIn("document", "documentElement");
    }
  });

  // node_modules/core-js/internals/object-create.js
  var require_object_create = __commonJS({
    "node_modules/core-js/internals/object-create.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var definePropertiesModule = require_object_define_properties();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = require_hidden_keys();
      var html = require_html();
      var documentCreateElement = require_document_create_element();
      var sharedKey = require_shared_key();
      var GT = ">";
      var LT = "<";
      var PROTOTYPE = "prototype";
      var SCRIPT = "script";
      var IE_PROTO = sharedKey("IE_PROTO");
      var EmptyConstructor = function() {
      };
      var scriptTag = function(content) {
        return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
      };
      var NullProtoObjectViaActiveX = function(activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      };
      var NullProtoObjectViaIFrame = function() {
        var iframe = documentCreateElement("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      };
      var activeXDocument;
      var NullProtoObject = function() {
        try {
          activeXDocument = new ActiveXObject("htmlfile");
        } catch (error) {
        }
        NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
        var length = enumBugKeys.length;
        while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
        return NullProtoObject();
      };
      hiddenKeys[IE_PROTO] = true;
      module.exports = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
          EmptyConstructor[PROTOTYPE] = anObject(O);
          result = new EmptyConstructor();
          EmptyConstructor[PROTOTYPE] = null;
          result[IE_PROTO] = O;
        } else result = NullProtoObject();
        return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
      };
    }
  });

  // node_modules/core-js/internals/array-slice.js
  var require_array_slice = __commonJS({
    "node_modules/core-js/internals/array-slice.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis([].slice);
    }
  });

  // node_modules/core-js/internals/object-get-own-property-names-external.js
  var require_object_get_own_property_names_external = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names-external.js"(exports, module) {
      "use strict";
      var classof = require_classof_raw();
      var toIndexedObject = require_to_indexed_object();
      var $getOwnPropertyNames = require_object_get_own_property_names().f;
      var arraySlice = require_array_slice();
      var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function(it) {
        try {
          return $getOwnPropertyNames(it);
        } catch (error) {
          return arraySlice(windowNames);
        }
      };
      module.exports.f = function getOwnPropertyNames(it) {
        return windowNames && classof(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
      };
    }
  });

  // node_modules/core-js/internals/define-built-in-accessor.js
  var require_define_built_in_accessor = __commonJS({
    "node_modules/core-js/internals/define-built-in-accessor.js"(exports, module) {
      "use strict";
      var makeBuiltIn = require_make_built_in();
      var defineProperty = require_object_define_property();
      module.exports = function(target, name, descriptor) {
        if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
        if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
        return defineProperty.f(target, name, descriptor);
      };
    }
  });

  // node_modules/core-js/internals/well-known-symbol-wrapped.js
  var require_well_known_symbol_wrapped = __commonJS({
    "node_modules/core-js/internals/well-known-symbol-wrapped.js"(exports) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      exports.f = wellKnownSymbol;
    }
  });

  // node_modules/core-js/internals/path.js
  var require_path = __commonJS({
    "node_modules/core-js/internals/path.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      module.exports = globalThis2;
    }
  });

  // node_modules/core-js/internals/well-known-symbol-define.js
  var require_well_known_symbol_define = __commonJS({
    "node_modules/core-js/internals/well-known-symbol-define.js"(exports, module) {
      "use strict";
      var path = require_path();
      var hasOwn = require_has_own_property();
      var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
      var defineProperty = require_object_define_property().f;
      module.exports = function(NAME) {
        var Symbol2 = path.Symbol || (path.Symbol = {});
        if (!hasOwn(Symbol2, NAME)) defineProperty(Symbol2, NAME, {
          value: wrappedWellKnownSymbolModule.f(NAME)
        });
      };
    }
  });

  // node_modules/core-js/internals/symbol-define-to-primitive.js
  var require_symbol_define_to_primitive = __commonJS({
    "node_modules/core-js/internals/symbol-define-to-primitive.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var getBuiltIn = require_get_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var defineBuiltIn = require_define_built_in();
      module.exports = function() {
        var Symbol2 = getBuiltIn("Symbol");
        var SymbolPrototype = Symbol2 && Symbol2.prototype;
        var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
          defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
            return call(valueOf, this);
          }, { arity: 1 });
        }
      };
    }
  });

  // node_modules/core-js/internals/set-to-string-tag.js
  var require_set_to_string_tag = __commonJS({
    "node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
      "use strict";
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      module.exports = function(target, TAG, STATIC) {
        if (target && !STATIC) target = target.prototype;
        if (target && !hasOwn(target, TO_STRING_TAG)) {
          defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
        }
      };
    }
  });

  // node_modules/core-js/internals/function-uncurry-this-clause.js
  var require_function_uncurry_this_clause = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
      "use strict";
      var classofRaw = require_classof_raw();
      var uncurryThis = require_function_uncurry_this();
      module.exports = function(fn) {
        if (classofRaw(fn) === "Function") return uncurryThis(fn);
      };
    }
  });

  // node_modules/core-js/internals/function-bind-context.js
  var require_function_bind_context = __commonJS({
    "node_modules/core-js/internals/function-bind-context.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this_clause();
      var aCallable = require_a_callable();
      var NATIVE_BIND = require_function_bind_native();
      var bind2 = uncurryThis(uncurryThis.bind);
      module.exports = function(fn, that) {
        aCallable(fn);
        return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
          return fn.apply(that, arguments);
        };
      };
    }
  });

  // node_modules/core-js/internals/is-array.js
  var require_is_array = __commonJS({
    "node_modules/core-js/internals/is-array.js"(exports, module) {
      "use strict";
      var classof = require_classof_raw();
      module.exports = Array.isArray || function isArray2(argument) {
        return classof(argument) === "Array";
      };
    }
  });

  // node_modules/core-js/internals/is-constructor.js
  var require_is_constructor = __commonJS({
    "node_modules/core-js/internals/is-constructor.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var classof = require_classof();
      var getBuiltIn = require_get_built_in();
      var inspectSource = require_inspect_source();
      var noop2 = function() {
      };
      var construct = getBuiltIn("Reflect", "construct");
      var constructorRegExp = /^\s*(?:class|function)\b/;
      var exec = uncurryThis(constructorRegExp.exec);
      var INCORRECT_TO_STRING = !constructorRegExp.test(noop2);
      var isConstructorModern = function isConstructor(argument) {
        if (!isCallable(argument)) return false;
        try {
          construct(noop2, [], argument);
          return true;
        } catch (error) {
          return false;
        }
      };
      var isConstructorLegacy = function isConstructor(argument) {
        if (!isCallable(argument)) return false;
        switch (classof(argument)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
        } catch (error) {
          return true;
        }
      };
      isConstructorLegacy.sham = true;
      module.exports = !construct || fails(function() {
        var called;
        return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
          called = true;
        }) || called;
      }) ? isConstructorLegacy : isConstructorModern;
    }
  });

  // node_modules/core-js/internals/array-species-constructor.js
  var require_array_species_constructor = __commonJS({
    "node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
      "use strict";
      var isArray2 = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject4 = require_is_object();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      var $Array = Array;
      module.exports = function(originalArray) {
        var C;
        if (isArray2(originalArray)) {
          C = originalArray.constructor;
          if (isConstructor(C) && (C === $Array || isArray2(C.prototype))) C = void 0;
          else if (isObject4(C)) {
            C = C[SPECIES];
            if (C === null) C = void 0;
          }
        }
        return C === void 0 ? $Array : C;
      };
    }
  });

  // node_modules/core-js/internals/array-species-create.js
  var require_array_species_create = __commonJS({
    "node_modules/core-js/internals/array-species-create.js"(exports, module) {
      "use strict";
      var arraySpeciesConstructor = require_array_species_constructor();
      module.exports = function(originalArray, length) {
        return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
      };
    }
  });

  // node_modules/core-js/internals/array-iteration.js
  var require_array_iteration = __commonJS({
    "node_modules/core-js/internals/array-iteration.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var IndexedObject = require_indexed_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var arraySpeciesCreate = require_array_species_create();
      var push = uncurryThis([].push);
      var createMethod = function(TYPE) {
        var IS_MAP = TYPE === 1;
        var IS_FILTER = TYPE === 2;
        var IS_SOME = TYPE === 3;
        var IS_EVERY = TYPE === 4;
        var IS_FIND_INDEX = TYPE === 6;
        var IS_FILTER_REJECT = TYPE === 7;
        var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
        return function($this, callbackfn, that, specificCreate) {
          var O = toObject($this);
          var self2 = IndexedObject(O);
          var length = lengthOfArrayLike(self2);
          var boundFunction = bind2(callbackfn, that);
          var index = 0;
          var create = specificCreate || arraySpeciesCreate;
          var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
          var value, result;
          for (; length > index; index++) if (NO_HOLES || index in self2) {
            value = self2[index];
            result = boundFunction(value, index, O);
            if (TYPE) {
              if (IS_MAP) target[index] = result;
              else if (result) switch (TYPE) {
                case 3:
                  return true;
                // some
                case 5:
                  return value;
                // find
                case 6:
                  return index;
                // findIndex
                case 2:
                  push(target, value);
              }
              else switch (TYPE) {
                case 4:
                  return false;
                // every
                case 7:
                  push(target, value);
              }
            }
          }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
      };
      module.exports = {
        // `Array.prototype.forEach` method
        // https://tc39.es/ecma262/#sec-array.prototype.foreach
        forEach: createMethod(0),
        // `Array.prototype.map` method
        // https://tc39.es/ecma262/#sec-array.prototype.map
        map: createMethod(1),
        // `Array.prototype.filter` method
        // https://tc39.es/ecma262/#sec-array.prototype.filter
        filter: createMethod(2),
        // `Array.prototype.some` method
        // https://tc39.es/ecma262/#sec-array.prototype.some
        some: createMethod(3),
        // `Array.prototype.every` method
        // https://tc39.es/ecma262/#sec-array.prototype.every
        every: createMethod(4),
        // `Array.prototype.find` method
        // https://tc39.es/ecma262/#sec-array.prototype.find
        find: createMethod(5),
        // `Array.prototype.findIndex` method
        // https://tc39.es/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod(6),
        // `Array.prototype.filterReject` method
        // https://github.com/tc39/proposal-array-filtering
        filterReject: createMethod(7)
      };
    }
  });

  // node_modules/core-js/modules/es.symbol.constructor.js
  var require_es_symbol_constructor = __commonJS({
    "node_modules/core-js/modules/es.symbol.constructor.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var anObject = require_an_object();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var $toString = require_to_string();
      var createPropertyDescriptor = require_create_property_descriptor();
      var nativeObjectCreate = require_object_create();
      var objectKeys = require_object_keys();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertyNamesExternal = require_object_get_own_property_names_external();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      var definePropertiesModule = require_object_define_properties();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var shared = require_shared();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var uid = require_uid();
      var wellKnownSymbol = require_well_known_symbol();
      var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var defineSymbolToPrimitive = require_symbol_define_to_primitive();
      var setToStringTag = require_set_to_string_tag();
      var InternalStateModule = require_internal_state();
      var $forEach = require_array_iteration().forEach;
      var HIDDEN = sharedKey("hidden");
      var SYMBOL = "Symbol";
      var PROTOTYPE = "prototype";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(SYMBOL);
      var ObjectPrototype = Object[PROTOTYPE];
      var $Symbol = globalThis2.Symbol;
      var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
      var RangeError2 = globalThis2.RangeError;
      var TypeError2 = globalThis2.TypeError;
      var QObject = globalThis2.QObject;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
      var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
      var push = uncurryThis([].push);
      var AllSymbols = shared("symbols");
      var ObjectPrototypeSymbols = shared("op-symbols");
      var WellKnownSymbolsStore = shared("wks");
      var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
      var fallbackDefineProperty = function(O, P, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
        if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
        nativeDefineProperty(O, P, Attributes);
        if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
          nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
        }
      };
      var setSymbolDescriptor = DESCRIPTORS && fails(function() {
        return nativeObjectCreate(nativeDefineProperty({}, "a", {
          get: function() {
            return nativeDefineProperty(this, "a", { value: 7 }).a;
          }
        })).a !== 7;
      }) ? fallbackDefineProperty : nativeDefineProperty;
      var wrap = function(tag, description) {
        var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
        setInternalState(symbol, {
          type: SYMBOL,
          tag,
          description
        });
        if (!DESCRIPTORS) symbol.description = description;
        return symbol;
      };
      var $defineProperty = function defineProperty(O, P, Attributes) {
        if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
        anObject(O);
        var key = toPropertyKey(P);
        anObject(Attributes);
        if (hasOwn(AllSymbols, key)) {
          if (!Attributes.enumerable) {
            if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
            O[HIDDEN][key] = true;
          } else {
            if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
          }
          return setSymbolDescriptor(O, key, Attributes);
        }
        return nativeDefineProperty(O, key, Attributes);
      };
      var $defineProperties = function defineProperties2(O, Properties) {
        anObject(O);
        var properties = toIndexedObject(Properties);
        var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach(keys, function(key) {
          if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
        });
        return O;
      };
      var $create = function create(O, Properties) {
        return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(V) {
        var P = toPropertyKey(V);
        var enumerable = call(nativePropertyIsEnumerable, this, P);
        if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
        return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
        var it = toIndexedObject(O);
        var key = toPropertyKey(P);
        if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
        var descriptor = nativeGetOwnPropertyDescriptor(it, key);
        if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
          descriptor.enumerable = true;
        }
        return descriptor;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(O) {
        var names = nativeGetOwnPropertyNames(toIndexedObject(O));
        var result = [];
        $forEach(names, function(key) {
          if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
        });
        return result;
      };
      var $getOwnPropertySymbols = function(O) {
        var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
        var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
        var result = [];
        $forEach(names, function(key) {
          if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
            push(result, AllSymbols[key]);
          }
        });
        return result;
      };
      if (!NATIVE_SYMBOL) {
        $Symbol = function Symbol2() {
          if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError2("Symbol is not a constructor");
          var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
          var tag = uid(description);
          var setter = function(value) {
            var $this = this === void 0 ? globalThis2 : this;
            if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
            if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
            var descriptor = createPropertyDescriptor(1, value);
            try {
              setSymbolDescriptor($this, tag, descriptor);
            } catch (error) {
              if (!(error instanceof RangeError2)) throw error;
              fallbackDefineProperty($this, tag, descriptor);
            }
          };
          if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
          return wrap(tag, description);
        };
        SymbolPrototype = $Symbol[PROTOTYPE];
        defineBuiltIn(SymbolPrototype, "toString", function toString() {
          return getInternalState(this).tag;
        });
        defineBuiltIn($Symbol, "withoutSetter", function(description) {
          return wrap(uid(description), description);
        });
        propertyIsEnumerableModule.f = $propertyIsEnumerable;
        definePropertyModule.f = $defineProperty;
        definePropertiesModule.f = $defineProperties;
        getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
        getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
        getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
        wrappedWellKnownSymbolModule.f = function(name) {
          return wrap(wellKnownSymbol(name), name);
        };
        if (DESCRIPTORS) {
          defineBuiltInAccessor(SymbolPrototype, "description", {
            configurable: true,
            get: function description() {
              return getInternalState(this).description;
            }
          });
          if (!IS_PURE) {
            defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
          }
        }
      }
      $({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
        Symbol: $Symbol
      });
      $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
        defineWellKnownSymbol(name);
      });
      $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
        useSetter: function() {
          USE_SETTER = true;
        },
        useSimple: function() {
          USE_SETTER = false;
        }
      });
      $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
        // `Object.create` method
        // https://tc39.es/ecma262/#sec-object.create
        create: $create,
        // `Object.defineProperty` method
        // https://tc39.es/ecma262/#sec-object.defineproperty
        defineProperty: $defineProperty,
        // `Object.defineProperties` method
        // https://tc39.es/ecma262/#sec-object.defineproperties
        defineProperties: $defineProperties,
        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor
      });
      $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
        // `Object.getOwnPropertyNames` method
        // https://tc39.es/ecma262/#sec-object.getownpropertynames
        getOwnPropertyNames: $getOwnPropertyNames
      });
      defineSymbolToPrimitive();
      setToStringTag($Symbol, SYMBOL);
      hiddenKeys[HIDDEN] = true;
    }
  });

  // node_modules/core-js/internals/symbol-registry-detection.js
  var require_symbol_registry_detection = __commonJS({
    "node_modules/core-js/internals/symbol-registry-detection.js"(exports, module) {
      "use strict";
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      module.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
    }
  });

  // node_modules/core-js/modules/es.symbol.for.js
  var require_es_symbol_for = __commonJS({
    "node_modules/core-js/modules/es.symbol.for.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var hasOwn = require_has_own_property();
      var toString = require_to_string();
      var shared = require_shared();
      var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
      var StringToSymbolRegistry = shared("string-to-symbol-registry");
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
        "for": function(key) {
          var string = toString(key);
          if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
          var symbol = getBuiltIn("Symbol")(string);
          StringToSymbolRegistry[string] = symbol;
          SymbolToStringRegistry[symbol] = string;
          return symbol;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.symbol.key-for.js
  var require_es_symbol_key_for = __commonJS({
    "node_modules/core-js/modules/es.symbol.key-for.js"() {
      "use strict";
      var $ = require_export();
      var hasOwn = require_has_own_property();
      var isSymbol = require_is_symbol();
      var tryToString = require_try_to_string();
      var shared = require_shared();
      var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
        keyFor: function keyFor(sym) {
          if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + " is not a symbol");
          if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
        }
      });
    }
  });

  // node_modules/core-js/internals/function-apply.js
  var require_function_apply = __commonJS({
    "node_modules/core-js/internals/function-apply.js"(exports, module) {
      "use strict";
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var apply = FunctionPrototype.apply;
      var call = FunctionPrototype.call;
      module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
        return call.apply(apply, arguments);
      });
    }
  });

  // node_modules/core-js/internals/get-json-replacer-function.js
  var require_get_json_replacer_function = __commonJS({
    "node_modules/core-js/internals/get-json-replacer-function.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var isArray2 = require_is_array();
      var isCallable = require_is_callable();
      var classof = require_classof_raw();
      var toString = require_to_string();
      var push = uncurryThis([].push);
      module.exports = function(replacer) {
        if (isCallable(replacer)) return replacer;
        if (!isArray2(replacer)) return;
        var rawLength = replacer.length;
        var keys = [];
        for (var i = 0; i < rawLength; i++) {
          var element = replacer[i];
          if (typeof element == "string") push(keys, element);
          else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String") push(keys, toString(element));
        }
        var keysLength = keys.length;
        var root2 = true;
        return function(key, value) {
          if (root2) {
            root2 = false;
            return value;
          }
          if (isArray2(this)) return value;
          for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
        };
      };
    }
  });

  // node_modules/core-js/modules/es.json.stringify.js
  var require_es_json_stringify = __commonJS({
    "node_modules/core-js/modules/es.json.stringify.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var isSymbol = require_is_symbol();
      var arraySlice = require_array_slice();
      var getReplacerFunction = require_get_json_replacer_function();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var $String = String;
      var $stringify = getBuiltIn("JSON", "stringify");
      var exec = uncurryThis(/./.exec);
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var replace = uncurryThis("".replace);
      var numberToString = uncurryThis(1.1.toString);
      var tester = /[\uD800-\uDFFF]/g;
      var low = /^[\uD800-\uDBFF]$/;
      var hi = /^[\uDC00-\uDFFF]$/;
      var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
        var symbol = getBuiltIn("Symbol")("stringify detection");
        return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
      });
      var ILL_FORMED_UNICODE = fails(function() {
        return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
      });
      var stringifyWithSymbolsFix = function(it, replacer) {
        var args = arraySlice(arguments);
        var $replacer = getReplacerFunction(replacer);
        if (!isCallable($replacer) && (it === void 0 || isSymbol(it))) return;
        args[1] = function(key, value) {
          if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
          if (!isSymbol(value)) return value;
        };
        return apply($stringify, null, args);
      };
      var fixIllFormed = function(match, offset, string) {
        var prev = charAt(string, offset - 1);
        var next = charAt(string, offset + 1);
        if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
          return "\\u" + numberToString(charCodeAt(match, 0), 16);
        }
        return match;
      };
      if ($stringify) {
        $({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          stringify: function stringify(it, replacer, space) {
            var args = arraySlice(arguments);
            var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
            return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-symbols.js
  var require_es_object_get_own_property_symbols = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-symbols.js"() {
      "use strict";
      var $ = require_export();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var fails = require_fails();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var toObject = require_to_object();
      var FORCED = !NATIVE_SYMBOL || fails(function() {
        getOwnPropertySymbolsModule.f(1);
      });
      $({ target: "Object", stat: true, forced: FORCED }, {
        getOwnPropertySymbols: function getOwnPropertySymbols(it) {
          var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
        }
      });
    }
  });

  // node_modules/core-js/modules/es.symbol.js
  var require_es_symbol = __commonJS({
    "node_modules/core-js/modules/es.symbol.js"() {
      "use strict";
      require_es_symbol_constructor();
      require_es_symbol_for();
      require_es_symbol_key_for();
      require_es_json_stringify();
      require_es_object_get_own_property_symbols();
    }
  });

  // node_modules/core-js/modules/es.symbol.description.js
  var require_es_symbol_description = __commonJS({
    "node_modules/core-js/modules/es.symbol.description.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var toString = require_to_string();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var copyConstructorProperties = require_copy_constructor_properties();
      var NativeSymbol = globalThis2.Symbol;
      var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
      if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
      NativeSymbol().description !== void 0)) {
        EmptyStringDescriptionStore = {};
        SymbolWrapper = function Symbol2() {
          var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
          var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
          if (description === "") EmptyStringDescriptionStore[result] = true;
          return result;
        };
        copyConstructorProperties(SymbolWrapper, NativeSymbol);
        SymbolWrapper.prototype = SymbolPrototype;
        SymbolPrototype.constructor = SymbolWrapper;
        NATIVE_SYMBOL = String(NativeSymbol("description detection")) === "Symbol(description detection)";
        thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
        symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
        regexp = /^Symbol\((.*)\)[^)]+$/;
        replace = uncurryThis("".replace);
        stringSlice = uncurryThis("".slice);
        defineBuiltInAccessor(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            var symbol = thisSymbolValue(this);
            if (hasOwn(EmptyStringDescriptionStore, symbol)) return "";
            var string = symbolDescriptiveString(symbol);
            var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
            return desc === "" ? void 0 : desc;
          }
        });
        $({ global: true, constructor: true, forced: true }, {
          Symbol: SymbolWrapper
        });
      }
      var EmptyStringDescriptionStore;
      var SymbolWrapper;
      var NATIVE_SYMBOL;
      var thisSymbolValue;
      var symbolDescriptiveString;
      var regexp;
      var replace;
      var stringSlice;
    }
  });

  // node_modules/core-js/modules/es.symbol.async-dispose.js
  var require_es_symbol_async_dispose = __commonJS({
    "node_modules/core-js/modules/es.symbol.async-dispose.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var defineProperty = require_object_define_property().f;
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var Symbol2 = globalThis2.Symbol;
      defineWellKnownSymbol("asyncDispose");
      if (Symbol2) {
        descriptor = getOwnPropertyDescriptor(Symbol2, "asyncDispose");
        if (descriptor.enumerable && descriptor.configurable && descriptor.writable) {
          defineProperty(Symbol2, "asyncDispose", { value: descriptor.value, enumerable: false, configurable: false, writable: false });
        }
      }
      var descriptor;
    }
  });

  // node_modules/core-js/modules/es.symbol.async-iterator.js
  var require_es_symbol_async_iterator = __commonJS({
    "node_modules/core-js/modules/es.symbol.async-iterator.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("asyncIterator");
    }
  });

  // node_modules/core-js/modules/es.symbol.dispose.js
  var require_es_symbol_dispose = __commonJS({
    "node_modules/core-js/modules/es.symbol.dispose.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var defineProperty = require_object_define_property().f;
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var Symbol2 = globalThis2.Symbol;
      defineWellKnownSymbol("dispose");
      if (Symbol2) {
        descriptor = getOwnPropertyDescriptor(Symbol2, "dispose");
        if (descriptor.enumerable && descriptor.configurable && descriptor.writable) {
          defineProperty(Symbol2, "dispose", { value: descriptor.value, enumerable: false, configurable: false, writable: false });
        }
      }
      var descriptor;
    }
  });

  // node_modules/core-js/modules/es.symbol.has-instance.js
  var require_es_symbol_has_instance = __commonJS({
    "node_modules/core-js/modules/es.symbol.has-instance.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("hasInstance");
    }
  });

  // node_modules/core-js/modules/es.symbol.is-concat-spreadable.js
  var require_es_symbol_is_concat_spreadable = __commonJS({
    "node_modules/core-js/modules/es.symbol.is-concat-spreadable.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("isConcatSpreadable");
    }
  });

  // node_modules/core-js/modules/es.symbol.iterator.js
  var require_es_symbol_iterator = __commonJS({
    "node_modules/core-js/modules/es.symbol.iterator.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("iterator");
    }
  });

  // node_modules/core-js/modules/es.symbol.match.js
  var require_es_symbol_match = __commonJS({
    "node_modules/core-js/modules/es.symbol.match.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("match");
    }
  });

  // node_modules/core-js/modules/es.symbol.match-all.js
  var require_es_symbol_match_all = __commonJS({
    "node_modules/core-js/modules/es.symbol.match-all.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("matchAll");
    }
  });

  // node_modules/core-js/modules/es.symbol.replace.js
  var require_es_symbol_replace = __commonJS({
    "node_modules/core-js/modules/es.symbol.replace.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("replace");
    }
  });

  // node_modules/core-js/modules/es.symbol.search.js
  var require_es_symbol_search = __commonJS({
    "node_modules/core-js/modules/es.symbol.search.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("search");
    }
  });

  // node_modules/core-js/modules/es.symbol.species.js
  var require_es_symbol_species = __commonJS({
    "node_modules/core-js/modules/es.symbol.species.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("species");
    }
  });

  // node_modules/core-js/modules/es.symbol.split.js
  var require_es_symbol_split = __commonJS({
    "node_modules/core-js/modules/es.symbol.split.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("split");
    }
  });

  // node_modules/core-js/modules/es.symbol.to-primitive.js
  var require_es_symbol_to_primitive = __commonJS({
    "node_modules/core-js/modules/es.symbol.to-primitive.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var defineSymbolToPrimitive = require_symbol_define_to_primitive();
      defineWellKnownSymbol("toPrimitive");
      defineSymbolToPrimitive();
    }
  });

  // node_modules/core-js/modules/es.symbol.to-string-tag.js
  var require_es_symbol_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.symbol.to-string-tag.js"() {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var setToStringTag = require_set_to_string_tag();
      defineWellKnownSymbol("toStringTag");
      setToStringTag(getBuiltIn("Symbol"), "Symbol");
    }
  });

  // node_modules/core-js/modules/es.symbol.unscopables.js
  var require_es_symbol_unscopables = __commonJS({
    "node_modules/core-js/modules/es.symbol.unscopables.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("unscopables");
    }
  });

  // node_modules/core-js/internals/function-uncurry-this-accessor.js
  var require_function_uncurry_this_accessor = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      module.exports = function(object, key, method) {
        try {
          return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
        } catch (error) {
        }
      };
    }
  });

  // node_modules/core-js/internals/is-possible-prototype.js
  var require_is_possible_prototype = __commonJS({
    "node_modules/core-js/internals/is-possible-prototype.js"(exports, module) {
      "use strict";
      var isObject4 = require_is_object();
      module.exports = function(argument) {
        return isObject4(argument) || argument === null;
      };
    }
  });

  // node_modules/core-js/internals/a-possible-prototype.js
  var require_a_possible_prototype = __commonJS({
    "node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
      "use strict";
      var isPossiblePrototype = require_is_possible_prototype();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isPossiblePrototype(argument)) return argument;
        throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
      };
    }
  });

  // node_modules/core-js/internals/object-set-prototype-of.js
  var require_object_set_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
      "use strict";
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var isObject4 = require_is_object();
      var requireObjectCoercible = require_require_object_coercible();
      var aPossiblePrototype = require_a_possible_prototype();
      module.exports = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
        var CORRECT_SETTER = false;
        var test = {};
        var setter;
        try {
          setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
          setter(test, []);
          CORRECT_SETTER = test instanceof Array;
        } catch (error) {
        }
        return function setPrototypeOf(O, proto2) {
          requireObjectCoercible(O);
          aPossiblePrototype(proto2);
          if (!isObject4(O)) return O;
          if (CORRECT_SETTER) setter(O, proto2);
          else O.__proto__ = proto2;
          return O;
        };
      })() : void 0);
    }
  });

  // node_modules/core-js/internals/proxy-accessor.js
  var require_proxy_accessor = __commonJS({
    "node_modules/core-js/internals/proxy-accessor.js"(exports, module) {
      "use strict";
      var defineProperty = require_object_define_property().f;
      module.exports = function(Target, Source, key) {
        key in Target || defineProperty(Target, key, {
          configurable: true,
          get: function() {
            return Source[key];
          },
          set: function(it) {
            Source[key] = it;
          }
        });
      };
    }
  });

  // node_modules/core-js/internals/inherit-if-required.js
  var require_inherit_if_required = __commonJS({
    "node_modules/core-js/internals/inherit-if-required.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var isObject4 = require_is_object();
      var setPrototypeOf = require_object_set_prototype_of();
      module.exports = function($this, dummy, Wrapper) {
        var NewTarget, NewTargetPrototype;
        if (
          // it can work only with native `setPrototypeOf`
          setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject4(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
        ) setPrototypeOf($this, NewTargetPrototype);
        return $this;
      };
    }
  });

  // node_modules/core-js/internals/normalize-string-argument.js
  var require_normalize_string_argument = __commonJS({
    "node_modules/core-js/internals/normalize-string-argument.js"(exports, module) {
      "use strict";
      var toString = require_to_string();
      module.exports = function(argument, $default) {
        return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
      };
    }
  });

  // node_modules/core-js/internals/install-error-cause.js
  var require_install_error_cause = __commonJS({
    "node_modules/core-js/internals/install-error-cause.js"(exports, module) {
      "use strict";
      var isObject4 = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      module.exports = function(O, options) {
        if (isObject4(options) && "cause" in options) {
          createNonEnumerableProperty(O, "cause", options.cause);
        }
      };
    }
  });

  // node_modules/core-js/internals/error-stack-clear.js
  var require_error_stack_clear = __commonJS({
    "node_modules/core-js/internals/error-stack-clear.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var $Error = Error;
      var replace = uncurryThis("".replace);
      var TEST = (function(arg) {
        return String(new $Error(arg).stack);
      })("zxcasd");
      var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
      var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
      module.exports = function(stack, dropEntries) {
        if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
          while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
        }
        return stack;
      };
    }
  });

  // node_modules/core-js/internals/error-stack-installable.js
  var require_error_stack_installable = __commonJS({
    "node_modules/core-js/internals/error-stack-installable.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = !fails(function() {
        var error = new Error("a");
        if (!("stack" in error)) return true;
        Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
        return error.stack !== 7;
      });
    }
  });

  // node_modules/core-js/internals/error-stack-install.js
  var require_error_stack_install = __commonJS({
    "node_modules/core-js/internals/error-stack-install.js"(exports, module) {
      "use strict";
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var clearErrorStack = require_error_stack_clear();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var captureStackTrace = Error.captureStackTrace;
      module.exports = function(error, C, stack, dropEntries) {
        if (ERROR_STACK_INSTALLABLE) {
          if (captureStackTrace) captureStackTrace(error, C);
          else createNonEnumerableProperty(error, "stack", clearErrorStack(stack, dropEntries));
        }
      };
    }
  });

  // node_modules/core-js/internals/wrap-error-constructor-with-cause.js
  var require_wrap_error_constructor_with_cause = __commonJS({
    "node_modules/core-js/internals/wrap-error-constructor-with-cause.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var hasOwn = require_has_own_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var proxyAccessor = require_proxy_accessor();
      var inheritIfRequired = require_inherit_if_required();
      var normalizeStringArgument = require_normalize_string_argument();
      var installErrorCause = require_install_error_cause();
      var installErrorStack = require_error_stack_install();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      module.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
        var STACK_TRACE_LIMIT = "stackTraceLimit";
        var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
        var path = FULL_NAME.split(".");
        var ERROR_NAME = path[path.length - 1];
        var OriginalError = getBuiltIn.apply(null, path);
        if (!OriginalError) return;
        var OriginalErrorPrototype = OriginalError.prototype;
        if (!IS_PURE && hasOwn(OriginalErrorPrototype, "cause")) delete OriginalErrorPrototype.cause;
        if (!FORCED) return OriginalError;
        var BaseError = getBuiltIn("Error");
        var WrappedError = wrapper(function(a, b) {
          var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, void 0);
          var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
          if (message !== void 0) createNonEnumerableProperty(result, "message", message);
          installErrorStack(result, WrappedError, result.stack, 2);
          if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
          if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
          return result;
        });
        WrappedError.prototype = OriginalErrorPrototype;
        if (ERROR_NAME !== "Error") {
          if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
          else copyConstructorProperties(WrappedError, BaseError, { name: true });
        } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
          proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
          proxyAccessor(WrappedError, OriginalError, "prepareStackTrace");
        }
        copyConstructorProperties(WrappedError, OriginalError);
        if (!IS_PURE) try {
          if (OriginalErrorPrototype.name !== ERROR_NAME) {
            createNonEnumerableProperty(OriginalErrorPrototype, "name", ERROR_NAME);
          }
          OriginalErrorPrototype.constructor = WrappedError;
        } catch (error) {
        }
        return WrappedError;
      };
    }
  });

  // node_modules/core-js/modules/es.error.cause.js
  var require_es_error_cause = __commonJS({
    "node_modules/core-js/modules/es.error.cause.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
      var WEB_ASSEMBLY = "WebAssembly";
      var WebAssembly = globalThis2[WEB_ASSEMBLY];
      var FORCED = new Error("e", { cause: 7 }).cause !== 7;
      var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
        var O = {};
        O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
        $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
      };
      var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
        if (WebAssembly && WebAssembly[ERROR_NAME]) {
          var O = {};
          O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED);
          $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
        }
      };
      exportGlobalErrorCauseWrapper("Error", function(init2) {
        return function Error2(message) {
          return apply(init2, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("EvalError", function(init2) {
        return function EvalError(message) {
          return apply(init2, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("RangeError", function(init2) {
        return function RangeError2(message) {
          return apply(init2, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("ReferenceError", function(init2) {
        return function ReferenceError2(message) {
          return apply(init2, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("SyntaxError", function(init2) {
        return function SyntaxError(message) {
          return apply(init2, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("TypeError", function(init2) {
        return function TypeError2(message) {
          return apply(init2, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("URIError", function(init2) {
        return function URIError(message) {
          return apply(init2, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("CompileError", function(init2) {
        return function CompileError(message) {
          return apply(init2, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("LinkError", function(init2) {
        return function LinkError(message) {
          return apply(init2, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init2) {
        return function RuntimeError(message) {
          return apply(init2, this, arguments);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.error.is-error.js
  var require_es_error_is_error = __commonJS({
    "node_modules/core-js/modules/es.error.is-error.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var isObject4 = require_is_object();
      var classof = require_classof();
      var fails = require_fails();
      var ERROR = "Error";
      var DOM_EXCEPTION = "DOMException";
      var PROTOTYPE_SETTING_AVAILABLE = Object.setPrototypeOf || {}.__proto__;
      var DOMException2 = getBuiltIn(DOM_EXCEPTION);
      var $Error = Error;
      var $isError = $Error.isError;
      var FORCED = !$isError || !PROTOTYPE_SETTING_AVAILABLE || fails(function() {
        return DOMException2 && !$isError(new DOMException2(DOM_EXCEPTION)) || // structuredClone-based implementations
        // eslint-disable-next-line es/no-error-cause -- detection
        !$isError(new $Error(ERROR, { cause: function() {
        } })) || // instanceof-based and FF Error#stack-based implementations
        $isError(getBuiltIn("Object", "create")($Error.prototype));
      });
      $({ target: "Error", stat: true, sham: true, forced: FORCED }, {
        isError: function isError(arg) {
          if (!isObject4(arg)) return false;
          var tag = classof(arg);
          return tag === ERROR || tag === DOM_EXCEPTION;
        }
      });
    }
  });

  // node_modules/core-js/internals/error-to-string.js
  var require_error_to_string = __commonJS({
    "node_modules/core-js/internals/error-to-string.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var anObject = require_an_object();
      var normalizeStringArgument = require_normalize_string_argument();
      var nativeErrorToString = Error.prototype.toString;
      var INCORRECT_TO_STRING = fails(function() {
        if (DESCRIPTORS) {
          var object = Object.create(Object.defineProperty({}, "name", { get: function() {
            return this === object;
          } }));
          if (nativeErrorToString.call(object) !== "true") return true;
        }
        return nativeErrorToString.call({ message: 1, name: 2 }) !== "2: 1" || nativeErrorToString.call({}) !== "Error";
      });
      module.exports = INCORRECT_TO_STRING ? function toString() {
        var O = anObject(this);
        var name = normalizeStringArgument(O.name, "Error");
        var message = normalizeStringArgument(O.message);
        return !name ? message : !message ? name : name + ": " + message;
      } : nativeErrorToString;
    }
  });

  // node_modules/core-js/modules/es.error.to-string.js
  var require_es_error_to_string = __commonJS({
    "node_modules/core-js/modules/es.error.to-string.js"() {
      "use strict";
      var defineBuiltIn = require_define_built_in();
      var errorToString = require_error_to_string();
      var ErrorPrototype = Error.prototype;
      if (ErrorPrototype.toString !== errorToString) {
        defineBuiltIn(ErrorPrototype, "toString", errorToString);
      }
    }
  });

  // node_modules/core-js/internals/correct-prototype-getter.js
  var require_correct_prototype_getter = __commonJS({
    "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = !fails(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
    }
  });

  // node_modules/core-js/internals/object-get-prototype-of.js
  var require_object_get_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
      "use strict";
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var toObject = require_to_object();
      var sharedKey = require_shared_key();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var IE_PROTO = sharedKey("IE_PROTO");
      var $Object = Object;
      var ObjectPrototype = $Object.prototype;
      module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
        var object = toObject(O);
        if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
        var constructor = object.constructor;
        if (isCallable(constructor) && object instanceof constructor) {
          return constructor.prototype;
        }
        return object instanceof $Object ? ObjectPrototype : null;
      };
    }
  });

  // node_modules/core-js/internals/iterators.js
  var require_iterators = __commonJS({
    "node_modules/core-js/internals/iterators.js"(exports, module) {
      "use strict";
      module.exports = {};
    }
  });

  // node_modules/core-js/internals/is-array-iterator-method.js
  var require_is_array_iterator_method = __commonJS({
    "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayPrototype = Array.prototype;
      module.exports = function(it) {
        return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
      };
    }
  });

  // node_modules/core-js/internals/get-iterator-method.js
  var require_get_iterator_method = __commonJS({
    "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      var getMethod = require_get_method();
      var isNullOrUndefined = require_is_null_or_undefined();
      var Iterators = require_iterators();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = function(it) {
        if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
      };
    }
  });

  // node_modules/core-js/internals/get-iterator.js
  var require_get_iterator = __commonJS({
    "node_modules/core-js/internals/get-iterator.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var getIteratorMethod = require_get_iterator_method();
      var $TypeError = TypeError;
      module.exports = function(argument, usingIterator) {
        var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
        if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
        throw new $TypeError(tryToString(argument) + " is not iterable");
      };
    }
  });

  // node_modules/core-js/internals/iterator-close.js
  var require_iterator_close = __commonJS({
    "node_modules/core-js/internals/iterator-close.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var anObject = require_an_object();
      var getMethod = require_get_method();
      module.exports = function(iterator, kind, value) {
        var innerResult, innerError;
        anObject(iterator);
        try {
          innerResult = getMethod(iterator, "return");
          if (!innerResult) {
            if (kind === "throw") throw value;
            return value;
          }
          innerResult = call(innerResult, iterator);
        } catch (error) {
          innerError = true;
          innerResult = error;
        }
        if (kind === "throw") throw value;
        if (innerError) throw innerResult;
        anObject(innerResult);
        return value;
      };
    }
  });

  // node_modules/core-js/internals/iterate.js
  var require_iterate = __commonJS({
    "node_modules/core-js/internals/iterate.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var call = require_function_call();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var lengthOfArrayLike = require_length_of_array_like();
      var isPrototypeOf = require_object_is_prototype_of();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var iteratorClose = require_iterator_close();
      var $TypeError = TypeError;
      var Result = function(stopped, result) {
        this.stopped = stopped;
        this.result = result;
      };
      var ResultPrototype = Result.prototype;
      module.exports = function(iterable, unboundFunction, options) {
        var that = options && options.that;
        var AS_ENTRIES = !!(options && options.AS_ENTRIES);
        var IS_RECORD = !!(options && options.IS_RECORD);
        var IS_ITERATOR = !!(options && options.IS_ITERATOR);
        var INTERRUPTED = !!(options && options.INTERRUPTED);
        var fn = bind2(unboundFunction, that);
        var iterator, iterFn, index, length, result, next, step2;
        var stop = function(condition) {
          if (iterator) iteratorClose(iterator, "normal");
          return new Result(true, condition);
        };
        var callFn = function(value) {
          if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
          }
          return INTERRUPTED ? fn(value, stop) : fn(value);
        };
        if (IS_RECORD) {
          iterator = iterable.iterator;
        } else if (IS_ITERATOR) {
          iterator = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
              result = callFn(iterable[index]);
              if (result && isPrototypeOf(ResultPrototype, result)) return result;
            }
            return new Result(false);
          }
          iterator = getIterator(iterable, iterFn);
        }
        next = IS_RECORD ? iterable.next : iterator.next;
        while (!(step2 = call(next, iterator)).done) {
          try {
            result = callFn(step2.value);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
          if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
        }
        return new Result(false);
      };
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.constructor.js
  var require_es_aggregate_error_constructor = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.constructor.js"() {
      "use strict";
      var $ = require_export();
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var create = require_object_create();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      var installErrorCause = require_install_error_cause();
      var installErrorStack = require_error_stack_install();
      var iterate = require_iterate();
      var normalizeStringArgument = require_normalize_string_argument();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Error = Error;
      var push = [].push;
      var $AggregateError = function AggregateError(errors, message) {
        var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
        var that;
        if (setPrototypeOf) {
          that = setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
        } else {
          that = isInstance ? this : create(AggregateErrorPrototype);
          createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
        }
        if (message !== void 0) createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
        installErrorStack(that, $AggregateError, that.stack, 1);
        if (arguments.length > 2) installErrorCause(that, arguments[2]);
        var errorsArray = [];
        iterate(errors, push, { that: errorsArray });
        createNonEnumerableProperty(that, "errors", errorsArray);
        return that;
      };
      if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);
      else copyConstructorProperties($AggregateError, $Error, { name: true });
      var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
        constructor: createPropertyDescriptor(1, $AggregateError),
        message: createPropertyDescriptor(1, ""),
        name: createPropertyDescriptor(1, "AggregateError")
      });
      $({ global: true, constructor: true, arity: 2 }, {
        AggregateError: $AggregateError
      });
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.js
  var require_es_aggregate_error = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.js"() {
      "use strict";
      require_es_aggregate_error_constructor();
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.cause.js
  var require_es_aggregate_error_cause = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.cause.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var fails = require_fails();
      var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
      var AGGREGATE_ERROR = "AggregateError";
      var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
      var FORCED = !fails(function() {
        return $AggregateError([1]).errors[0] !== 1;
      }) && fails(function() {
        return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
      });
      $({ global: true, constructor: true, arity: 2, forced: FORCED }, {
        AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init2) {
          return function AggregateError(errors, message) {
            return apply(init2, this, arguments);
          };
        }, FORCED, true)
      });
    }
  });

  // node_modules/core-js/modules/es.suppressed-error.constructor.js
  var require_es_suppressed_error_constructor = __commonJS({
    "node_modules/core-js/modules/es.suppressed-error.constructor.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var create = require_object_create();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      var installErrorStack = require_error_stack_install();
      var normalizeStringArgument = require_normalize_string_argument();
      var wellKnownSymbol = require_well_known_symbol();
      var fails = require_fails();
      var IS_PURE = require_is_pure();
      var NativeSuppressedError = globalThis2.SuppressedError;
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Error = Error;
      var WRONG_ARITY = !!NativeSuppressedError && NativeSuppressedError.length !== 3;
      var EXTRA_ARGS_SUPPORT = !!NativeSuppressedError && fails(function() {
        return new NativeSuppressedError(1, 2, 3, { cause: 4 }).cause === 4;
      });
      var PATCH = WRONG_ARITY || EXTRA_ARGS_SUPPORT;
      var $SuppressedError = function SuppressedError2(error, suppressed, message) {
        var isInstance = isPrototypeOf(SuppressedErrorPrototype, this);
        var that;
        if (setPrototypeOf) {
          that = PATCH && (!isInstance || getPrototypeOf(this) === SuppressedErrorPrototype) ? new NativeSuppressedError() : setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : SuppressedErrorPrototype);
        } else {
          that = isInstance ? this : create(SuppressedErrorPrototype);
          createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
        }
        if (message !== void 0) createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
        installErrorStack(that, $SuppressedError, that.stack, 1);
        createNonEnumerableProperty(that, "error", error);
        createNonEnumerableProperty(that, "suppressed", suppressed);
        return that;
      };
      if (setPrototypeOf) setPrototypeOf($SuppressedError, $Error);
      else copyConstructorProperties($SuppressedError, $Error, { name: true });
      var SuppressedErrorPrototype = $SuppressedError.prototype = PATCH ? NativeSuppressedError.prototype : create($Error.prototype, {
        constructor: createPropertyDescriptor(1, $SuppressedError),
        message: createPropertyDescriptor(1, ""),
        name: createPropertyDescriptor(1, "SuppressedError")
      });
      if (PATCH && !IS_PURE) SuppressedErrorPrototype.constructor = $SuppressedError;
      $({ global: true, constructor: true, arity: 3, forced: PATCH }, {
        SuppressedError: $SuppressedError
      });
    }
  });

  // node_modules/core-js/internals/add-to-unscopables.js
  var require_add_to_unscopables = __commonJS({
    "node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var create = require_object_create();
      var defineProperty = require_object_define_property().f;
      var UNSCOPABLES = wellKnownSymbol("unscopables");
      var ArrayPrototype = Array.prototype;
      if (ArrayPrototype[UNSCOPABLES] === void 0) {
        defineProperty(ArrayPrototype, UNSCOPABLES, {
          configurable: true,
          value: create(null)
        });
      }
      module.exports = function(key) {
        ArrayPrototype[UNSCOPABLES][key] = true;
      };
    }
  });

  // node_modules/core-js/modules/es.array.at.js
  var require_es_array_at = __commonJS({
    "node_modules/core-js/modules/es.array.at.js"() {
      "use strict";
      var $ = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        at: function at(index) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var relativeIndex = toIntegerOrInfinity(index);
          var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k < 0 || k >= len ? void 0 : O[k];
        }
      });
      addToUnscopables("at");
    }
  });

  // node_modules/core-js/internals/does-not-exceed-safe-integer.js
  var require_does_not_exceed_safe_integer = __commonJS({
    "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module) {
      "use strict";
      var $TypeError = TypeError;
      var MAX_SAFE_INTEGER = 9007199254740991;
      module.exports = function(it) {
        if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
        return it;
      };
    }
  });

  // node_modules/core-js/internals/create-property.js
  var require_create_property = __commonJS({
    "node_modules/core-js/internals/create-property.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = function(object, key, value) {
        if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
        else object[key] = value;
      };
    }
  });

  // node_modules/core-js/internals/array-method-has-species-support.js
  var require_array_method_has_species_support = __commonJS({
    "node_modules/core-js/internals/array-method-has-species-support.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var V8_VERSION = require_environment_v8_version();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(METHOD_NAME) {
        return V8_VERSION >= 51 || !fails(function() {
          var array = [];
          var constructor = array.constructor = {};
          constructor[SPECIES] = function() {
            return { foo: 1 };
          };
          return array[METHOD_NAME](Boolean).foo !== 1;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.concat.js
  var require_es_array_concat = __commonJS({
    "node_modules/core-js/modules/es.array.concat.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var isArray2 = require_is_array();
      var isObject4 = require_is_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var createProperty = require_create_property();
      var arraySpeciesCreate = require_array_species_create();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var wellKnownSymbol = require_well_known_symbol();
      var V8_VERSION = require_environment_v8_version();
      var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
      var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
        var array = [];
        array[IS_CONCAT_SPREADABLE] = false;
        return array.concat()[0] !== array;
      });
      var isConcatSpreadable = function(O) {
        if (!isObject4(O)) return false;
        var spreadable = O[IS_CONCAT_SPREADABLE];
        return spreadable !== void 0 ? !!spreadable : isArray2(O);
      };
      var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
      $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        concat: function concat(arg) {
          var O = toObject(this);
          var A = arraySpeciesCreate(O, 0);
          var n = 0;
          var i, k, length, len, E;
          for (i = -1, length = arguments.length; i < length; i++) {
            E = i === -1 ? O : arguments[i];
            if (isConcatSpreadable(E)) {
              len = lengthOfArrayLike(E);
              doesNotExceedSafeInteger(n + len);
              for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
            } else {
              doesNotExceedSafeInteger(n + 1);
              createProperty(A, n++, E);
            }
          }
          A.length = n;
          return A;
        }
      });
    }
  });

  // node_modules/core-js/internals/delete-property-or-throw.js
  var require_delete_property_or_throw = __commonJS({
    "node_modules/core-js/internals/delete-property-or-throw.js"(exports, module) {
      "use strict";
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(O, P) {
        if (!delete O[P]) throw new $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
      };
    }
  });

  // node_modules/core-js/internals/array-copy-within.js
  var require_array_copy_within = __commonJS({
    "node_modules/core-js/internals/array-copy-within.js"(exports, module) {
      "use strict";
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var min = Math.min;
      module.exports = [].copyWithin || function copyWithin(target, start2) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var to = toAbsoluteIndex(target, len);
        var from = toAbsoluteIndex(start2, len);
        var end = arguments.length > 2 ? arguments[2] : void 0;
        var count = min((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to);
        var inc = 1;
        if (from < to && to < from + count) {
          inc = -1;
          from += count - 1;
          to += count - 1;
        }
        while (count-- > 0) {
          if (from in O) O[to] = O[from];
          else deletePropertyOrThrow(O, to);
          to += inc;
          from += inc;
        }
        return O;
      };
    }
  });

  // node_modules/core-js/modules/es.array.copy-within.js
  var require_es_array_copy_within = __commonJS({
    "node_modules/core-js/modules/es.array.copy-within.js"() {
      "use strict";
      var $ = require_export();
      var copyWithin = require_array_copy_within();
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        copyWithin
      });
      addToUnscopables("copyWithin");
    }
  });

  // node_modules/core-js/internals/array-method-is-strict.js
  var require_array_method_is_strict = __commonJS({
    "node_modules/core-js/internals/array-method-is-strict.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = function(METHOD_NAME, argument) {
        var method = [][METHOD_NAME];
        return !!method && fails(function() {
          method.call(null, argument || function() {
            return 1;
          }, 1);
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.every.js
  var require_es_array_every = __commonJS({
    "node_modules/core-js/modules/es.array.every.js"() {
      "use strict";
      var $ = require_export();
      var $every = require_array_iteration().every;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("every");
      $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
        every: function every(callbackfn) {
          return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-fill.js
  var require_array_fill = __commonJS({
    "node_modules/core-js/internals/array-fill.js"(exports, module) {
      "use strict";
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function fill(value) {
        var O = toObject(this);
        var length = lengthOfArrayLike(O);
        var argumentsLength = arguments.length;
        var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
        var end = argumentsLength > 2 ? arguments[2] : void 0;
        var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
        while (endPos > index) O[index++] = value;
        return O;
      };
    }
  });

  // node_modules/core-js/modules/es.array.fill.js
  var require_es_array_fill = __commonJS({
    "node_modules/core-js/modules/es.array.fill.js"() {
      "use strict";
      var $ = require_export();
      var fill = require_array_fill();
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        fill
      });
      addToUnscopables("fill");
    }
  });

  // node_modules/core-js/modules/es.array.filter.js
  var require_es_array_filter = __commonJS({
    "node_modules/core-js/modules/es.array.filter.js"() {
      "use strict";
      var $ = require_export();
      var $filter = require_array_iteration().filter;
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
      $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        filter: function filter(callbackfn) {
          return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.find.js
  var require_es_array_find = __commonJS({
    "node_modules/core-js/modules/es.array.find.js"() {
      "use strict";
      var $ = require_export();
      var $find = require_array_iteration().find;
      var addToUnscopables = require_add_to_unscopables();
      var FIND = "find";
      var SKIPS_HOLES = true;
      if (FIND in []) Array(1)[FIND](function() {
        SKIPS_HOLES = false;
      });
      $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
        find: function find(callbackfn) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND);
    }
  });

  // node_modules/core-js/modules/es.array.find-index.js
  var require_es_array_find_index = __commonJS({
    "node_modules/core-js/modules/es.array.find-index.js"() {
      "use strict";
      var $ = require_export();
      var $findIndex = require_array_iteration().findIndex;
      var addToUnscopables = require_add_to_unscopables();
      var FIND_INDEX = "findIndex";
      var SKIPS_HOLES = true;
      if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
        SKIPS_HOLES = false;
      });
      $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
        findIndex: function findIndex(callbackfn) {
          return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND_INDEX);
    }
  });

  // node_modules/core-js/internals/array-iteration-from-last.js
  var require_array_iteration_from_last = __commonJS({
    "node_modules/core-js/internals/array-iteration-from-last.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var IndexedObject = require_indexed_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var createMethod = function(TYPE) {
        var IS_FIND_LAST_INDEX = TYPE === 1;
        return function($this, callbackfn, that) {
          var O = toObject($this);
          var self2 = IndexedObject(O);
          var index = lengthOfArrayLike(self2);
          var boundFunction = bind2(callbackfn, that);
          var value, result;
          while (index-- > 0) {
            value = self2[index];
            result = boundFunction(value, index, O);
            if (result) switch (TYPE) {
              case 0:
                return value;
              // findLast
              case 1:
                return index;
            }
          }
          return IS_FIND_LAST_INDEX ? -1 : void 0;
        };
      };
      module.exports = {
        // `Array.prototype.findLast` method
        // https://github.com/tc39/proposal-array-find-from-last
        findLast: createMethod(0),
        // `Array.prototype.findLastIndex` method
        // https://github.com/tc39/proposal-array-find-from-last
        findLastIndex: createMethod(1)
      };
    }
  });

  // node_modules/core-js/modules/es.array.find-last.js
  var require_es_array_find_last = __commonJS({
    "node_modules/core-js/modules/es.array.find-last.js"() {
      "use strict";
      var $ = require_export();
      var $findLast = require_array_iteration_from_last().findLast;
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        findLast: function findLast(callbackfn) {
          return $findLast(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("findLast");
    }
  });

  // node_modules/core-js/modules/es.array.find-last-index.js
  var require_es_array_find_last_index = __commonJS({
    "node_modules/core-js/modules/es.array.find-last-index.js"() {
      "use strict";
      var $ = require_export();
      var $findLastIndex = require_array_iteration_from_last().findLastIndex;
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        findLastIndex: function findLastIndex(callbackfn) {
          return $findLastIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("findLastIndex");
    }
  });

  // node_modules/core-js/internals/flatten-into-array.js
  var require_flatten_into_array = __commonJS({
    "node_modules/core-js/internals/flatten-into-array.js"(exports, module) {
      "use strict";
      var isArray2 = require_is_array();
      var lengthOfArrayLike = require_length_of_array_like();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var bind2 = require_function_bind_context();
      var flattenIntoArray = function(target, original, source, sourceLen, start2, depth, mapper, thisArg) {
        var targetIndex = start2;
        var sourceIndex = 0;
        var mapFn = mapper ? bind2(mapper, thisArg) : false;
        var element, elementLen;
        while (sourceIndex < sourceLen) {
          if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            if (depth > 0 && isArray2(element)) {
              elementLen = lengthOfArrayLike(element);
              targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
            } else {
              doesNotExceedSafeInteger(targetIndex + 1);
              target[targetIndex] = element;
            }
            targetIndex++;
          }
          sourceIndex++;
        }
        return targetIndex;
      };
      module.exports = flattenIntoArray;
    }
  });

  // node_modules/core-js/modules/es.array.flat.js
  var require_es_array_flat = __commonJS({
    "node_modules/core-js/modules/es.array.flat.js"() {
      "use strict";
      var $ = require_export();
      var flattenIntoArray = require_flatten_into_array();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var arraySpeciesCreate = require_array_species_create();
      $({ target: "Array", proto: true }, {
        flat: function flat() {
          var depthArg = arguments.length ? arguments[0] : void 0;
          var O = toObject(this);
          var sourceLen = lengthOfArrayLike(O);
          var A = arraySpeciesCreate(O, 0);
          A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
          return A;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.flat-map.js
  var require_es_array_flat_map = __commonJS({
    "node_modules/core-js/modules/es.array.flat-map.js"() {
      "use strict";
      var $ = require_export();
      var flattenIntoArray = require_flatten_into_array();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var arraySpeciesCreate = require_array_species_create();
      $({ target: "Array", proto: true }, {
        flatMap: function flatMap(callbackfn) {
          var O = toObject(this);
          var sourceLen = lengthOfArrayLike(O);
          var A;
          aCallable(callbackfn);
          A = arraySpeciesCreate(O, 0);
          A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          return A;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-for-each.js
  var require_array_for_each = __commonJS({
    "node_modules/core-js/internals/array-for-each.js"(exports, module) {
      "use strict";
      var $forEach = require_array_iteration().forEach;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("forEach");
      module.exports = !STRICT_METHOD ? function forEach(callbackfn) {
        return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      } : [].forEach;
    }
  });

  // node_modules/core-js/modules/es.array.for-each.js
  var require_es_array_for_each = __commonJS({
    "node_modules/core-js/modules/es.array.for-each.js"() {
      "use strict";
      var $ = require_export();
      var forEach = require_array_for_each();
      $({ target: "Array", proto: true, forced: [].forEach !== forEach }, {
        forEach
      });
    }
  });

  // node_modules/core-js/internals/call-with-safe-iteration-closing.js
  var require_call_with_safe_iteration_closing = __commonJS({
    "node_modules/core-js/internals/call-with-safe-iteration-closing.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var iteratorClose = require_iterator_close();
      module.exports = function(iterator, fn, value, ENTRIES) {
        try {
          return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
      };
    }
  });

  // node_modules/core-js/internals/array-from.js
  var require_array_from = __commonJS({
    "node_modules/core-js/internals/array-from.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var call = require_function_call();
      var toObject = require_to_object();
      var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var isConstructor = require_is_constructor();
      var lengthOfArrayLike = require_length_of_array_like();
      var createProperty = require_create_property();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var $Array = Array;
      module.exports = function from(arrayLike) {
        var O = toObject(arrayLike);
        var IS_CONSTRUCTOR = isConstructor(this);
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        if (mapping) mapfn = bind2(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
        var iteratorMethod = getIteratorMethod(O);
        var index = 0;
        var length, result, step2, iterator, next, value;
        if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
          result = IS_CONSTRUCTOR ? new this() : [];
          iterator = getIterator(O, iteratorMethod);
          next = iterator.next;
          for (; !(step2 = call(next, iterator)).done; index++) {
            value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step2.value, index], true) : step2.value;
            createProperty(result, index, value);
          }
        } else {
          length = lengthOfArrayLike(O);
          result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
          for (; length > index; index++) {
            value = mapping ? mapfn(O[index], index) : O[index];
            createProperty(result, index, value);
          }
        }
        result.length = index;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/check-correctness-of-iteration.js
  var require_check_correctness_of_iteration = __commonJS({
    "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var SAFE_CLOSING = false;
      try {
        called = 0;
        iteratorWithReturn = {
          next: function() {
            return { done: !!called++ };
          },
          "return": function() {
            SAFE_CLOSING = true;
          }
        };
        iteratorWithReturn[ITERATOR] = function() {
          return this;
        };
        Array.from(iteratorWithReturn, function() {
          throw 2;
        });
      } catch (error) {
      }
      var called;
      var iteratorWithReturn;
      module.exports = function(exec, SKIP_CLOSING) {
        try {
          if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
        } catch (error) {
          return false;
        }
        var ITERATION_SUPPORT = false;
        try {
          var object = {};
          object[ITERATOR] = function() {
            return {
              next: function() {
                return { done: ITERATION_SUPPORT = true };
              }
            };
          };
          exec(object);
        } catch (error) {
        }
        return ITERATION_SUPPORT;
      };
    }
  });

  // node_modules/core-js/modules/es.array.from.js
  var require_es_array_from = __commonJS({
    "node_modules/core-js/modules/es.array.from.js"() {
      "use strict";
      var $ = require_export();
      var from = require_array_from();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
        Array.from(iterable);
      });
      $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
        from
      });
    }
  });

  // node_modules/core-js/modules/es.array.includes.js
  var require_es_array_includes = __commonJS({
    "node_modules/core-js/modules/es.array.includes.js"() {
      "use strict";
      var $ = require_export();
      var $includes = require_array_includes().includes;
      var fails = require_fails();
      var addToUnscopables = require_add_to_unscopables();
      var BROKEN_ON_SPARSE = fails(function() {
        return !Array(1).includes();
      });
      $({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
        includes: function includes(el) {
          return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("includes");
    }
  });

  // node_modules/core-js/modules/es.array.index-of.js
  var require_es_array_index_of = __commonJS({
    "node_modules/core-js/modules/es.array.index-of.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var $indexOf = require_array_includes().indexOf;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var nativeIndexOf = uncurryThis([].indexOf);
      var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
      var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
      $({ target: "Array", proto: true, forced: FORCED }, {
        indexOf: function indexOf(searchElement) {
          var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
          return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.is-array.js
  var require_es_array_is_array = __commonJS({
    "node_modules/core-js/modules/es.array.is-array.js"() {
      "use strict";
      var $ = require_export();
      var isArray2 = require_is_array();
      $({ target: "Array", stat: true }, {
        isArray: isArray2
      });
    }
  });

  // node_modules/core-js/internals/iterators-core.js
  var require_iterators_core = __commonJS({
    "node_modules/core-js/internals/iterators-core.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var isCallable = require_is_callable();
      var isObject4 = require_is_object();
      var create = require_object_create();
      var getPrototypeOf = require_object_get_prototype_of();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      var BUGGY_SAFARI_ITERATORS = false;
      var IteratorPrototype;
      var PrototypeOfArrayIteratorPrototype;
      var arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
        else {
          PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
      }
      var NEW_ITERATOR_PROTOTYPE = !isObject4(IteratorPrototype) || fails(function() {
        var test = {};
        return IteratorPrototype[ITERATOR].call(test) !== test;
      });
      if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
      else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
      if (!isCallable(IteratorPrototype[ITERATOR])) {
        defineBuiltIn(IteratorPrototype, ITERATOR, function() {
          return this;
        });
      }
      module.exports = {
        IteratorPrototype,
        BUGGY_SAFARI_ITERATORS
      };
    }
  });

  // node_modules/core-js/internals/iterator-create-constructor.js
  var require_iterator_create_constructor = __commonJS({
    "node_modules/core-js/internals/iterator-create-constructor.js"(exports, module) {
      "use strict";
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var setToStringTag = require_set_to_string_tag();
      var Iterators = require_iterators();
      var returnThis = function() {
        return this;
      };
      module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
        var TO_STRING_TAG = NAME + " Iterator";
        IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
        Iterators[TO_STRING_TAG] = returnThis;
        return IteratorConstructor;
      };
    }
  });

  // node_modules/core-js/internals/iterator-define.js
  var require_iterator_define = __commonJS({
    "node_modules/core-js/internals/iterator-define.js"(exports, module) {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var IS_PURE = require_is_pure();
      var FunctionName = require_function_name();
      var isCallable = require_is_callable();
      var createIteratorConstructor = require_iterator_create_constructor();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var IteratorsCore = require_iterators_core();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var IteratorPrototype = IteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR = wellKnownSymbol("iterator");
      var KEYS = "keys";
      var VALUES = "values";
      var ENTRIES = "entries";
      var returnThis = function() {
        return this;
      };
      module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var getIterationMethod = function(KIND) {
          if (KIND === DEFAULT && defaultIterator) return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS:
              return function keys() {
                return new IteratorConstructor(this, KIND);
              };
            case VALUES:
              return function values() {
                return new IteratorConstructor(this, KIND);
              };
            case ENTRIES:
              return function entries() {
                return new IteratorConstructor(this, KIND);
              };
          }
          return function() {
            return new IteratorConstructor(this);
          };
        };
        var TO_STRING_TAG = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods3, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
          if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (setPrototypeOf) {
                setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
              }
            }
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
          }
        }
        if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
          if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(IterablePrototype, "name", VALUES);
          } else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
              return call(nativeIterator, this);
            };
          }
        }
        if (DEFAULT) {
          methods3 = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
          };
          if (FORCED) for (KEY in methods3) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods3[KEY]);
            }
          }
          else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods3);
        }
        if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
          defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
        }
        Iterators[NAME] = defaultIterator;
        return methods3;
      };
    }
  });

  // node_modules/core-js/internals/create-iter-result-object.js
  var require_create_iter_result_object = __commonJS({
    "node_modules/core-js/internals/create-iter-result-object.js"(exports, module) {
      "use strict";
      module.exports = function(value, done) {
        return { value, done };
      };
    }
  });

  // node_modules/core-js/modules/es.array.iterator.js
  var require_es_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
      "use strict";
      var toIndexedObject = require_to_indexed_object();
      var addToUnscopables = require_add_to_unscopables();
      var Iterators = require_iterators();
      var InternalStateModule = require_internal_state();
      var defineProperty = require_object_define_property().f;
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var ARRAY_ITERATOR = "Array Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
      module.exports = defineIterator(Array, "Array", function(iterated, kind) {
        setInternalState(this, {
          type: ARRAY_ITERATOR,
          target: toIndexedObject(iterated),
          // target
          index: 0,
          // next index
          kind
          // kind
        });
      }, function() {
        var state3 = getInternalState(this);
        var target = state3.target;
        var index = state3.index++;
        if (!target || index >= target.length) {
          state3.target = null;
          return createIterResultObject(void 0, true);
        }
        switch (state3.kind) {
          case "keys":
            return createIterResultObject(index, false);
          case "values":
            return createIterResultObject(target[index], false);
        }
        return createIterResultObject([index, target[index]], false);
      }, "values");
      var values = Iterators.Arguments = Iterators.Array;
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
      if (!IS_PURE && DESCRIPTORS && values.name !== "values") try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
    }
  });

  // node_modules/core-js/modules/es.array.join.js
  var require_es_array_join = __commonJS({
    "node_modules/core-js/modules/es.array.join.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var IndexedObject = require_indexed_object();
      var toIndexedObject = require_to_indexed_object();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var nativeJoin = uncurryThis([].join);
      var ES3_STRINGS = IndexedObject !== Object;
      var FORCED = ES3_STRINGS || !arrayMethodIsStrict("join", ",");
      $({ target: "Array", proto: true, forced: FORCED }, {
        join: function join(separator) {
          return nativeJoin(toIndexedObject(this), separator === void 0 ? "," : separator);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-last-index-of.js
  var require_array_last_index_of = __commonJS({
    "node_modules/core-js/internals/array-last-index-of.js"(exports, module) {
      "use strict";
      var apply = require_function_apply();
      var toIndexedObject = require_to_indexed_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var lengthOfArrayLike = require_length_of_array_like();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var min = Math.min;
      var $lastIndexOf = [].lastIndexOf;
      var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
      var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
      var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
      module.exports = FORCED ? function lastIndexOf(searchElement) {
        if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return -1;
        var index = length - 1;
        if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
        if (index < 0) index = length + index;
        for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
        return -1;
      } : $lastIndexOf;
    }
  });

  // node_modules/core-js/modules/es.array.last-index-of.js
  var require_es_array_last_index_of = __commonJS({
    "node_modules/core-js/modules/es.array.last-index-of.js"() {
      "use strict";
      var $ = require_export();
      var lastIndexOf = require_array_last_index_of();
      $({ target: "Array", proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
        lastIndexOf
      });
    }
  });

  // node_modules/core-js/modules/es.array.map.js
  var require_es_array_map = __commonJS({
    "node_modules/core-js/modules/es.array.map.js"() {
      "use strict";
      var $ = require_export();
      var $map = require_array_iteration().map;
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
      $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        map: function map(callbackfn) {
          return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.of.js
  var require_es_array_of = __commonJS({
    "node_modules/core-js/modules/es.array.of.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var isConstructor = require_is_constructor();
      var createProperty = require_create_property();
      var $Array = Array;
      var ISNT_GENERIC = fails(function() {
        function F() {
        }
        return !($Array.of.call(F) instanceof F);
      });
      $({ target: "Array", stat: true, forced: ISNT_GENERIC }, {
        of: function of() {
          var index = 0;
          var argumentsLength = arguments.length;
          var result = new (isConstructor(this) ? this : $Array)(argumentsLength);
          while (argumentsLength > index) createProperty(result, index, arguments[index++]);
          result.length = argumentsLength;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-set-length.js
  var require_array_set_length = __commonJS({
    "node_modules/core-js/internals/array-set-length.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var isArray2 = require_is_array();
      var $TypeError = TypeError;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !(function() {
        if (this !== void 0) return true;
        try {
          Object.defineProperty([], "length", { writable: false }).length = 1;
        } catch (error) {
          return error instanceof TypeError;
        }
      })();
      module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
        if (isArray2(O) && !getOwnPropertyDescriptor(O, "length").writable) {
          throw new $TypeError("Cannot set read only .length");
        }
        return O.length = length;
      } : function(O, length) {
        return O.length = length;
      };
    }
  });

  // node_modules/core-js/modules/es.array.push.js
  var require_es_array_push = __commonJS({
    "node_modules/core-js/modules/es.array.push.js"() {
      "use strict";
      var $ = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var fails = require_fails();
      var INCORRECT_TO_LENGTH = fails(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      });
      var properErrorOnNonWritableLength = function() {
        try {
          Object.defineProperty([], "length", { writable: false }).push();
        } catch (error) {
          return error instanceof TypeError;
        }
      };
      var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
      $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function push(item) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var argCount = arguments.length;
          doesNotExceedSafeInteger(len + argCount);
          for (var i = 0; i < argCount; i++) {
            O[len] = arguments[i];
            len++;
          }
          setArrayLength(O, len);
          return len;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-reduce.js
  var require_array_reduce = __commonJS({
    "node_modules/core-js/internals/array-reduce.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var IndexedObject = require_indexed_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var $TypeError = TypeError;
      var REDUCE_EMPTY = "Reduce of empty array with no initial value";
      var createMethod = function(IS_RIGHT) {
        return function(that, callbackfn, argumentsLength, memo) {
          var O = toObject(that);
          var self2 = IndexedObject(O);
          var length = lengthOfArrayLike(O);
          aCallable(callbackfn);
          if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
          var index = IS_RIGHT ? length - 1 : 0;
          var i = IS_RIGHT ? -1 : 1;
          if (argumentsLength < 2) while (true) {
            if (index in self2) {
              memo = self2[index];
              index += i;
              break;
            }
            index += i;
            if (IS_RIGHT ? index < 0 : length <= index) {
              throw new $TypeError(REDUCE_EMPTY);
            }
          }
          for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
            memo = callbackfn(memo, self2[index], index, O);
          }
          return memo;
        };
      };
      module.exports = {
        // `Array.prototype.reduce` method
        // https://tc39.es/ecma262/#sec-array.prototype.reduce
        left: createMethod(false),
        // `Array.prototype.reduceRight` method
        // https://tc39.es/ecma262/#sec-array.prototype.reduceright
        right: createMethod(true)
      };
    }
  });

  // node_modules/core-js/internals/environment.js
  var require_environment = __commonJS({
    "node_modules/core-js/internals/environment.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var userAgent = require_environment_user_agent();
      var classof = require_classof_raw();
      var userAgentStartsWith = function(string) {
        return userAgent.slice(0, string.length) === string;
      };
      module.exports = (function() {
        if (userAgentStartsWith("Bun/")) return "BUN";
        if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
        if (userAgentStartsWith("Deno/")) return "DENO";
        if (userAgentStartsWith("Node.js/")) return "NODE";
        if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
        if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
        if (classof(globalThis2.process) === "process") return "NODE";
        if (globalThis2.window && globalThis2.document) return "BROWSER";
        return "REST";
      })();
    }
  });

  // node_modules/core-js/internals/environment-is-node.js
  var require_environment_is_node = __commonJS({
    "node_modules/core-js/internals/environment-is-node.js"(exports, module) {
      "use strict";
      var ENVIRONMENT = require_environment();
      module.exports = ENVIRONMENT === "NODE";
    }
  });

  // node_modules/core-js/modules/es.array.reduce.js
  var require_es_array_reduce = __commonJS({
    "node_modules/core-js/modules/es.array.reduce.js"() {
      "use strict";
      var $ = require_export();
      var $reduce = require_array_reduce().left;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var CHROME_VERSION = require_environment_v8_version();
      var IS_NODE = require_environment_is_node();
      var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
      var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
      $({ target: "Array", proto: true, forced: FORCED }, {
        reduce: function reduce(callbackfn) {
          var length = arguments.length;
          return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.reduce-right.js
  var require_es_array_reduce_right = __commonJS({
    "node_modules/core-js/modules/es.array.reduce-right.js"() {
      "use strict";
      var $ = require_export();
      var $reduceRight = require_array_reduce().right;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var CHROME_VERSION = require_environment_v8_version();
      var IS_NODE = require_environment_is_node();
      var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
      var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduceRight");
      $({ target: "Array", proto: true, forced: FORCED }, {
        reduceRight: function reduceRight(callbackfn) {
          return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.reverse.js
  var require_es_array_reverse = __commonJS({
    "node_modules/core-js/modules/es.array.reverse.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var isArray2 = require_is_array();
      var nativeReverse = uncurryThis([].reverse);
      var test = [1, 2];
      $({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
        reverse: function reverse() {
          if (isArray2(this)) this.length = this.length;
          return nativeReverse(this);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.slice.js
  var require_es_array_slice = __commonJS({
    "node_modules/core-js/modules/es.array.slice.js"() {
      "use strict";
      var $ = require_export();
      var isArray2 = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject4 = require_is_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIndexedObject = require_to_indexed_object();
      var createProperty = require_create_property();
      var wellKnownSymbol = require_well_known_symbol();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var nativeSlice = require_array_slice();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
      var SPECIES = wellKnownSymbol("species");
      var $Array = Array;
      var max = Math.max;
      $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        slice: function slice(start2, end) {
          var O = toIndexedObject(this);
          var length = lengthOfArrayLike(O);
          var k = toAbsoluteIndex(start2, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var Constructor, result, n;
          if (isArray2(O)) {
            Constructor = O.constructor;
            if (isConstructor(Constructor) && (Constructor === $Array || isArray2(Constructor.prototype))) {
              Constructor = void 0;
            } else if (isObject4(Constructor)) {
              Constructor = Constructor[SPECIES];
              if (Constructor === null) Constructor = void 0;
            }
            if (Constructor === $Array || Constructor === void 0) {
              return nativeSlice(O, k, fin);
            }
          }
          result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k, 0));
          for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
          result.length = n;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.some.js
  var require_es_array_some = __commonJS({
    "node_modules/core-js/modules/es.array.some.js"() {
      "use strict";
      var $ = require_export();
      var $some = require_array_iteration().some;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("some");
      $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
        some: function some(callbackfn) {
          return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-sort.js
  var require_array_sort = __commonJS({
    "node_modules/core-js/internals/array-sort.js"(exports, module) {
      "use strict";
      var arraySlice = require_array_slice();
      var floor = Math.floor;
      var sort = function(array, comparefn) {
        var length = array.length;
        if (length < 8) {
          var i = 1;
          var element, j;
          while (i < length) {
            j = i;
            element = array[i];
            while (j && comparefn(array[j - 1], element) > 0) {
              array[j] = array[--j];
            }
            if (j !== i++) array[j] = element;
          }
        } else {
          var middle = floor(length / 2);
          var left2 = sort(arraySlice(array, 0, middle), comparefn);
          var right2 = sort(arraySlice(array, middle), comparefn);
          var llength = left2.length;
          var rlength = right2.length;
          var lindex = 0;
          var rindex = 0;
          while (lindex < llength || rindex < rlength) {
            array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left2[lindex], right2[rindex]) <= 0 ? left2[lindex++] : right2[rindex++] : lindex < llength ? left2[lindex++] : right2[rindex++];
          }
        }
        return array;
      };
      module.exports = sort;
    }
  });

  // node_modules/core-js/internals/environment-ff-version.js
  var require_environment_ff_version = __commonJS({
    "node_modules/core-js/internals/environment-ff-version.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      var firefox = userAgent.match(/firefox\/(\d+)/i);
      module.exports = !!firefox && +firefox[1];
    }
  });

  // node_modules/core-js/internals/environment-is-ie-or-edge.js
  var require_environment_is_ie_or_edge = __commonJS({
    "node_modules/core-js/internals/environment-is-ie-or-edge.js"(exports, module) {
      "use strict";
      var UA = require_environment_user_agent();
      module.exports = /MSIE|Trident/.test(UA);
    }
  });

  // node_modules/core-js/internals/environment-webkit-version.js
  var require_environment_webkit_version = __commonJS({
    "node_modules/core-js/internals/environment-webkit-version.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
      module.exports = !!webkit && +webkit[1];
    }
  });

  // node_modules/core-js/modules/es.array.sort.js
  var require_es_array_sort = __commonJS({
    "node_modules/core-js/modules/es.array.sort.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var toString = require_to_string();
      var fails = require_fails();
      var internalSort = require_array_sort();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var FF = require_environment_ff_version();
      var IE_OR_EDGE = require_environment_is_ie_or_edge();
      var V8 = require_environment_v8_version();
      var WEBKIT = require_environment_webkit_version();
      var test = [];
      var nativeSort = uncurryThis(test.sort);
      var push = uncurryThis(test.push);
      var FAILS_ON_UNDEFINED = fails(function() {
        test.sort(void 0);
      });
      var FAILS_ON_NULL = fails(function() {
        test.sort(null);
      });
      var STRICT_METHOD = arrayMethodIsStrict("sort");
      var STABLE_SORT = !fails(function() {
        if (V8) return V8 < 70;
        if (FF && FF > 3) return;
        if (IE_OR_EDGE) return true;
        if (WEBKIT) return WEBKIT < 603;
        var result = "";
        var code, chr, value, index;
        for (code = 65; code < 76; code++) {
          chr = String.fromCharCode(code);
          switch (code) {
            case 66:
            case 69:
            case 70:
            case 72:
              value = 3;
              break;
            case 68:
            case 71:
              value = 4;
              break;
            default:
              value = 2;
          }
          for (index = 0; index < 47; index++) {
            test.push({ k: chr + index, v: value });
          }
        }
        test.sort(function(a, b) {
          return b.v - a.v;
        });
        for (index = 0; index < test.length; index++) {
          chr = test[index].k.charAt(0);
          if (result.charAt(result.length - 1) !== chr) result += chr;
        }
        return result !== "DGBEFHACIJK";
      });
      var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
      var getSortCompare = function(comparefn) {
        return function(x, y) {
          if (y === void 0) return -1;
          if (x === void 0) return 1;
          if (comparefn !== void 0) return +comparefn(x, y) || 0;
          return toString(x) > toString(y) ? 1 : -1;
        };
      };
      $({ target: "Array", proto: true, forced: FORCED }, {
        sort: function sort(comparefn) {
          if (comparefn !== void 0) aCallable(comparefn);
          var array = toObject(this);
          if (STABLE_SORT) return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
          var items = [];
          var arrayLength = lengthOfArrayLike(array);
          var itemsLength, index;
          for (index = 0; index < arrayLength; index++) {
            if (index in array) push(items, array[index]);
          }
          internalSort(items, getSortCompare(comparefn));
          itemsLength = lengthOfArrayLike(items);
          index = 0;
          while (index < itemsLength) array[index] = items[index++];
          while (index < arrayLength) deletePropertyOrThrow(array, index++);
          return array;
        }
      });
    }
  });

  // node_modules/core-js/internals/set-species.js
  var require_set_species = __commonJS({
    "node_modules/core-js/internals/set-species.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var wellKnownSymbol = require_well_known_symbol();
      var DESCRIPTORS = require_descriptors();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
        if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
          defineBuiltInAccessor(Constructor, SPECIES, {
            configurable: true,
            get: function() {
              return this;
            }
          });
        }
      };
    }
  });

  // node_modules/core-js/modules/es.array.species.js
  var require_es_array_species = __commonJS({
    "node_modules/core-js/modules/es.array.species.js"() {
      "use strict";
      var setSpecies = require_set_species();
      setSpecies("Array");
    }
  });

  // node_modules/core-js/modules/es.array.splice.js
  var require_es_array_splice = __commonJS({
    "node_modules/core-js/modules/es.array.splice.js"() {
      "use strict";
      var $ = require_export();
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var arraySpeciesCreate = require_array_species_create();
      var createProperty = require_create_property();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
      var max = Math.max;
      var min = Math.min;
      $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        splice: function splice(start2, deleteCount) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var actualStart = toAbsoluteIndex(start2, len);
          var argumentsLength = arguments.length;
          var insertCount, actualDeleteCount, A, k, from, to;
          if (argumentsLength === 0) {
            insertCount = actualDeleteCount = 0;
          } else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
          } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
          }
          doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
          A = arraySpeciesCreate(O, actualDeleteCount);
          for (k = 0; k < actualDeleteCount; k++) {
            from = actualStart + k;
            if (from in O) createProperty(A, k, O[from]);
          }
          A.length = actualDeleteCount;
          if (insertCount < actualDeleteCount) {
            for (k = actualStart; k < len - actualDeleteCount; k++) {
              from = k + actualDeleteCount;
              to = k + insertCount;
              if (from in O) O[to] = O[from];
              else deletePropertyOrThrow(O, to);
            }
            for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
          } else if (insertCount > actualDeleteCount) {
            for (k = len - actualDeleteCount; k > actualStart; k--) {
              from = k + actualDeleteCount - 1;
              to = k + insertCount - 1;
              if (from in O) O[to] = O[from];
              else deletePropertyOrThrow(O, to);
            }
          }
          for (k = 0; k < insertCount; k++) {
            O[k + actualStart] = arguments[k + 2];
          }
          setArrayLength(O, len - actualDeleteCount + insertCount);
          return A;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-to-reversed.js
  var require_array_to_reversed = __commonJS({
    "node_modules/core-js/internals/array-to-reversed.js"(exports, module) {
      "use strict";
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function(O, C) {
        var len = lengthOfArrayLike(O);
        var A = new C(len);
        var k = 0;
        for (; k < len; k++) A[k] = O[len - k - 1];
        return A;
      };
    }
  });

  // node_modules/core-js/modules/es.array.to-reversed.js
  var require_es_array_to_reversed = __commonJS({
    "node_modules/core-js/modules/es.array.to-reversed.js"() {
      "use strict";
      var $ = require_export();
      var arrayToReversed = require_array_to_reversed();
      var toIndexedObject = require_to_indexed_object();
      var addToUnscopables = require_add_to_unscopables();
      var $Array = Array;
      $({ target: "Array", proto: true }, {
        toReversed: function toReversed() {
          return arrayToReversed(toIndexedObject(this), $Array);
        }
      });
      addToUnscopables("toReversed");
    }
  });

  // node_modules/core-js/internals/array-from-constructor-and-list.js
  var require_array_from_constructor_and_list = __commonJS({
    "node_modules/core-js/internals/array-from-constructor-and-list.js"(exports, module) {
      "use strict";
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function(Constructor, list, $length) {
        var index = 0;
        var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
        var result = new Constructor(length);
        while (length > index) result[index] = list[index++];
        return result;
      };
    }
  });

  // node_modules/core-js/internals/get-built-in-prototype-method.js
  var require_get_built_in_prototype_method = __commonJS({
    "node_modules/core-js/internals/get-built-in-prototype-method.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      module.exports = function(CONSTRUCTOR, METHOD) {
        var Constructor = globalThis2[CONSTRUCTOR];
        var Prototype = Constructor && Constructor.prototype;
        return Prototype && Prototype[METHOD];
      };
    }
  });

  // node_modules/core-js/modules/es.array.to-sorted.js
  var require_es_array_to_sorted = __commonJS({
    "node_modules/core-js/modules/es.array.to-sorted.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var toIndexedObject = require_to_indexed_object();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
      var addToUnscopables = require_add_to_unscopables();
      var $Array = Array;
      var sort = uncurryThis(getBuiltInPrototypeMethod("Array", "sort"));
      $({ target: "Array", proto: true }, {
        toSorted: function toSorted(compareFn) {
          if (compareFn !== void 0) aCallable(compareFn);
          var O = toIndexedObject(this);
          var A = arrayFromConstructorAndList($Array, O);
          return sort(A, compareFn);
        }
      });
      addToUnscopables("toSorted");
    }
  });

  // node_modules/core-js/modules/es.array.to-spliced.js
  var require_es_array_to_spliced = __commonJS({
    "node_modules/core-js/modules/es.array.to-spliced.js"() {
      "use strict";
      var $ = require_export();
      var addToUnscopables = require_add_to_unscopables();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var lengthOfArrayLike = require_length_of_array_like();
      var toAbsoluteIndex = require_to_absolute_index();
      var toIndexedObject = require_to_indexed_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $Array = Array;
      var max = Math.max;
      var min = Math.min;
      $({ target: "Array", proto: true }, {
        toSpliced: function toSpliced(start2, deleteCount) {
          var O = toIndexedObject(this);
          var len = lengthOfArrayLike(O);
          var actualStart = toAbsoluteIndex(start2, len);
          var argumentsLength = arguments.length;
          var k = 0;
          var insertCount, actualDeleteCount, newLen, A;
          if (argumentsLength === 0) {
            insertCount = actualDeleteCount = 0;
          } else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
          } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
          }
          newLen = doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
          A = $Array(newLen);
          for (; k < actualStart; k++) A[k] = O[k];
          for (; k < actualStart + insertCount; k++) A[k] = arguments[k - actualStart + 2];
          for (; k < newLen; k++) A[k] = O[k + actualDeleteCount - insertCount];
          return A;
        }
      });
      addToUnscopables("toSpliced");
    }
  });

  // node_modules/core-js/modules/es.array.unscopables.flat.js
  var require_es_array_unscopables_flat = __commonJS({
    "node_modules/core-js/modules/es.array.unscopables.flat.js"() {
      "use strict";
      var addToUnscopables = require_add_to_unscopables();
      addToUnscopables("flat");
    }
  });

  // node_modules/core-js/modules/es.array.unscopables.flat-map.js
  var require_es_array_unscopables_flat_map = __commonJS({
    "node_modules/core-js/modules/es.array.unscopables.flat-map.js"() {
      "use strict";
      var addToUnscopables = require_add_to_unscopables();
      addToUnscopables("flatMap");
    }
  });

  // node_modules/core-js/modules/es.array.unshift.js
  var require_es_array_unshift = __commonJS({
    "node_modules/core-js/modules/es.array.unshift.js"() {
      "use strict";
      var $ = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var INCORRECT_RESULT = [].unshift(0) !== 1;
      var properErrorOnNonWritableLength = function() {
        try {
          Object.defineProperty([], "length", { writable: false }).unshift();
        } catch (error) {
          return error instanceof TypeError;
        }
      };
      var FORCED = INCORRECT_RESULT || !properErrorOnNonWritableLength();
      $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        unshift: function unshift(item) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var argCount = arguments.length;
          if (argCount) {
            doesNotExceedSafeInteger(len + argCount);
            var k = len;
            while (k--) {
              var to = k + argCount;
              if (k in O) O[to] = O[k];
              else deletePropertyOrThrow(O, to);
            }
            for (var j = 0; j < argCount; j++) {
              O[j] = arguments[j];
            }
          }
          return setArrayLength(O, len + argCount);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-with.js
  var require_array_with = __commonJS({
    "node_modules/core-js/internals/array-with.js"(exports, module) {
      "use strict";
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $RangeError = RangeError;
      module.exports = function(O, C, index, value) {
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index);
        var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
        if (actualIndex >= len || actualIndex < 0) throw new $RangeError("Incorrect index");
        var A = new C(len);
        var k = 0;
        for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
        return A;
      };
    }
  });

  // node_modules/core-js/modules/es.array.with.js
  var require_es_array_with = __commonJS({
    "node_modules/core-js/modules/es.array.with.js"() {
      "use strict";
      var $ = require_export();
      var arrayWith = require_array_with();
      var toIndexedObject = require_to_indexed_object();
      var $Array = Array;
      var INCORRECT_EXCEPTION_ON_COERCION_FAIL = (function() {
        try {
          []["with"]({ valueOf: function() {
            throw 4;
          } }, null);
        } catch (error) {
          return error !== 4;
        }
      })();
      $({ target: "Array", proto: true, forced: INCORRECT_EXCEPTION_ON_COERCION_FAIL }, {
        "with": function(index, value) {
          return arrayWith(toIndexedObject(this), $Array, index, value);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-buffer-basic-detection.js
  var require_array_buffer_basic_detection = __commonJS({
    "node_modules/core-js/internals/array-buffer-basic-detection.js"(exports, module) {
      "use strict";
      module.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
    }
  });

  // node_modules/core-js/internals/define-built-ins.js
  var require_define_built_ins = __commonJS({
    "node_modules/core-js/internals/define-built-ins.js"(exports, module) {
      "use strict";
      var defineBuiltIn = require_define_built_in();
      module.exports = function(target, src, options) {
        for (var key in src) defineBuiltIn(target, key, src[key], options);
        return target;
      };
    }
  });

  // node_modules/core-js/internals/an-instance.js
  var require_an_instance = __commonJS({
    "node_modules/core-js/internals/an-instance.js"(exports, module) {
      "use strict";
      var isPrototypeOf = require_object_is_prototype_of();
      var $TypeError = TypeError;
      module.exports = function(it, Prototype) {
        if (isPrototypeOf(Prototype, it)) return it;
        throw new $TypeError("Incorrect invocation");
      };
    }
  });

  // node_modules/core-js/internals/to-index.js
  var require_to_index = __commonJS({
    "node_modules/core-js/internals/to-index.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var $RangeError = RangeError;
      module.exports = function(it) {
        if (it === void 0) return 0;
        var number = toIntegerOrInfinity(it);
        var length = toLength(number);
        if (number !== length) throw new $RangeError("Wrong length or index");
        return length;
      };
    }
  });

  // node_modules/core-js/internals/math-sign.js
  var require_math_sign = __commonJS({
    "node_modules/core-js/internals/math-sign.js"(exports, module) {
      "use strict";
      module.exports = Math.sign || function sign(x) {
        var n = +x;
        return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
      };
    }
  });

  // node_modules/core-js/internals/math-round-ties-to-even.js
  var require_math_round_ties_to_even = __commonJS({
    "node_modules/core-js/internals/math-round-ties-to-even.js"(exports, module) {
      "use strict";
      var EPSILON = 2220446049250313e-31;
      var INVERSE_EPSILON = 1 / EPSILON;
      module.exports = function(n) {
        return n + INVERSE_EPSILON - INVERSE_EPSILON;
      };
    }
  });

  // node_modules/core-js/internals/math-float-round.js
  var require_math_float_round = __commonJS({
    "node_modules/core-js/internals/math-float-round.js"(exports, module) {
      "use strict";
      var sign = require_math_sign();
      var roundTiesToEven = require_math_round_ties_to_even();
      var abs = Math.abs;
      var EPSILON = 2220446049250313e-31;
      module.exports = function(x, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
        var n = +x;
        var absolute = abs(n);
        var s = sign(n);
        if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
        var a = (1 + FLOAT_EPSILON / EPSILON) * absolute;
        var result = a - (a - absolute);
        if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
        return s * result;
      };
    }
  });

  // node_modules/core-js/internals/math-fround.js
  var require_math_fround = __commonJS({
    "node_modules/core-js/internals/math-fround.js"(exports, module) {
      "use strict";
      var floatRound = require_math_float_round();
      var FLOAT32_EPSILON = 11920928955078125e-23;
      var FLOAT32_MAX_VALUE = 34028234663852886e22;
      var FLOAT32_MIN_VALUE = 11754943508222875e-54;
      module.exports = Math.fround || function fround(x) {
        return floatRound(x, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
      };
    }
  });

  // node_modules/core-js/internals/ieee754.js
  var require_ieee754 = __commonJS({
    "node_modules/core-js/internals/ieee754.js"(exports, module) {
      "use strict";
      var $Array = Array;
      var abs = Math.abs;
      var pow = Math.pow;
      var floor = Math.floor;
      var log = Math.log;
      var LN2 = Math.LN2;
      var pack = function(number, mantissaLength, bytes) {
        var buffer = $Array(bytes);
        var exponentLength = bytes * 8 - mantissaLength - 1;
        var eMax = (1 << exponentLength) - 1;
        var eBias = eMax >> 1;
        var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
        var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
        var index = 0;
        var exponent, mantissa, c;
        number = abs(number);
        if (number !== number || number === Infinity) {
          mantissa = number !== number ? 1 : 0;
          exponent = eMax;
        } else {
          exponent = floor(log(number) / LN2);
          c = pow(2, -exponent);
          if (number * c < 1) {
            exponent--;
            c *= 2;
          }
          if (exponent + eBias >= 1) {
            number += rt / c;
          } else {
            number += rt * pow(2, 1 - eBias);
          }
          if (number * c >= 2) {
            exponent++;
            c /= 2;
          }
          if (exponent + eBias >= eMax) {
            mantissa = 0;
            exponent = eMax;
          } else if (exponent + eBias >= 1) {
            mantissa = (number * c - 1) * pow(2, mantissaLength);
            exponent += eBias;
          } else {
            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
            exponent = 0;
          }
        }
        while (mantissaLength >= 8) {
          buffer[index++] = mantissa & 255;
          mantissa /= 256;
          mantissaLength -= 8;
        }
        exponent = exponent << mantissaLength | mantissa;
        exponentLength += mantissaLength;
        while (exponentLength > 0) {
          buffer[index++] = exponent & 255;
          exponent /= 256;
          exponentLength -= 8;
        }
        buffer[index - 1] |= sign * 128;
        return buffer;
      };
      var unpack = function(buffer, mantissaLength) {
        var bytes = buffer.length;
        var exponentLength = bytes * 8 - mantissaLength - 1;
        var eMax = (1 << exponentLength) - 1;
        var eBias = eMax >> 1;
        var nBits = exponentLength - 7;
        var index = bytes - 1;
        var sign = buffer[index--];
        var exponent = sign & 127;
        var mantissa;
        sign >>= 7;
        while (nBits > 0) {
          exponent = exponent * 256 + buffer[index--];
          nBits -= 8;
        }
        mantissa = exponent & (1 << -nBits) - 1;
        exponent >>= -nBits;
        nBits += mantissaLength;
        while (nBits > 0) {
          mantissa = mantissa * 256 + buffer[index--];
          nBits -= 8;
        }
        if (exponent === 0) {
          exponent = 1 - eBias;
        } else if (exponent === eMax) {
          return mantissa ? NaN : sign ? -Infinity : Infinity;
        } else {
          mantissa += pow(2, mantissaLength);
          exponent -= eBias;
        }
        return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
      };
      module.exports = {
        pack,
        unpack
      };
    }
  });

  // node_modules/core-js/internals/array-buffer.js
  var require_array_buffer = __commonJS({
    "node_modules/core-js/internals/array-buffer.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var DESCRIPTORS = require_descriptors();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      var FunctionName = require_function_name();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var fails = require_fails();
      var anInstance = require_an_instance();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var toIndex = require_to_index();
      var fround = require_math_fround();
      var IEEE754 = require_ieee754();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var arrayFill = require_array_fill();
      var arraySlice = require_array_slice();
      var inheritIfRequired = require_inherit_if_required();
      var copyConstructorProperties = require_copy_constructor_properties();
      var setToStringTag = require_set_to_string_tag();
      var InternalStateModule = require_internal_state();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var ARRAY_BUFFER = "ArrayBuffer";
      var DATA_VIEW = "DataView";
      var PROTOTYPE = "prototype";
      var WRONG_LENGTH = "Wrong length";
      var WRONG_INDEX = "Wrong index";
      var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
      var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
      var setInternalState = InternalStateModule.set;
      var NativeArrayBuffer = globalThis2[ARRAY_BUFFER];
      var $ArrayBuffer = NativeArrayBuffer;
      var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
      var $DataView = globalThis2[DATA_VIEW];
      var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
      var ObjectPrototype = Object.prototype;
      var Array2 = globalThis2.Array;
      var RangeError2 = globalThis2.RangeError;
      var fill = uncurryThis(arrayFill);
      var reverse = uncurryThis([].reverse);
      var packIEEE754 = IEEE754.pack;
      var unpackIEEE754 = IEEE754.unpack;
      var packInt8 = function(number) {
        return [number & 255];
      };
      var packInt16 = function(number) {
        return [number & 255, number >> 8 & 255];
      };
      var packInt32 = function(number) {
        return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
      };
      var unpackInt32 = function(buffer) {
        return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
      };
      var packFloat32 = function(number) {
        return packIEEE754(fround(number), 23, 4);
      };
      var packFloat64 = function(number) {
        return packIEEE754(number, 52, 8);
      };
      var addGetter = function(Constructor, key, getInternalState) {
        defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
          configurable: true,
          get: function() {
            return getInternalState(this)[key];
          }
        });
      };
      var get = function(view, count, index, isLittleEndian) {
        var store = getInternalDataViewState(view);
        var intIndex = toIndex(index);
        var boolIsLittleEndian = !!isLittleEndian;
        if (intIndex + count > store.byteLength) throw new RangeError2(WRONG_INDEX);
        var bytes = store.bytes;
        var start2 = intIndex + store.byteOffset;
        var pack = arraySlice(bytes, start2, start2 + count);
        return boolIsLittleEndian ? pack : reverse(pack);
      };
      var set = function(view, count, index, conversion, value, isLittleEndian) {
        var store = getInternalDataViewState(view);
        var intIndex = toIndex(index);
        var pack = conversion(+value);
        var boolIsLittleEndian = !!isLittleEndian;
        if (intIndex + count > store.byteLength) throw new RangeError2(WRONG_INDEX);
        var bytes = store.bytes;
        var start2 = intIndex + store.byteOffset;
        for (var i = 0; i < count; i++) bytes[start2 + i] = pack[boolIsLittleEndian ? i : count - i - 1];
      };
      if (!NATIVE_ARRAY_BUFFER) {
        $ArrayBuffer = function ArrayBuffer2(length) {
          anInstance(this, ArrayBufferPrototype);
          var byteLength = toIndex(length);
          setInternalState(this, {
            type: ARRAY_BUFFER,
            bytes: fill(Array2(byteLength), 0),
            byteLength
          });
          if (!DESCRIPTORS) {
            this.byteLength = byteLength;
            this.detached = false;
          }
        };
        ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
        $DataView = function DataView2(buffer, byteOffset, byteLength) {
          anInstance(this, DataViewPrototype);
          anInstance(buffer, ArrayBufferPrototype);
          var bufferState = getInternalArrayBufferState(buffer);
          var bufferLength = bufferState.byteLength;
          var offset = toIntegerOrInfinity(byteOffset);
          if (offset < 0 || offset > bufferLength) throw new RangeError2("Wrong offset");
          byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
          if (offset + byteLength > bufferLength) throw new RangeError2(WRONG_LENGTH);
          setInternalState(this, {
            type: DATA_VIEW,
            buffer,
            byteLength,
            byteOffset: offset,
            bytes: bufferState.bytes
          });
          if (!DESCRIPTORS) {
            this.buffer = buffer;
            this.byteLength = byteLength;
            this.byteOffset = offset;
          }
        };
        DataViewPrototype = $DataView[PROTOTYPE];
        if (DESCRIPTORS) {
          addGetter($ArrayBuffer, "byteLength", getInternalArrayBufferState);
          addGetter($DataView, "buffer", getInternalDataViewState);
          addGetter($DataView, "byteLength", getInternalDataViewState);
          addGetter($DataView, "byteOffset", getInternalDataViewState);
        }
        defineBuiltIns(DataViewPrototype, {
          getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
          },
          getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
          },
          getInt16: function getInt16(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
          },
          getUint16: function getUint16(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
            return bytes[1] << 8 | bytes[0];
          },
          getInt32: function getInt32(byteOffset) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
          },
          getUint32: function getUint32(byteOffset) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
          },
          getFloat32: function getFloat32(byteOffset) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
          },
          getFloat64: function getFloat64(byteOffset) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
          },
          setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
          },
          setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
          },
          setInt16: function setInt16(byteOffset, value) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
          },
          setUint16: function setUint16(byteOffset, value) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
          },
          setInt32: function setInt32(byteOffset, value) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setUint32: function setUint32(byteOffset, value) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setFloat32: function setFloat32(byteOffset, value) {
            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setFloat64: function setFloat64(byteOffset, value) {
            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
          }
        });
      } else {
        INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
        if (!fails(function() {
          NativeArrayBuffer(1);
        }) || !fails(function() {
          new NativeArrayBuffer(-1);
        }) || fails(function() {
          new NativeArrayBuffer();
          new NativeArrayBuffer(1.5);
          new NativeArrayBuffer(NaN);
          return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
        })) {
          $ArrayBuffer = function ArrayBuffer2(length) {
            anInstance(this, ArrayBufferPrototype);
            return inheritIfRequired(new NativeArrayBuffer(toIndex(length)), this, $ArrayBuffer);
          };
          $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
          ArrayBufferPrototype.constructor = $ArrayBuffer;
          copyConstructorProperties($ArrayBuffer, NativeArrayBuffer);
        } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
        }
        if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
          setPrototypeOf(DataViewPrototype, ObjectPrototype);
        }
        testView = new $DataView(new $ArrayBuffer(2));
        $setInt8 = uncurryThis(DataViewPrototype.setInt8);
        testView.setInt8(0, 2147483648);
        testView.setInt8(1, 2147483649);
        if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
          setInt8: function setInt8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
          },
          setUint8: function setUint8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
          }
        }, { unsafe: true });
      }
      var INCORRECT_ARRAY_BUFFER_NAME;
      var testView;
      var $setInt8;
      setToStringTag($ArrayBuffer, ARRAY_BUFFER);
      setToStringTag($DataView, DATA_VIEW);
      module.exports = {
        ArrayBuffer: $ArrayBuffer,
        DataView: $DataView
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.constructor.js
  var require_es_array_buffer_constructor = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.constructor.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var arrayBufferModule = require_array_buffer();
      var setSpecies = require_set_species();
      var ARRAY_BUFFER = "ArrayBuffer";
      var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
      var NativeArrayBuffer = globalThis2[ARRAY_BUFFER];
      $({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer2 }, {
        ArrayBuffer: ArrayBuffer2
      });
      setSpecies(ARRAY_BUFFER);
    }
  });

  // node_modules/core-js/internals/array-buffer-view-core.js
  var require_array_buffer_view_core = __commonJS({
    "node_modules/core-js/internals/array-buffer-view-core.js"(exports, module) {
      "use strict";
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      var DESCRIPTORS = require_descriptors();
      var globalThis2 = require_global_this();
      var isCallable = require_is_callable();
      var isObject4 = require_is_object();
      var hasOwn = require_has_own_property();
      var classof = require_classof();
      var tryToString = require_try_to_string();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var wellKnownSymbol = require_well_known_symbol();
      var uid = require_uid();
      var InternalStateModule = require_internal_state();
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var Int8Array2 = globalThis2.Int8Array;
      var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
      var Uint8ClampedArray2 = globalThis2.Uint8ClampedArray;
      var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
      var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
      var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
      var ObjectPrototype = Object.prototype;
      var TypeError2 = globalThis2.TypeError;
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
      var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
      var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis2.opera) !== "Opera";
      var TYPED_ARRAY_TAG_REQUIRED = false;
      var NAME;
      var Constructor;
      var Prototype;
      var TypedArrayConstructorsList = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      };
      var BigIntArrayConstructorsList = {
        BigInt64Array: 8,
        BigUint64Array: 8
      };
      var isView = function isView2(it) {
        if (!isObject4(it)) return false;
        var klass = classof(it);
        return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
      };
      var getTypedArrayConstructor = function(it) {
        var proto2 = getPrototypeOf(it);
        if (!isObject4(proto2)) return;
        var state3 = getInternalState(proto2);
        return state3 && hasOwn(state3, TYPED_ARRAY_CONSTRUCTOR) ? state3[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto2);
      };
      var isTypedArray = function(it) {
        if (!isObject4(it)) return false;
        var klass = classof(it);
        return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
      };
      var aTypedArray = function(it) {
        if (isTypedArray(it)) return it;
        throw new TypeError2("Target is not a typed array");
      };
      var aTypedArrayConstructor = function(C) {
        if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
        throw new TypeError2(tryToString(C) + " is not a typed array constructor");
      };
      var exportTypedArrayMethod = function(KEY, property, forced, options) {
        if (!DESCRIPTORS) return;
        if (forced) for (var ARRAY in TypedArrayConstructorsList) {
          var TypedArrayConstructor = globalThis2[ARRAY];
          if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
            delete TypedArrayConstructor.prototype[KEY];
          } catch (error) {
            try {
              TypedArrayConstructor.prototype[KEY] = property;
            } catch (error2) {
            }
          }
        }
        if (!TypedArrayPrototype[KEY] || forced) {
          defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
        }
      };
      var exportTypedArrayStaticMethod = function(KEY, property, forced) {
        var ARRAY, TypedArrayConstructor;
        if (!DESCRIPTORS) return;
        if (setPrototypeOf) {
          if (forced) for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = globalThis2[ARRAY];
            if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
              delete TypedArrayConstructor[KEY];
            } catch (error) {
            }
          }
          if (!TypedArray[KEY] || forced) {
            try {
              return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
            } catch (error) {
            }
          } else return;
        }
        for (ARRAY in TypedArrayConstructorsList) {
          TypedArrayConstructor = globalThis2[ARRAY];
          if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
            defineBuiltIn(TypedArrayConstructor, KEY, property);
          }
        }
      };
      for (NAME in TypedArrayConstructorsList) {
        Constructor = globalThis2[NAME];
        Prototype = Constructor && Constructor.prototype;
        if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
        else NATIVE_ARRAY_BUFFER_VIEWS = false;
      }
      for (NAME in BigIntArrayConstructorsList) {
        Constructor = globalThis2[NAME];
        Prototype = Constructor && Constructor.prototype;
        if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
      }
      if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
        TypedArray = function TypedArray2() {
          throw new TypeError2("Incorrect invocation");
        };
        if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
          if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME], TypedArray);
        }
      }
      if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
        TypedArrayPrototype = TypedArray.prototype;
        if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
          if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME].prototype, TypedArrayPrototype);
        }
      }
      if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
        setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
      }
      if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
        TYPED_ARRAY_TAG_REQUIRED = true;
        defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
          configurable: true,
          get: function() {
            return isObject4(this) ? this[TYPED_ARRAY_TAG] : void 0;
          }
        });
        for (NAME in TypedArrayConstructorsList) if (globalThis2[NAME]) {
          createNonEnumerableProperty(globalThis2[NAME], TYPED_ARRAY_TAG, NAME);
        }
      }
      module.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS,
        TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
        aTypedArray,
        aTypedArrayConstructor,
        exportTypedArrayMethod,
        exportTypedArrayStaticMethod,
        getTypedArrayConstructor,
        isView,
        isTypedArray,
        TypedArray,
        TypedArrayPrototype
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.is-view.js
  var require_es_array_buffer_is_view = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.is-view.js"() {
      "use strict";
      var $ = require_export();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
      $({ target: "ArrayBuffer", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
        isView: ArrayBufferViewCore.isView
      });
    }
  });

  // node_modules/core-js/modules/es.array-buffer.slice.js
  var require_es_array_buffer_slice = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.slice.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var fails = require_fails();
      var ArrayBufferModule = require_array_buffer();
      var anObject = require_an_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var toLength = require_to_length();
      var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
      var DataView2 = ArrayBufferModule.DataView;
      var DataViewPrototype = DataView2.prototype;
      var nativeArrayBufferSlice = uncurryThis(ArrayBuffer2.prototype.slice);
      var getUint8 = uncurryThis(DataViewPrototype.getUint8);
      var setUint8 = uncurryThis(DataViewPrototype.setUint8);
      var INCORRECT_SLICE = fails(function() {
        return !new ArrayBuffer2(2).slice(1, void 0).byteLength;
      });
      $({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
        slice: function slice(start2, end) {
          if (nativeArrayBufferSlice && end === void 0) {
            return nativeArrayBufferSlice(anObject(this), start2);
          }
          var length = anObject(this).byteLength;
          var first = toAbsoluteIndex(start2, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var result = new ArrayBuffer2(toLength(fin - first));
          var viewSource = new DataView2(this);
          var viewTarget = new DataView2(result);
          var index = 0;
          while (first < fin) {
            setUint8(viewTarget, index++, getUint8(viewSource, first++));
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.data-view.constructor.js
  var require_es_data_view_constructor = __commonJS({
    "node_modules/core-js/modules/es.data-view.constructor.js"() {
      "use strict";
      var $ = require_export();
      var ArrayBufferModule = require_array_buffer();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      $({ global: true, constructor: true, forced: !NATIVE_ARRAY_BUFFER }, {
        DataView: ArrayBufferModule.DataView
      });
    }
  });

  // node_modules/core-js/modules/es.data-view.js
  var require_es_data_view = __commonJS({
    "node_modules/core-js/modules/es.data-view.js"() {
      "use strict";
      require_es_data_view_constructor();
    }
  });

  // node_modules/core-js/modules/es.data-view.get-float16.js
  var require_es_data_view_get_float16 = __commonJS({
    "node_modules/core-js/modules/es.data-view.get-float16.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var pow = Math.pow;
      var EXP_MASK16 = 31;
      var SIGNIFICAND_MASK16 = 1023;
      var MIN_SUBNORMAL16 = pow(2, -24);
      var SIGNIFICAND_DENOM16 = 9765625e-10;
      var unpackFloat16 = function(bytes) {
        var sign = bytes >>> 15;
        var exponent = bytes >>> 10 & EXP_MASK16;
        var significand = bytes & SIGNIFICAND_MASK16;
        if (exponent === EXP_MASK16) return significand === 0 ? sign === 0 ? Infinity : -Infinity : NaN;
        if (exponent === 0) return significand * (sign === 0 ? MIN_SUBNORMAL16 : -MIN_SUBNORMAL16);
        return pow(2, exponent - 15) * (sign === 0 ? 1 + significand * SIGNIFICAND_DENOM16 : -1 - significand * SIGNIFICAND_DENOM16);
      };
      var getUint16 = uncurryThis(DataView.prototype.getUint16);
      $({ target: "DataView", proto: true }, {
        getFloat16: function getFloat16(byteOffset) {
          return unpackFloat16(getUint16(this, byteOffset, arguments.length > 1 ? arguments[1] : false));
        }
      });
    }
  });

  // node_modules/core-js/internals/a-data-view.js
  var require_a_data_view = __commonJS({
    "node_modules/core-js/internals/a-data-view.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (classof(argument) === "DataView") return argument;
        throw new $TypeError("Argument is not a DataView");
      };
    }
  });

  // node_modules/core-js/internals/math-log2.js
  var require_math_log2 = __commonJS({
    "node_modules/core-js/internals/math-log2.js"(exports, module) {
      "use strict";
      var log = Math.log;
      var LN2 = Math.LN2;
      module.exports = Math.log2 || function log2(x) {
        return log(x) / LN2;
      };
    }
  });

  // node_modules/core-js/modules/es.data-view.set-float16.js
  var require_es_data_view_set_float16 = __commonJS({
    "node_modules/core-js/modules/es.data-view.set-float16.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aDataView = require_a_data_view();
      var toIndex = require_to_index();
      var log2 = require_math_log2();
      var roundTiesToEven = require_math_round_ties_to_even();
      var pow = Math.pow;
      var MIN_INFINITY16 = 65520;
      var MIN_NORMAL16 = 61005353927612305e-21;
      var REC_MIN_SUBNORMAL16 = 16777216;
      var REC_SIGNIFICAND_DENOM16 = 1024;
      var packFloat16 = function(value) {
        if (value !== value) return 32256;
        if (value === 0) return (1 / value === -Infinity) << 15;
        var neg = value < 0;
        if (neg) value = -value;
        if (value >= MIN_INFINITY16) return neg << 15 | 31744;
        if (value < MIN_NORMAL16) return neg << 15 | roundTiesToEven(value * REC_MIN_SUBNORMAL16);
        var exponent = log2(value) | 0;
        if (exponent === -15) {
          return neg << 15 | REC_SIGNIFICAND_DENOM16;
        }
        var significand = roundTiesToEven((value * pow(2, -exponent) - 1) * REC_SIGNIFICAND_DENOM16);
        if (significand === REC_SIGNIFICAND_DENOM16) {
          return neg << 15 | exponent + 16 << 10;
        }
        return neg << 15 | exponent + 15 << 10 | significand;
      };
      var setUint16 = uncurryThis(DataView.prototype.setUint16);
      $({ target: "DataView", proto: true }, {
        setFloat16: function setFloat16(byteOffset, value) {
          setUint16(
            aDataView(this),
            toIndex(byteOffset),
            packFloat16(+value),
            arguments.length > 2 ? arguments[2] : false
          );
        }
      });
    }
  });

  // node_modules/core-js/internals/array-buffer-byte-length.js
  var require_array_buffer_byte_length = __commonJS({
    "node_modules/core-js/internals/array-buffer-byte-length.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var classof = require_classof_raw();
      var ArrayBuffer2 = globalThis2.ArrayBuffer;
      var TypeError2 = globalThis2.TypeError;
      module.exports = ArrayBuffer2 && uncurryThisAccessor(ArrayBuffer2.prototype, "byteLength", "get") || function(O) {
        if (classof(O) !== "ArrayBuffer") throw new TypeError2("ArrayBuffer expected");
        return O.byteLength;
      };
    }
  });

  // node_modules/core-js/internals/array-buffer-is-detached.js
  var require_array_buffer_is_detached = __commonJS({
    "node_modules/core-js/internals/array-buffer-is-detached.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      var arrayBufferByteLength = require_array_buffer_byte_length();
      var DataView2 = globalThis2.DataView;
      module.exports = function(O) {
        if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength(O) !== 0) return false;
        try {
          new DataView2(O);
          return false;
        } catch (error) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.detached.js
  var require_es_array_buffer_detached = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.detached.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isDetached = require_array_buffer_is_detached();
      var ArrayBufferPrototype = ArrayBuffer.prototype;
      if (DESCRIPTORS && !("detached" in ArrayBufferPrototype)) {
        defineBuiltInAccessor(ArrayBufferPrototype, "detached", {
          configurable: true,
          get: function detached() {
            return isDetached(this);
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/array-buffer-not-detached.js
  var require_array_buffer_not_detached = __commonJS({
    "node_modules/core-js/internals/array-buffer-not-detached.js"(exports, module) {
      "use strict";
      var isDetached = require_array_buffer_is_detached();
      var $TypeError = TypeError;
      module.exports = function(it) {
        if (isDetached(it)) throw new $TypeError("ArrayBuffer is detached");
        return it;
      };
    }
  });

  // node_modules/core-js/internals/get-built-in-node-module.js
  var require_get_built_in_node_module = __commonJS({
    "node_modules/core-js/internals/get-built-in-node-module.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var IS_NODE = require_environment_is_node();
      module.exports = function(name) {
        if (IS_NODE) {
          try {
            return globalThis2.process.getBuiltinModule(name);
          } catch (error) {
          }
          try {
            return Function('return require("' + name + '")')();
          } catch (error) {
          }
        }
      };
    }
  });

  // node_modules/core-js/internals/structured-clone-proper-transfer.js
  var require_structured_clone_proper_transfer = __commonJS({
    "node_modules/core-js/internals/structured-clone-proper-transfer.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var V8 = require_environment_v8_version();
      var ENVIRONMENT = require_environment();
      var structuredClone = globalThis2.structuredClone;
      module.exports = !!structuredClone && !fails(function() {
        if (ENVIRONMENT === "DENO" && V8 > 92 || ENVIRONMENT === "NODE" && V8 > 94 || ENVIRONMENT === "BROWSER" && V8 > 97) return false;
        var buffer = new ArrayBuffer(8);
        var clone = structuredClone(buffer, { transfer: [buffer] });
        return buffer.byteLength !== 0 || clone.byteLength !== 8;
      });
    }
  });

  // node_modules/core-js/internals/detach-transferable.js
  var require_detach_transferable = __commonJS({
    "node_modules/core-js/internals/detach-transferable.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var getBuiltInNodeModule = require_get_built_in_node_module();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var structuredClone = globalThis2.structuredClone;
      var $ArrayBuffer = globalThis2.ArrayBuffer;
      var $MessageChannel = globalThis2.MessageChannel;
      var detach = false;
      var WorkerThreads;
      var channel;
      var buffer;
      var $detach;
      if (PROPER_STRUCTURED_CLONE_TRANSFER) {
        detach = function(transferable) {
          structuredClone(transferable, { transfer: [transferable] });
        };
      } else if ($ArrayBuffer) try {
        if (!$MessageChannel) {
          WorkerThreads = getBuiltInNodeModule("worker_threads");
          if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
        }
        if ($MessageChannel) {
          channel = new $MessageChannel();
          buffer = new $ArrayBuffer(2);
          $detach = function(transferable) {
            channel.port1.postMessage(null, [transferable]);
          };
          if (buffer.byteLength === 2) {
            $detach(buffer);
            if (buffer.byteLength === 0) detach = $detach;
          }
        }
      } catch (error) {
      }
      module.exports = detach;
    }
  });

  // node_modules/core-js/internals/array-buffer-transfer.js
  var require_array_buffer_transfer = __commonJS({
    "node_modules/core-js/internals/array-buffer-transfer.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var toIndex = require_to_index();
      var notDetached = require_array_buffer_not_detached();
      var arrayBufferByteLength = require_array_buffer_byte_length();
      var detachTransferable = require_detach_transferable();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var structuredClone = globalThis2.structuredClone;
      var ArrayBuffer2 = globalThis2.ArrayBuffer;
      var DataView2 = globalThis2.DataView;
      var min = Math.min;
      var ArrayBufferPrototype = ArrayBuffer2.prototype;
      var DataViewPrototype = DataView2.prototype;
      var slice = uncurryThis(ArrayBufferPrototype.slice);
      var isResizable = uncurryThisAccessor(ArrayBufferPrototype, "resizable", "get");
      var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, "maxByteLength", "get");
      var getInt8 = uncurryThis(DataViewPrototype.getInt8);
      var setInt8 = uncurryThis(DataViewPrototype.setInt8);
      module.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {
        var byteLength = arrayBufferByteLength(arrayBuffer);
        var newByteLength = newLength === void 0 ? byteLength : toIndex(newLength);
        var fixedLength = !isResizable || !isResizable(arrayBuffer);
        var newBuffer;
        notDetached(arrayBuffer);
        if (PROPER_STRUCTURED_CLONE_TRANSFER) {
          arrayBuffer = structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
          if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;
        }
        if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
          newBuffer = slice(arrayBuffer, 0, newByteLength);
        } else {
          var options = preserveResizability && !fixedLength && maxByteLength ? { maxByteLength: maxByteLength(arrayBuffer) } : void 0;
          newBuffer = new ArrayBuffer2(newByteLength, options);
          var a = new DataView2(arrayBuffer);
          var b = new DataView2(newBuffer);
          var copyLength = min(newByteLength, byteLength);
          for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
        }
        if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);
        return newBuffer;
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.transfer.js
  var require_es_array_buffer_transfer = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.transfer.js"() {
      "use strict";
      var $ = require_export();
      var $transfer = require_array_buffer_transfer();
      if ($transfer) $({ target: "ArrayBuffer", proto: true }, {
        transfer: function transfer() {
          return $transfer(this, arguments.length ? arguments[0] : void 0, true);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array-buffer.transfer-to-fixed-length.js
  var require_es_array_buffer_transfer_to_fixed_length = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.transfer-to-fixed-length.js"() {
      "use strict";
      var $ = require_export();
      var $transfer = require_array_buffer_transfer();
      if ($transfer) $({ target: "ArrayBuffer", proto: true }, {
        transferToFixedLength: function transferToFixedLength() {
          return $transfer(this, arguments.length ? arguments[0] : void 0, false);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.get-year.js
  var require_es_date_get_year = __commonJS({
    "node_modules/core-js/modules/es.date.get-year.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var FORCED = fails(function() {
        return (/* @__PURE__ */ new Date(16e11)).getYear() !== 120;
      });
      var getFullYear = uncurryThis(Date.prototype.getFullYear);
      $({ target: "Date", proto: true, forced: FORCED }, {
        getYear: function getYear() {
          return getFullYear(this) - 1900;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.now.js
  var require_es_date_now = __commonJS({
    "node_modules/core-js/modules/es.date.now.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var $Date = Date;
      var thisTimeValue = uncurryThis($Date.prototype.getTime);
      $({ target: "Date", stat: true }, {
        now: function now() {
          return thisTimeValue(new $Date());
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.set-year.js
  var require_es_date_set_year = __commonJS({
    "node_modules/core-js/modules/es.date.set-year.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var DatePrototype = Date.prototype;
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      var setFullYear = uncurryThis(DatePrototype.setFullYear);
      $({ target: "Date", proto: true }, {
        setYear: function setYear(year) {
          thisTimeValue(this);
          var yi = toIntegerOrInfinity(year);
          var yyyy = yi >= 0 && yi <= 99 ? yi + 1900 : yi;
          return setFullYear(this, yyyy);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.to-gmt-string.js
  var require_es_date_to_gmt_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-gmt-string.js"() {
      "use strict";
      var $ = require_export();
      $({ target: "Date", proto: true }, {
        toGMTString: Date.prototype.toUTCString
      });
    }
  });

  // node_modules/core-js/internals/string-repeat.js
  var require_string_repeat = __commonJS({
    "node_modules/core-js/internals/string-repeat.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var $RangeError = RangeError;
      module.exports = function repeat(count) {
        var str = toString(requireObjectCoercible(this));
        var result = "";
        var n = toIntegerOrInfinity(count);
        if (n < 0 || n === Infinity) throw new $RangeError("Wrong number of repetitions");
        for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/string-pad.js
  var require_string_pad = __commonJS({
    "node_modules/core-js/internals/string-pad.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toLength = require_to_length();
      var toString = require_to_string();
      var $repeat = require_string_repeat();
      var requireObjectCoercible = require_require_object_coercible();
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var ceil = Math.ceil;
      var createMethod = function(IS_END) {
        return function($this, maxLength, fillString) {
          var S = toString(requireObjectCoercible($this));
          var intMaxLength = toLength(maxLength);
          var stringLength = S.length;
          var fillStr = fillString === void 0 ? " " : toString(fillString);
          var fillLen, stringFiller;
          if (intMaxLength <= stringLength || fillStr === "") return S;
          fillLen = intMaxLength - stringLength;
          stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
          if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
          return IS_END ? S + stringFiller : stringFiller + S;
        };
      };
      module.exports = {
        // `String.prototype.padStart` method
        // https://tc39.es/ecma262/#sec-string.prototype.padstart
        start: createMethod(false),
        // `String.prototype.padEnd` method
        // https://tc39.es/ecma262/#sec-string.prototype.padend
        end: createMethod(true)
      };
    }
  });

  // node_modules/core-js/internals/date-to-iso-string.js
  var require_date_to_iso_string = __commonJS({
    "node_modules/core-js/internals/date-to-iso-string.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var padStart = require_string_pad().start;
      var $RangeError = RangeError;
      var $isFinite = isFinite;
      var abs = Math.abs;
      var DatePrototype = Date.prototype;
      var nativeDateToISOString = DatePrototype.toISOString;
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
      var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
      var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
      var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
      var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
      var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
      var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
      module.exports = fails(function() {
        return nativeDateToISOString.call(new Date(-5e13 - 1)) !== "0385-07-25T07:06:39.999Z";
      }) || !fails(function() {
        nativeDateToISOString.call(/* @__PURE__ */ new Date(NaN));
      }) ? function toISOString() {
        if (!$isFinite(thisTimeValue(this))) throw new $RangeError("Invalid time value");
        var date = this;
        var year = getUTCFullYear(date);
        var milliseconds = getUTCMilliseconds(date);
        var sign = year < 0 ? "-" : year > 9999 ? "+" : "";
        return sign + padStart(abs(year), sign ? 6 : 4, 0) + "-" + padStart(getUTCMonth(date) + 1, 2, 0) + "-" + padStart(getUTCDate(date), 2, 0) + "T" + padStart(getUTCHours(date), 2, 0) + ":" + padStart(getUTCMinutes(date), 2, 0) + ":" + padStart(getUTCSeconds(date), 2, 0) + "." + padStart(milliseconds, 3, 0) + "Z";
      } : nativeDateToISOString;
    }
  });

  // node_modules/core-js/modules/es.date.to-iso-string.js
  var require_es_date_to_iso_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-iso-string.js"() {
      "use strict";
      var $ = require_export();
      var toISOString = require_date_to_iso_string();
      $({ target: "Date", proto: true, forced: Date.prototype.toISOString !== toISOString }, {
        toISOString
      });
    }
  });

  // node_modules/core-js/modules/es.date.to-json.js
  var require_es_date_to_json = __commonJS({
    "node_modules/core-js/modules/es.date.to-json.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var toObject = require_to_object();
      var toPrimitive = require_to_primitive();
      var FORCED = fails(function() {
        return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function() {
          return 1;
        } }) !== 1;
      });
      $({ target: "Date", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        toJSON: function toJSON(key) {
          var O = toObject(this);
          var pv = toPrimitive(O, "number");
          return typeof pv == "number" && !isFinite(pv) ? null : O.toISOString();
        }
      });
    }
  });

  // node_modules/core-js/internals/date-to-primitive.js
  var require_date_to_primitive = __commonJS({
    "node_modules/core-js/internals/date-to-primitive.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var $TypeError = TypeError;
      module.exports = function(hint) {
        anObject(this);
        if (hint === "string" || hint === "default") hint = "string";
        else if (hint !== "number") throw new $TypeError("Incorrect hint");
        return ordinaryToPrimitive(this, hint);
      };
    }
  });

  // node_modules/core-js/modules/es.date.to-primitive.js
  var require_es_date_to_primitive = __commonJS({
    "node_modules/core-js/modules/es.date.to-primitive.js"() {
      "use strict";
      var hasOwn = require_has_own_property();
      var defineBuiltIn = require_define_built_in();
      var dateToPrimitive = require_date_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      var DatePrototype = Date.prototype;
      if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
        defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
      }
    }
  });

  // node_modules/core-js/modules/es.date.to-string.js
  var require_es_date_to_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-string.js"() {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIn = require_define_built_in();
      var DatePrototype = Date.prototype;
      var INVALID_DATE = "Invalid Date";
      var TO_STRING = "toString";
      var nativeDateToString = uncurryThis(DatePrototype[TO_STRING]);
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      if (String(/* @__PURE__ */ new Date(NaN)) !== INVALID_DATE) {
        defineBuiltIn(DatePrototype, TO_STRING, function toString() {
          var value = thisTimeValue(this);
          return value === value ? nativeDateToString(this) : INVALID_DATE;
        });
      }
    }
  });

  // node_modules/core-js/internals/add-disposable-resource.js
  var require_add_disposable_resource = __commonJS({
    "node_modules/core-js/internals/add-disposable-resource.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var bind2 = require_function_bind_context();
      var anObject = require_an_object();
      var aCallable = require_a_callable();
      var isNullOrUndefined = require_is_null_or_undefined();
      var getMethod = require_get_method();
      var wellKnownSymbol = require_well_known_symbol();
      var ASYNC_DISPOSE = wellKnownSymbol("asyncDispose");
      var DISPOSE = wellKnownSymbol("dispose");
      var push = uncurryThis([].push);
      var getDisposeMethod = function(V, hint) {
        if (hint === "async-dispose") {
          var method = getMethod(V, ASYNC_DISPOSE);
          if (method !== void 0) return method;
          method = getMethod(V, DISPOSE);
          if (method === void 0) return method;
          return function() {
            var O = this;
            var Promise2 = getBuiltIn("Promise");
            return new Promise2(function(resolve) {
              call(method, O);
              resolve(void 0);
            });
          };
        }
        return getMethod(V, DISPOSE);
      };
      var createDisposableResource = function(V, hint, method) {
        if (arguments.length < 3 && !isNullOrUndefined(V)) {
          method = aCallable(getDisposeMethod(anObject(V), hint));
        }
        return method === void 0 ? function() {
          return void 0;
        } : bind2(method, V);
      };
      module.exports = function(disposable, V, hint, method) {
        var resource;
        if (arguments.length < 4) {
          if (isNullOrUndefined(V) && hint === "sync-dispose") return;
          resource = createDisposableResource(V, hint);
        } else {
          resource = createDisposableResource(void 0, hint, method);
        }
        push(disposable.stack, resource);
      };
    }
  });

  // node_modules/core-js/modules/es.disposable-stack.constructor.js
  var require_es_disposable_stack_constructor = __commonJS({
    "node_modules/core-js/modules/es.disposable-stack.constructor.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var getBuiltIn = require_get_built_in();
      var aCallable = require_a_callable();
      var anInstance = require_an_instance();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltIns = require_define_built_ins();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var wellKnownSymbol = require_well_known_symbol();
      var InternalStateModule = require_internal_state();
      var addDisposableResource = require_add_disposable_resource();
      var SuppressedError2 = getBuiltIn("SuppressedError");
      var $ReferenceError = ReferenceError;
      var DISPOSE = wellKnownSymbol("dispose");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var DISPOSABLE_STACK = "DisposableStack";
      var setInternalState = InternalStateModule.set;
      var getDisposableStackInternalState = InternalStateModule.getterFor(DISPOSABLE_STACK);
      var HINT = "sync-dispose";
      var DISPOSED = "disposed";
      var PENDING = "pending";
      var getPendingDisposableStackInternalState = function(stack) {
        var internalState = getDisposableStackInternalState(stack);
        if (internalState.state === DISPOSED) throw new $ReferenceError(DISPOSABLE_STACK + " already disposed");
        return internalState;
      };
      var $DisposableStack = function DisposableStack() {
        setInternalState(anInstance(this, DisposableStackPrototype), {
          type: DISPOSABLE_STACK,
          state: PENDING,
          stack: []
        });
        if (!DESCRIPTORS) this.disposed = false;
      };
      var DisposableStackPrototype = $DisposableStack.prototype;
      defineBuiltIns(DisposableStackPrototype, {
        dispose: function dispose() {
          var internalState = getDisposableStackInternalState(this);
          if (internalState.state === DISPOSED) return;
          internalState.state = DISPOSED;
          if (!DESCRIPTORS) this.disposed = true;
          var stack = internalState.stack;
          var i = stack.length;
          var thrown = false;
          var suppressed;
          while (i) {
            var disposeMethod = stack[--i];
            stack[i] = null;
            try {
              disposeMethod();
            } catch (errorResult) {
              if (thrown) {
                suppressed = new SuppressedError2(errorResult, suppressed);
              } else {
                thrown = true;
                suppressed = errorResult;
              }
            }
          }
          internalState.stack = null;
          if (thrown) throw suppressed;
        },
        use: function use(value) {
          addDisposableResource(getPendingDisposableStackInternalState(this), value, HINT);
          return value;
        },
        adopt: function adopt(value, onDispose) {
          var internalState = getPendingDisposableStackInternalState(this);
          aCallable(onDispose);
          addDisposableResource(internalState, void 0, HINT, function() {
            onDispose(value);
          });
          return value;
        },
        defer: function defer(onDispose) {
          var internalState = getPendingDisposableStackInternalState(this);
          aCallable(onDispose);
          addDisposableResource(internalState, void 0, HINT, onDispose);
        },
        move: function move() {
          var internalState = getPendingDisposableStackInternalState(this);
          var newDisposableStack = new $DisposableStack();
          getDisposableStackInternalState(newDisposableStack).stack = internalState.stack;
          internalState.stack = [];
          internalState.state = DISPOSED;
          if (!DESCRIPTORS) this.disposed = true;
          return newDisposableStack;
        }
      });
      if (DESCRIPTORS) defineBuiltInAccessor(DisposableStackPrototype, "disposed", {
        configurable: true,
        get: function disposed() {
          return getDisposableStackInternalState(this).state === DISPOSED;
        }
      });
      defineBuiltIn(DisposableStackPrototype, DISPOSE, DisposableStackPrototype.dispose, { name: "dispose" });
      defineBuiltIn(DisposableStackPrototype, TO_STRING_TAG, DISPOSABLE_STACK, { nonWritable: true });
      $({ global: true, constructor: true }, {
        DisposableStack: $DisposableStack
      });
    }
  });

  // node_modules/core-js/modules/es.escape.js
  var require_es_escape = __commonJS({
    "node_modules/core-js/modules/es.escape.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var exec = uncurryThis(/./.exec);
      var numberToString = uncurryThis(1.1.toString);
      var toUpperCase = uncurryThis("".toUpperCase);
      var raw = /[\w*+\-./@]/;
      var hex = function(code, length) {
        var result = numberToString(code, 16);
        while (result.length < length) result = "0" + result;
        return result;
      };
      $({ global: true }, {
        escape: function escape2(string) {
          var str = toString(string);
          var result = "";
          var length = str.length;
          var index = 0;
          var chr, code;
          while (index < length) {
            chr = charAt(str, index++);
            if (exec(raw, chr)) {
              result += chr;
            } else {
              code = charCodeAt(chr, 0);
              if (code < 256) {
                result += "%" + hex(code, 2);
              } else {
                result += "%u" + toUpperCase(hex(code, 4));
              }
            }
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/function-bind.js
  var require_function_bind = __commonJS({
    "node_modules/core-js/internals/function-bind.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var isObject4 = require_is_object();
      var hasOwn = require_has_own_property();
      var arraySlice = require_array_slice();
      var NATIVE_BIND = require_function_bind_native();
      var $Function = Function;
      var concat = uncurryThis([].concat);
      var join = uncurryThis([].join);
      var factories = {};
      var construct = function(C, argsLength, args) {
        if (!hasOwn(factories, argsLength)) {
          var list = [];
          var i = 0;
          for (; i < argsLength; i++) list[i] = "a[" + i + "]";
          factories[argsLength] = $Function("C,a", "return new C(" + join(list, ",") + ")");
        }
        return factories[argsLength](C, args);
      };
      module.exports = NATIVE_BIND ? $Function.bind : function bind2(that) {
        var F = aCallable(this);
        var Prototype = F.prototype;
        var partArgs = arraySlice(arguments, 1);
        var boundFunction = function bound() {
          var args = concat(partArgs, arraySlice(arguments));
          return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
        };
        if (isObject4(Prototype)) boundFunction.prototype = Prototype;
        return boundFunction;
      };
    }
  });

  // node_modules/core-js/modules/es.function.bind.js
  var require_es_function_bind = __commonJS({
    "node_modules/core-js/modules/es.function.bind.js"() {
      "use strict";
      var $ = require_export();
      var bind2 = require_function_bind();
      $({ target: "Function", proto: true, forced: Function.bind !== bind2 }, {
        bind: bind2
      });
    }
  });

  // node_modules/core-js/modules/es.function.has-instance.js
  var require_es_function_has_instance = __commonJS({
    "node_modules/core-js/modules/es.function.has-instance.js"() {
      "use strict";
      var isCallable = require_is_callable();
      var isObject4 = require_is_object();
      var definePropertyModule = require_object_define_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var wellKnownSymbol = require_well_known_symbol();
      var makeBuiltIn = require_make_built_in();
      var HAS_INSTANCE = wellKnownSymbol("hasInstance");
      var FunctionPrototype = Function.prototype;
      if (!(HAS_INSTANCE in FunctionPrototype)) {
        definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, { value: makeBuiltIn(function(O) {
          if (!isCallable(this) || !isObject4(O)) return false;
          var P = this.prototype;
          return isObject4(P) ? isPrototypeOf(P, O) : O instanceof this;
        }, HAS_INSTANCE) });
      }
    }
  });

  // node_modules/core-js/modules/es.function.name.js
  var require_es_function_name = __commonJS({
    "node_modules/core-js/modules/es.function.name.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var FUNCTION_NAME_EXISTS = require_function_name().EXISTS;
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var FunctionPrototype = Function.prototype;
      var functionToString = uncurryThis(FunctionPrototype.toString);
      var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
      var regExpExec = uncurryThis(nameRE.exec);
      var NAME = "name";
      if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
        defineBuiltInAccessor(FunctionPrototype, NAME, {
          configurable: true,
          get: function() {
            try {
              return regExpExec(nameRE, functionToString(this))[1];
            } catch (error) {
              return "";
            }
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.global-this.js
  var require_es_global_this = __commonJS({
    "node_modules/core-js/modules/es.global-this.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      $({ global: true, forced: globalThis2.globalThis !== globalThis2 }, {
        globalThis: globalThis2
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.constructor.js
  var require_es_iterator_constructor = __commonJS({
    "node_modules/core-js/modules/es.iterator.constructor.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var getPrototypeOf = require_object_get_prototype_of();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var createProperty = require_create_property();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var CONSTRUCTOR = "constructor";
      var ITERATOR = "Iterator";
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $TypeError = TypeError;
      var NativeIterator = globalThis2[ITERATOR];
      var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function() {
        NativeIterator({});
      });
      var IteratorConstructor = function Iterator2() {
        anInstance(this, IteratorPrototype);
        if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError("Abstract class Iterator not directly constructable");
      };
      var defineIteratorPrototypeAccessor = function(key, value) {
        if (DESCRIPTORS) {
          defineBuiltInAccessor(IteratorPrototype, key, {
            configurable: true,
            get: function() {
              return value;
            },
            set: function(replacement) {
              anObject(this);
              if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
              if (hasOwn(this, key)) this[key] = replacement;
              else createProperty(this, key, replacement);
            }
          });
        } else IteratorPrototype[key] = value;
      };
      if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);
      if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
        defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
      }
      IteratorConstructor.prototype = IteratorPrototype;
      $({ global: true, constructor: true, forced: FORCED }, {
        Iterator: IteratorConstructor
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.dispose.js
  var require_es_iterator_dispose = __commonJS({
    "node_modules/core-js/modules/es.iterator.dispose.js"() {
      "use strict";
      var call = require_function_call();
      var defineBuiltIn = require_define_built_in();
      var getMethod = require_get_method();
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var DISPOSE = wellKnownSymbol("dispose");
      if (!hasOwn(IteratorPrototype, DISPOSE)) {
        defineBuiltIn(IteratorPrototype, DISPOSE, function() {
          var $return = getMethod(this, "return");
          if ($return) call($return, this);
        });
      }
    }
  });

  // node_modules/core-js/internals/get-iterator-direct.js
  var require_get_iterator_direct = __commonJS({
    "node_modules/core-js/internals/get-iterator-direct.js"(exports, module) {
      "use strict";
      module.exports = function(obj) {
        return {
          iterator: obj,
          next: obj.next,
          done: false
        };
      };
    }
  });

  // node_modules/core-js/internals/not-a-nan.js
  var require_not_a_nan = __commonJS({
    "node_modules/core-js/internals/not-a-nan.js"(exports, module) {
      "use strict";
      var $RangeError = RangeError;
      module.exports = function(it) {
        if (it === it) return it;
        throw new $RangeError("NaN is not allowed");
      };
    }
  });

  // node_modules/core-js/internals/to-positive-integer.js
  var require_to_positive_integer = __commonJS({
    "node_modules/core-js/internals/to-positive-integer.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $RangeError = RangeError;
      module.exports = function(it) {
        var result = toIntegerOrInfinity(it);
        if (result < 0) throw new $RangeError("The argument can't be less than 0");
        return result;
      };
    }
  });

  // node_modules/core-js/internals/iterator-close-all.js
  var require_iterator_close_all = __commonJS({
    "node_modules/core-js/internals/iterator-close-all.js"(exports, module) {
      "use strict";
      var iteratorClose = require_iterator_close();
      module.exports = function(iters, kind, value) {
        for (var i = iters.length - 1; i >= 0; i--) {
          if (iters[i] === void 0) continue;
          try {
            value = iteratorClose(iters[i].iterator, kind, value);
          } catch (error) {
            kind = "throw";
            value = error;
          }
        }
        if (kind === "throw") throw value;
        return value;
      };
    }
  });

  // node_modules/core-js/internals/iterator-create-proxy.js
  var require_iterator_create_proxy = __commonJS({
    "node_modules/core-js/internals/iterator-create-proxy.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var create = require_object_create();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIns = require_define_built_ins();
      var wellKnownSymbol = require_well_known_symbol();
      var InternalStateModule = require_internal_state();
      var getMethod = require_get_method();
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var createIterResultObject = require_create_iter_result_object();
      var iteratorClose = require_iterator_close();
      var iteratorCloseAll = require_iterator_close_all();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var ITERATOR_HELPER = "IteratorHelper";
      var WRAP_FOR_VALID_ITERATOR = "WrapForValidIterator";
      var NORMAL = "normal";
      var THROW = "throw";
      var setInternalState = InternalStateModule.set;
      var createIteratorProxyPrototype = function(IS_ITERATOR) {
        var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);
        return defineBuiltIns(create(IteratorPrototype), {
          next: function next() {
            var state3 = getInternalState(this);
            if (IS_ITERATOR) return state3.nextHandler();
            if (state3.done) return createIterResultObject(void 0, true);
            try {
              var result = state3.nextHandler();
              return state3.returnHandlerResult ? result : createIterResultObject(result, state3.done);
            } catch (error) {
              state3.done = true;
              throw error;
            }
          },
          "return": function() {
            var state3 = getInternalState(this);
            var iterator = state3.iterator;
            state3.done = true;
            if (IS_ITERATOR) {
              var returnMethod = getMethod(iterator, "return");
              return returnMethod ? call(returnMethod, iterator) : createIterResultObject(void 0, true);
            }
            if (state3.inner) try {
              iteratorClose(state3.inner.iterator, NORMAL);
            } catch (error) {
              return iteratorClose(iterator, THROW, error);
            }
            if (state3.openIters) try {
              iteratorCloseAll(state3.openIters, NORMAL);
            } catch (error) {
              return iteratorClose(iterator, THROW, error);
            }
            if (iterator) iteratorClose(iterator, NORMAL);
            return createIterResultObject(void 0, true);
          }
        });
      };
      var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
      var IteratorHelperPrototype = createIteratorProxyPrototype(false);
      createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, "Iterator Helper");
      module.exports = function(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {
        var IteratorProxy = function Iterator2(record, state3) {
          if (state3) {
            state3.iterator = record.iterator;
            state3.next = record.next;
          } else state3 = record;
          state3.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
          state3.returnHandlerResult = !!RETURN_HANDLER_RESULT;
          state3.nextHandler = nextHandler;
          state3.counter = 0;
          state3.done = false;
          setInternalState(this, state3);
        };
        IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;
        return IteratorProxy;
      };
    }
  });

  // node_modules/core-js/internals/iterator-helper-throws-on-invalid-iterator.js
  var require_iterator_helper_throws_on_invalid_iterator = __commonJS({
    "node_modules/core-js/internals/iterator-helper-throws-on-invalid-iterator.js"(exports, module) {
      "use strict";
      module.exports = function(methodName, argument) {
        var method = typeof Iterator == "function" && Iterator.prototype[methodName];
        if (method) try {
          method.call({ next: null }, argument).next();
        } catch (error) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js
  var require_iterator_helper_without_closing_on_early_error = __commonJS({
    "node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      module.exports = function(METHOD_NAME, ExpectedError) {
        var Iterator2 = globalThis2.Iterator;
        var IteratorPrototype = Iterator2 && Iterator2.prototype;
        var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];
        var CLOSED = false;
        if (method) try {
          method.call({
            next: function() {
              return { done: true };
            },
            "return": function() {
              CLOSED = true;
            }
          }, -1);
        } catch (error) {
          if (!(error instanceof ExpectedError)) CLOSED = false;
        }
        if (!CLOSED) return method;
      };
    }
  });

  // node_modules/core-js/modules/es.iterator.drop.js
  var require_es_iterator_drop = __commonJS({
    "node_modules/core-js/modules/es.iterator.drop.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var notANaN = require_not_a_nan();
      var toPositiveInteger = require_to_positive_integer();
      var iteratorClose = require_iterator_close();
      var createIteratorProxy = require_iterator_create_proxy();
      var iteratorHelperThrowsOnInvalidIterator = require_iterator_helper_throws_on_invalid_iterator();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var IS_PURE = require_is_pure();
      var DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("drop", 0);
      var dropWithoutClosingOnEarlyError = !IS_PURE && !DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("drop", RangeError);
      var FORCED = IS_PURE || DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR || dropWithoutClosingOnEarlyError;
      var IteratorProxy = createIteratorProxy(function() {
        var iterator = this.iterator;
        var next = this.next;
        var result, done;
        while (this.remaining) {
          this.remaining--;
          result = anObject(call(next, iterator));
          done = this.done = !!result.done;
          if (done) return;
        }
        result = anObject(call(next, iterator));
        done = this.done = !!result.done;
        if (!done) return result.value;
      });
      $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
        drop: function drop(limit) {
          anObject(this);
          var remaining;
          try {
            remaining = toPositiveInteger(notANaN(+limit));
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);
          return new IteratorProxy(getIteratorDirect(this), {
            remaining
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.every.js
  var require_es_iterator_every = __commonJS({
    "node_modules/core-js/modules/es.iterator.every.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("every", TypeError);
      $({ target: "Iterator", proto: true, real: true, forced: everyWithoutClosingOnEarlyError }, {
        every: function every(predicate) {
          anObject(this);
          try {
            aCallable(predicate);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);
          var record = getIteratorDirect(this);
          var counter = 0;
          return !iterate(record, function(value, stop) {
            if (!predicate(value, counter++)) return stop();
          }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.filter.js
  var require_es_iterator_filter = __commonJS({
    "node_modules/core-js/modules/es.iterator.filter.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var createIteratorProxy = require_iterator_create_proxy();
      var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
      var IS_PURE = require_is_pure();
      var iteratorClose = require_iterator_close();
      var iteratorHelperThrowsOnInvalidIterator = require_iterator_helper_throws_on_invalid_iterator();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("filter", function() {
      });
      var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("filter", TypeError);
      var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;
      var IteratorProxy = createIteratorProxy(function() {
        var iterator = this.iterator;
        var predicate = this.predicate;
        var next = this.next;
        var result, done, value;
        while (true) {
          result = anObject(call(next, iterator));
          done = this.done = !!result.done;
          if (done) return;
          value = result.value;
          if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
        }
      });
      $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
        filter: function filter(predicate) {
          anObject(this);
          try {
            aCallable(predicate);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);
          return new IteratorProxy(getIteratorDirect(this), {
            predicate
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.find.js
  var require_es_iterator_find = __commonJS({
    "node_modules/core-js/modules/es.iterator.find.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("find", TypeError);
      $({ target: "Iterator", proto: true, real: true, forced: findWithoutClosingOnEarlyError }, {
        find: function find(predicate) {
          anObject(this);
          try {
            aCallable(predicate);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);
          var record = getIteratorDirect(this);
          var counter = 0;
          return iterate(record, function(value, stop) {
            if (predicate(value, counter++)) return stop(value);
          }, { IS_RECORD: true, INTERRUPTED: true }).result;
        }
      });
    }
  });

  // node_modules/core-js/internals/get-iterator-flattenable.js
  var require_get_iterator_flattenable = __commonJS({
    "node_modules/core-js/internals/get-iterator-flattenable.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var getIteratorMethod = require_get_iterator_method();
      module.exports = function(obj, stringHandling) {
        if (!stringHandling || typeof obj !== "string") anObject(obj);
        var method = getIteratorMethod(obj);
        return getIteratorDirect(anObject(method !== void 0 ? call(method, obj) : obj));
      };
    }
  });

  // node_modules/core-js/modules/es.iterator.flat-map.js
  var require_es_iterator_flat_map = __commonJS({
    "node_modules/core-js/modules/es.iterator.flat-map.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var getIteratorFlattenable = require_get_iterator_flattenable();
      var createIteratorProxy = require_iterator_create_proxy();
      var iteratorClose = require_iterator_close();
      var IS_PURE = require_is_pure();
      var iteratorHelperThrowsOnInvalidIterator = require_iterator_helper_throws_on_invalid_iterator();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("flatMap", function() {
      });
      var flatMapWithoutClosingOnEarlyError = !IS_PURE && !FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("flatMap", TypeError);
      var FORCED = IS_PURE || FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || flatMapWithoutClosingOnEarlyError;
      var IteratorProxy = createIteratorProxy(function() {
        var iterator = this.iterator;
        var mapper = this.mapper;
        var result, inner;
        while (true) {
          if (inner = this.inner) try {
            result = anObject(call(inner.next, inner.iterator));
            if (!result.done) return result.value;
            this.inner = null;
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
          result = anObject(call(this.next, iterator));
          if (this.done = !!result.done) return;
          try {
            this.inner = getIteratorFlattenable(mapper(result.value, this.counter++), false);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
        }
      });
      $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
        flatMap: function flatMap(mapper) {
          anObject(this);
          try {
            aCallable(mapper);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);
          return new IteratorProxy(getIteratorDirect(this), {
            mapper,
            inner: null
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.for-each.js
  var require_es_iterator_for_each = __commonJS({
    "node_modules/core-js/modules/es.iterator.for-each.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("forEach", TypeError);
      $({ target: "Iterator", proto: true, real: true, forced: forEachWithoutClosingOnEarlyError }, {
        forEach: function forEach(fn) {
          anObject(this);
          try {
            aCallable(fn);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);
          var record = getIteratorDirect(this);
          var counter = 0;
          iterate(record, function(value) {
            fn(value, counter++);
          }, { IS_RECORD: true });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.from.js
  var require_es_iterator_from = __commonJS({
    "node_modules/core-js/modules/es.iterator.from.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var toObject = require_to_object();
      var isPrototypeOf = require_object_is_prototype_of();
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var createIteratorProxy = require_iterator_create_proxy();
      var getIteratorFlattenable = require_get_iterator_flattenable();
      var IS_PURE = require_is_pure();
      var FORCED = IS_PURE || (function() {
        try {
          Iterator.from({ "return": null })["return"]();
        } catch (error) {
          return true;
        }
      })();
      var IteratorProxy = createIteratorProxy(function() {
        return call(this.next, this.iterator);
      }, true);
      $({ target: "Iterator", stat: true, forced: FORCED }, {
        from: function from(O) {
          var iteratorRecord = getIteratorFlattenable(typeof O == "string" ? toObject(O) : O, true);
          return isPrototypeOf(IteratorPrototype, iteratorRecord.iterator) ? iteratorRecord.iterator : new IteratorProxy(iteratorRecord);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.map.js
  var require_es_iterator_map = __commonJS({
    "node_modules/core-js/modules/es.iterator.map.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var createIteratorProxy = require_iterator_create_proxy();
      var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
      var iteratorClose = require_iterator_close();
      var iteratorHelperThrowsOnInvalidIterator = require_iterator_helper_throws_on_invalid_iterator();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var IS_PURE = require_is_pure();
      var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("map", function() {
      });
      var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("map", TypeError);
      var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;
      var IteratorProxy = createIteratorProxy(function() {
        var iterator = this.iterator;
        var result = anObject(call(this.next, iterator));
        var done = this.done = !!result.done;
        if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
      });
      $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
        map: function map(mapper) {
          anObject(this);
          try {
            aCallable(mapper);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);
          return new IteratorProxy(getIteratorDirect(this), {
            mapper
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.reduce.js
  var require_es_iterator_reduce = __commonJS({
    "node_modules/core-js/modules/es.iterator.reduce.js"() {
      "use strict";
      var $ = require_export();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var apply = require_function_apply();
      var fails = require_fails();
      var $TypeError = TypeError;
      var FAILS_ON_INITIAL_UNDEFINED = fails(function() {
        [].keys().reduce(function() {
        }, void 0);
      });
      var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError("reduce", $TypeError);
      $({ target: "Iterator", proto: true, real: true, forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError }, {
        reduce: function reduce(reducer) {
          anObject(this);
          try {
            aCallable(reducer);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          var noInitial = arguments.length < 2;
          var accumulator = noInitial ? void 0 : arguments[1];
          if (reduceWithoutClosingOnEarlyError) {
            return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [reducer] : [reducer, accumulator]);
          }
          var record = getIteratorDirect(this);
          var counter = 0;
          iterate(record, function(value) {
            if (noInitial) {
              noInitial = false;
              accumulator = value;
            } else {
              accumulator = reducer(accumulator, value, counter);
            }
            counter++;
          }, { IS_RECORD: true });
          if (noInitial) throw new $TypeError("Reduce of empty iterator with no initial value");
          return accumulator;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.some.js
  var require_es_iterator_some = __commonJS({
    "node_modules/core-js/modules/es.iterator.some.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("some", TypeError);
      $({ target: "Iterator", proto: true, real: true, forced: someWithoutClosingOnEarlyError }, {
        some: function some(predicate) {
          anObject(this);
          try {
            aCallable(predicate);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);
          var record = getIteratorDirect(this);
          var counter = 0;
          return iterate(record, function(value, stop) {
            if (predicate(value, counter++)) return stop();
          }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.take.js
  var require_es_iterator_take = __commonJS({
    "node_modules/core-js/modules/es.iterator.take.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var notANaN = require_not_a_nan();
      var toPositiveInteger = require_to_positive_integer();
      var createIteratorProxy = require_iterator_create_proxy();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var IS_PURE = require_is_pure();
      var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError("take", RangeError);
      var IteratorProxy = createIteratorProxy(function() {
        var iterator = this.iterator;
        if (!this.remaining--) {
          this.done = true;
          return iteratorClose(iterator, "normal", void 0);
        }
        var result = anObject(call(this.next, iterator));
        var done = this.done = !!result.done;
        if (!done) return result.value;
      });
      $({ target: "Iterator", proto: true, real: true, forced: IS_PURE || takeWithoutClosingOnEarlyError }, {
        take: function take(limit) {
          anObject(this);
          var remaining;
          try {
            remaining = toPositiveInteger(notANaN(+limit));
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);
          return new IteratorProxy(getIteratorDirect(this), {
            remaining
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.to-array.js
  var require_es_iterator_to_array = __commonJS({
    "node_modules/core-js/modules/es.iterator.to-array.js"() {
      "use strict";
      var $ = require_export();
      var anObject = require_an_object();
      var iterate = require_iterate();
      var getIteratorDirect = require_get_iterator_direct();
      var push = [].push;
      $({ target: "Iterator", proto: true, real: true }, {
        toArray: function toArray() {
          var result = [];
          iterate(getIteratorDirect(anObject(this)), push, { that: result, IS_RECORD: true });
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.json.to-string-tag.js
  var require_es_json_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.json.to-string-tag.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var setToStringTag = require_set_to_string_tag();
      setToStringTag(globalThis2.JSON, "JSON", true);
    }
  });

  // node_modules/core-js/internals/array-buffer-non-extensible.js
  var require_array_buffer_non_extensible = __commonJS({
    "node_modules/core-js/internals/array-buffer-non-extensible.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = fails(function() {
        if (typeof ArrayBuffer == "function") {
          var buffer = new ArrayBuffer(8);
          if (Object.isExtensible(buffer)) Object.defineProperty(buffer, "a", { value: 8 });
        }
      });
    }
  });

  // node_modules/core-js/internals/object-is-extensible.js
  var require_object_is_extensible = __commonJS({
    "node_modules/core-js/internals/object-is-extensible.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var isObject4 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isExtensible = Object.isExtensible;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $isExtensible(1);
      });
      module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
        if (!isObject4(it)) return false;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer") return false;
        return $isExtensible ? $isExtensible(it) : true;
      } : $isExtensible;
    }
  });

  // node_modules/core-js/internals/freezing.js
  var require_freezing = __commonJS({
    "node_modules/core-js/internals/freezing.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = !fails(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      });
    }
  });

  // node_modules/core-js/internals/internal-metadata.js
  var require_internal_metadata = __commonJS({
    "node_modules/core-js/internals/internal-metadata.js"(exports, module) {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var hiddenKeys = require_hidden_keys();
      var isObject4 = require_is_object();
      var hasOwn = require_has_own_property();
      var defineProperty = require_object_define_property().f;
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertyNamesExternalModule = require_object_get_own_property_names_external();
      var isExtensible = require_object_is_extensible();
      var uid = require_uid();
      var FREEZING = require_freezing();
      var REQUIRED = false;
      var METADATA = uid("meta");
      var id = 0;
      var setMetadata = function(it) {
        defineProperty(it, METADATA, { value: {
          objectID: "O" + id++,
          // object ID
          weakData: {}
          // weak collections IDs
        } });
      };
      var fastKey = function(it, create) {
        if (!isObject4(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
        if (!hasOwn(it, METADATA)) {
          if (!isExtensible(it)) return "F";
          if (!create) return "E";
          setMetadata(it);
        }
        return it[METADATA].objectID;
      };
      var getWeakData = function(it, create) {
        if (!hasOwn(it, METADATA)) {
          if (!isExtensible(it)) return true;
          if (!create) return false;
          setMetadata(it);
        }
        return it[METADATA].weakData;
      };
      var onFreeze = function(it) {
        if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
        return it;
      };
      var enable = function() {
        meta2.enable = function() {
        };
        REQUIRED = true;
        var getOwnPropertyNames = getOwnPropertyNamesModule.f;
        var splice = uncurryThis([].splice);
        var test = {};
        test[METADATA] = 1;
        if (getOwnPropertyNames(test).length) {
          getOwnPropertyNamesModule.f = function(it) {
            var result = getOwnPropertyNames(it);
            for (var i = 0, length = result.length; i < length; i++) {
              if (result[i] === METADATA) {
                splice(result, i, 1);
                break;
              }
            }
            return result;
          };
          $({ target: "Object", stat: true, forced: true }, {
            getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
          });
        }
      };
      var meta2 = module.exports = {
        enable,
        fastKey,
        getWeakData,
        onFreeze
      };
      hiddenKeys[METADATA] = true;
    }
  });

  // node_modules/core-js/internals/collection.js
  var require_collection = __commonJS({
    "node_modules/core-js/internals/collection.js"(exports, module) {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var defineBuiltIn = require_define_built_in();
      var InternalMetadataModule = require_internal_metadata();
      var iterate = require_iterate();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var isNullOrUndefined = require_is_null_or_undefined();
      var isObject4 = require_is_object();
      var fails = require_fails();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var setToStringTag = require_set_to_string_tag();
      var inheritIfRequired = require_inherit_if_required();
      module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
        var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
        var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
        var ADDER = IS_MAP ? "set" : "add";
        var NativeConstructor = globalThis2[CONSTRUCTOR_NAME];
        var NativePrototype = NativeConstructor && NativeConstructor.prototype;
        var Constructor = NativeConstructor;
        var exported = {};
        var fixMethod = function(KEY) {
          var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
          defineBuiltIn(
            NativePrototype,
            KEY,
            KEY === "add" ? function add(value) {
              uncurriedNativeMethod(this, value === 0 ? 0 : value);
              return this;
            } : KEY === "delete" ? function(key) {
              return IS_WEAK && !isObject4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : KEY === "get" ? function get(key) {
              return IS_WEAK && !isObject4(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : KEY === "has" ? function has(key) {
              return IS_WEAK && !isObject4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : function set(key, value) {
              uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
              return this;
            }
          );
        };
        var REPLACE = isForced(
          CONSTRUCTOR_NAME,
          !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
            new NativeConstructor().entries().next();
          }))
        );
        if (REPLACE) {
          Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
          InternalMetadataModule.enable();
        } else if (isForced(CONSTRUCTOR_NAME, true)) {
          var instance = new Constructor();
          var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
          var THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
          });
          var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
            new NativeConstructor(iterable);
          });
          var BUGGY_ZERO = !IS_WEAK && fails(function() {
            var $instance = new NativeConstructor();
            var index = 5;
            while (index--) $instance[ADDER](index, index);
            return !$instance.has(-0);
          });
          if (!ACCEPT_ITERABLES) {
            Constructor = wrapper(function(dummy, iterable) {
              anInstance(dummy, NativePrototype);
              var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
              if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
              return that;
            });
            Constructor.prototype = NativePrototype;
            NativePrototype.constructor = Constructor;
          }
          if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod("delete");
            fixMethod("has");
            IS_MAP && fixMethod("get");
          }
          if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
          if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
        }
        exported[CONSTRUCTOR_NAME] = Constructor;
        $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
        setToStringTag(Constructor, CONSTRUCTOR_NAME);
        if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
        return Constructor;
      };
    }
  });

  // node_modules/core-js/internals/collection-strong.js
  var require_collection_strong = __commonJS({
    "node_modules/core-js/internals/collection-strong.js"(exports, module) {
      "use strict";
      var create = require_object_create();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var bind2 = require_function_bind_context();
      var anInstance = require_an_instance();
      var isNullOrUndefined = require_is_null_or_undefined();
      var iterate = require_iterate();
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var setSpecies = require_set_species();
      var DESCRIPTORS = require_descriptors();
      var fastKey = require_internal_metadata().fastKey;
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var internalStateGetterFor = InternalStateModule.getterFor;
      module.exports = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              index: create(null),
              first: null,
              last: null,
              size: 0
            });
            if (!DESCRIPTORS) that.size = 0;
            if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define = function(that, key, value) {
            var state3 = getInternalState(that);
            var entry = getEntry(that, key);
            var previous, index;
            if (entry) {
              entry.value = value;
            } else {
              state3.last = entry = {
                index: index = fastKey(key, true),
                key,
                value,
                previous: previous = state3.last,
                next: null,
                removed: false
              };
              if (!state3.first) state3.first = entry;
              if (previous) previous.next = entry;
              if (DESCRIPTORS) state3.size++;
              else that.size++;
              if (index !== "F") state3.index[index] = entry;
            }
            return that;
          };
          var getEntry = function(that, key) {
            var state3 = getInternalState(that);
            var index = fastKey(key);
            var entry;
            if (index !== "F") return state3.index[index];
            for (entry = state3.first; entry; entry = entry.next) {
              if (entry.key === key) return entry;
            }
          };
          defineBuiltIns(Prototype, {
            // `{ Map, Set }.prototype.clear()` methods
            // https://tc39.es/ecma262/#sec-map.prototype.clear
            // https://tc39.es/ecma262/#sec-set.prototype.clear
            clear: function clear() {
              var that = this;
              var state3 = getInternalState(that);
              var entry = state3.first;
              while (entry) {
                entry.removed = true;
                if (entry.previous) entry.previous = entry.previous.next = null;
                entry = entry.next;
              }
              state3.first = state3.last = null;
              state3.index = create(null);
              if (DESCRIPTORS) state3.size = 0;
              else that.size = 0;
            },
            // `{ Map, Set }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.delete
            // https://tc39.es/ecma262/#sec-set.prototype.delete
            "delete": function(key) {
              var that = this;
              var state3 = getInternalState(that);
              var entry = getEntry(that, key);
              if (entry) {
                var next = entry.next;
                var prev = entry.previous;
                delete state3.index[entry.index];
                entry.removed = true;
                if (prev) prev.next = next;
                if (next) next.previous = prev;
                if (state3.first === entry) state3.first = next;
                if (state3.last === entry) state3.last = prev;
                if (DESCRIPTORS) state3.size--;
                else that.size--;
              }
              return !!entry;
            },
            // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.foreach
            // https://tc39.es/ecma262/#sec-set.prototype.foreach
            forEach: function forEach(callbackfn) {
              var state3 = getInternalState(this);
              var boundFunction = bind2(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              var entry;
              while (entry = entry ? entry.next : state3.first) {
                boundFunction(entry.value, entry.key, this);
                while (entry && entry.removed) entry = entry.previous;
              }
            },
            // `{ Map, Set}.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.has
            // https://tc39.es/ecma262/#sec-set.prototype.has
            has: function has(key) {
              return !!getEntry(this, key);
            }
          });
          defineBuiltIns(Prototype, IS_MAP ? {
            // `Map.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-map.prototype.get
            get: function get(key) {
              var entry = getEntry(this, key);
              return entry && entry.value;
            },
            // `Map.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-map.prototype.set
            set: function set(key, value) {
              return define(this, key === 0 ? 0 : key, value);
            }
          } : {
            // `Set.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-set.prototype.add
            add: function add(value) {
              return define(this, value = value === 0 ? 0 : value, value);
            }
          });
          if (DESCRIPTORS) defineBuiltInAccessor(Prototype, "size", {
            configurable: true,
            get: function() {
              return getInternalState(this).size;
            }
          });
          return Constructor;
        },
        setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
          var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
          var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
          defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
            setInternalState(this, {
              type: ITERATOR_NAME,
              target: iterated,
              state: getInternalCollectionState(iterated),
              kind,
              last: null
            });
          }, function() {
            var state3 = getInternalIteratorState(this);
            var kind = state3.kind;
            var entry = state3.last;
            while (entry && entry.removed) entry = entry.previous;
            if (!state3.target || !(state3.last = entry = entry ? entry.next : state3.state.first)) {
              state3.target = null;
              return createIterResultObject(void 0, true);
            }
            if (kind === "keys") return createIterResultObject(entry.key, false);
            if (kind === "values") return createIterResultObject(entry.value, false);
            return createIterResultObject([entry.key, entry.value], false);
          }, IS_MAP ? "entries" : "values", !IS_MAP, true);
          setSpecies(CONSTRUCTOR_NAME);
        }
      };
    }
  });

  // node_modules/core-js/modules/es.map.constructor.js
  var require_es_map_constructor = __commonJS({
    "node_modules/core-js/modules/es.map.constructor.js"() {
      "use strict";
      var collection = require_collection();
      var collectionStrong = require_collection_strong();
      collection("Map", function(init2) {
        return function Map2() {
          return init2(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
    }
  });

  // node_modules/core-js/modules/es.map.js
  var require_es_map = __commonJS({
    "node_modules/core-js/modules/es.map.js"() {
      "use strict";
      require_es_map_constructor();
    }
  });

  // node_modules/core-js/internals/map-helpers.js
  var require_map_helpers = __commonJS({
    "node_modules/core-js/internals/map-helpers.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var MapPrototype = Map.prototype;
      module.exports = {
        // eslint-disable-next-line es/no-map -- safe
        Map,
        set: uncurryThis(MapPrototype.set),
        get: uncurryThis(MapPrototype.get),
        has: uncurryThis(MapPrototype.has),
        remove: uncurryThis(MapPrototype["delete"]),
        proto: MapPrototype
      };
    }
  });

  // node_modules/core-js/modules/es.map.group-by.js
  var require_es_map_group_by = __commonJS({
    "node_modules/core-js/modules/es.map.group-by.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var requireObjectCoercible = require_require_object_coercible();
      var iterate = require_iterate();
      var MapHelpers = require_map_helpers();
      var IS_PURE = require_is_pure();
      var fails = require_fails();
      var Map2 = MapHelpers.Map;
      var has = MapHelpers.has;
      var get = MapHelpers.get;
      var set = MapHelpers.set;
      var push = uncurryThis([].push);
      var DOES_NOT_WORK_WITH_PRIMITIVES = IS_PURE || fails(function() {
        return Map2.groupBy("ab", function(it) {
          return it;
        }).get("a").length !== 1;
      });
      $({ target: "Map", stat: true, forced: IS_PURE || DOES_NOT_WORK_WITH_PRIMITIVES }, {
        groupBy: function groupBy(items, callbackfn) {
          requireObjectCoercible(items);
          aCallable(callbackfn);
          var map = new Map2();
          var k = 0;
          iterate(items, function(value) {
            var key = callbackfn(value, k++);
            if (!has(map, key)) set(map, key, [value]);
            else push(get(map, key), value);
          });
          return map;
        }
      });
    }
  });

  // node_modules/core-js/internals/math-log1p.js
  var require_math_log1p = __commonJS({
    "node_modules/core-js/internals/math-log1p.js"(exports, module) {
      "use strict";
      var log = Math.log;
      module.exports = Math.log1p || function log1p(x) {
        var n = +x;
        return n > -1e-8 && n < 1e-8 ? n - n * n / 2 : log(1 + n);
      };
    }
  });

  // node_modules/core-js/modules/es.math.acosh.js
  var require_es_math_acosh = __commonJS({
    "node_modules/core-js/modules/es.math.acosh.js"() {
      "use strict";
      var $ = require_export();
      var log1p = require_math_log1p();
      var $acosh = Math.acosh;
      var log = Math.log;
      var sqrt = Math.sqrt;
      var LN2 = Math.LN2;
      var FORCED = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) !== 710 || $acosh(Infinity) !== Infinity;
      $({ target: "Math", stat: true, forced: FORCED }, {
        acosh: function acosh(x) {
          var n = +x;
          return n < 1 ? NaN : n > 9490626562425156e-8 ? log(n) + LN2 : log1p(n - 1 + sqrt(n - 1) * sqrt(n + 1));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.asinh.js
  var require_es_math_asinh = __commonJS({
    "node_modules/core-js/modules/es.math.asinh.js"() {
      "use strict";
      var $ = require_export();
      var $asinh = Math.asinh;
      var log = Math.log;
      var sqrt = Math.sqrt;
      function asinh(x) {
        var n = +x;
        return !isFinite(n) || n === 0 ? n : n < 0 ? -asinh(-n) : log(n + sqrt(n * n + 1));
      }
      var FORCED = !($asinh && 1 / $asinh(0) > 0);
      $({ target: "Math", stat: true, forced: FORCED }, {
        asinh
      });
    }
  });

  // node_modules/core-js/modules/es.math.atanh.js
  var require_es_math_atanh = __commonJS({
    "node_modules/core-js/modules/es.math.atanh.js"() {
      "use strict";
      var $ = require_export();
      var $atanh = Math.atanh;
      var log = Math.log;
      var FORCED = !($atanh && 1 / $atanh(-0) < 0);
      $({ target: "Math", stat: true, forced: FORCED }, {
        atanh: function atanh(x) {
          var n = +x;
          return n === 0 ? n : log((1 + n) / (1 - n)) / 2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.cbrt.js
  var require_es_math_cbrt = __commonJS({
    "node_modules/core-js/modules/es.math.cbrt.js"() {
      "use strict";
      var $ = require_export();
      var sign = require_math_sign();
      var abs = Math.abs;
      var pow = Math.pow;
      $({ target: "Math", stat: true }, {
        cbrt: function cbrt(x) {
          var n = +x;
          return sign(n) * pow(abs(n), 1 / 3);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.clz32.js
  var require_es_math_clz32 = __commonJS({
    "node_modules/core-js/modules/es.math.clz32.js"() {
      "use strict";
      var $ = require_export();
      var floor = Math.floor;
      var log = Math.log;
      var LOG2E = Math.LOG2E;
      $({ target: "Math", stat: true }, {
        clz32: function clz32(x) {
          var n = x >>> 0;
          return n ? 31 - floor(log(n + 0.5) * LOG2E) : 32;
        }
      });
    }
  });

  // node_modules/core-js/internals/math-expm1.js
  var require_math_expm1 = __commonJS({
    "node_modules/core-js/internals/math-expm1.js"(exports, module) {
      "use strict";
      var $expm1 = Math.expm1;
      var exp = Math.exp;
      module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) !== -2e-17 ? function expm1(x) {
        var n = +x;
        return n === 0 ? n : n > -1e-6 && n < 1e-6 ? n + n * n / 2 : exp(n) - 1;
      } : $expm1;
    }
  });

  // node_modules/core-js/modules/es.math.cosh.js
  var require_es_math_cosh = __commonJS({
    "node_modules/core-js/modules/es.math.cosh.js"() {
      "use strict";
      var $ = require_export();
      var expm1 = require_math_expm1();
      var $cosh = Math.cosh;
      var abs = Math.abs;
      var E = Math.E;
      var FORCED = !$cosh || $cosh(710) === Infinity;
      $({ target: "Math", stat: true, forced: FORCED }, {
        cosh: function cosh(x) {
          var t = expm1(abs(x) - 1) + 1;
          return (t + 1 / (t * E * E)) * (E / 2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.expm1.js
  var require_es_math_expm1 = __commonJS({
    "node_modules/core-js/modules/es.math.expm1.js"() {
      "use strict";
      var $ = require_export();
      var expm1 = require_math_expm1();
      $({ target: "Math", stat: true, forced: expm1 !== Math.expm1 }, { expm1 });
    }
  });

  // node_modules/core-js/modules/es.math.fround.js
  var require_es_math_fround = __commonJS({
    "node_modules/core-js/modules/es.math.fround.js"() {
      "use strict";
      var $ = require_export();
      var fround = require_math_fround();
      $({ target: "Math", stat: true }, { fround });
    }
  });

  // node_modules/core-js/modules/es.math.f16round.js
  var require_es_math_f16round = __commonJS({
    "node_modules/core-js/modules/es.math.f16round.js"() {
      "use strict";
      var $ = require_export();
      var floatRound = require_math_float_round();
      var FLOAT16_EPSILON = 9765625e-10;
      var FLOAT16_MAX_VALUE = 65504;
      var FLOAT16_MIN_VALUE = 6103515625e-14;
      $({ target: "Math", stat: true }, {
        f16round: function f16round(x) {
          return floatRound(x, FLOAT16_EPSILON, FLOAT16_MAX_VALUE, FLOAT16_MIN_VALUE);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.hypot.js
  var require_es_math_hypot = __commonJS({
    "node_modules/core-js/modules/es.math.hypot.js"() {
      "use strict";
      var $ = require_export();
      var $hypot = Math.hypot;
      var abs = Math.abs;
      var sqrt = Math.sqrt;
      var FORCED = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
      $({ target: "Math", stat: true, arity: 2, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        hypot: function hypot(value1, value2) {
          var sum = 0;
          var i = 0;
          var aLen = arguments.length;
          var larg = 0;
          var arg, div;
          while (i < aLen) {
            arg = abs(arguments[i++]);
            if (larg < arg) {
              div = larg / arg;
              sum = sum * div * div + 1;
              larg = arg;
            } else if (arg > 0) {
              div = arg / larg;
              sum += div * div;
            } else sum += arg;
          }
          return larg === Infinity ? Infinity : larg * sqrt(sum);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.imul.js
  var require_es_math_imul = __commonJS({
    "node_modules/core-js/modules/es.math.imul.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var $imul = Math.imul;
      var FORCED = fails(function() {
        return $imul(4294967295, 5) !== -5 || $imul.length !== 2;
      });
      $({ target: "Math", stat: true, forced: FORCED }, {
        imul: function imul(x, y) {
          var UINT16 = 65535;
          var xn = +x;
          var yn = +y;
          var xl = UINT16 & xn;
          var yl = UINT16 & yn;
          return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/math-log10.js
  var require_math_log10 = __commonJS({
    "node_modules/core-js/internals/math-log10.js"(exports, module) {
      "use strict";
      var log = Math.log;
      var LOG10E = Math.LOG10E;
      module.exports = Math.log10 || function log10(x) {
        return log(x) * LOG10E;
      };
    }
  });

  // node_modules/core-js/modules/es.math.log10.js
  var require_es_math_log10 = __commonJS({
    "node_modules/core-js/modules/es.math.log10.js"() {
      "use strict";
      var $ = require_export();
      var log10 = require_math_log10();
      $({ target: "Math", stat: true }, {
        log10
      });
    }
  });

  // node_modules/core-js/modules/es.math.log1p.js
  var require_es_math_log1p = __commonJS({
    "node_modules/core-js/modules/es.math.log1p.js"() {
      "use strict";
      var $ = require_export();
      var log1p = require_math_log1p();
      $({ target: "Math", stat: true }, { log1p });
    }
  });

  // node_modules/core-js/modules/es.math.log2.js
  var require_es_math_log2 = __commonJS({
    "node_modules/core-js/modules/es.math.log2.js"() {
      "use strict";
      var $ = require_export();
      var log2 = require_math_log2();
      $({ target: "Math", stat: true }, {
        log2
      });
    }
  });

  // node_modules/core-js/modules/es.math.sign.js
  var require_es_math_sign = __commonJS({
    "node_modules/core-js/modules/es.math.sign.js"() {
      "use strict";
      var $ = require_export();
      var sign = require_math_sign();
      $({ target: "Math", stat: true }, {
        sign
      });
    }
  });

  // node_modules/core-js/modules/es.math.sinh.js
  var require_es_math_sinh = __commonJS({
    "node_modules/core-js/modules/es.math.sinh.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var expm1 = require_math_expm1();
      var abs = Math.abs;
      var exp = Math.exp;
      var E = Math.E;
      var FORCED = fails(function() {
        return Math.sinh(-2e-17) !== -2e-17;
      });
      $({ target: "Math", stat: true, forced: FORCED }, {
        sinh: function sinh(x) {
          var n = +x;
          return abs(n) < 1 ? (expm1(n) - expm1(-n)) / 2 : (exp(n - 1) - exp(-n - 1)) * (E / 2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.sum-precise.js
  var require_es_math_sum_precise = __commonJS({
    "node_modules/core-js/modules/es.math.sum-precise.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var iterate = require_iterate();
      var $RangeError = RangeError;
      var $TypeError = TypeError;
      var $Infinity = Infinity;
      var $NaN = NaN;
      var abs = Math.abs;
      var pow = Math.pow;
      var push = uncurryThis([].push);
      var POW_2_1023 = pow(2, 1023);
      var MAX_SAFE_INTEGER = pow(2, 53) - 1;
      var MAX_DOUBLE = Number.MAX_VALUE;
      var MAX_ULP = pow(2, 971);
      var NOT_A_NUMBER = {};
      var MINUS_INFINITY = {};
      var PLUS_INFINITY = {};
      var MINUS_ZERO = {};
      var FINITE = {};
      var twosum = function(x, y) {
        var hi = x + y;
        var lo = y - (hi - x);
        return { hi, lo };
      };
      $({ target: "Math", stat: true }, {
        // eslint-disable-next-line max-statements -- ok
        sumPrecise: function sumPrecise(items) {
          var numbers = [];
          var count = 0;
          var state3 = MINUS_ZERO;
          iterate(items, function(n2) {
            if (++count >= MAX_SAFE_INTEGER) throw new $RangeError("Maximum allowed index exceeded");
            if (typeof n2 != "number") throw new $TypeError("Value is not a number");
            if (state3 !== NOT_A_NUMBER) {
              if (n2 !== n2) state3 = NOT_A_NUMBER;
              else if (n2 === $Infinity) state3 = state3 === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;
              else if (n2 === -$Infinity) state3 = state3 === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;
              else if ((n2 !== 0 || 1 / n2 === $Infinity) && (state3 === MINUS_ZERO || state3 === FINITE)) {
                state3 = FINITE;
                push(numbers, n2);
              }
            }
          });
          switch (state3) {
            case NOT_A_NUMBER:
              return $NaN;
            case MINUS_INFINITY:
              return -$Infinity;
            case PLUS_INFINITY:
              return $Infinity;
            case MINUS_ZERO:
              return -0;
          }
          var partials = [];
          var overflow = 0;
          var x, y, sum, hi, lo, tmp;
          for (var i = 0; i < numbers.length; i++) {
            x = numbers[i];
            var actuallyUsedPartials = 0;
            for (var j = 0; j < partials.length; j++) {
              y = partials[j];
              if (abs(x) < abs(y)) {
                tmp = x;
                x = y;
                y = tmp;
              }
              sum = twosum(x, y);
              hi = sum.hi;
              lo = sum.lo;
              if (abs(hi) === $Infinity) {
                var sign = hi === $Infinity ? 1 : -1;
                overflow += sign;
                x = x - sign * POW_2_1023 - sign * POW_2_1023;
                if (abs(x) < abs(y)) {
                  tmp = x;
                  x = y;
                  y = tmp;
                }
                sum = twosum(x, y);
                hi = sum.hi;
                lo = sum.lo;
              }
              if (lo !== 0) partials[actuallyUsedPartials++] = lo;
              x = hi;
            }
            partials.length = actuallyUsedPartials;
            if (x !== 0) push(partials, x);
          }
          var n = partials.length - 1;
          hi = 0;
          lo = 0;
          if (overflow !== 0) {
            var next = n >= 0 ? partials[n] : 0;
            n--;
            if (abs(overflow) > 1 || overflow > 0 && next > 0 || overflow < 0 && next < 0) {
              return overflow > 0 ? $Infinity : -$Infinity;
            }
            sum = twosum(overflow * POW_2_1023, next / 2);
            hi = sum.hi;
            lo = sum.lo;
            lo *= 2;
            if (abs(2 * hi) === $Infinity) {
              if (hi > 0) {
                return hi === POW_2_1023 && lo === -(MAX_ULP / 2) && n >= 0 && partials[n] < 0 ? MAX_DOUBLE : $Infinity;
              }
              return hi === -POW_2_1023 && lo === MAX_ULP / 2 && n >= 0 && partials[n] > 0 ? -MAX_DOUBLE : -$Infinity;
            }
            if (lo !== 0) {
              partials[++n] = lo;
              lo = 0;
            }
            hi *= 2;
          }
          while (n >= 0) {
            sum = twosum(hi, partials[n--]);
            hi = sum.hi;
            lo = sum.lo;
            if (lo !== 0) break;
          }
          if (n >= 0 && (lo < 0 && partials[n] < 0 || lo > 0 && partials[n] > 0)) {
            y = lo * 2;
            x = hi + y;
            if (y === x - hi) hi = x;
          }
          return hi;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.tanh.js
  var require_es_math_tanh = __commonJS({
    "node_modules/core-js/modules/es.math.tanh.js"() {
      "use strict";
      var $ = require_export();
      var expm1 = require_math_expm1();
      var exp = Math.exp;
      $({ target: "Math", stat: true }, {
        tanh: function tanh(x) {
          var n = +x;
          var a = expm1(n);
          var b = expm1(-n);
          return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (exp(n) + exp(-n));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.to-string-tag.js
  var require_es_math_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.math.to-string-tag.js"() {
      "use strict";
      var setToStringTag = require_set_to_string_tag();
      setToStringTag(Math, "Math", true);
    }
  });

  // node_modules/core-js/modules/es.math.trunc.js
  var require_es_math_trunc = __commonJS({
    "node_modules/core-js/modules/es.math.trunc.js"() {
      "use strict";
      var $ = require_export();
      var trunc = require_math_trunc();
      $({ target: "Math", stat: true }, {
        trunc
      });
    }
  });

  // node_modules/core-js/internals/this-number-value.js
  var require_this_number_value = __commonJS({
    "node_modules/core-js/internals/this-number-value.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis(1.1.valueOf);
    }
  });

  // node_modules/core-js/internals/whitespaces.js
  var require_whitespaces = __commonJS({
    "node_modules/core-js/internals/whitespaces.js"(exports, module) {
      "use strict";
      module.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }
  });

  // node_modules/core-js/internals/string-trim.js
  var require_string_trim = __commonJS({
    "node_modules/core-js/internals/string-trim.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var whitespaces = require_whitespaces();
      var replace = uncurryThis("".replace);
      var ltrim = RegExp("^[" + whitespaces + "]+");
      var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
      var createMethod = function(TYPE) {
        return function($this) {
          var string = toString(requireObjectCoercible($this));
          if (TYPE & 1) string = replace(string, ltrim, "");
          if (TYPE & 2) string = replace(string, rtrim, "$1");
          return string;
        };
      };
      module.exports = {
        // `String.prototype.{ trimLeft, trimStart }` methods
        // https://tc39.es/ecma262/#sec-string.prototype.trimstart
        start: createMethod(1),
        // `String.prototype.{ trimRight, trimEnd }` methods
        // https://tc39.es/ecma262/#sec-string.prototype.trimend
        end: createMethod(2),
        // `String.prototype.trim` method
        // https://tc39.es/ecma262/#sec-string.prototype.trim
        trim: createMethod(3)
      };
    }
  });

  // node_modules/core-js/modules/es.number.constructor.js
  var require_es_number_constructor = __commonJS({
    "node_modules/core-js/modules/es.number.constructor.js"() {
      "use strict";
      var $ = require_export();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var globalThis2 = require_global_this();
      var path = require_path();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var hasOwn = require_has_own_property();
      var inheritIfRequired = require_inherit_if_required();
      var isPrototypeOf = require_object_is_prototype_of();
      var isSymbol = require_is_symbol();
      var toPrimitive = require_to_primitive();
      var fails = require_fails();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var defineProperty = require_object_define_property().f;
      var thisNumberValue = require_this_number_value();
      var trim = require_string_trim().trim;
      var NUMBER = "Number";
      var NativeNumber = globalThis2[NUMBER];
      var PureNumberNamespace = path[NUMBER];
      var NumberPrototype = NativeNumber.prototype;
      var TypeError2 = globalThis2.TypeError;
      var stringSlice = uncurryThis("".slice);
      var charCodeAt = uncurryThis("".charCodeAt);
      var toNumeric = function(value) {
        var primValue = toPrimitive(value, "number");
        return typeof primValue == "bigint" ? primValue : toNumber(primValue);
      };
      var toNumber = function(argument) {
        var it = toPrimitive(argument, "number");
        var first, third, radix, maxCode, digits, length, index, code;
        if (isSymbol(it)) throw new TypeError2("Cannot convert a Symbol value to a number");
        if (typeof it == "string" && it.length > 2) {
          it = trim(it);
          first = charCodeAt(it, 0);
          if (first === 43 || first === 45) {
            third = charCodeAt(it, 2);
            if (third === 88 || third === 120) return NaN;
          } else if (first === 48) {
            switch (charCodeAt(it, 1)) {
              // fast equal of /^0b[01]+$/i
              case 66:
              case 98:
                radix = 2;
                maxCode = 49;
                break;
              // fast equal of /^0o[0-7]+$/i
              case 79:
              case 111:
                radix = 8;
                maxCode = 55;
                break;
              default:
                return +it;
            }
            digits = stringSlice(it, 2);
            length = digits.length;
            for (index = 0; index < length; index++) {
              code = charCodeAt(digits, index);
              if (code < 48 || code > maxCode) return NaN;
            }
            return parseInt(digits, radix);
          }
        }
        return +it;
      };
      var FORCED = isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"));
      var calledWithNew = function(dummy) {
        return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
          thisNumberValue(dummy);
        });
      };
      var NumberWrapper = function Number2(value) {
        var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
        return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
      };
      NumberWrapper.prototype = NumberPrototype;
      if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;
      $({ global: true, constructor: true, wrap: true, forced: FORCED }, {
        Number: NumberWrapper
      });
      var copyConstructorProperties = function(target, source) {
        for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
          // ES3:
          "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
        ), j = 0, key; keys.length > j; j++) {
          if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
      if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
      if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);
    }
  });

  // node_modules/core-js/modules/es.number.epsilon.js
  var require_es_number_epsilon = __commonJS({
    "node_modules/core-js/modules/es.number.epsilon.js"() {
      "use strict";
      var $ = require_export();
      $({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        EPSILON: Math.pow(2, -52)
      });
    }
  });

  // node_modules/core-js/internals/number-is-finite.js
  var require_number_is_finite = __commonJS({
    "node_modules/core-js/internals/number-is-finite.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var globalIsFinite = globalThis2.isFinite;
      module.exports = Number.isFinite || function isFinite2(it) {
        return typeof it == "number" && globalIsFinite(it);
      };
    }
  });

  // node_modules/core-js/modules/es.number.is-finite.js
  var require_es_number_is_finite = __commonJS({
    "node_modules/core-js/modules/es.number.is-finite.js"() {
      "use strict";
      var $ = require_export();
      var numberIsFinite = require_number_is_finite();
      $({ target: "Number", stat: true }, { isFinite: numberIsFinite });
    }
  });

  // node_modules/core-js/internals/is-integral-number.js
  var require_is_integral_number = __commonJS({
    "node_modules/core-js/internals/is-integral-number.js"(exports, module) {
      "use strict";
      var isObject4 = require_is_object();
      var floor = Math.floor;
      module.exports = Number.isInteger || function isInteger(it) {
        return !isObject4(it) && isFinite(it) && floor(it) === it;
      };
    }
  });

  // node_modules/core-js/modules/es.number.is-integer.js
  var require_es_number_is_integer = __commonJS({
    "node_modules/core-js/modules/es.number.is-integer.js"() {
      "use strict";
      var $ = require_export();
      var isIntegralNumber = require_is_integral_number();
      $({ target: "Number", stat: true }, {
        isInteger: isIntegralNumber
      });
    }
  });

  // node_modules/core-js/modules/es.number.is-nan.js
  var require_es_number_is_nan = __commonJS({
    "node_modules/core-js/modules/es.number.is-nan.js"() {
      "use strict";
      var $ = require_export();
      $({ target: "Number", stat: true }, {
        isNaN: function isNaN2(number) {
          return number !== number;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.is-safe-integer.js
  var require_es_number_is_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.is-safe-integer.js"() {
      "use strict";
      var $ = require_export();
      var isIntegralNumber = require_is_integral_number();
      var abs = Math.abs;
      $({ target: "Number", stat: true }, {
        isSafeInteger: function isSafeInteger(number) {
          return isIntegralNumber(number) && abs(number) <= 9007199254740991;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.max-safe-integer.js
  var require_es_number_max_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.max-safe-integer.js"() {
      "use strict";
      var $ = require_export();
      $({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        MAX_SAFE_INTEGER: 9007199254740991
      });
    }
  });

  // node_modules/core-js/modules/es.number.min-safe-integer.js
  var require_es_number_min_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.min-safe-integer.js"() {
      "use strict";
      var $ = require_export();
      $({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        MIN_SAFE_INTEGER: -9007199254740991
      });
    }
  });

  // node_modules/core-js/internals/number-parse-float.js
  var require_number_parse_float = __commonJS({
    "node_modules/core-js/internals/number-parse-float.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var trim = require_string_trim().trim;
      var whitespaces = require_whitespaces();
      var charAt = uncurryThis("".charAt);
      var $parseFloat = globalThis2.parseFloat;
      var Symbol2 = globalThis2.Symbol;
      var ITERATOR = Symbol2 && Symbol2.iterator;
      var FORCED = 1 / $parseFloat(whitespaces + "-0") !== -Infinity || ITERATOR && !fails(function() {
        $parseFloat(Object(ITERATOR));
      });
      module.exports = FORCED ? function parseFloat2(string) {
        var trimmedString = trim(toString(string));
        var result = $parseFloat(trimmedString);
        return result === 0 && charAt(trimmedString, 0) === "-" ? -0 : result;
      } : $parseFloat;
    }
  });

  // node_modules/core-js/modules/es.number.parse-float.js
  var require_es_number_parse_float = __commonJS({
    "node_modules/core-js/modules/es.number.parse-float.js"() {
      "use strict";
      var $ = require_export();
      var parseFloat2 = require_number_parse_float();
      $({ target: "Number", stat: true, forced: Number.parseFloat !== parseFloat2 }, {
        parseFloat: parseFloat2
      });
    }
  });

  // node_modules/core-js/internals/number-parse-int.js
  var require_number_parse_int = __commonJS({
    "node_modules/core-js/internals/number-parse-int.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var trim = require_string_trim().trim;
      var whitespaces = require_whitespaces();
      var $parseInt = globalThis2.parseInt;
      var Symbol2 = globalThis2.Symbol;
      var ITERATOR = Symbol2 && Symbol2.iterator;
      var hex = /^[+-]?0x/i;
      var exec = uncurryThis(hex.exec);
      var FORCED = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22 || ITERATOR && !fails(function() {
        $parseInt(Object(ITERATOR));
      });
      module.exports = FORCED ? function parseInt2(string, radix) {
        var S = trim(toString(string));
        return $parseInt(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
      } : $parseInt;
    }
  });

  // node_modules/core-js/modules/es.number.parse-int.js
  var require_es_number_parse_int = __commonJS({
    "node_modules/core-js/modules/es.number.parse-int.js"() {
      "use strict";
      var $ = require_export();
      var parseInt2 = require_number_parse_int();
      $({ target: "Number", stat: true, forced: Number.parseInt !== parseInt2 }, {
        parseInt: parseInt2
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-exponential.js
  var require_es_number_to_exponential = __commonJS({
    "node_modules/core-js/modules/es.number.to-exponential.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var thisNumberValue = require_this_number_value();
      var $repeat = require_string_repeat();
      var log10 = require_math_log10();
      var fails = require_fails();
      var $RangeError = RangeError;
      var $String = String;
      var $isFinite = isFinite;
      var abs = Math.abs;
      var floor = Math.floor;
      var pow = Math.pow;
      var round = Math.round;
      var nativeToExponential = uncurryThis(1.1.toExponential);
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var ROUNDS_PROPERLY = nativeToExponential(-69e-12, 4) === "-6.9000e-11" && nativeToExponential(1.255, 2) === "1.25e+0" && nativeToExponential(12345, 3) === "1.235e+4" && nativeToExponential(25, 0) === "3e+1";
      var throwsOnInfinityFraction = function() {
        return fails(function() {
          nativeToExponential(1, Infinity);
        }) && fails(function() {
          nativeToExponential(1, -Infinity);
        });
      };
      var properNonFiniteThisCheck = function() {
        return !fails(function() {
          nativeToExponential(Infinity, Infinity);
          nativeToExponential(NaN, Infinity);
        });
      };
      var FORCED = !ROUNDS_PROPERLY || !throwsOnInfinityFraction() || !properNonFiniteThisCheck();
      $({ target: "Number", proto: true, forced: FORCED }, {
        toExponential: function toExponential(fractionDigits) {
          var x = thisNumberValue(this);
          if (fractionDigits === void 0) return nativeToExponential(x);
          var f = toIntegerOrInfinity(fractionDigits);
          if (!$isFinite(x)) return String(x);
          if (f < 0 || f > 20) throw new $RangeError("Incorrect fraction digits");
          if (ROUNDS_PROPERLY) return nativeToExponential(x, f);
          var s = "";
          var m, e, c, d;
          if (x < 0) {
            s = "-";
            x = -x;
          }
          if (x === 0) {
            e = 0;
            m = repeat("0", f + 1);
          } else {
            var l = log10(x);
            e = floor(l);
            var w = pow(10, e - f);
            var n = round(x / w);
            if (2 * x >= (2 * n + 1) * w) {
              n += 1;
            }
            if (n >= pow(10, f + 1)) {
              n /= 10;
              e += 1;
            }
            m = $String(n);
          }
          if (f !== 0) {
            m = stringSlice(m, 0, 1) + "." + stringSlice(m, 1);
          }
          if (e === 0) {
            c = "+";
            d = "0";
          } else {
            c = e > 0 ? "+" : "-";
            d = $String(abs(e));
          }
          m += "e" + c + d;
          return s + m;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-fixed.js
  var require_es_number_to_fixed = __commonJS({
    "node_modules/core-js/modules/es.number.to-fixed.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var thisNumberValue = require_this_number_value();
      var $repeat = require_string_repeat();
      var fails = require_fails();
      var $RangeError = RangeError;
      var $String = String;
      var floor = Math.floor;
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var nativeToFixed = uncurryThis(1.1.toFixed);
      var pow = function(x, n, acc) {
        return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
      };
      var log = function(x) {
        var n = 0;
        var x2 = x;
        while (x2 >= 4096) {
          n += 12;
          x2 /= 4096;
        }
        while (x2 >= 2) {
          n += 1;
          x2 /= 2;
        }
        return n;
      };
      var multiply = function(data, n, c) {
        var index = -1;
        var c2 = c;
        while (++index < 6) {
          c2 += n * data[index];
          data[index] = c2 % 1e7;
          c2 = floor(c2 / 1e7);
        }
      };
      var divide = function(data, n) {
        var index = 6;
        var c = 0;
        while (--index >= 0) {
          c += data[index];
          data[index] = floor(c / n);
          c = c % n * 1e7;
        }
      };
      var dataToString = function(data) {
        var index = 6;
        var s = "";
        while (--index >= 0) {
          if (s !== "" || index === 0 || data[index] !== 0) {
            var t = $String(data[index]);
            s = s === "" ? t : s + repeat("0", 7 - t.length) + t;
          }
        }
        return s;
      };
      var FORCED = fails(function() {
        return nativeToFixed(8e-5, 3) !== "0.000" || nativeToFixed(0.9, 0) !== "1" || nativeToFixed(1.255, 2) !== "1.25" || nativeToFixed(1000000000000000100, 0) !== "1000000000000000128";
      }) || !fails(function() {
        nativeToFixed({});
      });
      $({ target: "Number", proto: true, forced: FORCED }, {
        toFixed: function toFixed(fractionDigits) {
          var number = thisNumberValue(this);
          var fractDigits = toIntegerOrInfinity(fractionDigits);
          var data = [0, 0, 0, 0, 0, 0];
          var sign = "";
          var result = "0";
          var e, z, j, k;
          if (fractDigits < 0 || fractDigits > 20) throw new $RangeError("Incorrect fraction digits");
          if (number !== number) return "NaN";
          if (number <= -1e21 || number >= 1e21) return $String(number);
          if (number < 0) {
            sign = "-";
            number = -number;
          }
          if (number > 1e-21) {
            e = log(number * pow(2, 69, 1)) - 69;
            z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
            z *= 4503599627370496;
            e = 52 - e;
            if (e > 0) {
              multiply(data, 0, z);
              j = fractDigits;
              while (j >= 7) {
                multiply(data, 1e7, 0);
                j -= 7;
              }
              multiply(data, pow(10, j, 1), 0);
              j = e - 1;
              while (j >= 23) {
                divide(data, 1 << 23);
                j -= 23;
              }
              divide(data, 1 << j);
              multiply(data, 1, 1);
              divide(data, 2);
              result = dataToString(data);
            } else {
              multiply(data, 0, z);
              multiply(data, 1 << -e, 0);
              result = dataToString(data) + repeat("0", fractDigits);
            }
          }
          if (fractDigits > 0) {
            k = result.length;
            result = sign + (k <= fractDigits ? "0." + repeat("0", fractDigits - k) + result : stringSlice(result, 0, k - fractDigits) + "." + stringSlice(result, k - fractDigits));
          } else {
            result = sign + result;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-precision.js
  var require_es_number_to_precision = __commonJS({
    "node_modules/core-js/modules/es.number.to-precision.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var thisNumberValue = require_this_number_value();
      var nativeToPrecision = uncurryThis(1.1.toPrecision);
      var FORCED = fails(function() {
        return nativeToPrecision(1, void 0) !== "1";
      }) || !fails(function() {
        nativeToPrecision({});
      });
      $({ target: "Number", proto: true, forced: FORCED }, {
        toPrecision: function toPrecision(precision2) {
          return precision2 === void 0 ? nativeToPrecision(thisNumberValue(this)) : nativeToPrecision(thisNumberValue(this), precision2);
        }
      });
    }
  });

  // node_modules/core-js/internals/object-assign.js
  var require_object_assign = __commonJS({
    "node_modules/core-js/internals/object-assign.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var objectKeys = require_object_keys();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var toObject = require_to_object();
      var IndexedObject = require_indexed_object();
      var $assign = Object.assign;
      var defineProperty = Object.defineProperty;
      var concat = uncurryThis([].concat);
      module.exports = !$assign || fails(function() {
        if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
          enumerable: true,
          get: function() {
            defineProperty(this, "b", {
              value: 3,
              enumerable: false
            });
          }
        }), { b: 2 })).b !== 1) return true;
        var A = {};
        var B = {};
        var symbol = Symbol("assign detection");
        var alphabet = "abcdefghijklmnopqrst";
        A[symbol] = 7;
        alphabet.split("").forEach(function(chr) {
          B[chr] = chr;
        });
        return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join("") !== alphabet;
      }) ? function assign(target, source) {
        var T = toObject(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        var propertyIsEnumerable = propertyIsEnumerableModule.f;
        while (argumentsLength > index) {
          var S = IndexedObject(arguments[index++]);
          var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
          var length = keys.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys[j++];
            if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
          }
        }
        return T;
      } : $assign;
    }
  });

  // node_modules/core-js/modules/es.object.assign.js
  var require_es_object_assign = __commonJS({
    "node_modules/core-js/modules/es.object.assign.js"() {
      "use strict";
      var $ = require_export();
      var assign = require_object_assign();
      $({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign }, {
        assign
      });
    }
  });

  // node_modules/core-js/modules/es.object.create.js
  var require_es_object_create = __commonJS({
    "node_modules/core-js/modules/es.object.create.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var create = require_object_create();
      $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
        create
      });
    }
  });

  // node_modules/core-js/internals/object-prototype-accessors-forced.js
  var require_object_prototype_accessors_forced = __commonJS({
    "node_modules/core-js/internals/object-prototype-accessors-forced.js"(exports, module) {
      "use strict";
      var IS_PURE = require_is_pure();
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var WEBKIT = require_environment_webkit_version();
      module.exports = IS_PURE || !fails(function() {
        if (WEBKIT && WEBKIT < 535) return;
        var key = Math.random();
        __defineSetter__.call(null, key, function() {
        });
        delete globalThis2[key];
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-getter.js
  var require_es_object_define_getter = __commonJS({
    "node_modules/core-js/modules/es.object.define-getter.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var definePropertyModule = require_object_define_property();
      if (DESCRIPTORS) {
        $({ target: "Object", proto: true, forced: FORCED }, {
          __defineGetter__: function __defineGetter__(P, getter) {
            definePropertyModule.f(toObject(this), P, { get: aCallable(getter), enumerable: true, configurable: true });
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.define-properties.js
  var require_es_object_define_properties = __commonJS({
    "node_modules/core-js/modules/es.object.define-properties.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var defineProperties2 = require_object_define_properties().f;
      $({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties2, sham: !DESCRIPTORS }, {
        defineProperties: defineProperties2
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-property.js
  var require_es_object_define_property = __commonJS({
    "node_modules/core-js/modules/es.object.define-property.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var defineProperty = require_object_define_property().f;
      $({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
        defineProperty
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-setter.js
  var require_es_object_define_setter = __commonJS({
    "node_modules/core-js/modules/es.object.define-setter.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var definePropertyModule = require_object_define_property();
      if (DESCRIPTORS) {
        $({ target: "Object", proto: true, forced: FORCED }, {
          __defineSetter__: function __defineSetter__2(P, setter) {
            definePropertyModule.f(toObject(this), P, { set: aCallable(setter), enumerable: true, configurable: true });
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/object-to-array.js
  var require_object_to_array = __commonJS({
    "node_modules/core-js/internals/object-to-array.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var objectGetPrototypeOf = require_object_get_prototype_of();
      var objectKeys = require_object_keys();
      var toIndexedObject = require_to_indexed_object();
      var $propertyIsEnumerable = require_object_property_is_enumerable().f;
      var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
      var push = uncurryThis([].push);
      var IE_BUG = DESCRIPTORS && fails(function() {
        var O = /* @__PURE__ */ Object.create(null);
        O[2] = 2;
        return !propertyIsEnumerable(O, 2);
      });
      var createMethod = function(TO_ENTRIES) {
        return function(it) {
          var O = toIndexedObject(it);
          var keys = objectKeys(O);
          var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
          var length = keys.length;
          var i = 0;
          var result = [];
          var key;
          while (length > i) {
            key = keys[i++];
            if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
              push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
            }
          }
          return result;
        };
      };
      module.exports = {
        // `Object.entries` method
        // https://tc39.es/ecma262/#sec-object.entries
        entries: createMethod(true),
        // `Object.values` method
        // https://tc39.es/ecma262/#sec-object.values
        values: createMethod(false)
      };
    }
  });

  // node_modules/core-js/modules/es.object.entries.js
  var require_es_object_entries = __commonJS({
    "node_modules/core-js/modules/es.object.entries.js"() {
      "use strict";
      var $ = require_export();
      var $entries = require_object_to_array().entries;
      $({ target: "Object", stat: true }, {
        entries: function entries(O) {
          return $entries(O);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.freeze.js
  var require_es_object_freeze = __commonJS({
    "node_modules/core-js/modules/es.object.freeze.js"() {
      "use strict";
      var $ = require_export();
      var FREEZING = require_freezing();
      var fails = require_fails();
      var isObject4 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var $freeze = Object.freeze;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $freeze(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        freeze: function freeze(it) {
          return $freeze && isObject4(it) ? $freeze(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.from-entries.js
  var require_es_object_from_entries = __commonJS({
    "node_modules/core-js/modules/es.object.from-entries.js"() {
      "use strict";
      var $ = require_export();
      var iterate = require_iterate();
      var createProperty = require_create_property();
      $({ target: "Object", stat: true }, {
        fromEntries: function fromEntries(iterable) {
          var obj = {};
          iterate(iterable, function(k, v) {
            createProperty(obj, k, v);
          }, { AS_ENTRIES: true });
          return obj;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-descriptor.js
  var require_es_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-descriptor.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var toIndexedObject = require_to_indexed_object();
      var nativeGetOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var DESCRIPTORS = require_descriptors();
      var FORCED = !DESCRIPTORS || fails(function() {
        nativeGetOwnPropertyDescriptor(1);
      });
      $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
          return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-descriptors.js
  var require_es_object_get_own_property_descriptors = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-descriptors.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var ownKeys = require_own_keys();
      var toIndexedObject = require_to_indexed_object();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var createProperty = require_create_property();
      $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
          var O = toIndexedObject(object);
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          var keys = ownKeys(O);
          var result = {};
          var index = 0;
          var key, descriptor;
          while (keys.length > index) {
            descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
            if (descriptor !== void 0) createProperty(result, key, descriptor);
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-names.js
  var require_es_object_get_own_property_names = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-names.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var getOwnPropertyNames = require_object_get_own_property_names_external().f;
      var FAILS_ON_PRIMITIVES = fails(function() {
        return !Object.getOwnPropertyNames(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        getOwnPropertyNames
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-prototype-of.js
  var require_es_object_get_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.object.get-prototype-of.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var toObject = require_to_object();
      var nativeGetPrototypeOf = require_object_get_prototype_of();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeGetPrototypeOf(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
        getPrototypeOf: function getPrototypeOf(it) {
          return nativeGetPrototypeOf(toObject(it));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.group-by.js
  var require_es_object_group_by = __commonJS({
    "node_modules/core-js/modules/es.object.group-by.js"() {
      "use strict";
      var $ = require_export();
      var createProperty = require_create_property();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var requireObjectCoercible = require_require_object_coercible();
      var toPropertyKey = require_to_property_key();
      var iterate = require_iterate();
      var fails = require_fails();
      var nativeGroupBy = Object.groupBy;
      var create = getBuiltIn("Object", "create");
      var push = uncurryThis([].push);
      var DOES_NOT_WORK_WITH_PRIMITIVES = !nativeGroupBy || fails(function() {
        return nativeGroupBy("ab", function(it) {
          return it;
        }).a.length !== 1;
      });
      $({ target: "Object", stat: true, forced: DOES_NOT_WORK_WITH_PRIMITIVES }, {
        groupBy: function groupBy(items, callbackfn) {
          requireObjectCoercible(items);
          aCallable(callbackfn);
          var obj = create(null);
          var k = 0;
          iterate(items, function(value) {
            var key = toPropertyKey(callbackfn(value, k++));
            if (key in obj) push(obj[key], value);
            else createProperty(obj, key, [value]);
          });
          return obj;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.has-own.js
  var require_es_object_has_own = __commonJS({
    "node_modules/core-js/modules/es.object.has-own.js"() {
      "use strict";
      var $ = require_export();
      var hasOwn = require_has_own_property();
      $({ target: "Object", stat: true }, {
        hasOwn
      });
    }
  });

  // node_modules/core-js/internals/same-value.js
  var require_same_value = __commonJS({
    "node_modules/core-js/internals/same-value.js"(exports, module) {
      "use strict";
      module.exports = Object.is || function is(x, y) {
        return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
      };
    }
  });

  // node_modules/core-js/modules/es.object.is.js
  var require_es_object_is = __commonJS({
    "node_modules/core-js/modules/es.object.is.js"() {
      "use strict";
      var $ = require_export();
      var is = require_same_value();
      $({ target: "Object", stat: true }, {
        is
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-extensible.js
  var require_es_object_is_extensible = __commonJS({
    "node_modules/core-js/modules/es.object.is-extensible.js"() {
      "use strict";
      var $ = require_export();
      var $isExtensible = require_object_is_extensible();
      $({ target: "Object", stat: true, forced: Object.isExtensible !== $isExtensible }, {
        isExtensible: $isExtensible
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-frozen.js
  var require_es_object_is_frozen = __commonJS({
    "node_modules/core-js/modules/es.object.is-frozen.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var isObject4 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isFrozen = Object.isFrozen;
      var FORCED = ARRAY_BUFFER_NON_EXTENSIBLE || fails(function() {
        $isFrozen(1);
      });
      $({ target: "Object", stat: true, forced: FORCED }, {
        isFrozen: function isFrozen(it) {
          if (!isObject4(it)) return true;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer") return true;
          return $isFrozen ? $isFrozen(it) : false;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-sealed.js
  var require_es_object_is_sealed = __commonJS({
    "node_modules/core-js/modules/es.object.is-sealed.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var isObject4 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isSealed = Object.isSealed;
      var FORCED = ARRAY_BUFFER_NON_EXTENSIBLE || fails(function() {
        $isSealed(1);
      });
      $({ target: "Object", stat: true, forced: FORCED }, {
        isSealed: function isSealed(it) {
          if (!isObject4(it)) return true;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer") return true;
          return $isSealed ? $isSealed(it) : false;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.keys.js
  var require_es_object_keys = __commonJS({
    "node_modules/core-js/modules/es.object.keys.js"() {
      "use strict";
      var $ = require_export();
      var toObject = require_to_object();
      var nativeKeys = require_object_keys();
      var fails = require_fails();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeKeys(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        keys: function keys(it) {
          return nativeKeys(toObject(it));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.lookup-getter.js
  var require_es_object_lookup_getter = __commonJS({
    "node_modules/core-js/modules/es.object.lookup-getter.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var toObject = require_to_object();
      var toPropertyKey = require_to_property_key();
      var getPrototypeOf = require_object_get_prototype_of();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      if (DESCRIPTORS) {
        $({ target: "Object", proto: true, forced: FORCED }, {
          __lookupGetter__: function __lookupGetter__(P) {
            var O = toObject(this);
            var key = toPropertyKey(P);
            var desc;
            do {
              if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
            } while (O = getPrototypeOf(O));
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.lookup-setter.js
  var require_es_object_lookup_setter = __commonJS({
    "node_modules/core-js/modules/es.object.lookup-setter.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var toObject = require_to_object();
      var toPropertyKey = require_to_property_key();
      var getPrototypeOf = require_object_get_prototype_of();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      if (DESCRIPTORS) {
        $({ target: "Object", proto: true, forced: FORCED }, {
          __lookupSetter__: function __lookupSetter__(P) {
            var O = toObject(this);
            var key = toPropertyKey(P);
            var desc;
            do {
              if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
            } while (O = getPrototypeOf(O));
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.prevent-extensions.js
  var require_es_object_prevent_extensions = __commonJS({
    "node_modules/core-js/modules/es.object.prevent-extensions.js"() {
      "use strict";
      var $ = require_export();
      var isObject4 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var FREEZING = require_freezing();
      var fails = require_fails();
      var $preventExtensions = Object.preventExtensions;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $preventExtensions(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        preventExtensions: function preventExtensions(it) {
          return $preventExtensions && isObject4(it) ? $preventExtensions(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.proto.js
  var require_es_object_proto = __commonJS({
    "node_modules/core-js/modules/es.object.proto.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isObject4 = require_is_object();
      var isPossiblePrototype = require_is_possible_prototype();
      var toObject = require_to_object();
      var requireObjectCoercible = require_require_object_coercible();
      var getPrototypeOf = Object.getPrototypeOf;
      var setPrototypeOf = Object.setPrototypeOf;
      var ObjectPrototype = Object.prototype;
      var PROTO = "__proto__";
      if (DESCRIPTORS && getPrototypeOf && setPrototypeOf && !(PROTO in ObjectPrototype)) try {
        defineBuiltInAccessor(ObjectPrototype, PROTO, {
          configurable: true,
          get: function __proto__() {
            return getPrototypeOf(toObject(this));
          },
          set: function __proto__(proto2) {
            var O = requireObjectCoercible(this);
            if (isPossiblePrototype(proto2) && isObject4(O)) {
              setPrototypeOf(O, proto2);
            }
          }
        });
      } catch (error) {
      }
    }
  });

  // node_modules/core-js/modules/es.object.seal.js
  var require_es_object_seal = __commonJS({
    "node_modules/core-js/modules/es.object.seal.js"() {
      "use strict";
      var $ = require_export();
      var isObject4 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var FREEZING = require_freezing();
      var fails = require_fails();
      var $seal = Object.seal;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $seal(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        seal: function seal(it) {
          return $seal && isObject4(it) ? $seal(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.set-prototype-of.js
  var require_es_object_set_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.object.set-prototype-of.js"() {
      "use strict";
      var $ = require_export();
      var setPrototypeOf = require_object_set_prototype_of();
      $({ target: "Object", stat: true }, {
        setPrototypeOf
      });
    }
  });

  // node_modules/core-js/internals/object-to-string.js
  var require_object_to_string = __commonJS({
    "node_modules/core-js/internals/object-to-string.js"(exports, module) {
      "use strict";
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var classof = require_classof();
      module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
        return "[object " + classof(this) + "]";
      };
    }
  });

  // node_modules/core-js/modules/es.object.to-string.js
  var require_es_object_to_string = __commonJS({
    "node_modules/core-js/modules/es.object.to-string.js"() {
      "use strict";
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var defineBuiltIn = require_define_built_in();
      var toString = require_object_to_string();
      if (!TO_STRING_TAG_SUPPORT) {
        defineBuiltIn(Object.prototype, "toString", toString, { unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/es.object.values.js
  var require_es_object_values = __commonJS({
    "node_modules/core-js/modules/es.object.values.js"() {
      "use strict";
      var $ = require_export();
      var $values = require_object_to_array().values;
      $({ target: "Object", stat: true }, {
        values: function values(O) {
          return $values(O);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.parse-float.js
  var require_es_parse_float = __commonJS({
    "node_modules/core-js/modules/es.parse-float.js"() {
      "use strict";
      var $ = require_export();
      var $parseFloat = require_number_parse_float();
      $({ global: true, forced: parseFloat !== $parseFloat }, {
        parseFloat: $parseFloat
      });
    }
  });

  // node_modules/core-js/modules/es.parse-int.js
  var require_es_parse_int = __commonJS({
    "node_modules/core-js/modules/es.parse-int.js"() {
      "use strict";
      var $ = require_export();
      var $parseInt = require_number_parse_int();
      $({ global: true, forced: parseInt !== $parseInt }, {
        parseInt: $parseInt
      });
    }
  });

  // node_modules/core-js/internals/a-constructor.js
  var require_a_constructor = __commonJS({
    "node_modules/core-js/internals/a-constructor.js"(exports, module) {
      "use strict";
      var isConstructor = require_is_constructor();
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isConstructor(argument)) return argument;
        throw new $TypeError(tryToString(argument) + " is not a constructor");
      };
    }
  });

  // node_modules/core-js/internals/species-constructor.js
  var require_species_constructor = __commonJS({
    "node_modules/core-js/internals/species-constructor.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var aConstructor = require_a_constructor();
      var isNullOrUndefined = require_is_null_or_undefined();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(O, defaultConstructor) {
        var C = anObject(O).constructor;
        var S;
        return C === void 0 || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
      };
    }
  });

  // node_modules/core-js/internals/validate-arguments-length.js
  var require_validate_arguments_length = __commonJS({
    "node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
      "use strict";
      var $TypeError = TypeError;
      module.exports = function(passed, required) {
        if (passed < required) throw new $TypeError("Not enough arguments");
        return passed;
      };
    }
  });

  // node_modules/core-js/internals/environment-is-ios.js
  var require_environment_is_ios = __commonJS({
    "node_modules/core-js/internals/environment-is-ios.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
    }
  });

  // node_modules/core-js/internals/task.js
  var require_task = __commonJS({
    "node_modules/core-js/internals/task.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var bind2 = require_function_bind_context();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var fails = require_fails();
      var html = require_html();
      var arraySlice = require_array_slice();
      var createElement = require_document_create_element();
      var validateArgumentsLength = require_validate_arguments_length();
      var IS_IOS = require_environment_is_ios();
      var IS_NODE = require_environment_is_node();
      var set = globalThis2.setImmediate;
      var clear = globalThis2.clearImmediate;
      var process = globalThis2.process;
      var Dispatch = globalThis2.Dispatch;
      var Function2 = globalThis2.Function;
      var MessageChannel = globalThis2.MessageChannel;
      var String2 = globalThis2.String;
      var counter = 0;
      var queue2 = {};
      var ONREADYSTATECHANGE = "onreadystatechange";
      var $location;
      var defer;
      var channel;
      var port;
      fails(function() {
        $location = globalThis2.location;
      });
      var run = function(id) {
        if (hasOwn(queue2, id)) {
          var fn = queue2[id];
          delete queue2[id];
          fn();
        }
      };
      var runner = function(id) {
        return function() {
          run(id);
        };
      };
      var eventListener = function(event) {
        run(event.data);
      };
      var globalPostMessageDefer = function(id) {
        globalThis2.postMessage(String2(id), $location.protocol + "//" + $location.host);
      };
      if (!set || !clear) {
        set = function setImmediate(handler) {
          validateArgumentsLength(arguments.length, 1);
          var fn = isCallable(handler) ? handler : Function2(handler);
          var args = arraySlice(arguments, 1);
          queue2[++counter] = function() {
            apply(fn, void 0, args);
          };
          defer(counter);
          return counter;
        };
        clear = function clearImmediate(id) {
          delete queue2[id];
        };
        if (IS_NODE) {
          defer = function(id) {
            process.nextTick(runner(id));
          };
        } else if (Dispatch && Dispatch.now) {
          defer = function(id) {
            Dispatch.now(runner(id));
          };
        } else if (MessageChannel && !IS_IOS) {
          channel = new MessageChannel();
          port = channel.port2;
          channel.port1.onmessage = eventListener;
          defer = bind2(port.postMessage, port);
        } else if (globalThis2.addEventListener && isCallable(globalThis2.postMessage) && !globalThis2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
          defer = globalPostMessageDefer;
          globalThis2.addEventListener("message", eventListener, false);
        } else if (ONREADYSTATECHANGE in createElement("script")) {
          defer = function(id) {
            html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
              html.removeChild(this);
              run(id);
            };
          };
        } else {
          defer = function(id) {
            setTimeout(runner(id), 0);
          };
        }
      }
      module.exports = {
        set,
        clear
      };
    }
  });

  // node_modules/core-js/internals/safe-get-built-in.js
  var require_safe_get_built_in = __commonJS({
    "node_modules/core-js/internals/safe-get-built-in.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var DESCRIPTORS = require_descriptors();
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      module.exports = function(name) {
        if (!DESCRIPTORS) return globalThis2[name];
        var descriptor = getOwnPropertyDescriptor(globalThis2, name);
        return descriptor && descriptor.value;
      };
    }
  });

  // node_modules/core-js/internals/queue.js
  var require_queue = __commonJS({
    "node_modules/core-js/internals/queue.js"(exports, module) {
      "use strict";
      var Queue = function() {
        this.head = null;
        this.tail = null;
      };
      Queue.prototype = {
        add: function(item) {
          var entry = { item, next: null };
          var tail = this.tail;
          if (tail) tail.next = entry;
          else this.head = entry;
          this.tail = entry;
        },
        get: function() {
          var entry = this.head;
          if (entry) {
            var next = this.head = entry.next;
            if (next === null) this.tail = null;
            return entry.item;
          }
        }
      };
      module.exports = Queue;
    }
  });

  // node_modules/core-js/internals/environment-is-ios-pebble.js
  var require_environment_is_ios_pebble = __commonJS({
    "node_modules/core-js/internals/environment-is-ios-pebble.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
    }
  });

  // node_modules/core-js/internals/environment-is-webos-webkit.js
  var require_environment_is_webos_webkit = __commonJS({
    "node_modules/core-js/internals/environment-is-webos-webkit.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      module.exports = /web0s(?!.*chrome)/i.test(userAgent);
    }
  });

  // node_modules/core-js/internals/microtask.js
  var require_microtask = __commonJS({
    "node_modules/core-js/internals/microtask.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var safeGetBuiltIn = require_safe_get_built_in();
      var bind2 = require_function_bind_context();
      var macrotask = require_task().set;
      var Queue = require_queue();
      var IS_IOS = require_environment_is_ios();
      var IS_IOS_PEBBLE = require_environment_is_ios_pebble();
      var IS_WEBOS_WEBKIT = require_environment_is_webos_webkit();
      var IS_NODE = require_environment_is_node();
      var MutationObserver = globalThis2.MutationObserver || globalThis2.WebKitMutationObserver;
      var document2 = globalThis2.document;
      var process = globalThis2.process;
      var Promise2 = globalThis2.Promise;
      var microtask = safeGetBuiltIn("queueMicrotask");
      var notify;
      var toggle;
      var node;
      var promise;
      var then;
      if (!microtask) {
        queue2 = new Queue();
        flush = function() {
          var parent, fn;
          if (IS_NODE && (parent = process.domain)) parent.exit();
          while (fn = queue2.get()) try {
            fn();
          } catch (error) {
            if (queue2.head) notify();
            throw error;
          }
          if (parent) parent.enter();
        };
        if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
          toggle = true;
          node = document2.createTextNode("");
          new MutationObserver(flush).observe(node, { characterData: true });
          notify = function() {
            node.data = toggle = !toggle;
          };
        } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
          promise = Promise2.resolve(void 0);
          promise.constructor = Promise2;
          then = bind2(promise.then, promise);
          notify = function() {
            then(flush);
          };
        } else if (IS_NODE) {
          notify = function() {
            process.nextTick(flush);
          };
        } else {
          macrotask = bind2(macrotask, globalThis2);
          notify = function() {
            macrotask(flush);
          };
        }
        microtask = function(fn) {
          if (!queue2.head) notify();
          queue2.add(fn);
        };
      }
      var queue2;
      var flush;
      module.exports = microtask;
    }
  });

  // node_modules/core-js/internals/host-report-errors.js
  var require_host_report_errors = __commonJS({
    "node_modules/core-js/internals/host-report-errors.js"(exports, module) {
      "use strict";
      module.exports = function(a, b) {
        try {
          arguments.length === 1 ? console.error(a) : console.error(a, b);
        } catch (error) {
        }
      };
    }
  });

  // node_modules/core-js/internals/perform.js
  var require_perform = __commonJS({
    "node_modules/core-js/internals/perform.js"(exports, module) {
      "use strict";
      module.exports = function(exec) {
        try {
          return { error: false, value: exec() };
        } catch (error) {
          return { error: true, value: error };
        }
      };
    }
  });

  // node_modules/core-js/internals/promise-native-constructor.js
  var require_promise_native_constructor = __commonJS({
    "node_modules/core-js/internals/promise-native-constructor.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      module.exports = globalThis2.Promise;
    }
  });

  // node_modules/core-js/internals/promise-constructor-detection.js
  var require_promise_constructor_detection = __commonJS({
    "node_modules/core-js/internals/promise-constructor-detection.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var NativePromiseConstructor = require_promise_native_constructor();
      var isCallable = require_is_callable();
      var isForced = require_is_forced();
      var inspectSource = require_inspect_source();
      var wellKnownSymbol = require_well_known_symbol();
      var ENVIRONMENT = require_environment();
      var IS_PURE = require_is_pure();
      var V8_VERSION = require_environment_v8_version();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var SPECIES = wellKnownSymbol("species");
      var SUBCLASSING = false;
      var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis2.PromiseRejectionEvent);
      var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
        var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
        var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
        if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
        if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"])) return true;
        if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
          var promise = new NativePromiseConstructor(function(resolve) {
            resolve(1);
          });
          var FakePromise = function(exec) {
            exec(function() {
            }, function() {
            });
          };
          var constructor = promise.constructor = {};
          constructor[SPECIES] = FakePromise;
          SUBCLASSING = promise.then(function() {
          }) instanceof FakePromise;
          if (!SUBCLASSING) return true;
        }
        return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === "BROWSER" || ENVIRONMENT === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT;
      });
      module.exports = {
        CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
        REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
        SUBCLASSING
      };
    }
  });

  // node_modules/core-js/internals/new-promise-capability.js
  var require_new_promise_capability = __commonJS({
    "node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var $TypeError = TypeError;
      var PromiseCapability = function(C) {
        var resolve, reject;
        this.promise = new C(function($$resolve, $$reject) {
          if (resolve !== void 0 || reject !== void 0) throw new $TypeError("Bad Promise constructor");
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aCallable(resolve);
        this.reject = aCallable(reject);
      };
      module.exports.f = function(C) {
        return new PromiseCapability(C);
      };
    }
  });

  // node_modules/core-js/modules/es.promise.constructor.js
  var require_es_promise_constructor = __commonJS({
    "node_modules/core-js/modules/es.promise.constructor.js"() {
      "use strict";
      var $ = require_export();
      var IS_PURE = require_is_pure();
      var IS_NODE = require_environment_is_node();
      var globalThis2 = require_global_this();
      var path = require_path();
      var call = require_function_call();
      var defineBuiltIn = require_define_built_in();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var setSpecies = require_set_species();
      var aCallable = require_a_callable();
      var isCallable = require_is_callable();
      var isObject4 = require_is_object();
      var anInstance = require_an_instance();
      var speciesConstructor = require_species_constructor();
      var task = require_task().set;
      var microtask = require_microtask();
      var hostReportErrors = require_host_report_errors();
      var perform = require_perform();
      var Queue = require_queue();
      var InternalStateModule = require_internal_state();
      var NativePromiseConstructor = require_promise_native_constructor();
      var PromiseConstructorDetection = require_promise_constructor_detection();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var PROMISE = "Promise";
      var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
      var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
      var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
      var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
      var setInternalState = InternalStateModule.set;
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var PromiseConstructor = NativePromiseConstructor;
      var PromisePrototype = NativePromisePrototype;
      var TypeError2 = globalThis2.TypeError;
      var document2 = globalThis2.document;
      var process = globalThis2.process;
      var newPromiseCapability = newPromiseCapabilityModule.f;
      var newGenericPromiseCapability = newPromiseCapability;
      var DISPATCH_EVENT = !!(document2 && document2.createEvent && globalThis2.dispatchEvent);
      var UNHANDLED_REJECTION = "unhandledrejection";
      var REJECTION_HANDLED = "rejectionhandled";
      var PENDING = 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      var HANDLED = 1;
      var UNHANDLED = 2;
      var Internal;
      var OwnPromiseCapability;
      var PromiseWrapper;
      var nativeThen;
      var isThenable = function(it) {
        var then;
        return isObject4(it) && isCallable(then = it.then) ? then : false;
      };
      var callReaction = function(reaction, state3) {
        var value = state3.value;
        var ok = state3.state === FULFILLED;
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state3.rejection === UNHANDLED) onHandleUnhandled(state3);
              state3.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value);
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(new TypeError2("Promise-chain cycle"));
            } else if (then = isThenable(result)) {
              call(then, result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain && !exited) domain.exit();
          reject(error);
        }
      };
      var notify = function(state3, isReject) {
        if (state3.notified) return;
        state3.notified = true;
        microtask(function() {
          var reactions = state3.reactions;
          var reaction;
          while (reaction = reactions.get()) {
            callReaction(reaction, state3);
          }
          state3.notified = false;
          if (isReject && !state3.rejection) onUnhandled(state3);
        });
      };
      var dispatchEvent = function(name, promise, reason) {
        var event, handler;
        if (DISPATCH_EVENT) {
          event = document2.createEvent("Event");
          event.promise = promise;
          event.reason = reason;
          event.initEvent(name, false, true);
          globalThis2.dispatchEvent(event);
        } else event = { promise, reason };
        if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis2["on" + name])) handler(event);
        else if (name === UNHANDLED_REJECTION) hostReportErrors("Unhandled promise rejection", reason);
      };
      var onUnhandled = function(state3) {
        call(task, globalThis2, function() {
          var promise = state3.facade;
          var value = state3.value;
          var IS_UNHANDLED = isUnhandled(state3);
          var result;
          if (IS_UNHANDLED) {
            result = perform(function() {
              if (IS_NODE) {
                process.emit("unhandledRejection", value, promise);
              } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            state3.rejection = IS_NODE || isUnhandled(state3) ? UNHANDLED : HANDLED;
            if (result.error) throw result.value;
          }
        });
      };
      var isUnhandled = function(state3) {
        return state3.rejection !== HANDLED && !state3.parent;
      };
      var onHandleUnhandled = function(state3) {
        call(task, globalThis2, function() {
          var promise = state3.facade;
          if (IS_NODE) {
            process.emit("rejectionHandled", promise);
          } else dispatchEvent(REJECTION_HANDLED, promise, state3.value);
        });
      };
      var bind2 = function(fn, state3, unwrap) {
        return function(value) {
          fn(state3, value, unwrap);
        };
      };
      var internalReject = function(state3, value, unwrap) {
        if (state3.done) return;
        state3.done = true;
        if (unwrap) state3 = unwrap;
        state3.value = value;
        state3.state = REJECTED;
        notify(state3, true);
      };
      var internalResolve = function(state3, value, unwrap) {
        if (state3.done) return;
        state3.done = true;
        if (unwrap) state3 = unwrap;
        try {
          if (state3.facade === value) throw new TypeError2("Promise can't be resolved itself");
          var then = isThenable(value);
          if (then) {
            microtask(function() {
              var wrapper = { done: false };
              try {
                call(
                  then,
                  value,
                  bind2(internalResolve, wrapper, state3),
                  bind2(internalReject, wrapper, state3)
                );
              } catch (error) {
                internalReject(wrapper, error, state3);
              }
            });
          } else {
            state3.value = value;
            state3.state = FULFILLED;
            notify(state3, false);
          }
        } catch (error) {
          internalReject({ done: false }, error, state3);
        }
      };
      if (FORCED_PROMISE_CONSTRUCTOR) {
        PromiseConstructor = function Promise2(executor) {
          anInstance(this, PromisePrototype);
          aCallable(executor);
          call(Internal, this);
          var state3 = getInternalPromiseState(this);
          try {
            executor(bind2(internalResolve, state3), bind2(internalReject, state3));
          } catch (error) {
            internalReject(state3, error);
          }
        };
        PromisePrototype = PromiseConstructor.prototype;
        Internal = function Promise2(executor) {
          setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: new Queue(),
            rejection: false,
            state: PENDING,
            value: null
          });
        };
        Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
          var state3 = getInternalPromiseState(this);
          var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
          state3.parent = true;
          reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
          reaction.fail = isCallable(onRejected) && onRejected;
          reaction.domain = IS_NODE ? process.domain : void 0;
          if (state3.state === PENDING) state3.reactions.add(reaction);
          else microtask(function() {
            callReaction(reaction, state3);
          });
          return reaction.promise;
        });
        OwnPromiseCapability = function() {
          var promise = new Internal();
          var state3 = getInternalPromiseState(promise);
          this.promise = promise;
          this.resolve = bind2(internalResolve, state3);
          this.reject = bind2(internalReject, state3);
        };
        newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
          return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
        };
        if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
          nativeThen = NativePromisePrototype.then;
          if (!NATIVE_PROMISE_SUBCLASSING) {
            defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
              var that = this;
              return new PromiseConstructor(function(resolve, reject) {
                call(nativeThen, that, resolve, reject);
              }).then(onFulfilled, onRejected);
            }, { unsafe: true });
          }
          try {
            delete NativePromisePrototype.constructor;
          } catch (error) {
          }
          if (setPrototypeOf) {
            setPrototypeOf(NativePromisePrototype, PromisePrototype);
          }
        }
      }
      $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
        Promise: PromiseConstructor
      });
      PromiseWrapper = path.Promise;
      setToStringTag(PromiseConstructor, PROMISE, false, true);
      setSpecies(PROMISE);
    }
  });

  // node_modules/core-js/internals/promise-statics-incorrect-iteration.js
  var require_promise_statics_incorrect_iteration = __commonJS({
    "node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports, module) {
      "use strict";
      var NativePromiseConstructor = require_promise_native_constructor();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
        NativePromiseConstructor.all(iterable).then(void 0, function() {
        });
      });
    }
  });

  // node_modules/core-js/modules/es.promise.all.js
  var require_es_promise_all = __commonJS({
    "node_modules/core-js/modules/es.promise.all.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        all: function all(iterable) {
          var C = this;
          var capability = newPromiseCapabilityModule.f(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyCalled = false;
              remaining++;
              call($promiseResolve, C, promise).then(function(value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.catch.js
  var require_es_promise_catch = __commonJS({
    "node_modules/core-js/modules/es.promise.catch.js"() {
      "use strict";
      var $ = require_export();
      var IS_PURE = require_is_pure();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      var NativePromiseConstructor = require_promise_native_constructor();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var defineBuiltIn = require_define_built_in();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
        "catch": function(onRejected) {
          return this.then(void 0, onRejected);
        }
      });
      if (!IS_PURE && isCallable(NativePromiseConstructor)) {
        method = getBuiltIn("Promise").prototype["catch"];
        if (NativePromisePrototype["catch"] !== method) {
          defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
        }
      }
      var method;
    }
  });

  // node_modules/core-js/modules/es.promise.race.js
  var require_es_promise_race = __commonJS({
    "node_modules/core-js/modules/es.promise.race.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        race: function race(iterable) {
          var C = this;
          var capability = newPromiseCapabilityModule.f(C);
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C.resolve);
            iterate(iterable, function(promise) {
              call($promiseResolve, C, promise).then(capability.resolve, reject);
            });
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.reject.js
  var require_es_promise_reject = __commonJS({
    "node_modules/core-js/modules/es.promise.reject.js"() {
      "use strict";
      var $ = require_export();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
        reject: function reject(r) {
          var capability = newPromiseCapabilityModule.f(this);
          var capabilityReject = capability.reject;
          capabilityReject(r);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/internals/promise-resolve.js
  var require_promise_resolve = __commonJS({
    "node_modules/core-js/internals/promise-resolve.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var newPromiseCapability = require_new_promise_capability();
      module.exports = function(C, x) {
        anObject(C);
        if (isObject4(x) && x.constructor === C) return x;
        var promiseCapability = newPromiseCapability.f(C);
        var resolve = promiseCapability.resolve;
        resolve(x);
        return promiseCapability.promise;
      };
    }
  });

  // node_modules/core-js/modules/es.promise.resolve.js
  var require_es_promise_resolve = __commonJS({
    "node_modules/core-js/modules/es.promise.resolve.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var IS_PURE = require_is_pure();
      var NativePromiseConstructor = require_promise_native_constructor();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      var promiseResolve = require_promise_resolve();
      var PromiseConstructorWrapper = getBuiltIn("Promise");
      var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
      $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
        resolve: function resolve(x) {
          return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.js
  var require_es_promise = __commonJS({
    "node_modules/core-js/modules/es.promise.js"() {
      "use strict";
      require_es_promise_constructor();
      require_es_promise_all();
      require_es_promise_catch();
      require_es_promise_race();
      require_es_promise_reject();
      require_es_promise_resolve();
    }
  });

  // node_modules/core-js/modules/es.promise.all-settled.js
  var require_es_promise_all_settled = __commonJS({
    "node_modules/core-js/modules/es.promise.all-settled.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        allSettled: function allSettled(iterable) {
          var C = this;
          var capability = newPromiseCapabilityModule.f(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var promiseResolve = aCallable(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyCalled = false;
              remaining++;
              call(promiseResolve, C, promise).then(function(value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = { status: "fulfilled", value };
                --remaining || resolve(values);
              }, function(error) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = { status: "rejected", reason: error };
                --remaining || resolve(values);
              });
            });
            --remaining || resolve(values);
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.any.js
  var require_es_promise_any = __commonJS({
    "node_modules/core-js/modules/es.promise.any.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var getBuiltIn = require_get_built_in();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      var PROMISE_ANY_ERROR = "No one promise resolved";
      $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        any: function any(iterable) {
          var C = this;
          var AggregateError = getBuiltIn("AggregateError");
          var capability = newPromiseCapabilityModule.f(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var promiseResolve = aCallable(C.resolve);
            var errors = [];
            var counter = 0;
            var remaining = 1;
            var alreadyResolved = false;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyRejected = false;
              remaining++;
              call(promiseResolve, C, promise).then(function(value) {
                if (alreadyRejected || alreadyResolved) return;
                alreadyResolved = true;
                resolve(value);
              }, function(error) {
                if (alreadyRejected || alreadyResolved) return;
                alreadyRejected = true;
                errors[index] = error;
                --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
              });
            });
            --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.finally.js
  var require_es_promise_finally = __commonJS({
    "node_modules/core-js/modules/es.promise.finally.js"() {
      "use strict";
      var $ = require_export();
      var IS_PURE = require_is_pure();
      var NativePromiseConstructor = require_promise_native_constructor();
      var fails = require_fails();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var speciesConstructor = require_species_constructor();
      var promiseResolve = require_promise_resolve();
      var defineBuiltIn = require_define_built_in();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
        NativePromisePrototype["finally"].call({ then: function() {
        } }, function() {
        });
      });
      $({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
        "finally": function(onFinally) {
          var C = speciesConstructor(this, getBuiltIn("Promise"));
          var isFunction3 = isCallable(onFinally);
          return this.then(
            isFunction3 ? function(x) {
              return promiseResolve(C, onFinally()).then(function() {
                return x;
              });
            } : onFinally,
            isFunction3 ? function(e) {
              return promiseResolve(C, onFinally()).then(function() {
                throw e;
              });
            } : onFinally
          );
        }
      });
      if (!IS_PURE && isCallable(NativePromiseConstructor)) {
        method = getBuiltIn("Promise").prototype["finally"];
        if (NativePromisePrototype["finally"] !== method) {
          defineBuiltIn(NativePromisePrototype, "finally", method, { unsafe: true });
        }
      }
      var method;
    }
  });

  // node_modules/core-js/modules/es.promise.try.js
  var require_es_promise_try = __commonJS({
    "node_modules/core-js/modules/es.promise.try.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var slice = require_array_slice();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var aCallable = require_a_callable();
      var perform = require_perform();
      var Promise2 = globalThis2.Promise;
      var ACCEPT_ARGUMENTS = false;
      var FORCED = !Promise2 || !Promise2["try"] || perform(function() {
        Promise2["try"](function(argument) {
          ACCEPT_ARGUMENTS = argument === 8;
        }, 8);
      }).error || !ACCEPT_ARGUMENTS;
      $({ target: "Promise", stat: true, forced: FORCED }, {
        "try": function(callbackfn) {
          var args = arguments.length > 1 ? slice(arguments, 1) : [];
          var promiseCapability = newPromiseCapabilityModule.f(this);
          var result = perform(function() {
            return apply(aCallable(callbackfn), void 0, args);
          });
          (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
          return promiseCapability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.with-resolvers.js
  var require_es_promise_with_resolvers = __commonJS({
    "node_modules/core-js/modules/es.promise.with-resolvers.js"() {
      "use strict";
      var $ = require_export();
      var newPromiseCapabilityModule = require_new_promise_capability();
      $({ target: "Promise", stat: true }, {
        withResolvers: function withResolvers() {
          var promiseCapability = newPromiseCapabilityModule.f(this);
          return {
            promise: promiseCapability.promise,
            resolve: promiseCapability.resolve,
            reject: promiseCapability.reject
          };
        }
      });
    }
  });

  // node_modules/core-js/internals/async-iterator-prototype.js
  var require_async_iterator_prototype = __commonJS({
    "node_modules/core-js/internals/async-iterator-prototype.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var shared = require_shared_store();
      var isCallable = require_is_callable();
      var create = require_object_create();
      var getPrototypeOf = require_object_get_prototype_of();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var USE_FUNCTION_CONSTRUCTOR = "USE_FUNCTION_CONSTRUCTOR";
      var ASYNC_ITERATOR = wellKnownSymbol("asyncIterator");
      var AsyncIterator2 = globalThis2.AsyncIterator;
      var PassedAsyncIteratorPrototype = shared.AsyncIteratorPrototype;
      var AsyncIteratorPrototype;
      var prototype;
      if (PassedAsyncIteratorPrototype) {
        AsyncIteratorPrototype = PassedAsyncIteratorPrototype;
      } else if (isCallable(AsyncIterator2)) {
        AsyncIteratorPrototype = AsyncIterator2.prototype;
      } else if (shared[USE_FUNCTION_CONSTRUCTOR] || globalThis2[USE_FUNCTION_CONSTRUCTOR]) {
        try {
          prototype = getPrototypeOf(getPrototypeOf(getPrototypeOf(Function("return async function*(){}()")())));
          if (getPrototypeOf(prototype) === Object.prototype) AsyncIteratorPrototype = prototype;
        } catch (error) {
        }
      }
      if (!AsyncIteratorPrototype) AsyncIteratorPrototype = {};
      else if (IS_PURE) AsyncIteratorPrototype = create(AsyncIteratorPrototype);
      if (!isCallable(AsyncIteratorPrototype[ASYNC_ITERATOR])) {
        defineBuiltIn(AsyncIteratorPrototype, ASYNC_ITERATOR, function() {
          return this;
        });
      }
      module.exports = AsyncIteratorPrototype;
    }
  });

  // node_modules/core-js/internals/async-from-sync-iterator.js
  var require_async_from_sync_iterator = __commonJS({
    "node_modules/core-js/internals/async-from-sync-iterator.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var anObject = require_an_object();
      var create = require_object_create();
      var getMethod = require_get_method();
      var defineBuiltIns = require_define_built_ins();
      var InternalStateModule = require_internal_state();
      var iteratorClose = require_iterator_close();
      var getBuiltIn = require_get_built_in();
      var AsyncIteratorPrototype = require_async_iterator_prototype();
      var createIterResultObject = require_create_iter_result_object();
      var Promise2 = getBuiltIn("Promise");
      var ASYNC_FROM_SYNC_ITERATOR = "AsyncFromSyncIterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ASYNC_FROM_SYNC_ITERATOR);
      var asyncFromSyncIteratorContinuation = function(result, resolve, reject, syncIterator, closeOnRejection) {
        var done = result.done;
        Promise2.resolve(result.value).then(function(value) {
          resolve(createIterResultObject(value, done));
        }, function(error) {
          if (!done && closeOnRejection) {
            try {
              iteratorClose(syncIterator, "throw", error);
            } catch (error2) {
              error = error2;
            }
          }
          reject(error);
        });
      };
      var AsyncFromSyncIterator = function AsyncIterator2(iteratorRecord) {
        iteratorRecord.type = ASYNC_FROM_SYNC_ITERATOR;
        setInternalState(this, iteratorRecord);
      };
      AsyncFromSyncIterator.prototype = defineBuiltIns(create(AsyncIteratorPrototype), {
        next: function next() {
          var state3 = getInternalState(this);
          return new Promise2(function(resolve, reject) {
            var result = anObject(call(state3.next, state3.iterator));
            asyncFromSyncIteratorContinuation(result, resolve, reject, state3.iterator, true);
          });
        },
        "return": function() {
          var iterator = getInternalState(this).iterator;
          return new Promise2(function(resolve, reject) {
            var $return = getMethod(iterator, "return");
            if ($return === void 0) return resolve(createIterResultObject(void 0, true));
            var result = anObject(call($return, iterator));
            asyncFromSyncIteratorContinuation(result, resolve, reject, iterator);
          });
        }
      });
      module.exports = AsyncFromSyncIterator;
    }
  });

  // node_modules/core-js/internals/get-async-iterator.js
  var require_get_async_iterator = __commonJS({
    "node_modules/core-js/internals/get-async-iterator.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var AsyncFromSyncIterator = require_async_from_sync_iterator();
      var anObject = require_an_object();
      var getIterator = require_get_iterator();
      var getIteratorDirect = require_get_iterator_direct();
      var getMethod = require_get_method();
      var wellKnownSymbol = require_well_known_symbol();
      var ASYNC_ITERATOR = wellKnownSymbol("asyncIterator");
      module.exports = function(it, usingIterator) {
        var method = arguments.length < 2 ? getMethod(it, ASYNC_ITERATOR) : usingIterator;
        return method ? anObject(call(method, it)) : new AsyncFromSyncIterator(getIteratorDirect(getIterator(it)));
      };
    }
  });

  // node_modules/core-js/internals/async-iterator-close.js
  var require_async_iterator_close = __commonJS({
    "node_modules/core-js/internals/async-iterator-close.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var getBuiltIn = require_get_built_in();
      var getMethod = require_get_method();
      module.exports = function(iterator, method, argument, reject) {
        try {
          var returnMethod = getMethod(iterator, "return");
          if (returnMethod) {
            return getBuiltIn("Promise").resolve(call(returnMethod, iterator)).then(function() {
              method(argument);
            }, function(error) {
              reject(error);
            });
          }
        } catch (error2) {
          return reject(error2);
        }
        method(argument);
      };
    }
  });

  // node_modules/core-js/internals/async-iterator-iteration.js
  var require_async_iterator_iteration = __commonJS({
    "node_modules/core-js/internals/async-iterator-iteration.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var getBuiltIn = require_get_built_in();
      var getIteratorDirect = require_get_iterator_direct();
      var closeAsyncIteration = require_async_iterator_close();
      var createMethod = function(TYPE) {
        var IS_TO_ARRAY = TYPE === 0;
        var IS_FOR_EACH = TYPE === 1;
        var IS_EVERY = TYPE === 2;
        var IS_SOME = TYPE === 3;
        return function(object, fn, target) {
          anObject(object);
          var MAPPING = fn !== void 0;
          if (MAPPING || !IS_TO_ARRAY) aCallable(fn);
          var record = getIteratorDirect(object);
          var Promise2 = getBuiltIn("Promise");
          var iterator = record.iterator;
          var next = record.next;
          var counter = 0;
          return new Promise2(function(resolve, reject) {
            var ifAbruptCloseAsyncIterator = function(error) {
              closeAsyncIteration(iterator, reject, error, reject);
            };
            var loop = function() {
              try {
                if (MAPPING) try {
                  doesNotExceedSafeInteger(counter);
                } catch (error5) {
                  ifAbruptCloseAsyncIterator(error5);
                }
                Promise2.resolve(anObject(call(next, iterator))).then(function(step2) {
                  try {
                    if (anObject(step2).done) {
                      if (IS_TO_ARRAY) {
                        target.length = counter;
                        resolve(target);
                      } else resolve(IS_SOME ? false : IS_EVERY || void 0);
                    } else {
                      var value = step2.value;
                      try {
                        if (MAPPING) {
                          var result = fn(value, counter);
                          var handler = function($result) {
                            if (IS_FOR_EACH) {
                              loop();
                            } else if (IS_EVERY) {
                              $result ? loop() : closeAsyncIteration(iterator, resolve, false, reject);
                            } else if (IS_TO_ARRAY) {
                              try {
                                target[counter++] = $result;
                                loop();
                              } catch (error4) {
                                ifAbruptCloseAsyncIterator(error4);
                              }
                            } else {
                              $result ? closeAsyncIteration(iterator, resolve, IS_SOME || value, reject) : loop();
                            }
                          };
                          if (isObject4(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                          else handler(result);
                        } else {
                          target[counter++] = value;
                          loop();
                        }
                      } catch (error3) {
                        ifAbruptCloseAsyncIterator(error3);
                      }
                    }
                  } catch (error2) {
                    reject(error2);
                  }
                }, reject);
              } catch (error) {
                reject(error);
              }
            };
            loop();
          });
        };
      };
      module.exports = {
        // `AsyncIterator.prototype.toArray` / `Array.fromAsync` methods
        toArray: createMethod(0),
        // `AsyncIterator.prototype.forEach` method
        forEach: createMethod(1),
        // `AsyncIterator.prototype.every` method
        every: createMethod(2),
        // `AsyncIterator.prototype.some` method
        some: createMethod(3),
        // `AsyncIterator.prototype.find` method
        find: createMethod(4)
      };
    }
  });

  // node_modules/core-js/internals/array-from-async.js
  var require_array_from_async = __commonJS({
    "node_modules/core-js/internals/array-from-async.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var isConstructor = require_is_constructor();
      var getAsyncIterator = require_get_async_iterator();
      var getIterator = require_get_iterator();
      var getIteratorDirect = require_get_iterator_direct();
      var getIteratorMethod = require_get_iterator_method();
      var getMethod = require_get_method();
      var getBuiltIn = require_get_built_in();
      var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
      var wellKnownSymbol = require_well_known_symbol();
      var AsyncFromSyncIterator = require_async_from_sync_iterator();
      var toArray = require_async_iterator_iteration().toArray;
      var ASYNC_ITERATOR = wellKnownSymbol("asyncIterator");
      var arrayIterator = uncurryThis(getBuiltInPrototypeMethod("Array", "values"));
      var arrayIteratorNext = uncurryThis(arrayIterator([]).next);
      var safeArrayIterator = function() {
        return new SafeArrayIterator(this);
      };
      var SafeArrayIterator = function(O) {
        this.iterator = arrayIterator(O);
      };
      SafeArrayIterator.prototype.next = function() {
        return arrayIteratorNext(this.iterator);
      };
      module.exports = function fromAsync(asyncItems) {
        var C = this;
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var thisArg = argumentsLength > 2 ? arguments[2] : void 0;
        return new (getBuiltIn("Promise"))(function(resolve) {
          var O = toObject(asyncItems);
          if (mapfn !== void 0) mapfn = bind2(mapfn, thisArg);
          var usingAsyncIterator = getMethod(O, ASYNC_ITERATOR);
          var usingSyncIterator = usingAsyncIterator ? void 0 : getIteratorMethod(O) || safeArrayIterator;
          var A = isConstructor(C) ? new C() : [];
          var iterator = usingAsyncIterator ? getAsyncIterator(O, usingAsyncIterator) : new AsyncFromSyncIterator(getIteratorDirect(getIterator(O, usingSyncIterator)));
          resolve(toArray(iterator, mapfn, A));
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.from-async.js
  var require_es_array_from_async = __commonJS({
    "node_modules/core-js/modules/es.array.from-async.js"() {
      "use strict";
      var $ = require_export();
      var fromAsync = require_array_from_async();
      var fails = require_fails();
      var nativeFromAsync = Array.fromAsync;
      var INCORRECT_CONSTRUCTURING = !nativeFromAsync || fails(function() {
        var counter = 0;
        nativeFromAsync.call(function() {
          counter++;
          return [];
        }, { length: 0 });
        return counter !== 1;
      });
      $({ target: "Array", stat: true, forced: INCORRECT_CONSTRUCTURING }, {
        fromAsync
      });
    }
  });

  // node_modules/core-js/modules/es.async-disposable-stack.constructor.js
  var require_es_async_disposable_stack_constructor = __commonJS({
    "node_modules/core-js/modules/es.async-disposable-stack.constructor.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var getBuiltIn = require_get_built_in();
      var aCallable = require_a_callable();
      var anInstance = require_an_instance();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltIns = require_define_built_ins();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var wellKnownSymbol = require_well_known_symbol();
      var InternalStateModule = require_internal_state();
      var addDisposableResource = require_add_disposable_resource();
      var V8_VERSION = require_environment_v8_version();
      var Promise2 = getBuiltIn("Promise");
      var SuppressedError2 = getBuiltIn("SuppressedError");
      var $ReferenceError = ReferenceError;
      var ASYNC_DISPOSE = wellKnownSymbol("asyncDispose");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var ASYNC_DISPOSABLE_STACK = "AsyncDisposableStack";
      var setInternalState = InternalStateModule.set;
      var getAsyncDisposableStackInternalState = InternalStateModule.getterFor(ASYNC_DISPOSABLE_STACK);
      var HINT = "async-dispose";
      var DISPOSED = "disposed";
      var PENDING = "pending";
      var getPendingAsyncDisposableStackInternalState = function(stack) {
        var internalState = getAsyncDisposableStackInternalState(stack);
        if (internalState.state === DISPOSED) throw new $ReferenceError(ASYNC_DISPOSABLE_STACK + " already disposed");
        return internalState;
      };
      var $AsyncDisposableStack = function AsyncDisposableStack() {
        setInternalState(anInstance(this, AsyncDisposableStackPrototype), {
          type: ASYNC_DISPOSABLE_STACK,
          state: PENDING,
          stack: []
        });
        if (!DESCRIPTORS) this.disposed = false;
      };
      var AsyncDisposableStackPrototype = $AsyncDisposableStack.prototype;
      defineBuiltIns(AsyncDisposableStackPrototype, {
        disposeAsync: function disposeAsync() {
          var asyncDisposableStack = this;
          return new Promise2(function(resolve, reject) {
            var internalState = getAsyncDisposableStackInternalState(asyncDisposableStack);
            if (internalState.state === DISPOSED) return resolve(void 0);
            internalState.state = DISPOSED;
            if (!DESCRIPTORS) asyncDisposableStack.disposed = true;
            var stack = internalState.stack;
            var i = stack.length;
            var thrown = false;
            var suppressed;
            var handleError2 = function(result) {
              if (thrown) {
                suppressed = new SuppressedError2(result, suppressed);
              } else {
                thrown = true;
                suppressed = result;
              }
              loop();
            };
            var loop = function() {
              if (i) {
                var disposeMethod = stack[--i];
                stack[i] = null;
                try {
                  Promise2.resolve(disposeMethod()).then(loop, handleError2);
                } catch (error) {
                  handleError2(error);
                }
              } else {
                internalState.stack = null;
                thrown ? reject(suppressed) : resolve(void 0);
              }
            };
            loop();
          });
        },
        use: function use(value) {
          addDisposableResource(getPendingAsyncDisposableStackInternalState(this), value, HINT);
          return value;
        },
        adopt: function adopt(value, onDispose) {
          var internalState = getPendingAsyncDisposableStackInternalState(this);
          aCallable(onDispose);
          addDisposableResource(internalState, void 0, HINT, function() {
            return onDispose(value);
          });
          return value;
        },
        defer: function defer(onDispose) {
          var internalState = getPendingAsyncDisposableStackInternalState(this);
          aCallable(onDispose);
          addDisposableResource(internalState, void 0, HINT, onDispose);
        },
        move: function move() {
          var internalState = getPendingAsyncDisposableStackInternalState(this);
          var newAsyncDisposableStack = new $AsyncDisposableStack();
          getAsyncDisposableStackInternalState(newAsyncDisposableStack).stack = internalState.stack;
          internalState.stack = [];
          internalState.state = DISPOSED;
          if (!DESCRIPTORS) this.disposed = true;
          return newAsyncDisposableStack;
        }
      });
      if (DESCRIPTORS) defineBuiltInAccessor(AsyncDisposableStackPrototype, "disposed", {
        configurable: true,
        get: function disposed() {
          return getAsyncDisposableStackInternalState(this).state === DISPOSED;
        }
      });
      defineBuiltIn(AsyncDisposableStackPrototype, ASYNC_DISPOSE, AsyncDisposableStackPrototype.disposeAsync, { name: "disposeAsync" });
      defineBuiltIn(AsyncDisposableStackPrototype, TO_STRING_TAG, ASYNC_DISPOSABLE_STACK, { nonWritable: true });
      var SYNC_DISPOSE_RETURNING_PROMISE_RESOLUTION_BUG = V8_VERSION && V8_VERSION < 136;
      $({ global: true, constructor: true, forced: SYNC_DISPOSE_RETURNING_PROMISE_RESOLUTION_BUG }, {
        AsyncDisposableStack: $AsyncDisposableStack
      });
    }
  });

  // node_modules/core-js/modules/es.async-iterator.async-dispose.js
  var require_es_async_iterator_async_dispose = __commonJS({
    "node_modules/core-js/modules/es.async-iterator.async-dispose.js"() {
      "use strict";
      var call = require_function_call();
      var defineBuiltIn = require_define_built_in();
      var getBuiltIn = require_get_built_in();
      var getMethod = require_get_method();
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var AsyncIteratorPrototype = require_async_iterator_prototype();
      var ASYNC_DISPOSE = wellKnownSymbol("asyncDispose");
      var Promise2 = getBuiltIn("Promise");
      if (!hasOwn(AsyncIteratorPrototype, ASYNC_DISPOSE)) {
        defineBuiltIn(AsyncIteratorPrototype, ASYNC_DISPOSE, function() {
          var O = this;
          return new Promise2(function(resolve, reject) {
            var $return = getMethod(O, "return");
            if ($return) {
              Promise2.resolve(call($return, O)).then(function() {
                resolve(void 0);
              }, reject);
            } else resolve(void 0);
          });
        });
      }
    }
  });

  // node_modules/core-js/modules/es.reflect.apply.js
  var require_es_reflect_apply = __commonJS({
    "node_modules/core-js/modules/es.reflect.apply.js"() {
      "use strict";
      var $ = require_export();
      var functionApply = require_function_apply();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var fails = require_fails();
      var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
        Reflect.apply(function() {
        });
      });
      $({ target: "Reflect", stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
        apply: function apply(target, thisArgument, argumentsList) {
          return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.construct.js
  var require_es_reflect_construct = __commonJS({
    "node_modules/core-js/modules/es.reflect.construct.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var bind2 = require_function_bind();
      var aConstructor = require_a_constructor();
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var create = require_object_create();
      var fails = require_fails();
      var nativeConstruct = getBuiltIn("Reflect", "construct");
      var ObjectPrototype = Object.prototype;
      var push = [].push;
      var NEW_TARGET_BUG = fails(function() {
        function F() {
        }
        return !(nativeConstruct(function() {
        }, [], F) instanceof F);
      });
      var ARGS_BUG = !fails(function() {
        nativeConstruct(function() {
        });
      });
      var FORCED = NEW_TARGET_BUG || ARGS_BUG;
      $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
        construct: function construct(Target, args) {
          aConstructor(Target);
          anObject(args);
          var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
          if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
          if (Target === newTarget) {
            switch (args.length) {
              case 0:
                return new Target();
              case 1:
                return new Target(args[0]);
              case 2:
                return new Target(args[0], args[1]);
              case 3:
                return new Target(args[0], args[1], args[2]);
              case 4:
                return new Target(args[0], args[1], args[2], args[3]);
            }
            var $args = [null];
            apply(push, $args, args);
            return new (apply(bind2, Target, $args))();
          }
          var proto2 = newTarget.prototype;
          var instance = create(isObject4(proto2) ? proto2 : ObjectPrototype);
          var result = apply(Target, instance, args);
          return isObject4(result) ? result : instance;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.define-property.js
  var require_es_reflect_define_property = __commonJS({
    "node_modules/core-js/modules/es.reflect.define-property.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var definePropertyModule = require_object_define_property();
      var fails = require_fails();
      var ERROR_INSTEAD_OF_FALSE = fails(function() {
        Reflect.defineProperty(definePropertyModule.f({}, 1, { value: 1 }), 1, { value: 2 });
      });
      $({ target: "Reflect", stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !DESCRIPTORS }, {
        defineProperty: function defineProperty(target, propertyKey, attributes) {
          anObject(target);
          var key = toPropertyKey(propertyKey);
          anObject(attributes);
          try {
            definePropertyModule.f(target, key, attributes);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.delete-property.js
  var require_es_reflect_delete_property = __commonJS({
    "node_modules/core-js/modules/es.reflect.delete-property.js"() {
      "use strict";
      var $ = require_export();
      var anObject = require_an_object();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      $({ target: "Reflect", stat: true }, {
        deleteProperty: function deleteProperty(target, propertyKey) {
          var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
          return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
        }
      });
    }
  });

  // node_modules/core-js/internals/is-data-descriptor.js
  var require_is_data_descriptor = __commonJS({
    "node_modules/core-js/internals/is-data-descriptor.js"(exports, module) {
      "use strict";
      var hasOwn = require_has_own_property();
      module.exports = function(descriptor) {
        return descriptor !== void 0 && (hasOwn(descriptor, "value") || hasOwn(descriptor, "writable"));
      };
    }
  });

  // node_modules/core-js/modules/es.reflect.get.js
  var require_es_reflect_get = __commonJS({
    "node_modules/core-js/modules/es.reflect.get.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var isObject4 = require_is_object();
      var anObject = require_an_object();
      var isDataDescriptor = require_is_data_descriptor();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var getPrototypeOf = require_object_get_prototype_of();
      function get(target, propertyKey) {
        var receiver = arguments.length < 3 ? target : arguments[2];
        var descriptor, prototype;
        if (anObject(target) === receiver) return target[propertyKey];
        descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
        if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call(descriptor.get, receiver);
        if (isObject4(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
      }
      $({ target: "Reflect", stat: true }, {
        get
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js
  var require_es_reflect_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js"() {
      "use strict";
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var anObject = require_an_object();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      $({ target: "Reflect", stat: true, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
          return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.get-prototype-of.js
  var require_es_reflect_get_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.reflect.get-prototype-of.js"() {
      "use strict";
      var $ = require_export();
      var anObject = require_an_object();
      var objectGetPrototypeOf = require_object_get_prototype_of();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      $({ target: "Reflect", stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
        getPrototypeOf: function getPrototypeOf(target) {
          return objectGetPrototypeOf(anObject(target));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.has.js
  var require_es_reflect_has = __commonJS({
    "node_modules/core-js/modules/es.reflect.has.js"() {
      "use strict";
      var $ = require_export();
      $({ target: "Reflect", stat: true }, {
        has: function has(target, propertyKey) {
          return propertyKey in target;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.is-extensible.js
  var require_es_reflect_is_extensible = __commonJS({
    "node_modules/core-js/modules/es.reflect.is-extensible.js"() {
      "use strict";
      var $ = require_export();
      var anObject = require_an_object();
      var $isExtensible = require_object_is_extensible();
      $({ target: "Reflect", stat: true }, {
        isExtensible: function isExtensible(target) {
          anObject(target);
          return $isExtensible(target);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.own-keys.js
  var require_es_reflect_own_keys = __commonJS({
    "node_modules/core-js/modules/es.reflect.own-keys.js"() {
      "use strict";
      var $ = require_export();
      var ownKeys = require_own_keys();
      $({ target: "Reflect", stat: true }, {
        ownKeys
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.prevent-extensions.js
  var require_es_reflect_prevent_extensions = __commonJS({
    "node_modules/core-js/modules/es.reflect.prevent-extensions.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var anObject = require_an_object();
      var FREEZING = require_freezing();
      $({ target: "Reflect", stat: true, sham: !FREEZING }, {
        preventExtensions: function preventExtensions(target) {
          anObject(target);
          try {
            var objectPreventExtensions = getBuiltIn("Object", "preventExtensions");
            if (objectPreventExtensions) objectPreventExtensions(target);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.set.js
  var require_es_reflect_set = __commonJS({
    "node_modules/core-js/modules/es.reflect.set.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var isDataDescriptor = require_is_data_descriptor();
      var fails = require_fails();
      var definePropertyModule = require_object_define_property();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var getPrototypeOf = require_object_get_prototype_of();
      var createPropertyDescriptor = require_create_property_descriptor();
      function set(target, propertyKey, V) {
        var receiver = arguments.length < 4 ? target : arguments[3];
        var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
        var existingDescriptor, prototype, setter;
        if (!ownDescriptor) {
          if (isObject4(prototype = getPrototypeOf(target))) {
            return set(prototype, propertyKey, V, receiver);
          }
          ownDescriptor = createPropertyDescriptor(0);
        }
        if (isDataDescriptor(ownDescriptor)) {
          if (ownDescriptor.writable === false || !isObject4(receiver)) return false;
          if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
            if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
            existingDescriptor.value = V;
            definePropertyModule.f(receiver, propertyKey, existingDescriptor);
          } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
        } else {
          setter = ownDescriptor.set;
          if (setter === void 0) return false;
          call(setter, receiver, V);
        }
        return true;
      }
      var MS_EDGE_BUG = fails(function() {
        var Constructor = function() {
        };
        var object = definePropertyModule.f(new Constructor(), "a", { configurable: true });
        return Reflect.set(Constructor.prototype, "a", 1, object) !== false;
      });
      $({ target: "Reflect", stat: true, forced: MS_EDGE_BUG }, {
        set
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.set-prototype-of.js
  var require_es_reflect_set_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.reflect.set-prototype-of.js"() {
      "use strict";
      var $ = require_export();
      var anObject = require_an_object();
      var aPossiblePrototype = require_a_possible_prototype();
      var objectSetPrototypeOf = require_object_set_prototype_of();
      if (objectSetPrototypeOf) $({ target: "Reflect", stat: true }, {
        setPrototypeOf: function setPrototypeOf(target, proto2) {
          anObject(target);
          aPossiblePrototype(proto2);
          try {
            objectSetPrototypeOf(target, proto2);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.to-string-tag.js
  var require_es_reflect_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.reflect.to-string-tag.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var setToStringTag = require_set_to_string_tag();
      $({ global: true }, { Reflect: {} });
      setToStringTag(globalThis2.Reflect, "Reflect", true);
    }
  });

  // node_modules/core-js/internals/is-regexp.js
  var require_is_regexp = __commonJS({
    "node_modules/core-js/internals/is-regexp.js"(exports, module) {
      "use strict";
      var isObject4 = require_is_object();
      var classof = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var MATCH = wellKnownSymbol("match");
      module.exports = function(it) {
        var isRegExp;
        return isObject4(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) === "RegExp");
      };
    }
  });

  // node_modules/core-js/internals/regexp-flags-detection.js
  var require_regexp_flags_detection = __commonJS({
    "node_modules/core-js/internals/regexp-flags-detection.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var RegExp2 = globalThis2.RegExp;
      var FLAGS_GETTER_IS_CORRECT = !fails(function() {
        var INDICES_SUPPORT = true;
        try {
          RegExp2(".", "d");
        } catch (error) {
          INDICES_SUPPORT = false;
        }
        var O = {};
        var calls = "";
        var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
        var addGetter = function(key2, chr) {
          Object.defineProperty(O, key2, { get: function() {
            calls += chr;
            return true;
          } });
        };
        var pairs = {
          dotAll: "s",
          global: "g",
          ignoreCase: "i",
          multiline: "m",
          sticky: "y"
        };
        if (INDICES_SUPPORT) pairs.hasIndices = "d";
        for (var key in pairs) addGetter(key, pairs[key]);
        var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O);
        return result !== expected || calls !== expected;
      });
      module.exports = { correct: FLAGS_GETTER_IS_CORRECT };
    }
  });

  // node_modules/core-js/internals/regexp-flags.js
  var require_regexp_flags = __commonJS({
    "node_modules/core-js/internals/regexp-flags.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      module.exports = function() {
        var that = anObject(this);
        var result = "";
        if (that.hasIndices) result += "d";
        if (that.global) result += "g";
        if (that.ignoreCase) result += "i";
        if (that.multiline) result += "m";
        if (that.dotAll) result += "s";
        if (that.unicode) result += "u";
        if (that.unicodeSets) result += "v";
        if (that.sticky) result += "y";
        return result;
      };
    }
  });

  // node_modules/core-js/internals/regexp-get-flags.js
  var require_regexp_get_flags = __commonJS({
    "node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var hasOwn = require_has_own_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var regExpFlagsDetection = require_regexp_flags_detection();
      var regExpFlagsGetterImplementation = require_regexp_flags();
      var RegExpPrototype = RegExp.prototype;
      module.exports = regExpFlagsDetection.correct ? function(it) {
        return it.flags;
      } : function(it) {
        return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn(it, "flags") ? call(regExpFlagsGetterImplementation, it) : it.flags;
      };
    }
  });

  // node_modules/core-js/internals/regexp-sticky-helpers.js
  var require_regexp_sticky_helpers = __commonJS({
    "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var $RegExp = globalThis2.RegExp;
      var UNSUPPORTED_Y = fails(function() {
        var re = $RegExp("a", "y");
        re.lastIndex = 2;
        return re.exec("abcd") !== null;
      });
      var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
        return !$RegExp("a", "y").sticky;
      });
      var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
        var re = $RegExp("^r", "gy");
        re.lastIndex = 2;
        return re.exec("str") !== null;
      });
      module.exports = {
        BROKEN_CARET,
        MISSED_STICKY,
        UNSUPPORTED_Y
      };
    }
  });

  // node_modules/core-js/internals/regexp-unsupported-dot-all.js
  var require_regexp_unsupported_dot_all = __commonJS({
    "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var $RegExp = globalThis2.RegExp;
      module.exports = fails(function() {
        var re = $RegExp(".", "s");
        return !(re.dotAll && re.test("\n") && re.flags === "s");
      });
    }
  });

  // node_modules/core-js/internals/regexp-unsupported-ncg.js
  var require_regexp_unsupported_ncg = __commonJS({
    "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var $RegExp = globalThis2.RegExp;
      module.exports = fails(function() {
        var re = $RegExp("(?<a>b)", "g");
        return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.constructor.js
  var require_es_regexp_constructor = __commonJS({
    "node_modules/core-js/modules/es.regexp.constructor.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var inheritIfRequired = require_inherit_if_required();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var create = require_object_create();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var isPrototypeOf = require_object_is_prototype_of();
      var isRegExp = require_is_regexp();
      var toString = require_to_string();
      var getRegExpFlags = require_regexp_get_flags();
      var stickyHelpers = require_regexp_sticky_helpers();
      var proxyAccessor = require_proxy_accessor();
      var defineBuiltIn = require_define_built_in();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var enforceInternalState = require_internal_state().enforce;
      var setSpecies = require_set_species();
      var wellKnownSymbol = require_well_known_symbol();
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
      var MATCH = wellKnownSymbol("match");
      var NativeRegExp = globalThis2.RegExp;
      var RegExpPrototype = NativeRegExp.prototype;
      var SyntaxError = globalThis2.SyntaxError;
      var exec = uncurryThis(RegExpPrototype.exec);
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var stringIndexOf = uncurryThis("".indexOf);
      var stringSlice = uncurryThis("".slice);
      var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
      var re1 = /a/g;
      var re2 = /a/g;
      var CORRECT_NEW = new NativeRegExp(re1) !== re1;
      var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
      var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
      var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
        re2[MATCH] = false;
        return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, "i")) !== "/a/i";
      }));
      var handleDotAll = function(string) {
        var length = string.length;
        var index2 = 0;
        var result = "";
        var brackets = false;
        var chr;
        for (; index2 <= length; index2++) {
          chr = charAt(string, index2);
          if (chr === "\\") {
            result += chr + charAt(string, ++index2);
            continue;
          }
          if (!brackets && chr === ".") {
            result += "[\\s\\S]";
          } else {
            if (chr === "[") {
              brackets = true;
            } else if (chr === "]") {
              brackets = false;
            }
            result += chr;
          }
        }
        return result;
      };
      var handleNCG = function(string) {
        var length = string.length;
        var index2 = 0;
        var result = "";
        var named = [];
        var names = create(null);
        var brackets = false;
        var ncg = false;
        var groupid = 0;
        var groupname = "";
        var chr;
        for (; index2 <= length; index2++) {
          chr = charAt(string, index2);
          if (chr === "\\") {
            chr += charAt(string, ++index2);
          } else if (chr === "]") {
            brackets = false;
          } else if (!brackets) switch (true) {
            case chr === "[":
              brackets = true;
              break;
            case chr === "(":
              result += chr;
              if (stringSlice(string, index2 + 1, index2 + 3) === "?:") {
                continue;
              }
              if (exec(IS_NCG, stringSlice(string, index2 + 1))) {
                index2 += 2;
                ncg = true;
              }
              groupid++;
              continue;
            case (chr === ">" && ncg):
              if (groupname === "" || hasOwn(names, groupname)) {
                throw new SyntaxError("Invalid capture group name");
              }
              names[groupname] = true;
              named[named.length] = [groupname, groupid];
              ncg = false;
              groupname = "";
              continue;
          }
          if (ncg) groupname += chr;
          else result += chr;
        }
        return [result, named];
      };
      if (isForced("RegExp", BASE_FORCED)) {
        RegExpWrapper = function RegExp2(pattern, flags) {
          var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
          var patternIsRegExp = isRegExp(pattern);
          var flagsAreUndefined = flags === void 0;
          var groups = [];
          var rawPattern = pattern;
          var rawFlags, dotAll, sticky, handled, result, state3;
          if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
            return pattern;
          }
          if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
            pattern = pattern.source;
            if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
          }
          pattern = pattern === void 0 ? "" : toString(pattern);
          flags = flags === void 0 ? "" : toString(flags);
          rawPattern = pattern;
          if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
            dotAll = !!flags && stringIndexOf(flags, "s") > -1;
            if (dotAll) flags = replace(flags, /s/g, "");
          }
          rawFlags = flags;
          if (MISSED_STICKY && "sticky" in re1) {
            sticky = !!flags && stringIndexOf(flags, "y") > -1;
            if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, "");
          }
          if (UNSUPPORTED_NCG) {
            handled = handleNCG(pattern);
            pattern = handled[0];
            groups = handled[1];
          }
          result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
          if (dotAll || sticky || groups.length) {
            state3 = enforceInternalState(result);
            if (dotAll) {
              state3.dotAll = true;
              state3.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
            }
            if (sticky) state3.sticky = true;
            if (groups.length) state3.groups = groups;
          }
          if (pattern !== rawPattern) try {
            createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
          } catch (error) {
          }
          return result;
        };
        for (keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index; ) {
          proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
        }
        RegExpPrototype.constructor = RegExpWrapper;
        RegExpWrapper.prototype = RegExpPrototype;
        defineBuiltIn(globalThis2, "RegExp", RegExpWrapper, { constructor: true });
      }
      var RegExpWrapper;
      var keys;
      var index;
      setSpecies("RegExp");
    }
  });

  // node_modules/core-js/internals/a-string.js
  var require_a_string = __commonJS({
    "node_modules/core-js/internals/a-string.js"(exports, module) {
      "use strict";
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (typeof argument == "string") return argument;
        throw new $TypeError("Argument is not a string");
      };
    }
  });

  // node_modules/core-js/modules/es.regexp.escape.js
  var require_es_regexp_escape = __commonJS({
    "node_modules/core-js/modules/es.regexp.escape.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aString = require_a_string();
      var hasOwn = require_has_own_property();
      var padStart = require_string_pad().start;
      var WHITESPACES = require_whitespaces();
      var $Array = Array;
      var $escape = RegExp.escape;
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var numberToString = uncurryThis(1.1.toString);
      var join = uncurryThis([].join);
      var FIRST_DIGIT_OR_ASCII = /^[0-9a-z]/i;
      var SYNTAX_SOLIDUS = /^[$()*+./?[\\\]^{|}]/;
      var OTHER_PUNCTUATORS_AND_WHITESPACES = RegExp("^[!\"#%&',\\-:;<=>@`~" + WHITESPACES + "]");
      var exec = uncurryThis(FIRST_DIGIT_OR_ASCII.exec);
      var ControlEscape = {
        "	": "t",
        "\n": "n",
        "\v": "v",
        "\f": "f",
        "\r": "r"
      };
      var escapeChar = function(chr) {
        var hex = numberToString(charCodeAt(chr, 0), 16);
        return hex.length < 3 ? "\\x" + padStart(hex, 2, "0") : "\\u" + padStart(hex, 4, "0");
      };
      var FORCED = !$escape || $escape("ab") !== "\\x61b";
      $({ target: "RegExp", stat: true, forced: FORCED }, {
        escape: function escape2(S) {
          aString(S);
          var length = S.length;
          var result = $Array(length);
          for (var i = 0; i < length; i++) {
            var chr = charAt(S, i);
            if (i === 0 && exec(FIRST_DIGIT_OR_ASCII, chr)) {
              result[i] = escapeChar(chr);
            } else if (hasOwn(ControlEscape, chr)) {
              result[i] = "\\" + ControlEscape[chr];
            } else if (exec(SYNTAX_SOLIDUS, chr)) {
              result[i] = "\\" + chr;
            } else if (exec(OTHER_PUNCTUATORS_AND_WHITESPACES, chr)) {
              result[i] = escapeChar(chr);
            } else {
              var charCode = charCodeAt(chr, 0);
              if ((charCode & 63488) !== 55296) result[i] = chr;
              else if (charCode >= 56320 || i + 1 >= length || (charCodeAt(S, i + 1) & 64512) !== 56320) result[i] = escapeChar(chr);
              else {
                result[i] = chr;
                result[++i] = charAt(S, i);
              }
            }
          }
          return join(result, "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.dot-all.js
  var require_es_regexp_dot_all = __commonJS({
    "node_modules/core-js/modules/es.regexp.dot-all.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var classof = require_classof_raw();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var getInternalState = require_internal_state().get;
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) {
        defineBuiltInAccessor(RegExpPrototype, "dotAll", {
          configurable: true,
          get: function dotAll() {
            if (this === RegExpPrototype) return;
            if (classof(this) === "RegExp") {
              return !!getInternalState(this).dotAll;
            }
            throw new $TypeError("Incompatible receiver, RegExp required");
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/regexp-exec.js
  var require_regexp_exec = __commonJS({
    "node_modules/core-js/internals/regexp-exec.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var regexpFlags = require_regexp_flags();
      var stickyHelpers = require_regexp_sticky_helpers();
      var shared = require_shared();
      var create = require_object_create();
      var getInternalState = require_internal_state().get;
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
      var nativeReplace = shared("native-string-replace", String.prototype.replace);
      var nativeExec = RegExp.prototype.exec;
      var patchedExec = nativeExec;
      var charAt = uncurryThis("".charAt);
      var indexOf = uncurryThis("".indexOf);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var UPDATES_LAST_INDEX_WRONG = (function() {
        var re1 = /a/;
        var re2 = /b*/g;
        call(nativeExec, re1, "a");
        call(nativeExec, re2, "a");
        return re1.lastIndex !== 0 || re2.lastIndex !== 0;
      })();
      var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
      var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
      var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
      if (PATCH) {
        patchedExec = function exec(string) {
          var re = this;
          var state3 = getInternalState(re);
          var str = toString(string);
          var raw = state3.raw;
          var result, reCopy, lastIndex, match, i, object, group;
          if (raw) {
            raw.lastIndex = re.lastIndex;
            result = call(patchedExec, raw, str);
            re.lastIndex = raw.lastIndex;
            return result;
          }
          var groups = state3.groups;
          var sticky = UNSUPPORTED_Y && re.sticky;
          var flags = call(regexpFlags, re);
          var source = re.source;
          var charsAdded = 0;
          var strCopy = str;
          if (sticky) {
            flags = replace(flags, "y", "");
            if (indexOf(flags, "g") === -1) {
              flags += "g";
            }
            strCopy = stringSlice(str, re.lastIndex);
            if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
              source = "(?: " + source + ")";
              strCopy = " " + strCopy;
              charsAdded++;
            }
            reCopy = new RegExp("^(?:" + source + ")", flags);
          }
          if (NPCG_INCLUDED) {
            reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
          }
          if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
          match = call(nativeExec, sticky ? reCopy : re, strCopy);
          if (sticky) {
            if (match) {
              match.input = stringSlice(match.input, charsAdded);
              match[0] = stringSlice(match[0], charsAdded);
              match.index = re.lastIndex;
              re.lastIndex += match[0].length;
            } else re.lastIndex = 0;
          } else if (UPDATES_LAST_INDEX_WRONG && match) {
            re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
          }
          if (NPCG_INCLUDED && match && match.length > 1) {
            call(nativeReplace, match[0], reCopy, function() {
              for (i = 1; i < arguments.length - 2; i++) {
                if (arguments[i] === void 0) match[i] = void 0;
              }
            });
          }
          if (match && groups) {
            match.groups = object = create(null);
            for (i = 0; i < groups.length; i++) {
              group = groups[i];
              object[group[0]] = match[group[1]];
            }
          }
          return match;
        };
      }
      module.exports = patchedExec;
    }
  });

  // node_modules/core-js/modules/es.regexp.exec.js
  var require_es_regexp_exec = __commonJS({
    "node_modules/core-js/modules/es.regexp.exec.js"() {
      "use strict";
      var $ = require_export();
      var exec = require_regexp_exec();
      $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
        exec
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.flags.js
  var require_es_regexp_flags = __commonJS({
    "node_modules/core-js/modules/es.regexp.flags.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var regExpFlagsDetection = require_regexp_flags_detection();
      var regExpFlagsGetterImplementation = require_regexp_flags();
      if (DESCRIPTORS && !regExpFlagsDetection.correct) {
        defineBuiltInAccessor(RegExp.prototype, "flags", {
          configurable: true,
          get: regExpFlagsGetterImplementation
        });
        regExpFlagsDetection.correct = true;
      }
    }
  });

  // node_modules/core-js/modules/es.regexp.sticky.js
  var require_es_regexp_sticky = __commonJS({
    "node_modules/core-js/modules/es.regexp.sticky.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var MISSED_STICKY = require_regexp_sticky_helpers().MISSED_STICKY;
      var classof = require_classof_raw();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var getInternalState = require_internal_state().get;
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      if (DESCRIPTORS && MISSED_STICKY) {
        defineBuiltInAccessor(RegExpPrototype, "sticky", {
          configurable: true,
          get: function sticky() {
            if (this === RegExpPrototype) return;
            if (classof(this) === "RegExp") {
              return !!getInternalState(this).sticky;
            }
            throw new $TypeError("Incompatible receiver, RegExp required");
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.regexp.test.js
  var require_es_regexp_test = __commonJS({
    "node_modules/core-js/modules/es.regexp.test.js"() {
      "use strict";
      require_es_regexp_exec();
      var $ = require_export();
      var call = require_function_call();
      var isCallable = require_is_callable();
      var anObject = require_an_object();
      var toString = require_to_string();
      var DELEGATES_TO_EXEC = (function() {
        var execCalled = false;
        var re = /[ac]/;
        re.exec = function() {
          execCalled = true;
          return /./.exec.apply(this, arguments);
        };
        return re.test("abc") === true && execCalled;
      })();
      var nativeTest = /./.test;
      $({ target: "RegExp", proto: true, forced: !DELEGATES_TO_EXEC }, {
        test: function(S) {
          var R = anObject(this);
          var string = toString(S);
          var exec = R.exec;
          if (!isCallable(exec)) return call(nativeTest, R, string);
          var result = call(exec, R, string);
          if (result === null) return false;
          anObject(result);
          return true;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.to-string.js
  var require_es_regexp_to_string = __commonJS({
    "node_modules/core-js/modules/es.regexp.to-string.js"() {
      "use strict";
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var defineBuiltIn = require_define_built_in();
      var anObject = require_an_object();
      var $toString = require_to_string();
      var fails = require_fails();
      var getRegExpFlags = require_regexp_get_flags();
      var TO_STRING = "toString";
      var RegExpPrototype = RegExp.prototype;
      var nativeToString = RegExpPrototype[TO_STRING];
      var NOT_GENERIC = fails(function() {
        return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
      });
      var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
      if (NOT_GENERIC || INCORRECT_NAME) {
        defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
          var R = anObject(this);
          var pattern = $toString(R.source);
          var flags = $toString(getRegExpFlags(R));
          return "/" + pattern + "/" + flags;
        }, { unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/es.set.constructor.js
  var require_es_set_constructor = __commonJS({
    "node_modules/core-js/modules/es.set.constructor.js"() {
      "use strict";
      var collection = require_collection();
      var collectionStrong = require_collection_strong();
      collection("Set", function(init2) {
        return function Set2() {
          return init2(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
    }
  });

  // node_modules/core-js/modules/es.set.js
  var require_es_set = __commonJS({
    "node_modules/core-js/modules/es.set.js"() {
      "use strict";
      require_es_set_constructor();
    }
  });

  // node_modules/core-js/internals/set-helpers.js
  var require_set_helpers = __commonJS({
    "node_modules/core-js/internals/set-helpers.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var SetPrototype = Set.prototype;
      module.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: uncurryThis(SetPrototype.add),
        has: uncurryThis(SetPrototype.has),
        remove: uncurryThis(SetPrototype["delete"]),
        proto: SetPrototype
      };
    }
  });

  // node_modules/core-js/internals/a-set.js
  var require_a_set = __commonJS({
    "node_modules/core-js/internals/a-set.js"(exports, module) {
      "use strict";
      var has = require_set_helpers().has;
      module.exports = function(it) {
        has(it);
        return it;
      };
    }
  });

  // node_modules/core-js/internals/iterate-simple.js
  var require_iterate_simple = __commonJS({
    "node_modules/core-js/internals/iterate-simple.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      module.exports = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
        var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
        var next = record.next;
        var step2, result;
        while (!(step2 = call(next, iterator)).done) {
          result = fn(step2.value);
          if (result !== void 0) return result;
        }
      };
    }
  });

  // node_modules/core-js/internals/set-iterate.js
  var require_set_iterate = __commonJS({
    "node_modules/core-js/internals/set-iterate.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var iterateSimple = require_iterate_simple();
      var SetHelpers = require_set_helpers();
      var Set2 = SetHelpers.Set;
      var SetPrototype = SetHelpers.proto;
      var forEach = uncurryThis(SetPrototype.forEach);
      var keys = uncurryThis(SetPrototype.keys);
      var next = keys(new Set2()).next;
      module.exports = function(set, fn, interruptible) {
        return interruptible ? iterateSimple({ iterator: keys(set), next }, fn) : forEach(set, fn);
      };
    }
  });

  // node_modules/core-js/internals/set-clone.js
  var require_set_clone = __commonJS({
    "node_modules/core-js/internals/set-clone.js"(exports, module) {
      "use strict";
      var SetHelpers = require_set_helpers();
      var iterate = require_set_iterate();
      var Set2 = SetHelpers.Set;
      var add = SetHelpers.add;
      module.exports = function(set) {
        var result = new Set2();
        iterate(set, function(it) {
          add(result, it);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/internals/set-size.js
  var require_set_size = __commonJS({
    "node_modules/core-js/internals/set-size.js"(exports, module) {
      "use strict";
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var SetHelpers = require_set_helpers();
      module.exports = uncurryThisAccessor(SetHelpers.proto, "size", "get") || function(set) {
        return set.size;
      };
    }
  });

  // node_modules/core-js/internals/get-set-record.js
  var require_get_set_record = __commonJS({
    "node_modules/core-js/internals/get-set-record.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var call = require_function_call();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var getIteratorDirect = require_get_iterator_direct();
      var INVALID_SIZE = "Invalid size";
      var $RangeError = RangeError;
      var $TypeError = TypeError;
      var max = Math.max;
      var SetRecord = function(set, intSize) {
        this.set = set;
        this.size = max(intSize, 0);
        this.has = aCallable(set.has);
        this.keys = aCallable(set.keys);
      };
      SetRecord.prototype = {
        getIterator: function() {
          return getIteratorDirect(anObject(call(this.keys, this.set)));
        },
        includes: function(it) {
          return call(this.has, this.set, it);
        }
      };
      module.exports = function(obj) {
        anObject(obj);
        var numSize = +obj.size;
        if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
        var intSize = toIntegerOrInfinity(numSize);
        if (intSize < 0) throw new $RangeError(INVALID_SIZE);
        return new SetRecord(obj, intSize);
      };
    }
  });

  // node_modules/core-js/internals/set-difference.js
  var require_set_difference = __commonJS({
    "node_modules/core-js/internals/set-difference.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var clone = require_set_clone();
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var has = SetHelpers.has;
      var remove = SetHelpers.remove;
      module.exports = function difference(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        var result = clone(O);
        if (size(O) <= otherRec.size) iterateSet(O, function(e) {
          if (otherRec.includes(e)) remove(result, e);
        });
        else iterateSimple(otherRec.getIterator(), function(e) {
          if (has(result, e)) remove(result, e);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/internals/set-method-accept-set-like.js
  var require_set_method_accept_set_like = __commonJS({
    "node_modules/core-js/internals/set-method-accept-set-like.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var createSetLike = function(size) {
        return {
          size,
          has: function() {
            return false;
          },
          keys: function() {
            return {
              next: function() {
                return { done: true };
              }
            };
          }
        };
      };
      var createSetLikeWithInfinitySize = function(size) {
        return {
          size,
          has: function() {
            return true;
          },
          keys: function() {
            throw new Error("e");
          }
        };
      };
      module.exports = function(name, callback) {
        var Set2 = getBuiltIn("Set");
        try {
          new Set2()[name](createSetLike(0));
          try {
            new Set2()[name](createSetLike(-1));
            return false;
          } catch (error2) {
            if (!callback) return true;
            try {
              new Set2()[name](createSetLikeWithInfinitySize(-Infinity));
              return false;
            } catch (error) {
              var set = new Set2();
              set.add(1);
              set.add(2);
              return callback(set[name](createSetLikeWithInfinitySize(Infinity)));
            }
          }
        } catch (error) {
          return false;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.set.difference.v2.js
  var require_es_set_difference_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.difference.v2.js"() {
      "use strict";
      var $ = require_export();
      var difference = require_set_difference();
      var fails = require_fails();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var SET_LIKE_INCORRECT_BEHAVIOR = !setMethodAcceptSetLike("difference", function(result) {
        return result.size === 0;
      });
      var FORCED = SET_LIKE_INCORRECT_BEHAVIOR || fails(function() {
        var setLike = {
          size: 1,
          has: function() {
            return true;
          },
          keys: function() {
            var index = 0;
            return {
              next: function() {
                var done = index++ > 1;
                if (baseSet.has(1)) baseSet.clear();
                return { done, value: 2 };
              }
            };
          }
        };
        var baseSet = /* @__PURE__ */ new Set([1, 2, 3, 4]);
        return baseSet.difference(setLike).size !== 3;
      });
      $({ target: "Set", proto: true, real: true, forced: FORCED }, {
        difference
      });
    }
  });

  // node_modules/core-js/internals/set-intersection.js
  var require_set_intersection = __commonJS({
    "node_modules/core-js/internals/set-intersection.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var Set2 = SetHelpers.Set;
      var add = SetHelpers.add;
      var has = SetHelpers.has;
      module.exports = function intersection(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        var result = new Set2();
        if (size(O) > otherRec.size) {
          iterateSimple(otherRec.getIterator(), function(e) {
            if (has(O, e)) add(result, e);
          });
        } else {
          iterateSet(O, function(e) {
            if (otherRec.includes(e)) add(result, e);
          });
        }
        return result;
      };
    }
  });

  // node_modules/core-js/modules/es.set.intersection.v2.js
  var require_es_set_intersection_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.intersection.v2.js"() {
      "use strict";
      var $ = require_export();
      var fails = require_fails();
      var intersection = require_set_intersection();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("intersection", function(result) {
        return result.size === 2 && result.has(1) && result.has(2);
      }) || fails(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        intersection
      });
    }
  });

  // node_modules/core-js/internals/set-is-disjoint-from.js
  var require_set_is_disjoint_from = __commonJS({
    "node_modules/core-js/internals/set-is-disjoint-from.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var has = require_set_helpers().has;
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var iteratorClose = require_iterator_close();
      module.exports = function isDisjointFrom(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O) <= otherRec.size) return iterateSet(O, function(e) {
          if (otherRec.includes(e)) return false;
        }, true) !== false;
        var iterator = otherRec.getIterator();
        return iterateSimple(iterator, function(e) {
          if (has(O, e)) return iteratorClose(iterator, "normal", false);
        }) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-disjoint-from.v2.js
  var require_es_set_is_disjoint_from_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-disjoint-from.v2.js"() {
      "use strict";
      var $ = require_export();
      var isDisjointFrom = require_set_is_disjoint_from();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("isDisjointFrom", function(result) {
        return !result;
      });
      $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        isDisjointFrom
      });
    }
  });

  // node_modules/core-js/internals/set-is-subset-of.js
  var require_set_is_subset_of = __commonJS({
    "node_modules/core-js/internals/set-is-subset-of.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var size = require_set_size();
      var iterate = require_set_iterate();
      var getSetRecord = require_get_set_record();
      module.exports = function isSubsetOf(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O) > otherRec.size) return false;
        return iterate(O, function(e) {
          if (!otherRec.includes(e)) return false;
        }, true) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-subset-of.v2.js
  var require_es_set_is_subset_of_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-subset-of.v2.js"() {
      "use strict";
      var $ = require_export();
      var isSubsetOf = require_set_is_subset_of();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("isSubsetOf", function(result) {
        return result;
      });
      $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        isSubsetOf
      });
    }
  });

  // node_modules/core-js/internals/set-is-superset-of.js
  var require_set_is_superset_of = __commonJS({
    "node_modules/core-js/internals/set-is-superset-of.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var has = require_set_helpers().has;
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      var iteratorClose = require_iterator_close();
      module.exports = function isSupersetOf(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O) < otherRec.size) return false;
        var iterator = otherRec.getIterator();
        return iterateSimple(iterator, function(e) {
          if (!has(O, e)) return iteratorClose(iterator, "normal", false);
        }) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-superset-of.v2.js
  var require_es_set_is_superset_of_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-superset-of.v2.js"() {
      "use strict";
      var $ = require_export();
      var isSupersetOf = require_set_is_superset_of();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("isSupersetOf", function(result) {
        return !result;
      });
      $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        isSupersetOf
      });
    }
  });

  // node_modules/core-js/internals/set-symmetric-difference.js
  var require_set_symmetric_difference = __commonJS({
    "node_modules/core-js/internals/set-symmetric-difference.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var clone = require_set_clone();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      var add = SetHelpers.add;
      var has = SetHelpers.has;
      var remove = SetHelpers.remove;
      module.exports = function symmetricDifference(other) {
        var O = aSet(this);
        var keysIter = getSetRecord(other).getIterator();
        var result = clone(O);
        iterateSimple(keysIter, function(e) {
          if (has(O, e)) remove(result, e);
          else add(result, e);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/internals/set-method-get-keys-before-cloning-detection.js
  var require_set_method_get_keys_before_cloning_detection = __commonJS({
    "node_modules/core-js/internals/set-method-get-keys-before-cloning-detection.js"(exports, module) {
      "use strict";
      module.exports = function(METHOD_NAME) {
        try {
          var baseSet = /* @__PURE__ */ new Set();
          var setLike = {
            size: 0,
            has: function() {
              return true;
            },
            keys: function() {
              return Object.defineProperty({}, "next", {
                get: function() {
                  baseSet.clear();
                  baseSet.add(4);
                  return function() {
                    return { done: true };
                  };
                }
              });
            }
          };
          var result = baseSet[METHOD_NAME](setLike);
          return result.size === 1 && result.values().next().value === 4;
        } catch (error) {
          return false;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.set.symmetric-difference.v2.js
  var require_es_set_symmetric_difference_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.symmetric-difference.v2.js"() {
      "use strict";
      var $ = require_export();
      var symmetricDifference = require_set_symmetric_difference();
      var setMethodGetKeysBeforeCloning = require_set_method_get_keys_before_cloning_detection();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var FORCED = !setMethodAcceptSetLike("symmetricDifference") || !setMethodGetKeysBeforeCloning("symmetricDifference");
      $({ target: "Set", proto: true, real: true, forced: FORCED }, {
        symmetricDifference
      });
    }
  });

  // node_modules/core-js/internals/set-union.js
  var require_set_union = __commonJS({
    "node_modules/core-js/internals/set-union.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var add = require_set_helpers().add;
      var clone = require_set_clone();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      module.exports = function union(other) {
        var O = aSet(this);
        var keysIter = getSetRecord(other).getIterator();
        var result = clone(O);
        iterateSimple(keysIter, function(it) {
          add(result, it);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/modules/es.set.union.v2.js
  var require_es_set_union_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.union.v2.js"() {
      "use strict";
      var $ = require_export();
      var union = require_set_union();
      var setMethodGetKeysBeforeCloning = require_set_method_get_keys_before_cloning_detection();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var FORCED = !setMethodAcceptSetLike("union") || !setMethodGetKeysBeforeCloning("union");
      $({ target: "Set", proto: true, real: true, forced: FORCED }, {
        union
      });
    }
  });

  // node_modules/core-js/modules/es.string.at-alternative.js
  var require_es_string_at_alternative = __commonJS({
    "node_modules/core-js/modules/es.string.at-alternative.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var fails = require_fails();
      var charAt = uncurryThis("".charAt);
      var FORCED = fails(function() {
        return "\u{20BB7}".at(-2) !== "\uD842";
      });
      $({ target: "String", proto: true, forced: FORCED }, {
        at: function at(index) {
          var S = toString(requireObjectCoercible(this));
          var len = S.length;
          var relativeIndex = toIntegerOrInfinity(index);
          var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k < 0 || k >= len ? void 0 : charAt(S, k);
        }
      });
    }
  });

  // node_modules/core-js/internals/string-multibyte.js
  var require_string_multibyte = __commonJS({
    "node_modules/core-js/internals/string-multibyte.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var stringSlice = uncurryThis("".slice);
      var createMethod = function(CONVERT_TO_STRING) {
        return function($this, pos) {
          var S = toString(requireObjectCoercible($this));
          var position = toIntegerOrInfinity(pos);
          var size = S.length;
          var first, second;
          if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
          first = charCodeAt(S, position);
          return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
        };
      };
      module.exports = {
        // `String.prototype.codePointAt` method
        // https://tc39.es/ecma262/#sec-string.prototype.codepointat
        codeAt: createMethod(false),
        // `String.prototype.at` method
        // https://github.com/mathiasbynens/String.prototype.at
        charAt: createMethod(true)
      };
    }
  });

  // node_modules/core-js/modules/es.string.code-point-at.js
  var require_es_string_code_point_at = __commonJS({
    "node_modules/core-js/modules/es.string.code-point-at.js"() {
      "use strict";
      var $ = require_export();
      var codeAt = require_string_multibyte().codeAt;
      $({ target: "String", proto: true }, {
        codePointAt: function codePointAt(pos) {
          return codeAt(this, pos);
        }
      });
    }
  });

  // node_modules/core-js/internals/not-a-regexp.js
  var require_not_a_regexp = __commonJS({
    "node_modules/core-js/internals/not-a-regexp.js"(exports, module) {
      "use strict";
      var isRegExp = require_is_regexp();
      var $TypeError = TypeError;
      module.exports = function(it) {
        if (isRegExp(it)) {
          throw new $TypeError("The method doesn't accept regular expressions");
        }
        return it;
      };
    }
  });

  // node_modules/core-js/internals/correct-is-regexp-logic.js
  var require_correct_is_regexp_logic = __commonJS({
    "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var MATCH = wellKnownSymbol("match");
      module.exports = function(METHOD_NAME) {
        var regexp = /./;
        try {
          "/./"[METHOD_NAME](regexp);
        } catch (error1) {
          try {
            regexp[MATCH] = false;
            return "/./"[METHOD_NAME](regexp);
          } catch (error2) {
          }
        }
        return false;
      };
    }
  });

  // node_modules/core-js/modules/es.string.ends-with.js
  var require_es_string_ends_with = __commonJS({
    "node_modules/core-js/modules/es.string.ends-with.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var toLength = require_to_length();
      var toString = require_to_string();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var IS_PURE = require_is_pure();
      var slice = uncurryThis("".slice);
      var min = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
      var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
        return descriptor && !descriptor.writable;
      })();
      $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        endsWith: function endsWith(searchString) {
          var that = toString(requireObjectCoercible(this));
          notARegExp(searchString);
          var endPosition = arguments.length > 1 ? arguments[1] : void 0;
          var len = that.length;
          var end = endPosition === void 0 ? len : min(toLength(endPosition), len);
          var search = toString(searchString);
          return slice(that, end - search.length, end) === search;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.from-code-point.js
  var require_es_string_from_code_point = __commonJS({
    "node_modules/core-js/modules/es.string.from-code-point.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toAbsoluteIndex = require_to_absolute_index();
      var $RangeError = RangeError;
      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = String.fromCodePoint;
      var join = uncurryThis([].join);
      var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;
      $({ target: "String", stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        fromCodePoint: function fromCodePoint(x) {
          var elements = [];
          var length = arguments.length;
          var i = 0;
          var code;
          while (length > i) {
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 1114111) !== code) throw new $RangeError(code + " is not a valid code point");
            elements[i] = code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
          }
          return join(elements, "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.includes.js
  var require_es_string_includes = __commonJS({
    "node_modules/core-js/modules/es.string.includes.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var stringIndexOf = uncurryThis("".indexOf);
      $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
        includes: function includes(searchString) {
          return !!~stringIndexOf(
            toString(requireObjectCoercible(this)),
            toString(notARegExp(searchString)),
            arguments.length > 1 ? arguments[1] : void 0
          );
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.is-well-formed.js
  var require_es_string_is_well_formed = __commonJS({
    "node_modules/core-js/modules/es.string.is-well-formed.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var charCodeAt = uncurryThis("".charCodeAt);
      $({ target: "String", proto: true }, {
        isWellFormed: function isWellFormed() {
          var S = toString(requireObjectCoercible(this));
          var length = S.length;
          for (var i = 0; i < length; i++) {
            var charCode = charCodeAt(S, i);
            if ((charCode & 63488) !== 55296) continue;
            if (charCode >= 56320 || ++i >= length || (charCodeAt(S, i) & 64512) !== 56320) return false;
          }
          return true;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.iterator.js
  var require_es_string_iterator = __commonJS({
    "node_modules/core-js/modules/es.string.iterator.js"() {
      "use strict";
      var charAt = require_string_multibyte().charAt;
      var toString = require_to_string();
      var InternalStateModule = require_internal_state();
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var STRING_ITERATOR = "String Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
      defineIterator(String, "String", function(iterated) {
        setInternalState(this, {
          type: STRING_ITERATOR,
          string: toString(iterated),
          index: 0
        });
      }, function next() {
        var state3 = getInternalState(this);
        var string = state3.string;
        var index = state3.index;
        var point;
        if (index >= string.length) return createIterResultObject(void 0, true);
        point = charAt(string, index);
        state3.index += point.length;
        return createIterResultObject(point, false);
      });
    }
  });

  // node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
  var require_fix_regexp_well_known_symbol_logic = __commonJS({
    "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
      "use strict";
      require_es_regexp_exec();
      var call = require_function_call();
      var defineBuiltIn = require_define_built_in();
      var regexpExec = require_regexp_exec();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var SPECIES = wellKnownSymbol("species");
      var RegExpPrototype = RegExp.prototype;
      module.exports = function(KEY, exec, FORCED, SHAM) {
        var SYMBOL = wellKnownSymbol(KEY);
        var DELEGATES_TO_SYMBOL = !fails(function() {
          var O = {};
          O[SYMBOL] = function() {
            return 7;
          };
          return ""[KEY](O) !== 7;
        });
        var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
          var execCalled = false;
          var re = /a/;
          if (KEY === "split") {
            re = {};
            re.constructor = {};
            re.constructor[SPECIES] = function() {
              return re;
            };
            re.flags = "";
            re[SYMBOL] = /./[SYMBOL];
          }
          re.exec = function() {
            execCalled = true;
            return null;
          };
          re[SYMBOL]("");
          return !execCalled;
        });
        if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
          var nativeRegExpMethod = /./[SYMBOL];
          var methods3 = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
            var $exec = regexp.exec;
            if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
              if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
              }
              return { done: true, value: call(nativeMethod, str, regexp, arg2) };
            }
            return { done: false };
          });
          defineBuiltIn(String.prototype, KEY, methods3[0]);
          defineBuiltIn(RegExpPrototype, SYMBOL, methods3[1]);
        }
        if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
      };
    }
  });

  // node_modules/core-js/internals/advance-string-index.js
  var require_advance_string_index = __commonJS({
    "node_modules/core-js/internals/advance-string-index.js"(exports, module) {
      "use strict";
      var charAt = require_string_multibyte().charAt;
      module.exports = function(S, index, unicode) {
        return index + (unicode ? charAt(S, index).length : 1);
      };
    }
  });

  // node_modules/core-js/internals/regexp-exec-abstract.js
  var require_regexp_exec_abstract = __commonJS({
    "node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var classof = require_classof_raw();
      var regexpExec = require_regexp_exec();
      var $TypeError = TypeError;
      module.exports = function(R, S) {
        var exec = R.exec;
        if (isCallable(exec)) {
          var result = call(exec, R, S);
          if (result !== null) anObject(result);
          return result;
        }
        if (classof(R) === "RegExp") return call(regexpExec, R, S);
        throw new $TypeError("RegExp#exec called on incompatible receiver");
      };
    }
  });

  // node_modules/core-js/modules/es.string.match.js
  var require_es_string_match = __commonJS({
    "node_modules/core-js/modules/es.string.match.js"() {
      "use strict";
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var toLength = require_to_length();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var getMethod = require_get_method();
      var advanceStringIndex = require_advance_string_index();
      var getRegExpFlags = require_regexp_get_flags();
      var regExpExec = require_regexp_exec_abstract();
      var stringIndexOf = uncurryThis("".indexOf);
      fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
        return [
          // `String.prototype.match` method
          // https://tc39.es/ecma262/#sec-string.prototype.match
          function match(regexp) {
            var O = requireObjectCoercible(this);
            var matcher = isObject4(regexp) ? getMethod(regexp, MATCH) : void 0;
            return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
          },
          // `RegExp.prototype[@@match]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
          function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeMatch, rx, S);
            if (res.done) return res.value;
            var flags = toString(getRegExpFlags(rx));
            if (stringIndexOf(flags, "g") === -1) return regExpExec(rx, S);
            var fullUnicode = stringIndexOf(flags, "u") !== -1;
            rx.lastIndex = 0;
            var A = [];
            var n = 0;
            var result;
            while ((result = regExpExec(rx, S)) !== null) {
              var matchStr = toString(result[0]);
              A[n] = matchStr;
              if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
              n++;
            }
            return n === 0 ? null : A;
          }
        ];
      });
    }
  });

  // node_modules/core-js/modules/es.string.match-all.js
  var require_es_string_match_all = __commonJS({
    "node_modules/core-js/modules/es.string.match-all.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this_clause();
      var createIteratorConstructor = require_iterator_create_constructor();
      var createIterResultObject = require_create_iter_result_object();
      var requireObjectCoercible = require_require_object_coercible();
      var toLength = require_to_length();
      var toString = require_to_string();
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var classof = require_classof_raw();
      var isRegExp = require_is_regexp();
      var getRegExpFlags = require_regexp_get_flags();
      var getMethod = require_get_method();
      var defineBuiltIn = require_define_built_in();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var speciesConstructor = require_species_constructor();
      var advanceStringIndex = require_advance_string_index();
      var regExpExec = require_regexp_exec_abstract();
      var InternalStateModule = require_internal_state();
      var IS_PURE = require_is_pure();
      var MATCH_ALL = wellKnownSymbol("matchAll");
      var REGEXP_STRING = "RegExp String";
      var REGEXP_STRING_ITERATOR = REGEXP_STRING + " Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      var stringIndexOf = uncurryThis("".indexOf);
      var nativeMatchAll = uncurryThis("".matchAll);
      var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function() {
        nativeMatchAll("a", /./);
      });
      var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
        setInternalState(this, {
          type: REGEXP_STRING_ITERATOR,
          regexp,
          string,
          global: $global,
          unicode: fullUnicode,
          done: false
        });
      }, REGEXP_STRING, function next() {
        var state3 = getInternalState(this);
        if (state3.done) return createIterResultObject(void 0, true);
        var R = state3.regexp;
        var S = state3.string;
        var match = regExpExec(R, S);
        if (match === null) {
          state3.done = true;
          return createIterResultObject(void 0, true);
        }
        if (state3.global) {
          if (toString(match[0]) === "") R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state3.unicode);
          return createIterResultObject(match, false);
        }
        state3.done = true;
        return createIterResultObject(match, false);
      });
      var $matchAll = function(string) {
        var R = anObject(this);
        var S = toString(string);
        var C = speciesConstructor(R, RegExp);
        var flags = toString(getRegExpFlags(R));
        var matcher, $global, fullUnicode;
        matcher = new C(C === RegExp ? R.source : R, flags);
        $global = !!~stringIndexOf(flags, "g");
        fullUnicode = !!~stringIndexOf(flags, "u");
        matcher.lastIndex = toLength(R.lastIndex);
        return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
      };
      $({ target: "String", proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
        matchAll: function matchAll(regexp) {
          var O = requireObjectCoercible(this);
          var flags, S, matcher, rx;
          if (isObject4(regexp)) {
            if (isRegExp(regexp)) {
              flags = toString(requireObjectCoercible(getRegExpFlags(regexp)));
              if (!~stringIndexOf(flags, "g")) throw new $TypeError("`.matchAll` does not allow non-global regexes");
            }
            if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
            matcher = getMethod(regexp, MATCH_ALL);
            if (matcher === void 0 && IS_PURE && classof(regexp) === "RegExp") matcher = $matchAll;
            if (matcher) return call(matcher, regexp, O);
          } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
          S = toString(O);
          rx = new RegExp(regexp, "g");
          return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
        }
      });
      IS_PURE || MATCH_ALL in RegExpPrototype || defineBuiltIn(RegExpPrototype, MATCH_ALL, $matchAll);
    }
  });

  // node_modules/core-js/internals/string-pad-webkit-bug.js
  var require_string_pad_webkit_bug = __commonJS({
    "node_modules/core-js/internals/string-pad-webkit-bug.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
    }
  });

  // node_modules/core-js/modules/es.string.pad-end.js
  var require_es_string_pad_end = __commonJS({
    "node_modules/core-js/modules/es.string.pad-end.js"() {
      "use strict";
      var $ = require_export();
      var $padEnd = require_string_pad().end;
      var WEBKIT_BUG = require_string_pad_webkit_bug();
      $({ target: "String", proto: true, forced: WEBKIT_BUG }, {
        padEnd: function padEnd(maxLength) {
          return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.pad-start.js
  var require_es_string_pad_start = __commonJS({
    "node_modules/core-js/modules/es.string.pad-start.js"() {
      "use strict";
      var $ = require_export();
      var $padStart = require_string_pad().start;
      var WEBKIT_BUG = require_string_pad_webkit_bug();
      $({ target: "String", proto: true, forced: WEBKIT_BUG }, {
        padStart: function padStart(maxLength) {
          return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.raw.js
  var require_es_string_raw = __commonJS({
    "node_modules/core-js/modules/es.string.raw.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIndexedObject = require_to_indexed_object();
      var toObject = require_to_object();
      var toString = require_to_string();
      var lengthOfArrayLike = require_length_of_array_like();
      var push = uncurryThis([].push);
      var join = uncurryThis([].join);
      $({ target: "String", stat: true }, {
        raw: function raw(template) {
          var rawTemplate = toIndexedObject(toObject(template).raw);
          var literalSegments = lengthOfArrayLike(rawTemplate);
          if (!literalSegments) return "";
          var argumentsLength = arguments.length;
          var elements = [];
          var i = 0;
          while (true) {
            push(elements, toString(rawTemplate[i++]));
            if (i === literalSegments) return join(elements, "");
            if (i < argumentsLength) push(elements, toString(arguments[i]));
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.repeat.js
  var require_es_string_repeat = __commonJS({
    "node_modules/core-js/modules/es.string.repeat.js"() {
      "use strict";
      var $ = require_export();
      var repeat = require_string_repeat();
      $({ target: "String", proto: true }, {
        repeat
      });
    }
  });

  // node_modules/core-js/internals/get-substitution.js
  var require_get_substitution = __commonJS({
    "node_modules/core-js/internals/get-substitution.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var floor = Math.floor;
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
      var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
      module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
        var tailPos = position + matched.length;
        var m = captures.length;
        var symbols2 = SUBSTITUTION_SYMBOLS_NO_NAMED;
        if (namedCaptures !== void 0) {
          namedCaptures = toObject(namedCaptures);
          symbols2 = SUBSTITUTION_SYMBOLS;
        }
        return replace(replacement, symbols2, function(match, ch) {
          var capture;
          switch (charAt(ch, 0)) {
            case "$":
              return "$";
            case "&":
              return matched;
            case "`":
              return stringSlice(str, 0, position);
            case "'":
              return stringSlice(str, tailPos);
            case "<":
              capture = namedCaptures[stringSlice(ch, 1, -1)];
              break;
            default:
              var n = +ch;
              if (n === 0) return match;
              if (n > m) {
                var f = floor(n / 10);
                if (f === 0) return match;
                if (f <= m) return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
                return match;
              }
              capture = captures[n - 1];
          }
          return capture === void 0 ? "" : capture;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.replace.js
  var require_es_string_replace = __commonJS({
    "node_modules/core-js/modules/es.string.replace.js"() {
      "use strict";
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var fails = require_fails();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var isObject4 = require_is_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var advanceStringIndex = require_advance_string_index();
      var getMethod = require_get_method();
      var getSubstitution = require_get_substitution();
      var getRegExpFlags = require_regexp_get_flags();
      var regExpExec = require_regexp_exec_abstract();
      var wellKnownSymbol = require_well_known_symbol();
      var REPLACE = wellKnownSymbol("replace");
      var max = Math.max;
      var min = Math.min;
      var concat = uncurryThis([].concat);
      var push = uncurryThis([].push);
      var stringIndexOf = uncurryThis("".indexOf);
      var stringSlice = uncurryThis("".slice);
      var maybeToString = function(it) {
        return it === void 0 ? it : String(it);
      };
      var REPLACE_KEEPS_$0 = (function() {
        return "a".replace(/./, "$0") === "$0";
      })();
      var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
        if (/./[REPLACE]) {
          return /./[REPLACE]("a", "$0") === "";
        }
        return false;
      })();
      var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
        var re = /./;
        re.exec = function() {
          var result = [];
          result.groups = { a: "7" };
          return result;
        };
        return "".replace(re, "$<a>") !== "7";
      });
      fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
        var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
        return [
          // `String.prototype.replace` method
          // https://tc39.es/ecma262/#sec-string.prototype.replace
          function replace(searchValue, replaceValue) {
            var O = requireObjectCoercible(this);
            var replacer = isObject4(searchValue) ? getMethod(searchValue, REPLACE) : void 0;
            return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
          },
          // `RegExp.prototype[@@replace]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
          function(string, replaceValue) {
            var rx = anObject(this);
            var S = toString(string);
            if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
              var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
              if (res.done) return res.value;
            }
            var functionalReplace = isCallable(replaceValue);
            if (!functionalReplace) replaceValue = toString(replaceValue);
            var flags = toString(getRegExpFlags(rx));
            var global2 = stringIndexOf(flags, "g") !== -1;
            var fullUnicode;
            if (global2) {
              fullUnicode = stringIndexOf(flags, "u") !== -1;
              rx.lastIndex = 0;
            }
            var results = [];
            var result;
            while (true) {
              result = regExpExec(rx, S);
              if (result === null) break;
              push(results, result);
              if (!global2) break;
              var matchStr = toString(result[0]);
              if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }
            var accumulatedResult = "";
            var nextSourcePosition = 0;
            for (var i = 0; i < results.length; i++) {
              result = results[i];
              var matched = toString(result[0]);
              var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
              var captures = [];
              var replacement;
              for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
              var namedCaptures = result.groups;
              if (functionalReplace) {
                var replacerArgs = concat([matched], captures, position, S);
                if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
                replacement = toString(apply(replaceValue, void 0, replacerArgs));
              } else {
                replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
              }
              if (position >= nextSourcePosition) {
                accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
                nextSourcePosition = position + matched.length;
              }
            }
            return accumulatedResult + stringSlice(S, nextSourcePosition);
          }
        ];
      }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
    }
  });

  // node_modules/core-js/modules/es.string.replace-all.js
  var require_es_string_replace_all = __commonJS({
    "node_modules/core-js/modules/es.string.replace-all.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var isCallable = require_is_callable();
      var isObject4 = require_is_object();
      var isRegExp = require_is_regexp();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var getRegExpFlags = require_regexp_get_flags();
      var getSubstitution = require_get_substitution();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var REPLACE = wellKnownSymbol("replace");
      var $TypeError = TypeError;
      var indexOf = uncurryThis("".indexOf);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var max = Math.max;
      $({ target: "String", proto: true }, {
        replaceAll: function replaceAll(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
          var endOfLastMatch = 0;
          var result = "";
          if (isObject4(searchValue)) {
            IS_REG_EXP = isRegExp(searchValue);
            if (IS_REG_EXP) {
              flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)));
              if (!~indexOf(flags, "g")) throw new $TypeError("`.replaceAll` does not allow non-global regexes");
            }
            replacer = getMethod(searchValue, REPLACE);
            if (replacer) return call(replacer, searchValue, O, replaceValue);
            if (IS_PURE && IS_REG_EXP) return replace(toString(O), searchValue, replaceValue);
          }
          string = toString(O);
          searchString = toString(searchValue);
          functionalReplace = isCallable(replaceValue);
          if (!functionalReplace) replaceValue = toString(replaceValue);
          searchLength = searchString.length;
          advanceBy = max(1, searchLength);
          position = indexOf(string, searchString);
          while (position !== -1) {
            replacement = functionalReplace ? toString(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], void 0, replaceValue);
            result += stringSlice(string, endOfLastMatch, position) + replacement;
            endOfLastMatch = position + searchLength;
            position = position + advanceBy > string.length ? -1 : indexOf(string, searchString, position + advanceBy);
          }
          if (endOfLastMatch < string.length) {
            result += stringSlice(string, endOfLastMatch);
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.search.js
  var require_es_string_search = __commonJS({
    "node_modules/core-js/modules/es.string.search.js"() {
      "use strict";
      var call = require_function_call();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var requireObjectCoercible = require_require_object_coercible();
      var sameValue = require_same_value();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var regExpExec = require_regexp_exec_abstract();
      fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
        return [
          // `String.prototype.search` method
          // https://tc39.es/ecma262/#sec-string.prototype.search
          function search(regexp) {
            var O = requireObjectCoercible(this);
            var searcher = isObject4(regexp) ? getMethod(regexp, SEARCH) : void 0;
            return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
          },
          // `RegExp.prototype[@@search]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
          function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeSearch, rx, S);
            if (res.done) return res.value;
            var previousLastIndex = rx.lastIndex;
            if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
            var result = regExpExec(rx, S);
            if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
            return result === null ? -1 : result.index;
          }
        ];
      });
    }
  });

  // node_modules/core-js/modules/es.string.split.js
  var require_es_string_split = __commonJS({
    "node_modules/core-js/modules/es.string.split.js"() {
      "use strict";
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var requireObjectCoercible = require_require_object_coercible();
      var speciesConstructor = require_species_constructor();
      var advanceStringIndex = require_advance_string_index();
      var toLength = require_to_length();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var regExpExec = require_regexp_exec_abstract();
      var stickyHelpers = require_regexp_sticky_helpers();
      var fails = require_fails();
      var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
      var MAX_UINT32 = 4294967295;
      var min = Math.min;
      var push = uncurryThis([].push);
      var stringSlice = uncurryThis("".slice);
      var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
        var re = /(?:)/;
        var originalExec = re.exec;
        re.exec = function() {
          return originalExec.apply(this, arguments);
        };
        var result = "ab".split(re);
        return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
      });
      var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
      "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      ".".split(/()()/).length > 1 || "".split(/.?/).length;
      fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
        var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
        } : nativeSplit;
        return [
          // `String.prototype.split` method
          // https://tc39.es/ecma262/#sec-string.prototype.split
          function split(separator, limit) {
            var O = requireObjectCoercible(this);
            var splitter = isObject4(separator) ? getMethod(separator, SPLIT) : void 0;
            return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
          },
          // `RegExp.prototype[@@split]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
          //
          // NOTE: This cannot be properly polyfilled in engines that don't support
          // the 'y' flag.
          function(string, limit) {
            var rx = anObject(this);
            var S = toString(string);
            if (!BUGGY) {
              var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
              if (res.done) return res.value;
            }
            var C = speciesConstructor(rx, RegExp);
            var unicodeMatching = rx.unicode;
            var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
            var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
            var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
            if (lim === 0) return [];
            if (S.length === 0) return regExpExec(splitter, S) === null ? [S] : [];
            var p = 0;
            var q = 0;
            var A = [];
            while (q < S.length) {
              splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
              var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
              var e;
              if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
                q = advanceStringIndex(S, q, unicodeMatching);
              } else {
                push(A, stringSlice(S, p, q));
                if (A.length === lim) return A;
                for (var i = 1; i <= z.length - 1; i++) {
                  push(A, z[i]);
                  if (A.length === lim) return A;
                }
                q = p = e;
              }
            }
            push(A, stringSlice(S, p));
            return A;
          }
        ];
      }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
    }
  });

  // node_modules/core-js/modules/es.string.starts-with.js
  var require_es_string_starts_with = __commonJS({
    "node_modules/core-js/modules/es.string.starts-with.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var toLength = require_to_length();
      var toString = require_to_string();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var IS_PURE = require_is_pure();
      var stringSlice = uncurryThis("".slice);
      var min = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
      var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
        return descriptor && !descriptor.writable;
      })();
      $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        startsWith: function startsWith(searchString) {
          var that = toString(requireObjectCoercible(this));
          notARegExp(searchString);
          var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
          var search = toString(searchString);
          return stringSlice(that, index, index + search.length) === search;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.substr.js
  var require_es_string_substr = __commonJS({
    "node_modules/core-js/modules/es.string.substr.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var stringSlice = uncurryThis("".slice);
      var max = Math.max;
      var min = Math.min;
      var FORCED = !"".substr || "ab".substr(-1) !== "b";
      $({ target: "String", proto: true, forced: FORCED }, {
        substr: function substr(start2, length) {
          var that = toString(requireObjectCoercible(this));
          var size = that.length;
          var intStart = toIntegerOrInfinity(start2);
          var intLength, intEnd;
          if (intStart === Infinity) intStart = 0;
          if (intStart < 0) intStart = max(size + intStart, 0);
          intLength = length === void 0 ? size : toIntegerOrInfinity(length);
          if (intLength <= 0 || intLength === Infinity) return "";
          intEnd = min(intStart + intLength, size);
          return intStart >= intEnd ? "" : stringSlice(that, intStart, intEnd);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.to-well-formed.js
  var require_es_string_to_well_formed = __commonJS({
    "node_modules/core-js/modules/es.string.to-well-formed.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var fails = require_fails();
      var $Array = Array;
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var join = uncurryThis([].join);
      var $toWellFormed = "".toWellFormed;
      var REPLACEMENT_CHARACTER = "\uFFFD";
      var TO_STRING_CONVERSION_BUG = $toWellFormed && fails(function() {
        return call($toWellFormed, 1) !== "1";
      });
      $({ target: "String", proto: true, forced: TO_STRING_CONVERSION_BUG }, {
        toWellFormed: function toWellFormed() {
          var S = toString(requireObjectCoercible(this));
          if (TO_STRING_CONVERSION_BUG) return call($toWellFormed, S);
          var length = S.length;
          var result = $Array(length);
          for (var i = 0; i < length; i++) {
            var charCode = charCodeAt(S, i);
            if ((charCode & 63488) !== 55296) result[i] = charAt(S, i);
            else if (charCode >= 56320 || i + 1 >= length || (charCodeAt(S, i + 1) & 64512) !== 56320) result[i] = REPLACEMENT_CHARACTER;
            else {
              result[i] = charAt(S, i);
              result[++i] = charAt(S, i);
            }
          }
          return join(result, "");
        }
      });
    }
  });

  // node_modules/core-js/internals/string-trim-forced.js
  var require_string_trim_forced = __commonJS({
    "node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
      "use strict";
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var fails = require_fails();
      var whitespaces = require_whitespaces();
      var non = "\u200B\x85\u180E";
      module.exports = function(METHOD_NAME) {
        return fails(function() {
          return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.trim.js
  var require_es_string_trim = __commonJS({
    "node_modules/core-js/modules/es.string.trim.js"() {
      "use strict";
      var $ = require_export();
      var $trim = require_string_trim().trim;
      var forcedStringTrimMethod = require_string_trim_forced();
      $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
        trim: function trim() {
          return $trim(this);
        }
      });
    }
  });

  // node_modules/core-js/internals/string-trim-end.js
  var require_string_trim_end = __commonJS({
    "node_modules/core-js/internals/string-trim-end.js"(exports, module) {
      "use strict";
      var $trimEnd = require_string_trim().end;
      var forcedStringTrimMethod = require_string_trim_forced();
      module.exports = forcedStringTrimMethod("trimEnd") ? function trimEnd() {
        return $trimEnd(this);
      } : "".trimEnd;
    }
  });

  // node_modules/core-js/modules/es.string.trim-right.js
  var require_es_string_trim_right = __commonJS({
    "node_modules/core-js/modules/es.string.trim-right.js"() {
      "use strict";
      var $ = require_export();
      var trimEnd = require_string_trim_end();
      $({ target: "String", proto: true, name: "trimEnd", forced: "".trimRight !== trimEnd }, {
        trimRight: trimEnd
      });
    }
  });

  // node_modules/core-js/modules/es.string.trim-end.js
  var require_es_string_trim_end = __commonJS({
    "node_modules/core-js/modules/es.string.trim-end.js"() {
      "use strict";
      require_es_string_trim_right();
      var $ = require_export();
      var trimEnd = require_string_trim_end();
      $({ target: "String", proto: true, name: "trimEnd", forced: "".trimEnd !== trimEnd }, {
        trimEnd
      });
    }
  });

  // node_modules/core-js/internals/string-trim-start.js
  var require_string_trim_start = __commonJS({
    "node_modules/core-js/internals/string-trim-start.js"(exports, module) {
      "use strict";
      var $trimStart = require_string_trim().start;
      var forcedStringTrimMethod = require_string_trim_forced();
      module.exports = forcedStringTrimMethod("trimStart") ? function trimStart() {
        return $trimStart(this);
      } : "".trimStart;
    }
  });

  // node_modules/core-js/modules/es.string.trim-left.js
  var require_es_string_trim_left = __commonJS({
    "node_modules/core-js/modules/es.string.trim-left.js"() {
      "use strict";
      var $ = require_export();
      var trimStart = require_string_trim_start();
      $({ target: "String", proto: true, name: "trimStart", forced: "".trimLeft !== trimStart }, {
        trimLeft: trimStart
      });
    }
  });

  // node_modules/core-js/modules/es.string.trim-start.js
  var require_es_string_trim_start = __commonJS({
    "node_modules/core-js/modules/es.string.trim-start.js"() {
      "use strict";
      require_es_string_trim_left();
      var $ = require_export();
      var trimStart = require_string_trim_start();
      $({ target: "String", proto: true, name: "trimStart", forced: "".trimStart !== trimStart }, {
        trimStart
      });
    }
  });

  // node_modules/core-js/internals/create-html.js
  var require_create_html = __commonJS({
    "node_modules/core-js/internals/create-html.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var quot = /"/g;
      var replace = uncurryThis("".replace);
      module.exports = function(string, tag, attribute, value) {
        var S = toString(requireObjectCoercible(string));
        var p1 = "<" + tag;
        if (attribute !== "") p1 += " " + attribute + '="' + replace(toString(value), quot, "&quot;") + '"';
        return p1 + ">" + S + "</" + tag + ">";
      };
    }
  });

  // node_modules/core-js/internals/string-html-forced.js
  var require_string_html_forced = __commonJS({
    "node_modules/core-js/internals/string-html-forced.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = function(METHOD_NAME) {
        return fails(function() {
          var test = ""[METHOD_NAME]('"');
          return test !== test.toLowerCase() || test.split('"').length > 3;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.anchor.js
  var require_es_string_anchor = __commonJS({
    "node_modules/core-js/modules/es.string.anchor.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("anchor") }, {
        anchor: function anchor(name) {
          return createHTML(this, "a", "name", name);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.big.js
  var require_es_string_big = __commonJS({
    "node_modules/core-js/modules/es.string.big.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("big") }, {
        big: function big() {
          return createHTML(this, "big", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.blink.js
  var require_es_string_blink = __commonJS({
    "node_modules/core-js/modules/es.string.blink.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("blink") }, {
        blink: function blink() {
          return createHTML(this, "blink", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.bold.js
  var require_es_string_bold = __commonJS({
    "node_modules/core-js/modules/es.string.bold.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("bold") }, {
        bold: function bold() {
          return createHTML(this, "b", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fixed.js
  var require_es_string_fixed = __commonJS({
    "node_modules/core-js/modules/es.string.fixed.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fixed") }, {
        fixed: function fixed() {
          return createHTML(this, "tt", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fontcolor.js
  var require_es_string_fontcolor = __commonJS({
    "node_modules/core-js/modules/es.string.fontcolor.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontcolor") }, {
        fontcolor: function fontcolor(color) {
          return createHTML(this, "font", "color", color);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fontsize.js
  var require_es_string_fontsize = __commonJS({
    "node_modules/core-js/modules/es.string.fontsize.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontsize") }, {
        fontsize: function fontsize(size) {
          return createHTML(this, "font", "size", size);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.italics.js
  var require_es_string_italics = __commonJS({
    "node_modules/core-js/modules/es.string.italics.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("italics") }, {
        italics: function italics() {
          return createHTML(this, "i", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.link.js
  var require_es_string_link = __commonJS({
    "node_modules/core-js/modules/es.string.link.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("link") }, {
        link: function link(url) {
          return createHTML(this, "a", "href", url);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.small.js
  var require_es_string_small = __commonJS({
    "node_modules/core-js/modules/es.string.small.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("small") }, {
        small: function small() {
          return createHTML(this, "small", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.strike.js
  var require_es_string_strike = __commonJS({
    "node_modules/core-js/modules/es.string.strike.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("strike") }, {
        strike: function strike() {
          return createHTML(this, "strike", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.sub.js
  var require_es_string_sub = __commonJS({
    "node_modules/core-js/modules/es.string.sub.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("sub") }, {
        sub: function sub() {
          return createHTML(this, "sub", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.sup.js
  var require_es_string_sup = __commonJS({
    "node_modules/core-js/modules/es.string.sup.js"() {
      "use strict";
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("sup") }, {
        sup: function sup() {
          return createHTML(this, "sup", "", "");
        }
      });
    }
  });

  // node_modules/core-js/internals/typed-array-constructors-require-wrappers.js
  var require_typed_array_constructors_require_wrappers = __commonJS({
    "node_modules/core-js/internals/typed-array-constructors-require-wrappers.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var NATIVE_ARRAY_BUFFER_VIEWS = require_array_buffer_view_core().NATIVE_ARRAY_BUFFER_VIEWS;
      var ArrayBuffer2 = globalThis2.ArrayBuffer;
      var Int8Array2 = globalThis2.Int8Array;
      module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
        Int8Array2(1);
      }) || !fails(function() {
        new Int8Array2(-1);
      }) || !checkCorrectnessOfIteration(function(iterable) {
        new Int8Array2();
        new Int8Array2(null);
        new Int8Array2(1.5);
        new Int8Array2(iterable);
      }, true) || fails(function() {
        return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
      });
    }
  });

  // node_modules/core-js/internals/to-offset.js
  var require_to_offset = __commonJS({
    "node_modules/core-js/internals/to-offset.js"(exports, module) {
      "use strict";
      var toPositiveInteger = require_to_positive_integer();
      var $RangeError = RangeError;
      module.exports = function(it, BYTES) {
        var offset = toPositiveInteger(it);
        if (offset % BYTES) throw new $RangeError("Wrong offset");
        return offset;
      };
    }
  });

  // node_modules/core-js/internals/to-uint8-clamped.js
  var require_to_uint8_clamped = __commonJS({
    "node_modules/core-js/internals/to-uint8-clamped.js"(exports, module) {
      "use strict";
      var round = Math.round;
      module.exports = function(it) {
        var value = round(it);
        return value < 0 ? 0 : value > 255 ? 255 : value & 255;
      };
    }
  });

  // node_modules/core-js/internals/is-big-int-array.js
  var require_is_big_int_array = __commonJS({
    "node_modules/core-js/internals/is-big-int-array.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      module.exports = function(it) {
        var klass = classof(it);
        return klass === "BigInt64Array" || klass === "BigUint64Array";
      };
    }
  });

  // node_modules/core-js/internals/to-big-int.js
  var require_to_big_int = __commonJS({
    "node_modules/core-js/internals/to-big-int.js"(exports, module) {
      "use strict";
      var toPrimitive = require_to_primitive();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        var prim = toPrimitive(argument, "number");
        if (typeof prim == "number") throw new $TypeError("Can't convert number to bigint");
        return BigInt(prim);
      };
    }
  });

  // node_modules/core-js/internals/typed-array-from.js
  var require_typed_array_from = __commonJS({
    "node_modules/core-js/internals/typed-array-from.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var call = require_function_call();
      var aConstructor = require_a_constructor();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var isBigIntArray = require_is_big_int_array();
      var aTypedArrayConstructor = require_array_buffer_view_core().aTypedArrayConstructor;
      var toBigInt = require_to_big_int();
      module.exports = function from(source) {
        var C = aConstructor(this);
        var O = toObject(source);
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var iteratorMethod = getIteratorMethod(O);
        var i, length, result, thisIsBigIntArray, value, step2, iterator, next;
        if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
          iterator = getIterator(O, iteratorMethod);
          next = iterator.next;
          O = [];
          while (!(step2 = call(next, iterator)).done) {
            O.push(step2.value);
          }
        }
        if (mapping && argumentsLength > 2) {
          mapfn = bind2(mapfn, arguments[2]);
        }
        length = lengthOfArrayLike(O);
        result = new (aTypedArrayConstructor(C))(length);
        thisIsBigIntArray = isBigIntArray(result);
        for (i = 0; length > i; i++) {
          value = mapping ? mapfn(O[i], i) : O[i];
          result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
        }
        return result;
      };
    }
  });

  // node_modules/core-js/internals/typed-array-constructor.js
  var require_typed_array_constructor = __commonJS({
    "node_modules/core-js/internals/typed-array-constructor.js"(exports, module) {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var call = require_function_call();
      var DESCRIPTORS = require_descriptors();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var ArrayBufferModule = require_array_buffer();
      var anInstance = require_an_instance();
      var createPropertyDescriptor = require_create_property_descriptor();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var isIntegralNumber = require_is_integral_number();
      var toLength = require_to_length();
      var toIndex = require_to_index();
      var toOffset = require_to_offset();
      var toUint8Clamped = require_to_uint8_clamped();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var classof = require_classof();
      var isObject4 = require_is_object();
      var isSymbol = require_is_symbol();
      var create = require_object_create();
      var isPrototypeOf = require_object_is_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var typedArrayFrom = require_typed_array_from();
      var forEach = require_array_iteration().forEach;
      var setSpecies = require_set_species();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var definePropertyModule = require_object_define_property();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var InternalStateModule = require_internal_state();
      var inheritIfRequired = require_inherit_if_required();
      var getInternalState = InternalStateModule.get;
      var setInternalState = InternalStateModule.set;
      var enforceInternalState = InternalStateModule.enforce;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var RangeError2 = globalThis2.RangeError;
      var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
      var ArrayBufferPrototype = ArrayBuffer2.prototype;
      var DataView2 = ArrayBufferModule.DataView;
      var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
      var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
      var TypedArray = ArrayBufferViewCore.TypedArray;
      var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
      var isTypedArray = ArrayBufferViewCore.isTypedArray;
      var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
      var WRONG_LENGTH = "Wrong length";
      var addGetter = function(it, key) {
        defineBuiltInAccessor(it, key, {
          configurable: true,
          get: function() {
            return getInternalState(this)[key];
          }
        });
      };
      var isArrayBuffer = function(it) {
        var klass;
        return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) === "ArrayBuffer" || klass === "SharedArrayBuffer";
      };
      var isTypedArrayIndex = function(target, key) {
        return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
      };
      var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
        key = toPropertyKey(key);
        return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
      };
      var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
        key = toPropertyKey(key);
        if (isTypedArrayIndex(target, key) && isObject4(descriptor) && hasOwn(descriptor, "value") && !hasOwn(descriptor, "get") && !hasOwn(descriptor, "set") && !descriptor.configurable && (!hasOwn(descriptor, "writable") || descriptor.writable) && (!hasOwn(descriptor, "enumerable") || descriptor.enumerable)) {
          target[key] = descriptor.value;
          return target;
        }
        return nativeDefineProperty(target, key, descriptor);
      };
      if (DESCRIPTORS) {
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
          getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
          definePropertyModule.f = wrappedDefineProperty;
          addGetter(TypedArrayPrototype, "buffer");
          addGetter(TypedArrayPrototype, "byteOffset");
          addGetter(TypedArrayPrototype, "byteLength");
          addGetter(TypedArrayPrototype, "length");
        }
        $({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
          getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
          defineProperty: wrappedDefineProperty
        });
        module.exports = function(TYPE, wrapper, CLAMPED) {
          var BYTES = TYPE.match(/\d+/)[0] / 8;
          var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
          var GETTER = "get" + TYPE;
          var SETTER = "set" + TYPE;
          var NativeTypedArrayConstructor = globalThis2[CONSTRUCTOR_NAME];
          var TypedArrayConstructor = NativeTypedArrayConstructor;
          var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
          var exported = {};
          var getter = function(that, index) {
            var data = getInternalState(that);
            return data.view[GETTER](index * BYTES + data.byteOffset, true);
          };
          var setter = function(that, index, value) {
            var data = getInternalState(that);
            data.view[SETTER](index * BYTES + data.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
          };
          var addElement = function(that, index) {
            nativeDefineProperty(that, index, {
              get: function() {
                return getter(this, index);
              },
              set: function(value) {
                return setter(this, index, value);
              },
              enumerable: true
            });
          };
          if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
              anInstance(that, TypedArrayConstructorPrototype);
              var index = 0;
              var byteOffset = 0;
              var buffer, byteLength, length;
              if (!isObject4(data)) {
                length = toIndex(data);
                byteLength = length * BYTES;
                buffer = new ArrayBuffer2(byteLength);
              } else if (isArrayBuffer(data)) {
                buffer = data;
                byteOffset = toOffset(offset, BYTES);
                var $len = data.byteLength;
                if ($length === void 0) {
                  if ($len % BYTES) throw new RangeError2(WRONG_LENGTH);
                  byteLength = $len - byteOffset;
                  if (byteLength < 0) throw new RangeError2(WRONG_LENGTH);
                } else {
                  byteLength = toLength($length) * BYTES;
                  if (byteLength + byteOffset > $len) throw new RangeError2(WRONG_LENGTH);
                }
                length = byteLength / BYTES;
              } else if (isTypedArray(data)) {
                return arrayFromConstructorAndList(TypedArrayConstructor, data);
              } else {
                return call(typedArrayFrom, TypedArrayConstructor, data);
              }
              setInternalState(that, {
                buffer,
                byteOffset,
                byteLength,
                length,
                view: new DataView2(buffer)
              });
              while (index < length) addElement(that, index++);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
          } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
            TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
              anInstance(dummy, TypedArrayConstructorPrototype);
              return inheritIfRequired((function() {
                if (!isObject4(data)) return new NativeTypedArrayConstructor(toIndex(data));
                if (isArrayBuffer(data)) return $length !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                if (isTypedArray(data)) return arrayFromConstructorAndList(TypedArrayConstructor, data);
                return call(typedArrayFrom, TypedArrayConstructor, data);
              })(), dummy, TypedArrayConstructor);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
              if (!(key in TypedArrayConstructor)) {
                createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
              }
            });
            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
          }
          if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
          }
          enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;
          if (TYPED_ARRAY_TAG) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
          }
          var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;
          exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
          $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);
          if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
          }
          if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
          }
          setSpecies(CONSTRUCTOR_NAME);
        };
      } else module.exports = function() {
      };
    }
  });

  // node_modules/core-js/modules/es.typed-array.float32-array.js
  var require_es_typed_array_float32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.float32-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Float32", function(init2) {
        return function Float32Array2(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.float64-array.js
  var require_es_typed_array_float64_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.float64-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Float64", function(init2) {
        return function Float64Array(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int8-array.js
  var require_es_typed_array_int8_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int8-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int8", function(init2) {
        return function Int8Array2(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int16-array.js
  var require_es_typed_array_int16_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int16-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int16", function(init2) {
        return function Int16Array(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int32-array.js
  var require_es_typed_array_int32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int32-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int32", function(init2) {
        return function Int32Array2(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint8-array.js
  var require_es_typed_array_uint8_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint8-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint8", function(init2) {
        return function Uint8Array2(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js
  var require_es_typed_array_uint8_clamped_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint8", function(init2) {
        return function Uint8ClampedArray2(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      }, true);
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint16-array.js
  var require_es_typed_array_uint16_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint16-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint16", function(init2) {
        return function Uint16Array2(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint32-array.js
  var require_es_typed_array_uint32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint32-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint32", function(init2) {
        return function Uint32Array2(data, byteOffset, length) {
          return init2(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.at.js
  var require_es_typed_array_at = __commonJS({
    "node_modules/core-js/modules/es.typed-array.at.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("at", function at(index) {
        var O = aTypedArray(this);
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : O[k];
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.copy-within.js
  var require_es_typed_array_copy_within = __commonJS({
    "node_modules/core-js/modules/es.typed-array.copy-within.js"() {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $ArrayCopyWithin = require_array_copy_within();
      var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("copyWithin", function copyWithin(target, start2) {
        return u$ArrayCopyWithin(aTypedArray(this), target, start2, arguments.length > 2 ? arguments[2] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.every.js
  var require_es_typed_array_every = __commonJS({
    "node_modules/core-js/modules/es.typed-array.every.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $every = require_array_iteration().every;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("every", function every(callbackfn) {
        return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.fill.js
  var require_es_typed_array_fill = __commonJS({
    "node_modules/core-js/modules/es.typed-array.fill.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $fill = require_array_fill();
      var toBigInt = require_to_big_int();
      var classof = require_classof();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var slice = uncurryThis("".slice);
      var CONVERSION_BUG = fails(function() {
        var count = 0;
        new Int8Array(2).fill({ valueOf: function() {
          return count++;
        } });
        return count !== 1;
      });
      exportTypedArrayMethod("fill", function fill(value) {
        var length = arguments.length;
        aTypedArray(this);
        var actualValue = slice(classof(this), 0, 3) === "Big" ? toBigInt(value) : +value;
        return call($fill, this, actualValue, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
      }, CONVERSION_BUG);
    }
  });

  // node_modules/core-js/internals/typed-array-from-same-type-and-list.js
  var require_typed_array_from_same_type_and_list = __commonJS({
    "node_modules/core-js/internals/typed-array-from-same-type-and-list.js"(exports, module) {
      "use strict";
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var getTypedArrayConstructor = require_array_buffer_view_core().getTypedArrayConstructor;
      module.exports = function(instance, list) {
        return arrayFromConstructorAndList(getTypedArrayConstructor(instance), list);
      };
    }
  });

  // node_modules/core-js/modules/es.typed-array.filter.js
  var require_es_typed_array_filter = __commonJS({
    "node_modules/core-js/modules/es.typed-array.filter.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $filter = require_array_iteration().filter;
      var fromSameTypeAndList = require_typed_array_from_same_type_and_list();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("filter", function filter(callbackfn) {
        var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return fromSameTypeAndList(this, list);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find.js
  var require_es_typed_array_find = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $find = require_array_iteration().find;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("find", function find(predicate) {
        return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-index.js
  var require_es_typed_array_find_index = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-index.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findIndex = require_array_iteration().findIndex;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findIndex", function findIndex(predicate) {
        return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-last.js
  var require_es_typed_array_find_last = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-last.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findLast = require_array_iteration_from_last().findLast;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findLast", function findLast(predicate) {
        return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-last-index.js
  var require_es_typed_array_find_last_index = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-last-index.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findLastIndex = require_array_iteration_from_last().findLastIndex;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findLastIndex", function findLastIndex(predicate) {
        return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.for-each.js
  var require_es_typed_array_for_each = __commonJS({
    "node_modules/core-js/modules/es.typed-array.for-each.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $forEach = require_array_iteration().forEach;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("forEach", function forEach(callbackfn) {
        $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.from.js
  var require_es_typed_array_from = __commonJS({
    "node_modules/core-js/modules/es.typed-array.from.js"() {
      "use strict";
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var exportTypedArrayStaticMethod = require_array_buffer_view_core().exportTypedArrayStaticMethod;
      var typedArrayFrom = require_typed_array_from();
      exportTypedArrayStaticMethod("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.includes.js
  var require_es_typed_array_includes = __commonJS({
    "node_modules/core-js/modules/es.typed-array.includes.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $includes = require_array_includes().includes;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("includes", function includes(searchElement) {
        return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.index-of.js
  var require_es_typed_array_index_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.index-of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $indexOf = require_array_includes().indexOf;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
        return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.iterator.js
  var require_es_typed_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.typed-array.iterator.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var ArrayIterators = require_es_array_iterator();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var Uint8Array2 = globalThis2.Uint8Array;
      var arrayValues = uncurryThis(ArrayIterators.values);
      var arrayKeys = uncurryThis(ArrayIterators.keys);
      var arrayEntries = uncurryThis(ArrayIterators.entries);
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var TypedArrayPrototype = Uint8Array2 && Uint8Array2.prototype;
      var GENERIC = !fails(function() {
        TypedArrayPrototype[ITERATOR].call([1]);
      });
      var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
      var typedArrayValues = function values() {
        return arrayValues(aTypedArray(this));
      };
      exportTypedArrayMethod("entries", function entries() {
        return arrayEntries(aTypedArray(this));
      }, GENERIC);
      exportTypedArrayMethod("keys", function keys() {
        return arrayKeys(aTypedArray(this));
      }, GENERIC);
      exportTypedArrayMethod("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
      exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
    }
  });

  // node_modules/core-js/modules/es.typed-array.join.js
  var require_es_typed_array_join = __commonJS({
    "node_modules/core-js/modules/es.typed-array.join.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var uncurryThis = require_function_uncurry_this();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var $join = uncurryThis([].join);
      exportTypedArrayMethod("join", function join(separator) {
        return $join(aTypedArray(this), separator);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.last-index-of.js
  var require_es_typed_array_last_index_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.last-index-of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var apply = require_function_apply();
      var $lastIndexOf = require_array_last_index_of();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
        var length = arguments.length;
        return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.map.js
  var require_es_typed_array_map = __commonJS({
    "node_modules/core-js/modules/es.typed-array.map.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $map = require_array_iteration().map;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("map", function map(mapfn) {
        return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
          return new (getTypedArrayConstructor(O))(length);
        });
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.of.js
  var require_es_typed_array_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
      var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
      exportTypedArrayStaticMethod("of", function of() {
        var index = 0;
        var length = arguments.length;
        var result = new (aTypedArrayConstructor(this))(length);
        while (length > index) result[index] = arguments[index++];
        return result;
      }, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.reduce.js
  var require_es_typed_array_reduce = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reduce.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $reduce = require_array_reduce().left;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("reduce", function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.reduce-right.js
  var require_es_typed_array_reduce_right = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reduce-right.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $reduceRight = require_array_reduce().right;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
        var length = arguments.length;
        return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.reverse.js
  var require_es_typed_array_reverse = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reverse.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var floor = Math.floor;
      exportTypedArrayMethod("reverse", function reverse() {
        var that = this;
        var length = aTypedArray(that).length;
        var middle = floor(length / 2);
        var index = 0;
        var value;
        while (index < middle) {
          value = that[index];
          that[index++] = that[--length];
          that[length] = value;
        }
        return that;
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.set.js
  var require_es_typed_array_set = __commonJS({
    "node_modules/core-js/modules/es.typed-array.set.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var call = require_function_call();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var lengthOfArrayLike = require_length_of_array_like();
      var toOffset = require_to_offset();
      var toIndexedObject = require_to_object();
      var fails = require_fails();
      var RangeError2 = globalThis2.RangeError;
      var Int8Array2 = globalThis2.Int8Array;
      var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
      var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function() {
        var array = new Uint8ClampedArray(2);
        call($set, array, { length: 1, 0: 3 }, 1);
        return array[1] !== 3;
      });
      var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
        var array = new Int8Array2(2);
        array.set(1);
        array.set("2", 1);
        return array[0] !== 0 || array[1] !== 2;
      });
      exportTypedArrayMethod("set", function set(arrayLike) {
        aTypedArray(this);
        var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
        var src = toIndexedObject(arrayLike);
        if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
        var length = this.length;
        var len = lengthOfArrayLike(src);
        var index = 0;
        if (len + offset > length) throw new RangeError2("Wrong length");
        while (index < len) this[offset + index] = src[index++];
      }, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
    }
  });

  // node_modules/core-js/modules/es.typed-array.slice.js
  var require_es_typed_array_slice = __commonJS({
    "node_modules/core-js/modules/es.typed-array.slice.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var fails = require_fails();
      var arraySlice = require_array_slice();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var FORCED = fails(function() {
        new Int8Array(1).slice();
      });
      exportTypedArrayMethod("slice", function slice(start2, end) {
        var list = arraySlice(aTypedArray(this), start2, end);
        var C = getTypedArrayConstructor(this);
        var index = 0;
        var length = list.length;
        var result = new C(length);
        while (length > index) result[index] = list[index++];
        return result;
      }, FORCED);
    }
  });

  // node_modules/core-js/modules/es.typed-array.some.js
  var require_es_typed_array_some = __commonJS({
    "node_modules/core-js/modules/es.typed-array.some.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $some = require_array_iteration().some;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("some", function some(callbackfn) {
        return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.sort.js
  var require_es_typed_array_sort = __commonJS({
    "node_modules/core-js/modules/es.typed-array.sort.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this_clause();
      var fails = require_fails();
      var aCallable = require_a_callable();
      var internalSort = require_array_sort();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var FF = require_environment_ff_version();
      var IE_OR_EDGE = require_environment_is_ie_or_edge();
      var V8 = require_environment_v8_version();
      var WEBKIT = require_environment_webkit_version();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var Uint16Array2 = globalThis2.Uint16Array;
      var nativeSort = Uint16Array2 && uncurryThis(Uint16Array2.prototype.sort);
      var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function() {
        nativeSort(new Uint16Array2(2), null);
      }) && fails(function() {
        nativeSort(new Uint16Array2(2), {});
      }));
      var STABLE_SORT = !!nativeSort && !fails(function() {
        if (V8) return V8 < 74;
        if (FF) return FF < 67;
        if (IE_OR_EDGE) return true;
        if (WEBKIT) return WEBKIT < 602;
        var array = new Uint16Array2(516);
        var expected = Array(516);
        var index, mod;
        for (index = 0; index < 516; index++) {
          mod = index % 4;
          array[index] = 515 - index;
          expected[index] = index - 2 * mod + 3;
        }
        nativeSort(array, function(a, b) {
          return (a / 4 | 0) - (b / 4 | 0);
        });
        for (index = 0; index < 516; index++) {
          if (array[index] !== expected[index]) return true;
        }
      });
      var getSortCompare = function(comparefn) {
        return function(x, y) {
          if (comparefn !== void 0) return +comparefn(x, y) || 0;
          if (y !== y) return -1;
          if (x !== x) return 1;
          if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
          return x > y;
        };
      };
      exportTypedArrayMethod("sort", function sort(comparefn) {
        if (comparefn !== void 0) aCallable(comparefn);
        if (STABLE_SORT) return nativeSort(this, comparefn);
        return internalSort(aTypedArray(this), getSortCompare(comparefn));
      }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.subarray.js
  var require_es_typed_array_subarray = __commonJS({
    "node_modules/core-js/modules/es.typed-array.subarray.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var toLength = require_to_length();
      var toAbsoluteIndex = require_to_absolute_index();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("subarray", function subarray(begin, end) {
        var O = aTypedArray(this);
        var length = O.length;
        var beginIndex = toAbsoluteIndex(begin, length);
        var C = getTypedArrayConstructor(O);
        return new C(
          O.buffer,
          O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
          toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - beginIndex)
        );
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-locale-string.js
  var require_es_typed_array_to_locale_string = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-locale-string.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var fails = require_fails();
      var arraySlice = require_array_slice();
      var Int8Array2 = globalThis2.Int8Array;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var $toLocaleString = [].toLocaleString;
      var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
        $toLocaleString.call(new Int8Array2(1));
      });
      var FORCED = fails(function() {
        return [1, 2].toLocaleString() !== new Int8Array2([1, 2]).toLocaleString();
      }) || !fails(function() {
        Int8Array2.prototype.toLocaleString.call([1, 2]);
      });
      exportTypedArrayMethod("toLocaleString", function toLocaleString() {
        return apply(
          $toLocaleString,
          TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
          arraySlice(arguments)
        );
      }, FORCED);
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-reversed.js
  var require_es_typed_array_to_reversed = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-reversed.js"() {
      "use strict";
      var arrayToReversed = require_array_to_reversed();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      exportTypedArrayMethod("toReversed", function toReversed() {
        return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-sorted.js
  var require_es_typed_array_to_sorted = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-sorted.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);
      exportTypedArrayMethod("toSorted", function toSorted(compareFn) {
        if (compareFn !== void 0) aCallable(compareFn);
        var O = aTypedArray(this);
        var A = arrayFromConstructorAndList(getTypedArrayConstructor(O), O);
        return sort(A, compareFn);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-string.js
  var require_es_typed_array_to_string = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-string.js"() {
      "use strict";
      var exportTypedArrayMethod = require_array_buffer_view_core().exportTypedArrayMethod;
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var Uint8Array2 = globalThis2.Uint8Array;
      var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
      var arrayToString = [].toString;
      var join = uncurryThis([].join);
      if (fails(function() {
        arrayToString.call({});
      })) {
        arrayToString = function toString() {
          return join(this);
        };
      }
      var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;
      exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
    }
  });

  // node_modules/core-js/modules/es.typed-array.with.js
  var require_es_typed_array_with = __commonJS({
    "node_modules/core-js/modules/es.typed-array.with.js"() {
      "use strict";
      var arrayWith = require_array_with();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var isBigIntArray = require_is_big_int_array();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toBigInt = require_to_big_int();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var PROPER_ORDER = (function() {
        try {
          new Int8Array(1)["with"](2, { valueOf: function() {
            throw 8;
          } });
        } catch (error) {
          return error === 8;
        }
      })();
      var THROW_ON_NEGATIVE_FRACTIONAL_INDEX = PROPER_ORDER && (function() {
        try {
          new Int8Array(1)["with"](-0.5, 1);
        } catch (error) {
          return true;
        }
      })();
      exportTypedArrayMethod("with", { "with": function(index, value) {
        var O = aTypedArray(this);
        var relativeIndex = toIntegerOrInfinity(index);
        var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;
        return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);
      } }["with"], !PROPER_ORDER || THROW_ON_NEGATIVE_FRACTIONAL_INDEX);
    }
  });

  // node_modules/core-js/internals/an-object-or-undefined.js
  var require_an_object_or_undefined = __commonJS({
    "node_modules/core-js/internals/an-object-or-undefined.js"(exports, module) {
      "use strict";
      var isObject4 = require_is_object();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (argument === void 0 || isObject4(argument)) return argument;
        throw new $TypeError($String(argument) + " is not an object or undefined");
      };
    }
  });

  // node_modules/core-js/internals/base64-map.js
  var require_base64_map = __commonJS({
    "node_modules/core-js/internals/base64-map.js"(exports, module) {
      "use strict";
      var commonAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      var base64Alphabet = commonAlphabet + "+/";
      var base64UrlAlphabet = commonAlphabet + "-_";
      var inverse = function(characters) {
        var result = {};
        var index = 0;
        for (; index < 64; index++) result[characters.charAt(index)] = index;
        return result;
      };
      module.exports = {
        i2c: base64Alphabet,
        c2i: inverse(base64Alphabet),
        i2cUrl: base64UrlAlphabet,
        c2iUrl: inverse(base64UrlAlphabet)
      };
    }
  });

  // node_modules/core-js/internals/get-alphabet-option.js
  var require_get_alphabet_option = __commonJS({
    "node_modules/core-js/internals/get-alphabet-option.js"(exports, module) {
      "use strict";
      var $TypeError = TypeError;
      module.exports = function(options) {
        var alphabet = options && options.alphabet;
        if (alphabet === void 0 || alphabet === "base64" || alphabet === "base64url") return alphabet || "base64";
        throw new $TypeError("Incorrect `alphabet` option");
      };
    }
  });

  // node_modules/core-js/internals/uint8-from-base64.js
  var require_uint8_from_base64 = __commonJS({
    "node_modules/core-js/internals/uint8-from-base64.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var anObjectOrUndefined = require_an_object_or_undefined();
      var aString = require_a_string();
      var hasOwn = require_has_own_property();
      var base64Map = require_base64_map();
      var getAlphabetOption = require_get_alphabet_option();
      var notDetached = require_array_buffer_not_detached();
      var base64Alphabet = base64Map.c2i;
      var base64UrlAlphabet = base64Map.c2iUrl;
      var SyntaxError = globalThis2.SyntaxError;
      var TypeError2 = globalThis2.TypeError;
      var at = uncurryThis("".charAt);
      var skipAsciiWhitespace = function(string, index) {
        var length = string.length;
        for (; index < length; index++) {
          var chr = at(string, index);
          if (chr !== " " && chr !== "	" && chr !== "\n" && chr !== "\f" && chr !== "\r") break;
        }
        return index;
      };
      var decodeBase64Chunk = function(chunk, alphabet, throwOnExtraBits) {
        var chunkLength = chunk.length;
        if (chunkLength < 4) {
          chunk += chunkLength === 2 ? "AA" : "A";
        }
        var triplet = (alphabet[at(chunk, 0)] << 18) + (alphabet[at(chunk, 1)] << 12) + (alphabet[at(chunk, 2)] << 6) + alphabet[at(chunk, 3)];
        var chunkBytes = [
          triplet >> 16 & 255,
          triplet >> 8 & 255,
          triplet & 255
        ];
        if (chunkLength === 2) {
          if (throwOnExtraBits && chunkBytes[1] !== 0) {
            throw new SyntaxError("Extra bits");
          }
          return [chunkBytes[0]];
        }
        if (chunkLength === 3) {
          if (throwOnExtraBits && chunkBytes[2] !== 0) {
            throw new SyntaxError("Extra bits");
          }
          return [chunkBytes[0], chunkBytes[1]];
        }
        return chunkBytes;
      };
      var writeBytes = function(bytes, elements, written) {
        var elementsLength = elements.length;
        for (var index = 0; index < elementsLength; index++) {
          bytes[written + index] = elements[index];
        }
        return written + elementsLength;
      };
      module.exports = function(string, options, into, maxLength) {
        aString(string);
        anObjectOrUndefined(options);
        var alphabet = getAlphabetOption(options) === "base64" ? base64Alphabet : base64UrlAlphabet;
        var lastChunkHandling = options ? options.lastChunkHandling : void 0;
        if (lastChunkHandling === void 0) lastChunkHandling = "loose";
        if (lastChunkHandling !== "loose" && lastChunkHandling !== "strict" && lastChunkHandling !== "stop-before-partial") {
          throw new TypeError2("Incorrect `lastChunkHandling` option");
        }
        if (into) notDetached(into.buffer);
        var stringLength = string.length;
        var bytes = into || [];
        var written = 0;
        var read = 0;
        var chunk = "";
        var index = 0;
        if (maxLength) while (true) {
          index = skipAsciiWhitespace(string, index);
          if (index === stringLength) {
            if (chunk.length > 0) {
              if (lastChunkHandling === "stop-before-partial") {
                break;
              }
              if (lastChunkHandling === "loose") {
                if (chunk.length === 1) {
                  throw new SyntaxError("Malformed padding: exactly one additional character");
                }
                written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
              } else {
                throw new SyntaxError("Missing padding");
              }
            }
            read = stringLength;
            break;
          }
          var chr = at(string, index);
          ++index;
          if (chr === "=") {
            if (chunk.length < 2) {
              throw new SyntaxError("Padding is too early");
            }
            index = skipAsciiWhitespace(string, index);
            if (chunk.length === 2) {
              if (index === stringLength) {
                if (lastChunkHandling === "stop-before-partial") {
                  break;
                }
                throw new SyntaxError("Malformed padding: only one =");
              }
              if (at(string, index) === "=") {
                ++index;
                index = skipAsciiWhitespace(string, index);
              }
            }
            if (index < stringLength) {
              throw new SyntaxError("Unexpected character after padding");
            }
            written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, lastChunkHandling === "strict"), written);
            read = stringLength;
            break;
          }
          if (!hasOwn(alphabet, chr)) {
            throw new SyntaxError("Unexpected character");
          }
          var remainingBytes = maxLength - written;
          if (remainingBytes === 1 && chunk.length === 2 || remainingBytes === 2 && chunk.length === 3) {
            break;
          }
          chunk += chr;
          if (chunk.length === 4) {
            written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
            chunk = "";
            read = index;
            if (written === maxLength) {
              break;
            }
          }
        }
        return { bytes, read, written };
      };
    }
  });

  // node_modules/core-js/modules/es.uint8-array.from-base64.js
  var require_es_uint8_array_from_base64 = __commonJS({
    "node_modules/core-js/modules/es.uint8-array.from-base64.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var $fromBase64 = require_uint8_from_base64();
      var Uint8Array2 = globalThis2.Uint8Array;
      var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.fromBase64 || !(function() {
        try {
          Uint8Array2.fromBase64("a");
          return;
        } catch (error) {
        }
        try {
          Uint8Array2.fromBase64("", null);
        } catch (error) {
          return true;
        }
      })();
      if (Uint8Array2) $({ target: "Uint8Array", stat: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
        fromBase64: function fromBase64(string) {
          var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, null, 9007199254740991);
          return arrayFromConstructorAndList(Uint8Array2, result.bytes);
        }
      });
    }
  });

  // node_modules/core-js/internals/uint8-from-hex.js
  var require_uint8_from_hex = __commonJS({
    "node_modules/core-js/internals/uint8-from-hex.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var Uint8Array2 = globalThis2.Uint8Array;
      var SyntaxError = globalThis2.SyntaxError;
      var parseInt2 = globalThis2.parseInt;
      var min = Math.min;
      var NOT_HEX = /[^\da-f]/i;
      var exec = uncurryThis(NOT_HEX.exec);
      var stringSlice = uncurryThis("".slice);
      module.exports = function(string, into) {
        var stringLength = string.length;
        if (stringLength % 2 !== 0) throw new SyntaxError("String should be an even number of characters");
        var maxLength = into ? min(into.length, stringLength / 2) : stringLength / 2;
        var bytes = into || new Uint8Array2(maxLength);
        var read = 0;
        var written = 0;
        while (written < maxLength) {
          var hexits = stringSlice(string, read, read += 2);
          if (exec(NOT_HEX, hexits)) throw new SyntaxError("String should only contain hex characters");
          bytes[written++] = parseInt2(hexits, 16);
        }
        return { bytes, read };
      };
    }
  });

  // node_modules/core-js/modules/es.uint8-array.from-hex.js
  var require_es_uint8_array_from_hex = __commonJS({
    "node_modules/core-js/modules/es.uint8-array.from-hex.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var aString = require_a_string();
      var $fromHex = require_uint8_from_hex();
      if (globalThis2.Uint8Array) $({ target: "Uint8Array", stat: true }, {
        fromHex: function fromHex(string) {
          return $fromHex(aString(string)).bytes;
        }
      });
    }
  });

  // node_modules/core-js/internals/an-uint8-array.js
  var require_an_uint8_array = __commonJS({
    "node_modules/core-js/internals/an-uint8-array.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (classof(argument) === "Uint8Array") return argument;
        throw new $TypeError("Argument is not an Uint8Array");
      };
    }
  });

  // node_modules/core-js/modules/es.uint8-array.set-from-base64.js
  var require_es_uint8_array_set_from_base64 = __commonJS({
    "node_modules/core-js/modules/es.uint8-array.set-from-base64.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var $fromBase64 = require_uint8_from_base64();
      var anUint8Array = require_an_uint8_array();
      var Uint8Array2 = globalThis2.Uint8Array;
      var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.setFromBase64 || !(function() {
        var target = new Uint8Array2([255, 255, 255, 255, 255]);
        try {
          target.setFromBase64("", null);
          return;
        } catch (error) {
        }
        try {
          target.setFromBase64("a");
          return;
        } catch (error) {
        }
        try {
          target.setFromBase64("MjYyZg===");
        } catch (error) {
          return target[0] === 50 && target[1] === 54 && target[2] === 50 && target[3] === 255 && target[4] === 255;
        }
      })();
      if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
        setFromBase64: function setFromBase64(string) {
          anUint8Array(this);
          var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, this, this.length);
          return { read: result.read, written: result.written };
        }
      });
    }
  });

  // node_modules/core-js/modules/es.uint8-array.set-from-hex.js
  var require_es_uint8_array_set_from_hex = __commonJS({
    "node_modules/core-js/modules/es.uint8-array.set-from-hex.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var aString = require_a_string();
      var anUint8Array = require_an_uint8_array();
      var notDetached = require_array_buffer_not_detached();
      var $fromHex = require_uint8_from_hex();
      if (globalThis2.Uint8Array) $({ target: "Uint8Array", proto: true }, {
        setFromHex: function setFromHex(string) {
          anUint8Array(this);
          aString(string);
          notDetached(this.buffer);
          var read = $fromHex(string, this).read;
          return { read, written: read / 2 };
        }
      });
    }
  });

  // node_modules/core-js/modules/es.uint8-array.to-base64.js
  var require_es_uint8_array_to_base64 = __commonJS({
    "node_modules/core-js/modules/es.uint8-array.to-base64.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var anObjectOrUndefined = require_an_object_or_undefined();
      var anUint8Array = require_an_uint8_array();
      var notDetached = require_array_buffer_not_detached();
      var base64Map = require_base64_map();
      var getAlphabetOption = require_get_alphabet_option();
      var base64Alphabet = base64Map.i2c;
      var base64UrlAlphabet = base64Map.i2cUrl;
      var charAt = uncurryThis("".charAt);
      var Uint8Array2 = globalThis2.Uint8Array;
      var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.toBase64 || !(function() {
        try {
          var target = new Uint8Array2();
          target.toBase64(null);
        } catch (error) {
          return true;
        }
      })();
      if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
        toBase64: function toBase64() {
          var array = anUint8Array(this);
          var options = arguments.length ? anObjectOrUndefined(arguments[0]) : void 0;
          var alphabet = getAlphabetOption(options) === "base64" ? base64Alphabet : base64UrlAlphabet;
          var omitPadding = !!options && !!options.omitPadding;
          notDetached(this.buffer);
          var result = "";
          var i = 0;
          var length = array.length;
          var triplet;
          var at = function(shift) {
            return charAt(alphabet, triplet >> 6 * shift & 63);
          };
          for (; i + 2 < length; i += 3) {
            triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];
            result += at(3) + at(2) + at(1) + at(0);
          }
          if (i + 2 === length) {
            triplet = (array[i] << 16) + (array[i + 1] << 8);
            result += at(3) + at(2) + at(1) + (omitPadding ? "" : "=");
          } else if (i + 1 === length) {
            triplet = array[i] << 16;
            result += at(3) + at(2) + (omitPadding ? "" : "==");
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.uint8-array.to-hex.js
  var require_es_uint8_array_to_hex = __commonJS({
    "node_modules/core-js/modules/es.uint8-array.to-hex.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var anUint8Array = require_an_uint8_array();
      var notDetached = require_array_buffer_not_detached();
      var numberToString = uncurryThis(1.1.toString);
      var Uint8Array2 = globalThis2.Uint8Array;
      var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.toHex || !(function() {
        try {
          var target = new Uint8Array2([255, 255, 255, 255, 255, 255, 255, 255]);
          return target.toHex() === "ffffffffffffffff";
        } catch (error) {
          return false;
        }
      })();
      if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
        toHex: function toHex() {
          anUint8Array(this);
          notDetached(this.buffer);
          var result = "";
          for (var i = 0, length = this.length; i < length; i++) {
            var hex = numberToString(this[i], 16);
            result += hex.length === 1 ? "0" + hex : hex;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.unescape.js
  var require_es_unescape = __commonJS({
    "node_modules/core-js/modules/es.unescape.js"() {
      "use strict";
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var fromCharCode = String.fromCharCode;
      var charAt = uncurryThis("".charAt);
      var exec = uncurryThis(/./.exec);
      var stringSlice = uncurryThis("".slice);
      var hex2 = /^[\da-f]{2}$/i;
      var hex4 = /^[\da-f]{4}$/i;
      $({ global: true }, {
        unescape: function unescape(string) {
          var str = toString(string);
          var result = "";
          var length = str.length;
          var index = 0;
          var chr, part;
          while (index < length) {
            chr = charAt(str, index++);
            if (chr === "%") {
              if (charAt(str, index) === "u") {
                part = stringSlice(str, index + 1, index + 5);
                if (exec(hex4, part)) {
                  result += fromCharCode(parseInt(part, 16));
                  index += 5;
                  continue;
                }
              } else {
                part = stringSlice(str, index, index + 2);
                if (exec(hex2, part)) {
                  result += fromCharCode(parseInt(part, 16));
                  index += 2;
                  continue;
                }
              }
            }
            result += chr;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/collection-weak.js
  var require_collection_weak = __commonJS({
    "node_modules/core-js/internals/collection-weak.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIns = require_define_built_ins();
      var getWeakData = require_internal_metadata().getWeakData;
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var isNullOrUndefined = require_is_null_or_undefined();
      var isObject4 = require_is_object();
      var iterate = require_iterate();
      var ArrayIterationModule = require_array_iteration();
      var hasOwn = require_has_own_property();
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var internalStateGetterFor = InternalStateModule.getterFor;
      var find = ArrayIterationModule.find;
      var findIndex = ArrayIterationModule.findIndex;
      var splice = uncurryThis([].splice);
      var id = 0;
      var uncaughtFrozenStore = function(state3) {
        return state3.frozen || (state3.frozen = new UncaughtFrozenStore());
      };
      var UncaughtFrozenStore = function() {
        this.entries = [];
      };
      var findUncaughtFrozen = function(store, key) {
        return find(store.entries, function(it) {
          return it[0] === key;
        });
      };
      UncaughtFrozenStore.prototype = {
        get: function(key) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) return entry[1];
        },
        has: function(key) {
          return !!findUncaughtFrozen(this, key);
        },
        set: function(key, value) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) entry[1] = value;
          else this.entries.push([key, value]);
        },
        "delete": function(key) {
          var index = findIndex(this.entries, function(it) {
            return it[0] === key;
          });
          if (~index) splice(this.entries, index, 1);
          return !!~index;
        }
      };
      module.exports = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              id: id++,
              frozen: null
            });
            if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define = function(that, key, value) {
            var state3 = getInternalState(that);
            var data = getWeakData(anObject(key), true);
            if (data === true) uncaughtFrozenStore(state3).set(key, value);
            else data[state3.id] = value;
            return that;
          };
          defineBuiltIns(Prototype, {
            // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
            // https://tc39.es/ecma262/#sec-weakset.prototype.delete
            "delete": function(key) {
              var state3 = getInternalState(this);
              if (!isObject4(key)) return false;
              var data = getWeakData(key);
              if (data === true) return uncaughtFrozenStore(state3)["delete"](key);
              return data && hasOwn(data, state3.id) && delete data[state3.id];
            },
            // `{ WeakMap, WeakSet }.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.has
            // https://tc39.es/ecma262/#sec-weakset.prototype.has
            has: function has(key) {
              var state3 = getInternalState(this);
              if (!isObject4(key)) return false;
              var data = getWeakData(key);
              if (data === true) return uncaughtFrozenStore(state3).has(key);
              return data && hasOwn(data, state3.id);
            }
          });
          defineBuiltIns(Prototype, IS_MAP ? {
            // `WeakMap.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.get
            get: function get(key) {
              var state3 = getInternalState(this);
              if (isObject4(key)) {
                var data = getWeakData(key);
                if (data === true) return uncaughtFrozenStore(state3).get(key);
                if (data) return data[state3.id];
              }
            },
            // `WeakMap.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.set
            set: function set(key, value) {
              return define(this, key, value);
            }
          } : {
            // `WeakSet.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-weakset.prototype.add
            add: function add(value) {
              return define(this, value, true);
            }
          });
          return Constructor;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.weak-map.constructor.js
  var require_es_weak_map_constructor = __commonJS({
    "node_modules/core-js/modules/es.weak-map.constructor.js"() {
      "use strict";
      var FREEZING = require_freezing();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIns = require_define_built_ins();
      var InternalMetadataModule = require_internal_metadata();
      var collection = require_collection();
      var collectionWeak = require_collection_weak();
      var isObject4 = require_is_object();
      var enforceInternalState = require_internal_state().enforce;
      var fails = require_fails();
      var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
      var $Object = Object;
      var isArray2 = Array.isArray;
      var isExtensible = $Object.isExtensible;
      var isFrozen = $Object.isFrozen;
      var isSealed = $Object.isSealed;
      var freeze = $Object.freeze;
      var seal = $Object.seal;
      var IS_IE11 = !globalThis2.ActiveXObject && "ActiveXObject" in globalThis2;
      var InternalWeakMap;
      var wrapper = function(init2) {
        return function WeakMap2() {
          return init2(this, arguments.length ? arguments[0] : void 0);
        };
      };
      var $WeakMap = collection("WeakMap", wrapper, collectionWeak);
      var WeakMapPrototype = $WeakMap.prototype;
      var nativeSet = uncurryThis(WeakMapPrototype.set);
      var hasMSEdgeFreezingBug = function() {
        return FREEZING && fails(function() {
          var frozenArray = freeze([]);
          nativeSet(new $WeakMap(), frozenArray, 1);
          return !isFrozen(frozenArray);
        });
      };
      if (NATIVE_WEAK_MAP) {
        if (IS_IE11) {
          InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
          InternalMetadataModule.enable();
          nativeDelete = uncurryThis(WeakMapPrototype["delete"]);
          nativeHas = uncurryThis(WeakMapPrototype.has);
          nativeGet = uncurryThis(WeakMapPrototype.get);
          defineBuiltIns(WeakMapPrototype, {
            "delete": function(key) {
              if (isObject4(key) && !isExtensible(key)) {
                var state3 = enforceInternalState(this);
                if (!state3.frozen) state3.frozen = new InternalWeakMap();
                return nativeDelete(this, key) || state3.frozen["delete"](key);
              }
              return nativeDelete(this, key);
            },
            has: function has(key) {
              if (isObject4(key) && !isExtensible(key)) {
                var state3 = enforceInternalState(this);
                if (!state3.frozen) state3.frozen = new InternalWeakMap();
                return nativeHas(this, key) || state3.frozen.has(key);
              }
              return nativeHas(this, key);
            },
            get: function get(key) {
              if (isObject4(key) && !isExtensible(key)) {
                var state3 = enforceInternalState(this);
                if (!state3.frozen) state3.frozen = new InternalWeakMap();
                return nativeHas(this, key) ? nativeGet(this, key) : state3.frozen.get(key);
              }
              return nativeGet(this, key);
            },
            set: function set(key, value) {
              if (isObject4(key) && !isExtensible(key)) {
                var state3 = enforceInternalState(this);
                if (!state3.frozen) state3.frozen = new InternalWeakMap();
                nativeHas(this, key) ? nativeSet(this, key, value) : state3.frozen.set(key, value);
              } else nativeSet(this, key, value);
              return this;
            }
          });
        } else if (hasMSEdgeFreezingBug()) {
          defineBuiltIns(WeakMapPrototype, {
            set: function set(key, value) {
              var arrayIntegrityLevel;
              if (isArray2(key)) {
                if (isFrozen(key)) arrayIntegrityLevel = freeze;
                else if (isSealed(key)) arrayIntegrityLevel = seal;
              }
              nativeSet(this, key, value);
              if (arrayIntegrityLevel) arrayIntegrityLevel(key);
              return this;
            }
          });
        }
      }
      var nativeDelete;
      var nativeHas;
      var nativeGet;
    }
  });

  // node_modules/core-js/modules/es.weak-map.js
  var require_es_weak_map = __commonJS({
    "node_modules/core-js/modules/es.weak-map.js"() {
      "use strict";
      require_es_weak_map_constructor();
    }
  });

  // node_modules/core-js/modules/es.weak-set.constructor.js
  var require_es_weak_set_constructor = __commonJS({
    "node_modules/core-js/modules/es.weak-set.constructor.js"() {
      "use strict";
      var collection = require_collection();
      var collectionWeak = require_collection_weak();
      collection("WeakSet", function(init2) {
        return function WeakSet2() {
          return init2(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionWeak);
    }
  });

  // node_modules/core-js/modules/es.weak-set.js
  var require_es_weak_set = __commonJS({
    "node_modules/core-js/modules/es.weak-set.js"() {
      "use strict";
      require_es_weak_set_constructor();
    }
  });

  // node_modules/core-js/modules/web.atob.js
  var require_web_atob = __commonJS({
    "node_modules/core-js/modules/web.atob.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var c2i = require_base64_map().c2i;
      var disallowed = /[^\d+/a-z]/i;
      var whitespaces = /[\t\n\f\r ]+/g;
      var finalEq = /[=]{1,2}$/;
      var $atob = getBuiltIn("atob");
      var fromCharCode = String.fromCharCode;
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var exec = uncurryThis(disallowed.exec);
      var BASIC = !!$atob && !fails(function() {
        return $atob("aGk=") !== "hi";
      });
      var NO_SPACES_IGNORE = BASIC && fails(function() {
        return $atob(" ") !== "";
      });
      var NO_ENCODING_CHECK = BASIC && !fails(function() {
        $atob("a");
      });
      var NO_ARG_RECEIVING_CHECK = BASIC && !fails(function() {
        $atob();
      });
      var WRONG_ARITY = BASIC && $atob.length !== 1;
      var FORCED = !BASIC || NO_SPACES_IGNORE || NO_ENCODING_CHECK || NO_ARG_RECEIVING_CHECK || WRONG_ARITY;
      $({ global: true, bind: true, enumerable: true, forced: FORCED }, {
        atob: function atob(data) {
          validateArgumentsLength(arguments.length, 1);
          if (BASIC && !NO_SPACES_IGNORE && !NO_ENCODING_CHECK) return call($atob, globalThis2, data);
          var string = replace(toString(data), whitespaces, "");
          var output = "";
          var position = 0;
          var bc = 0;
          var length, chr, bs;
          if (string.length % 4 === 0) {
            string = replace(string, finalEq, "");
          }
          length = string.length;
          if (length % 4 === 1 || exec(disallowed, string)) {
            throw new (getBuiltIn("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
          }
          while (position < length) {
            chr = charAt(string, position++);
            bs = bc % 4 ? bs * 64 + c2i[chr] : c2i[chr];
            if (bc++ % 4) output += fromCharCode(255 & bs >> (-2 * bc & 6));
          }
          return output;
        }
      });
    }
  });

  // node_modules/core-js/modules/web.btoa.js
  var require_web_btoa = __commonJS({
    "node_modules/core-js/modules/web.btoa.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var i2c = require_base64_map().i2c;
      var $btoa = getBuiltIn("btoa");
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var BASIC = !!$btoa && !fails(function() {
        return $btoa("hi") !== "aGk=";
      });
      var NO_ARG_RECEIVING_CHECK = BASIC && !fails(function() {
        $btoa();
      });
      var WRONG_ARG_CONVERSION = BASIC && fails(function() {
        return $btoa(null) !== "bnVsbA==";
      });
      var WRONG_ARITY = BASIC && $btoa.length !== 1;
      $({ global: true, bind: true, enumerable: true, forced: !BASIC || NO_ARG_RECEIVING_CHECK || WRONG_ARG_CONVERSION || WRONG_ARITY }, {
        btoa: function btoa(data) {
          validateArgumentsLength(arguments.length, 1);
          if (BASIC) return call($btoa, globalThis2, toString(data));
          var string = toString(data);
          var output = "";
          var position = 0;
          var map = i2c;
          var block, charCode;
          while (charAt(string, position) || (map = "=", position % 1)) {
            charCode = charCodeAt(string, position += 3 / 4);
            if (charCode > 255) {
              throw new (getBuiltIn("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
            }
            block = block << 8 | charCode;
            output += charAt(map, 63 & block >> 8 - position % 1 * 8);
          }
          return output;
        }
      });
    }
  });

  // node_modules/core-js/internals/dom-iterables.js
  var require_dom_iterables = __commonJS({
    "node_modules/core-js/internals/dom-iterables.js"(exports, module) {
      "use strict";
      module.exports = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
      };
    }
  });

  // node_modules/core-js/internals/dom-token-list-prototype.js
  var require_dom_token_list_prototype = __commonJS({
    "node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module) {
      "use strict";
      var documentCreateElement = require_document_create_element();
      var classList = documentCreateElement("span").classList;
      var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
      module.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
    }
  });

  // node_modules/core-js/modules/web.dom-collections.for-each.js
  var require_web_dom_collections_for_each = __commonJS({
    "node_modules/core-js/modules/web.dom-collections.for-each.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var DOMIterables = require_dom_iterables();
      var DOMTokenListPrototype = require_dom_token_list_prototype();
      var forEach = require_array_for_each();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var handlePrototype = function(CollectionPrototype) {
        if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
          createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
        } catch (error) {
          CollectionPrototype.forEach = forEach;
        }
      };
      for (COLLECTION_NAME in DOMIterables) {
        if (DOMIterables[COLLECTION_NAME]) {
          handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype);
        }
      }
      var COLLECTION_NAME;
      handlePrototype(DOMTokenListPrototype);
    }
  });

  // node_modules/core-js/modules/web.dom-collections.iterator.js
  var require_web_dom_collections_iterator = __commonJS({
    "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var DOMIterables = require_dom_iterables();
      var DOMTokenListPrototype = require_dom_token_list_prototype();
      var ArrayIteratorMethods = require_es_array_iterator();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var setToStringTag = require_set_to_string_tag();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayValues = ArrayIteratorMethods.values;
      var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
        if (CollectionPrototype) {
          if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
          setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
          if (DOMIterables[COLLECTION_NAME2]) for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
              createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
            } catch (error) {
              CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
            }
          }
        }
      };
      for (COLLECTION_NAME in DOMIterables) {
        handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype, COLLECTION_NAME);
      }
      var COLLECTION_NAME;
      handlePrototype(DOMTokenListPrototype, "DOMTokenList");
    }
  });

  // node_modules/core-js/internals/dom-exception-constants.js
  var require_dom_exception_constants = __commonJS({
    "node_modules/core-js/internals/dom-exception-constants.js"(exports, module) {
      "use strict";
      module.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    }
  });

  // node_modules/core-js/modules/web.dom-exception.constructor.js
  var require_web_dom_exception_constructor = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.constructor.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var getBuiltInNodeModule = require_get_built_in_node_module();
      var fails = require_fails();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var defineProperty = require_object_define_property().f;
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var hasOwn = require_has_own_property();
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var errorToString = require_error_to_string();
      var normalizeStringArgument = require_normalize_string_argument();
      var DOMExceptionConstants = require_dom_exception_constants();
      var clearErrorStack = require_error_stack_clear();
      var InternalStateModule = require_internal_state();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var DOM_EXCEPTION = "DOMException";
      var DATA_CLONE_ERR = "DATA_CLONE_ERR";
      var Error2 = getBuiltIn("Error");
      var NativeDOMException = getBuiltIn(DOM_EXCEPTION) || (function() {
        try {
          var MessageChannel = getBuiltIn("MessageChannel") || getBuiltInNodeModule("worker_threads").MessageChannel;
          new MessageChannel().port1.postMessage(/* @__PURE__ */ new WeakMap());
        } catch (error) {
          if (error.name === DATA_CLONE_ERR && error.code === 25) return error.constructor;
        }
      })();
      var NativeDOMExceptionPrototype = NativeDOMException && NativeDOMException.prototype;
      var ErrorPrototype = Error2.prototype;
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(DOM_EXCEPTION);
      var HAS_STACK = "stack" in new Error2(DOM_EXCEPTION);
      var codeFor = function(name) {
        return hasOwn(DOMExceptionConstants, name) && DOMExceptionConstants[name].m ? DOMExceptionConstants[name].c : 0;
      };
      var $DOMException = function DOMException2() {
        anInstance(this, DOMExceptionPrototype);
        var argumentsLength = arguments.length;
        var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
        var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
        var code = codeFor(name);
        setInternalState(this, {
          type: DOM_EXCEPTION,
          name,
          message,
          code
        });
        if (!DESCRIPTORS) {
          this.name = name;
          this.message = message;
          this.code = code;
        }
        if (HAS_STACK) {
          var error = new Error2(message);
          error.name = DOM_EXCEPTION;
          defineProperty(this, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
        }
      };
      var DOMExceptionPrototype = $DOMException.prototype = create(ErrorPrototype);
      var createGetterDescriptor = function(get) {
        return { enumerable: true, configurable: true, get };
      };
      var getterFor = function(key2) {
        return createGetterDescriptor(function() {
          return getInternalState(this)[key2];
        });
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(DOMExceptionPrototype, "code", getterFor("code"));
        defineBuiltInAccessor(DOMExceptionPrototype, "message", getterFor("message"));
        defineBuiltInAccessor(DOMExceptionPrototype, "name", getterFor("name"));
      }
      defineProperty(DOMExceptionPrototype, "constructor", createPropertyDescriptor(1, $DOMException));
      var INCORRECT_CONSTRUCTOR = fails(function() {
        return !(new NativeDOMException() instanceof Error2);
      });
      var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function() {
        return ErrorPrototype.toString !== errorToString || String(new NativeDOMException(1, 2)) !== "2: 1";
      });
      var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function() {
        return new NativeDOMException(1, "DataCloneError").code !== 25;
      });
      var MISSED_CONSTANTS = INCORRECT_CONSTRUCTOR || NativeDOMException[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
      var FORCED_CONSTRUCTOR = IS_PURE ? INCORRECT_TO_STRING || INCORRECT_CODE || MISSED_CONSTANTS : INCORRECT_CONSTRUCTOR;
      $({ global: true, constructor: true, forced: FORCED_CONSTRUCTOR }, {
        DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
      });
      var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
      var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
      if (INCORRECT_TO_STRING && (IS_PURE || NativeDOMException === PolyfilledDOMException)) {
        defineBuiltIn(PolyfilledDOMExceptionPrototype, "toString", errorToString);
      }
      if (INCORRECT_CODE && DESCRIPTORS && NativeDOMException === PolyfilledDOMException) {
        defineBuiltInAccessor(PolyfilledDOMExceptionPrototype, "code", createGetterDescriptor(function() {
          return codeFor(anObject(this).name);
        }));
      }
      for (key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
        constant = DOMExceptionConstants[key];
        constantName = constant.s;
        descriptor = createPropertyDescriptor(6, constant.c);
        if (!hasOwn(PolyfilledDOMException, constantName)) {
          defineProperty(PolyfilledDOMException, constantName, descriptor);
        }
        if (!hasOwn(PolyfilledDOMExceptionPrototype, constantName)) {
          defineProperty(PolyfilledDOMExceptionPrototype, constantName, descriptor);
        }
      }
      var constant;
      var constantName;
      var descriptor;
      var key;
    }
  });

  // node_modules/core-js/modules/web.dom-exception.stack.js
  var require_web_dom_exception_stack = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.stack.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var getBuiltIn = require_get_built_in();
      var createPropertyDescriptor = require_create_property_descriptor();
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var anInstance = require_an_instance();
      var inheritIfRequired = require_inherit_if_required();
      var normalizeStringArgument = require_normalize_string_argument();
      var DOMExceptionConstants = require_dom_exception_constants();
      var clearErrorStack = require_error_stack_clear();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var DOM_EXCEPTION = "DOMException";
      var Error2 = getBuiltIn("Error");
      var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
      var $DOMException = function DOMException2() {
        anInstance(this, DOMExceptionPrototype);
        var argumentsLength = arguments.length;
        var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
        var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
        var that = new NativeDOMException(message, name);
        var error = new Error2(message);
        error.name = DOM_EXCEPTION;
        defineProperty(that, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
        inheritIfRequired(that, this, $DOMException);
        return that;
      };
      var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
      var ERROR_HAS_STACK = "stack" in new Error2(DOM_EXCEPTION);
      var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
      var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis2, DOM_EXCEPTION);
      var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);
      var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
      $({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, {
        // TODO: fix export logic
        DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
      });
      var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
      var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
      if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
        if (!IS_PURE) {
          defineProperty(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor(1, PolyfilledDOMException));
        }
        for (key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
          constant = DOMExceptionConstants[key];
          constantName = constant.s;
          if (!hasOwn(PolyfilledDOMException, constantName)) {
            defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
          }
        }
      }
      var constant;
      var constantName;
      var key;
    }
  });

  // node_modules/core-js/modules/web.dom-exception.to-string-tag.js
  var require_web_dom_exception_to_string_tag = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.to-string-tag.js"() {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var setToStringTag = require_set_to_string_tag();
      var DOM_EXCEPTION = "DOMException";
      setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);
    }
  });

  // node_modules/core-js/modules/web.clear-immediate.js
  var require_web_clear_immediate = __commonJS({
    "node_modules/core-js/modules/web.clear-immediate.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var clearImmediate = require_task().clear;
      $({ global: true, bind: true, enumerable: true, forced: globalThis2.clearImmediate !== clearImmediate }, {
        clearImmediate
      });
    }
  });

  // node_modules/core-js/internals/schedulers-fix.js
  var require_schedulers_fix = __commonJS({
    "node_modules/core-js/internals/schedulers-fix.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var isCallable = require_is_callable();
      var ENVIRONMENT = require_environment();
      var USER_AGENT = require_environment_user_agent();
      var arraySlice = require_array_slice();
      var validateArgumentsLength = require_validate_arguments_length();
      var Function2 = globalThis2.Function;
      var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === "BUN" && (function() {
        var version = globalThis2.Bun.version.split(".");
        return version.length < 3 || version[0] === "0" && (version[1] < 3 || version[1] === "3" && version[2] === "0");
      })();
      module.exports = function(scheduler, hasTimeArg) {
        var firstParamIndex = hasTimeArg ? 2 : 1;
        return WRAP ? function(handler, timeout2) {
          var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
          var fn = isCallable(handler) ? handler : Function2(handler);
          var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
          var callback = boundArgs ? function() {
            apply(fn, this, params);
          } : fn;
          return hasTimeArg ? scheduler(callback, timeout2) : scheduler(callback);
        } : scheduler;
      };
    }
  });

  // node_modules/core-js/modules/web.set-immediate.js
  var require_web_set_immediate = __commonJS({
    "node_modules/core-js/modules/web.set-immediate.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var setTask = require_task().set;
      var schedulersFix = require_schedulers_fix();
      var setImmediate = globalThis2.setImmediate ? schedulersFix(setTask, false) : setTask;
      $({ global: true, bind: true, enumerable: true, forced: globalThis2.setImmediate !== setImmediate }, {
        setImmediate
      });
    }
  });

  // node_modules/core-js/modules/web.immediate.js
  var require_web_immediate = __commonJS({
    "node_modules/core-js/modules/web.immediate.js"() {
      "use strict";
      require_web_clear_immediate();
      require_web_set_immediate();
    }
  });

  // node_modules/core-js/modules/web.queue-microtask.js
  var require_web_queue_microtask = __commonJS({
    "node_modules/core-js/modules/web.queue-microtask.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var microtask = require_microtask();
      var aCallable = require_a_callable();
      var validateArgumentsLength = require_validate_arguments_length();
      var fails = require_fails();
      var DESCRIPTORS = require_descriptors();
      var WRONG_ARITY = fails(function() {
        return DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis2, "queueMicrotask").value.length !== 1;
      });
      $({ global: true, enumerable: true, dontCallGetSet: true, forced: WRONG_ARITY }, {
        queueMicrotask: function queueMicrotask(fn) {
          validateArgumentsLength(arguments.length, 1);
          microtask(aCallable(fn));
        }
      });
    }
  });

  // node_modules/core-js/modules/web.self.js
  var require_web_self = __commonJS({
    "node_modules/core-js/modules/web.self.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var DESCRIPTORS = require_descriptors();
      var $TypeError = TypeError;
      var defineProperty = Object.defineProperty;
      var INCORRECT_VALUE = globalThis2.self !== globalThis2;
      try {
        if (DESCRIPTORS) {
          descriptor = Object.getOwnPropertyDescriptor(globalThis2, "self");
          if (INCORRECT_VALUE || !descriptor || !descriptor.get || !descriptor.enumerable) {
            defineBuiltInAccessor(globalThis2, "self", {
              get: function self2() {
                return globalThis2;
              },
              set: function self2(value) {
                if (this !== globalThis2) throw new $TypeError("Illegal invocation");
                defineProperty(globalThis2, "self", {
                  value,
                  writable: true,
                  configurable: true,
                  enumerable: true
                });
              },
              configurable: true,
              enumerable: true
            });
          }
        } else $({ global: true, simple: true, forced: INCORRECT_VALUE }, {
          self: globalThis2
        });
      } catch (error) {
      }
      var descriptor;
    }
  });

  // node_modules/core-js/modules/web.structured-clone.js
  var require_web_structured_clone = __commonJS({
    "node_modules/core-js/modules/web.structured-clone.js"() {
      "use strict";
      var IS_PURE = require_is_pure();
      var $ = require_export();
      var globalThis2 = require_global_this();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var uid = require_uid();
      var isCallable = require_is_callable();
      var isConstructor = require_is_constructor();
      var isNullOrUndefined = require_is_null_or_undefined();
      var isObject4 = require_is_object();
      var isSymbol = require_is_symbol();
      var iterate = require_iterate();
      var anObject = require_an_object();
      var classof = require_classof();
      var hasOwn = require_has_own_property();
      var createProperty = require_create_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var lengthOfArrayLike = require_length_of_array_like();
      var validateArgumentsLength = require_validate_arguments_length();
      var getRegExpFlags = require_regexp_get_flags();
      var MapHelpers = require_map_helpers();
      var SetHelpers = require_set_helpers();
      var setIterate = require_set_iterate();
      var detachTransferable = require_detach_transferable();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var Object2 = globalThis2.Object;
      var Array2 = globalThis2.Array;
      var Date2 = globalThis2.Date;
      var Error2 = globalThis2.Error;
      var TypeError2 = globalThis2.TypeError;
      var PerformanceMark = globalThis2.PerformanceMark;
      var DOMException2 = getBuiltIn("DOMException");
      var Map2 = MapHelpers.Map;
      var mapHas = MapHelpers.has;
      var mapGet = MapHelpers.get;
      var mapSet = MapHelpers.set;
      var Set2 = SetHelpers.Set;
      var setAdd = SetHelpers.add;
      var setHas = SetHelpers.has;
      var objectKeys = getBuiltIn("Object", "keys");
      var push = uncurryThis([].push);
      var thisBooleanValue = uncurryThis(true.valueOf);
      var thisNumberValue = uncurryThis(1.1.valueOf);
      var thisStringValue = uncurryThis("".valueOf);
      var thisTimeValue = uncurryThis(Date2.prototype.getTime);
      var PERFORMANCE_MARK = uid("structuredClone");
      var DATA_CLONE_ERROR = "DataCloneError";
      var TRANSFERRING = "Transferring";
      var checkBasicSemantic = function(structuredCloneImplementation) {
        return !fails(function() {
          var set1 = new globalThis2.Set([7]);
          var set2 = structuredCloneImplementation(set1);
          var number = structuredCloneImplementation(Object2(7));
          return set2 === set1 || !set2.has(7) || !isObject4(number) || +number !== 7;
        }) && structuredCloneImplementation;
      };
      var checkErrorsCloning = function(structuredCloneImplementation, $Error) {
        return !fails(function() {
          var error = new $Error();
          var test = structuredCloneImplementation({ a: error, b: error });
          return !(test && test.a === test.b && test.a instanceof $Error && test.a.stack === error.stack);
        });
      };
      var checkNewErrorsCloningSemantic = function(structuredCloneImplementation) {
        return !fails(function() {
          var test = structuredCloneImplementation(new globalThis2.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
          return test.name !== "AggregateError" || test.errors[0] !== 1 || test.message !== PERFORMANCE_MARK || test.cause !== 3;
        });
      };
      var nativeStructuredClone = globalThis2.structuredClone;
      var FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error2) || !checkErrorsCloning(nativeStructuredClone, DOMException2) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
      var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
        return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
      });
      var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
      var throwUncloneable = function(type) {
        throw new DOMException2("Uncloneable type: " + type, DATA_CLONE_ERROR);
      };
      var throwUnpolyfillable = function(type, action) {
        throw new DOMException2((action || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
      };
      var tryNativeRestrictedStructuredClone = function(value, type) {
        if (!nativeRestrictedStructuredClone) throwUnpolyfillable(type);
        return nativeRestrictedStructuredClone(value);
      };
      var createDataTransfer = function() {
        var dataTransfer;
        try {
          dataTransfer = new globalThis2.DataTransfer();
        } catch (error) {
          try {
            dataTransfer = new globalThis2.ClipboardEvent("").clipboardData;
          } catch (error2) {
          }
        }
        return dataTransfer && dataTransfer.items && dataTransfer.files ? dataTransfer : null;
      };
      var cloneBuffer = function(value, map, $type) {
        if (mapHas(map, value)) return mapGet(map, value);
        var type = $type || classof(value);
        var clone, length, options, source, target, i;
        if (type === "SharedArrayBuffer") {
          if (nativeRestrictedStructuredClone) clone = nativeRestrictedStructuredClone(value);
          else clone = value;
        } else {
          var DataView2 = globalThis2.DataView;
          if (!DataView2 && !isCallable(value.slice)) throwUnpolyfillable("ArrayBuffer");
          try {
            if (isCallable(value.slice) && !value.resizable) {
              clone = value.slice(0);
            } else {
              length = value.byteLength;
              options = "maxByteLength" in value ? { maxByteLength: value.maxByteLength } : void 0;
              clone = new ArrayBuffer(length, options);
              source = new DataView2(value);
              target = new DataView2(clone);
              for (i = 0; i < length; i++) {
                target.setUint8(i, source.getUint8(i));
              }
            }
          } catch (error) {
            throw new DOMException2("ArrayBuffer is detached", DATA_CLONE_ERROR);
          }
        }
        mapSet(map, value, clone);
        return clone;
      };
      var cloneView = function(value, type, offset, length, map) {
        var C = globalThis2[type];
        if (!isObject4(C)) throwUnpolyfillable(type);
        return new C(cloneBuffer(value.buffer, map), offset, length);
      };
      var structuredCloneInternal = function(value, map) {
        if (isSymbol(value)) throwUncloneable("Symbol");
        if (!isObject4(value)) return value;
        if (map) {
          if (mapHas(map, value)) return mapGet(map, value);
        } else map = new Map2();
        var type = classof(value);
        var C, name, cloned, dataTransfer, i, length, keys, key;
        switch (type) {
          case "Array":
            cloned = Array2(lengthOfArrayLike(value));
            break;
          case "Object":
            cloned = {};
            break;
          case "Map":
            cloned = new Map2();
            break;
          case "Set":
            cloned = new Set2();
            break;
          case "RegExp":
            cloned = new RegExp(value.source, getRegExpFlags(value));
            break;
          case "Error":
            name = value.name;
            switch (name) {
              case "AggregateError":
                cloned = new (getBuiltIn(name))([]);
                break;
              case "EvalError":
              case "RangeError":
              case "ReferenceError":
              case "SuppressedError":
              case "SyntaxError":
              case "TypeError":
              case "URIError":
                cloned = new (getBuiltIn(name))();
                break;
              case "CompileError":
              case "LinkError":
              case "RuntimeError":
                cloned = new (getBuiltIn("WebAssembly", name))();
                break;
              default:
                cloned = new Error2();
            }
            break;
          case "DOMException":
            cloned = new DOMException2(value.message, value.name);
            break;
          case "ArrayBuffer":
          case "SharedArrayBuffer":
            cloned = cloneBuffer(value, map, type);
            break;
          case "DataView":
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float16Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array":
            length = type === "DataView" ? value.byteLength : value.length;
            cloned = cloneView(value, type, value.byteOffset, length, map);
            break;
          case "DOMQuad":
            try {
              cloned = new DOMQuad(
                structuredCloneInternal(value.p1, map),
                structuredCloneInternal(value.p2, map),
                structuredCloneInternal(value.p3, map),
                structuredCloneInternal(value.p4, map)
              );
            } catch (error) {
              cloned = tryNativeRestrictedStructuredClone(value, type);
            }
            break;
          case "File":
            if (nativeRestrictedStructuredClone) try {
              cloned = nativeRestrictedStructuredClone(value);
              if (classof(cloned) !== type) cloned = void 0;
            } catch (error) {
            }
            if (!cloned) try {
              cloned = new File([value], value.name, value);
            } catch (error) {
            }
            if (!cloned) throwUnpolyfillable(type);
            break;
          case "FileList":
            dataTransfer = createDataTransfer();
            if (dataTransfer) {
              for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
                dataTransfer.items.add(structuredCloneInternal(value[i], map));
              }
              cloned = dataTransfer.files;
            } else cloned = tryNativeRestrictedStructuredClone(value, type);
            break;
          case "ImageData":
            try {
              cloned = new ImageData(
                structuredCloneInternal(value.data, map),
                value.width,
                value.height,
                { colorSpace: value.colorSpace }
              );
            } catch (error) {
              cloned = tryNativeRestrictedStructuredClone(value, type);
            }
            break;
          default:
            if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else switch (type) {
              case "BigInt":
                cloned = Object2(value.valueOf());
                break;
              case "Boolean":
                cloned = Object2(thisBooleanValue(value));
                break;
              case "Number":
                cloned = Object2(thisNumberValue(value));
                break;
              case "String":
                cloned = Object2(thisStringValue(value));
                break;
              case "Date":
                cloned = new Date2(thisTimeValue(value));
                break;
              case "Blob":
                try {
                  cloned = value.slice(0, value.size, value.type);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMPoint":
              case "DOMPointReadOnly":
                C = globalThis2[type];
                try {
                  cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMRect":
              case "DOMRectReadOnly":
                C = globalThis2[type];
                try {
                  cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMMatrix":
              case "DOMMatrixReadOnly":
                C = globalThis2[type];
                try {
                  cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "AudioData":
              case "VideoFrame":
                if (!isCallable(value.clone)) throwUnpolyfillable(type);
                try {
                  cloned = value.clone();
                } catch (error) {
                  throwUncloneable(type);
                }
                break;
              case "CropTarget":
              case "CryptoKey":
              case "FileSystemDirectoryHandle":
              case "FileSystemFileHandle":
              case "FileSystemHandle":
              case "GPUCompilationInfo":
              case "GPUCompilationMessage":
              case "ImageBitmap":
              case "RTCCertificate":
              case "WebAssembly.Module":
                throwUnpolyfillable(type);
              // break omitted
              default:
                throwUncloneable(type);
            }
        }
        mapSet(map, value, cloned);
        switch (type) {
          case "Array":
          case "Object":
            keys = objectKeys(value);
            for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
              key = keys[i];
              createProperty(cloned, key, structuredCloneInternal(value[key], map));
            }
            break;
          case "Map":
            value.forEach(function(v, k) {
              mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
            });
            break;
          case "Set":
            value.forEach(function(v) {
              setAdd(cloned, structuredCloneInternal(v, map));
            });
            break;
          case "Error":
            createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
            if (hasOwn(value, "cause")) {
              createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
            }
            if (name === "AggregateError") {
              cloned.errors = structuredCloneInternal(value.errors, map);
            } else if (name === "SuppressedError") {
              cloned.error = structuredCloneInternal(value.error, map);
              cloned.suppressed = structuredCloneInternal(value.suppressed, map);
            }
          // break omitted
          case "DOMException":
            if (ERROR_STACK_INSTALLABLE) {
              createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
            }
        }
        return cloned;
      };
      var tryToTransfer = function(rawTransfer, map) {
        if (!isObject4(rawTransfer)) throw new TypeError2("Transfer option cannot be converted to a sequence");
        var transfer = [];
        iterate(rawTransfer, function(value2) {
          push(transfer, anObject(value2));
        });
        var i = 0;
        var length = lengthOfArrayLike(transfer);
        var buffers = new Set2();
        var value, type, C, transferred, canvas, context2;
        while (i < length) {
          value = transfer[i++];
          type = classof(value);
          if (type === "ArrayBuffer" ? setHas(buffers, value) : mapHas(map, value)) {
            throw new DOMException2("Duplicate transferable", DATA_CLONE_ERROR);
          }
          if (type === "ArrayBuffer") {
            setAdd(buffers, value);
            continue;
          }
          if (PROPER_STRUCTURED_CLONE_TRANSFER) {
            transferred = nativeStructuredClone(value, { transfer: [value] });
          } else switch (type) {
            case "ImageBitmap":
              C = globalThis2.OffscreenCanvas;
              if (!isConstructor(C)) throwUnpolyfillable(type, TRANSFERRING);
              try {
                canvas = new C(value.width, value.height);
                context2 = canvas.getContext("bitmaprenderer");
                context2.transferFromImageBitmap(value);
                transferred = canvas.transferToImageBitmap();
              } catch (error) {
              }
              break;
            case "AudioData":
            case "VideoFrame":
              if (!isCallable(value.clone) || !isCallable(value.close)) throwUnpolyfillable(type, TRANSFERRING);
              try {
                transferred = value.clone();
                value.close();
              } catch (error) {
              }
              break;
            case "MediaSourceHandle":
            case "MessagePort":
            case "MIDIAccess":
            case "OffscreenCanvas":
            case "ReadableStream":
            case "RTCDataChannel":
            case "TransformStream":
            case "WebTransportReceiveStream":
            case "WebTransportSendStream":
            case "WritableStream":
              throwUnpolyfillable(type, TRANSFERRING);
          }
          if (transferred === void 0) throw new DOMException2("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
          mapSet(map, value, transferred);
        }
        return buffers;
      };
      var detachBuffers = function(buffers) {
        setIterate(buffers, function(buffer) {
          if (PROPER_STRUCTURED_CLONE_TRANSFER) {
            nativeRestrictedStructuredClone(buffer, { transfer: [buffer] });
          } else if (isCallable(buffer.transfer)) {
            buffer.transfer();
          } else if (detachTransferable) {
            detachTransferable(buffer);
          } else {
            throwUnpolyfillable("ArrayBuffer", TRANSFERRING);
          }
        });
      };
      $({ global: true, enumerable: true, sham: !PROPER_STRUCTURED_CLONE_TRANSFER, forced: FORCED_REPLACEMENT }, {
        structuredClone: function structuredClone(value) {
          var options = validateArgumentsLength(arguments.length, 1) > 1 && !isNullOrUndefined(arguments[1]) ? anObject(arguments[1]) : void 0;
          var transfer = options ? options.transfer : void 0;
          var map, buffers;
          if (transfer !== void 0) {
            map = new Map2();
            buffers = tryToTransfer(transfer, map);
          }
          var clone = structuredCloneInternal(value, map);
          if (buffers) detachBuffers(buffers);
          return clone;
        }
      });
    }
  });

  // node_modules/core-js/modules/web.set-interval.js
  var require_web_set_interval = __commonJS({
    "node_modules/core-js/modules/web.set-interval.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var schedulersFix = require_schedulers_fix();
      var setInterval2 = schedulersFix(globalThis2.setInterval, true);
      $({ global: true, bind: true, forced: globalThis2.setInterval !== setInterval2 }, {
        setInterval: setInterval2
      });
    }
  });

  // node_modules/core-js/modules/web.set-timeout.js
  var require_web_set_timeout = __commonJS({
    "node_modules/core-js/modules/web.set-timeout.js"() {
      "use strict";
      var $ = require_export();
      var globalThis2 = require_global_this();
      var schedulersFix = require_schedulers_fix();
      var setTimeout2 = schedulersFix(globalThis2.setTimeout, true);
      $({ global: true, bind: true, forced: globalThis2.setTimeout !== setTimeout2 }, {
        setTimeout: setTimeout2
      });
    }
  });

  // node_modules/core-js/modules/web.timers.js
  var require_web_timers = __commonJS({
    "node_modules/core-js/modules/web.timers.js"() {
      "use strict";
      require_web_set_interval();
      require_web_set_timeout();
    }
  });

  // node_modules/core-js/internals/url-constructor-detection.js
  var require_url_constructor_detection = __commonJS({
    "node_modules/core-js/internals/url-constructor-detection.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = !fails(function() {
        var url = new URL("b?a=1&b=2&c=3", "https://a");
        var params = url.searchParams;
        var params2 = new URLSearchParams("a=1&a=2&b=3");
        var result = "";
        url.pathname = "c%20d";
        params.forEach(function(value, key) {
          params["delete"]("b");
          result += key + value;
        });
        params2["delete"]("a", 2);
        params2["delete"]("b", void 0);
        return IS_PURE && (!url.toJSON || !params2.has("a", 1) || params2.has("a", 2) || !params2.has("a", void 0) || params2.has("b")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== "https://a/c%20d?a=1&c=3" || params.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("https://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("https://x", void 0).host !== "x";
      });
    }
  });

  // node_modules/core-js/internals/string-punycode-to-ascii.js
  var require_string_punycode_to_ascii = __commonJS({
    "node_modules/core-js/internals/string-punycode-to-ascii.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexNonASCII = /[^\0-\u007E]/;
      var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
      var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
      var baseMinusTMin = base - tMin;
      var $RangeError = RangeError;
      var exec = uncurryThis(regexSeparators.exec);
      var floor = Math.floor;
      var fromCharCode = String.fromCharCode;
      var charCodeAt = uncurryThis("".charCodeAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var split = uncurryThis("".split);
      var toLowerCase = uncurryThis("".toLowerCase);
      var ucs2decode = function(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = charCodeAt(string, counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = charCodeAt(string, counter++);
            if ((extra & 64512) === 56320) {
              push(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              push(output, value);
              counter--;
            }
          } else {
            push(output, value);
          }
        }
        return output;
      };
      var digitToBasic = function(digit) {
        return digit + 22 + 75 * (digit < 26);
      };
      var adapt = function(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        while (delta > baseMinusTMin * tMax >> 1) {
          delta = floor(delta / baseMinusTMin);
          k += base;
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var encode2 = function(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var i, currentValue;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue < 128) {
            push(output, fromCharCode(currentValue));
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          push(output, delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          for (i = 0; i < input.length; i++) {
            currentValue = input[i];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            throw new $RangeError(OVERFLOW_ERROR);
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (i = 0; i < input.length; i++) {
            currentValue = input[i];
            if (currentValue < n && ++delta > maxInt) {
              throw new $RangeError(OVERFLOW_ERROR);
            }
            if (currentValue === n) {
              var q = delta;
              var k = base;
              while (true) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) break;
                var qMinusT = q - t;
                var baseMinusT = base - t;
                push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                q = floor(qMinusT / baseMinusT);
                k += base;
              }
              push(output, fromCharCode(digitToBasic(q)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
              delta = 0;
              handledCPCount++;
            }
          }
          delta++;
          n++;
        }
        return join(output, "");
      };
      module.exports = function(input) {
        var encoded = [];
        var labels = split(replace(toLowerCase(input), regexSeparators, "."), ".");
        var i, label;
        for (i = 0; i < labels.length; i++) {
          label = labels[i];
          push(encoded, exec(regexNonASCII, label) ? "xn--" + encode2(label) : label);
        }
        return join(encoded, ".");
      };
    }
  });

  // node_modules/core-js/modules/web.url-search-params.constructor.js
  var require_web_url_search_params_constructor = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.constructor.js"(exports, module) {
      "use strict";
      require_es_array_iterator();
      require_es_string_from_code_point();
      var $ = require_export();
      var globalThis2 = require_global_this();
      var safeGetBuiltIn = require_safe_get_built_in();
      var getBuiltIn = require_get_built_in();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var DESCRIPTORS = require_descriptors();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var setToStringTag = require_set_to_string_tag();
      var createIteratorConstructor = require_iterator_create_constructor();
      var InternalStateModule = require_internal_state();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var bind2 = require_function_bind_context();
      var classof = require_classof();
      var anObject = require_an_object();
      var isObject4 = require_is_object();
      var $toString = require_to_string();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var createIterResultObject = require_create_iter_result_object();
      var validateArgumentsLength = require_validate_arguments_length();
      var wellKnownSymbol = require_well_known_symbol();
      var arraySort = require_array_sort();
      var ITERATOR = wellKnownSymbol("iterator");
      var URL_SEARCH_PARAMS = "URLSearchParams";
      var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
      var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
      var nativeFetch = safeGetBuiltIn("fetch");
      var NativeRequest = safeGetBuiltIn("Request");
      var Headers3 = safeGetBuiltIn("Headers");
      var RequestPrototype = NativeRequest && NativeRequest.prototype;
      var HeadersPrototype = Headers3 && Headers3.prototype;
      var TypeError2 = globalThis2.TypeError;
      var encodeURIComponent2 = globalThis2.encodeURIComponent;
      var fromCharCode = String.fromCharCode;
      var fromCodePoint = getBuiltIn("String", "fromCodePoint");
      var $parseInt = parseInt;
      var charAt = uncurryThis("".charAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift = uncurryThis([].shift);
      var splice = uncurryThis([].splice);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var exec = uncurryThis(/./.exec);
      var plus = /\+/g;
      var FALLBACK_REPLACER = "\uFFFD";
      var VALID_HEX = /^[0-9a-f]+$/i;
      var parseHexOctet = function(string, start2) {
        var substr = stringSlice(string, start2, start2 + 2);
        if (!exec(VALID_HEX, substr)) return NaN;
        return $parseInt(substr, 16);
      };
      var getLeadingOnes = function(octet) {
        var count = 0;
        for (var mask = 128; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
          count++;
        }
        return count;
      };
      var utf8Decode = function(octets) {
        var codePoint = null;
        switch (octets.length) {
          case 1:
            codePoint = octets[0];
            break;
          case 2:
            codePoint = (octets[0] & 31) << 6 | octets[1] & 63;
            break;
          case 3:
            codePoint = (octets[0] & 15) << 12 | (octets[1] & 63) << 6 | octets[2] & 63;
            break;
          case 4:
            codePoint = (octets[0] & 7) << 18 | (octets[1] & 63) << 12 | (octets[2] & 63) << 6 | octets[3] & 63;
            break;
        }
        return codePoint > 1114111 ? null : codePoint;
      };
      var decode3 = function(input) {
        input = replace(input, plus, " ");
        var length = input.length;
        var result = "";
        var i = 0;
        while (i < length) {
          var decodedChar = charAt(input, i);
          if (decodedChar === "%") {
            if (charAt(input, i + 1) === "%" || i + 3 > length) {
              result += "%";
              i++;
              continue;
            }
            var octet = parseHexOctet(input, i + 1);
            if (octet !== octet) {
              result += decodedChar;
              i++;
              continue;
            }
            i += 2;
            var byteSequenceLength = getLeadingOnes(octet);
            if (byteSequenceLength === 0) {
              decodedChar = fromCharCode(octet);
            } else {
              if (byteSequenceLength === 1 || byteSequenceLength > 4) {
                result += FALLBACK_REPLACER;
                i++;
                continue;
              }
              var octets = [octet];
              var sequenceIndex = 1;
              while (sequenceIndex < byteSequenceLength) {
                i++;
                if (i + 3 > length || charAt(input, i) !== "%") break;
                var nextByte = parseHexOctet(input, i + 1);
                if (nextByte !== nextByte) {
                  i += 3;
                  break;
                }
                if (nextByte > 191 || nextByte < 128) break;
                push(octets, nextByte);
                i += 2;
                sequenceIndex++;
              }
              if (octets.length !== byteSequenceLength) {
                result += FALLBACK_REPLACER;
                continue;
              }
              var codePoint = utf8Decode(octets);
              if (codePoint === null) {
                result += FALLBACK_REPLACER;
              } else {
                decodedChar = fromCodePoint(codePoint);
              }
            }
          }
          result += decodedChar;
          i++;
        }
        return result;
      };
      var find = /[!'()~]|%20/g;
      var replacements = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+"
      };
      var replacer = function(match) {
        return replacements[match];
      };
      var serialize = function(it) {
        return replace(encodeURIComponent2(it), find, replacer);
      };
      var URLSearchParamsIterator = createIteratorConstructor(function Iterator2(params, kind) {
        setInternalState(this, {
          type: URL_SEARCH_PARAMS_ITERATOR,
          target: getInternalParamsState(params).entries,
          index: 0,
          kind
        });
      }, URL_SEARCH_PARAMS, function next() {
        var state3 = getInternalIteratorState(this);
        var target = state3.target;
        var index = state3.index++;
        if (!target || index >= target.length) {
          state3.target = null;
          return createIterResultObject(void 0, true);
        }
        var entry = target[index];
        switch (state3.kind) {
          case "keys":
            return createIterResultObject(entry.key, false);
          case "values":
            return createIterResultObject(entry.value, false);
        }
        return createIterResultObject([entry.key, entry.value], false);
      }, true);
      var URLSearchParamsState = function(init2) {
        this.entries = [];
        this.url = null;
        if (init2 !== void 0) {
          if (isObject4(init2)) this.parseObject(init2);
          else this.parseQuery(typeof init2 == "string" ? charAt(init2, 0) === "?" ? stringSlice(init2, 1) : init2 : $toString(init2));
        }
      };
      URLSearchParamsState.prototype = {
        type: URL_SEARCH_PARAMS,
        bindURL: function(url) {
          this.url = url;
          this.update();
        },
        parseObject: function(object) {
          var entries = this.entries;
          var iteratorMethod = getIteratorMethod(object);
          var iterator, next, step2, entryIterator, entryNext, first, second;
          if (iteratorMethod) {
            iterator = getIterator(object, iteratorMethod);
            next = iterator.next;
            while (!(step2 = call(next, iterator)).done) {
              entryIterator = getIterator(anObject(step2.value));
              entryNext = entryIterator.next;
              if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done) throw new TypeError2("Expected sequence with length 2");
              push(entries, { key: $toString(first.value), value: $toString(second.value) });
            }
          } else for (var key in object) if (hasOwn(object, key)) {
            push(entries, { key, value: $toString(object[key]) });
          }
        },
        parseQuery: function(query) {
          if (query) {
            var entries = this.entries;
            var attributes = split(query, "&");
            var index = 0;
            var attribute, entry;
            while (index < attributes.length) {
              attribute = attributes[index++];
              if (attribute.length) {
                entry = split(attribute, "=");
                push(entries, {
                  key: decode3(shift(entry)),
                  value: decode3(join(entry, "="))
                });
              }
            }
          }
        },
        serialize: function() {
          var entries = this.entries;
          var result = [];
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            push(result, serialize(entry.key) + "=" + serialize(entry.value));
          }
          return join(result, "&");
        },
        update: function() {
          this.entries.length = 0;
          this.parseQuery(this.url.query);
        },
        updateURL: function() {
          if (this.url) this.url.update();
        }
      };
      var URLSearchParamsConstructor = function URLSearchParams2() {
        anInstance(this, URLSearchParamsPrototype);
        var init2 = arguments.length > 0 ? arguments[0] : void 0;
        var state3 = setInternalState(this, new URLSearchParamsState(init2));
        if (!DESCRIPTORS) this.size = state3.entries.length;
      };
      var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
      defineBuiltIns(URLSearchParamsPrototype, {
        // `URLSearchParams.prototype.append` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-append
        append: function append(name, value) {
          var state3 = getInternalParamsState(this);
          validateArgumentsLength(arguments.length, 2);
          push(state3.entries, { key: $toString(name), value: $toString(value) });
          if (!DESCRIPTORS) this.length++;
          state3.updateURL();
        },
        // `URLSearchParams.prototype.delete` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
        "delete": function(name) {
          var state3 = getInternalParamsState(this);
          var length = validateArgumentsLength(arguments.length, 1);
          var entries = state3.entries;
          var key = $toString(name);
          var $value = length < 2 ? void 0 : arguments[1];
          var value = $value === void 0 ? $value : $toString($value);
          var index = 0;
          while (index < entries.length) {
            var entry = entries[index];
            if (entry.key === key && (value === void 0 || entry.value === value)) {
              splice(entries, index, 1);
              if (value !== void 0) break;
            } else index++;
          }
          if (!DESCRIPTORS) this.size = entries.length;
          state3.updateURL();
        },
        // `URLSearchParams.prototype.get` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-get
        get: function get(name) {
          var entries = getInternalParamsState(this).entries;
          validateArgumentsLength(arguments.length, 1);
          var key = $toString(name);
          var index = 0;
          for (; index < entries.length; index++) {
            if (entries[index].key === key) return entries[index].value;
          }
          return null;
        },
        // `URLSearchParams.prototype.getAll` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
        getAll: function getAll(name) {
          var entries = getInternalParamsState(this).entries;
          validateArgumentsLength(arguments.length, 1);
          var key = $toString(name);
          var result = [];
          var index = 0;
          for (; index < entries.length; index++) {
            if (entries[index].key === key) push(result, entries[index].value);
          }
          return result;
        },
        // `URLSearchParams.prototype.has` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-has
        has: function has(name) {
          var entries = getInternalParamsState(this).entries;
          var length = validateArgumentsLength(arguments.length, 1);
          var key = $toString(name);
          var $value = length < 2 ? void 0 : arguments[1];
          var value = $value === void 0 ? $value : $toString($value);
          var index = 0;
          while (index < entries.length) {
            var entry = entries[index++];
            if (entry.key === key && (value === void 0 || entry.value === value)) return true;
          }
          return false;
        },
        // `URLSearchParams.prototype.set` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-set
        set: function set(name, value) {
          var state3 = getInternalParamsState(this);
          validateArgumentsLength(arguments.length, 1);
          var entries = state3.entries;
          var found = false;
          var key = $toString(name);
          var val = $toString(value);
          var index = 0;
          var entry;
          for (; index < entries.length; index++) {
            entry = entries[index];
            if (entry.key === key) {
              if (found) splice(entries, index--, 1);
              else {
                found = true;
                entry.value = val;
              }
            }
          }
          if (!found) push(entries, { key, value: val });
          if (!DESCRIPTORS) this.size = entries.length;
          state3.updateURL();
        },
        // `URLSearchParams.prototype.sort` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
        sort: function sort() {
          var state3 = getInternalParamsState(this);
          arraySort(state3.entries, function(a, b) {
            return a.key > b.key ? 1 : -1;
          });
          state3.updateURL();
        },
        // `URLSearchParams.prototype.forEach` method
        forEach: function forEach(callback) {
          var entries = getInternalParamsState(this).entries;
          var boundFunction = bind2(callback, arguments.length > 1 ? arguments[1] : void 0);
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            boundFunction(entry.value, entry.key, this);
          }
        },
        // `URLSearchParams.prototype.keys` method
        keys: function keys() {
          return new URLSearchParamsIterator(this, "keys");
        },
        // `URLSearchParams.prototype.values` method
        values: function values() {
          return new URLSearchParamsIterator(this, "values");
        },
        // `URLSearchParams.prototype.entries` method
        entries: function entries() {
          return new URLSearchParamsIterator(this, "entries");
        }
      }, { enumerable: true });
      defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
      defineBuiltIn(URLSearchParamsPrototype, "toString", function toString() {
        return getInternalParamsState(this).serialize();
      }, { enumerable: true });
      if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
        get: function size() {
          return getInternalParamsState(this).entries.length;
        },
        configurable: true,
        enumerable: true
      });
      setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
      $({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
        URLSearchParams: URLSearchParamsConstructor
      });
      if (!USE_NATIVE_URL && isCallable(Headers3)) {
        headersHas = uncurryThis(HeadersPrototype.has);
        headersSet = uncurryThis(HeadersPrototype.set);
        wrapRequestOptions = function(init2) {
          if (isObject4(init2)) {
            var body = init2.body;
            var headers;
            if (classof(body) === URL_SEARCH_PARAMS) {
              headers = init2.headers ? new Headers3(init2.headers) : new Headers3();
              if (!headersHas(headers, "content-type")) {
                headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
              return create(init2, {
                body: createPropertyDescriptor(0, $toString(body)),
                headers: createPropertyDescriptor(0, headers)
              });
            }
          }
          return init2;
        };
        if (isCallable(nativeFetch)) {
          $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
            fetch: function fetch3(input) {
              return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
            }
          });
        }
        if (isCallable(NativeRequest)) {
          RequestConstructor = function Request3(input) {
            anInstance(this, RequestPrototype);
            return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          };
          RequestPrototype.constructor = RequestConstructor;
          RequestConstructor.prototype = RequestPrototype;
          $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
            Request: RequestConstructor
          });
        }
      }
      var headersHas;
      var headersSet;
      var wrapRequestOptions;
      var RequestConstructor;
      module.exports = {
        URLSearchParams: URLSearchParamsConstructor,
        getState: getInternalParamsState
      };
    }
  });

  // node_modules/core-js/modules/web.url.constructor.js
  var require_web_url_constructor = __commonJS({
    "node_modules/core-js/modules/web.url.constructor.js"() {
      "use strict";
      require_es_string_iterator();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var globalThis2 = require_global_this();
      var bind2 = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var anInstance = require_an_instance();
      var hasOwn = require_has_own_property();
      var assign = require_object_assign();
      var arrayFrom = require_array_from();
      var arraySlice = require_array_slice();
      var codeAt = require_string_multibyte().codeAt;
      var toASCII = require_string_punycode_to_ascii();
      var $toString = require_to_string();
      var setToStringTag = require_set_to_string_tag();
      var validateArgumentsLength = require_validate_arguments_length();
      var URLSearchParamsModule = require_web_url_search_params_constructor();
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var getInternalURLState = InternalStateModule.getterFor("URL");
      var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
      var getInternalSearchParamsState = URLSearchParamsModule.getState;
      var NativeURL = globalThis2.URL;
      var TypeError2 = globalThis2.TypeError;
      var parseInt2 = globalThis2.parseInt;
      var floor = Math.floor;
      var pow = Math.pow;
      var charAt = uncurryThis("".charAt);
      var exec = uncurryThis(/./.exec);
      var join = uncurryThis([].join);
      var numberToString = uncurryThis(1.1.toString);
      var pop = uncurryThis([].pop);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift = uncurryThis([].shift);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var toLowerCase = uncurryThis("".toLowerCase);
      var unshift = uncurryThis([].unshift);
      var INVALID_AUTHORITY = "Invalid authority";
      var INVALID_SCHEME = "Invalid scheme";
      var INVALID_HOST = "Invalid host";
      var INVALID_PORT = "Invalid port";
      var ALPHA = /[a-z]/i;
      var ALPHANUMERIC = /[\d+-.a-z]/i;
      var DIGIT = /\d/;
      var HEX_START = /^0x/i;
      var OCT = /^[0-7]+$/;
      var DEC = /^\d+$/;
      var HEX = /^[\da-f]+$/i;
      var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
      var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
      var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
      var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
      var TAB_AND_NEW_LINE = /[\t\n\r]/g;
      var EOF;
      var parseIPv4 = function(input) {
        var parts = split(input, ".");
        var partsLength, numbers, index, part, radix, number, ipv4;
        if (parts.length && parts[parts.length - 1] === "") {
          parts.length--;
        }
        partsLength = parts.length;
        if (partsLength > 4) return input;
        numbers = [];
        for (index = 0; index < partsLength; index++) {
          part = parts[index];
          if (part === "") return input;
          radix = 10;
          if (part.length > 1 && charAt(part, 0) === "0") {
            radix = exec(HEX_START, part) ? 16 : 8;
            part = stringSlice(part, radix === 8 ? 1 : 2);
          }
          if (part === "") {
            number = 0;
          } else {
            if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
            number = parseInt2(part, radix);
          }
          push(numbers, number);
        }
        for (index = 0; index < partsLength; index++) {
          number = numbers[index];
          if (index === partsLength - 1) {
            if (number >= pow(256, 5 - partsLength)) return null;
          } else if (number > 255) return null;
        }
        ipv4 = pop(numbers);
        for (index = 0; index < numbers.length; index++) {
          ipv4 += numbers[index] * pow(256, 3 - index);
        }
        return ipv4;
      };
      var parseIPv6 = function(input) {
        var address = [0, 0, 0, 0, 0, 0, 0, 0];
        var pieceIndex = 0;
        var compress = null;
        var pointer = 0;
        var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
        var chr = function() {
          return charAt(input, pointer);
        };
        if (chr() === ":") {
          if (charAt(input, 1) !== ":") return;
          pointer += 2;
          pieceIndex++;
          compress = pieceIndex;
        }
        while (chr()) {
          if (pieceIndex === 8) return;
          if (chr() === ":") {
            if (compress !== null) return;
            pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
          }
          value = length = 0;
          while (length < 4 && exec(HEX, chr())) {
            value = value * 16 + parseInt2(chr(), 16);
            pointer++;
            length++;
          }
          if (chr() === ".") {
            if (length === 0) return;
            pointer -= length;
            if (pieceIndex > 6) return;
            numbersSeen = 0;
            while (chr()) {
              ipv4Piece = null;
              if (numbersSeen > 0) {
                if (chr() === "." && numbersSeen < 4) pointer++;
                else return;
              }
              if (!exec(DIGIT, chr())) return;
              while (exec(DIGIT, chr())) {
                number = parseInt2(chr(), 10);
                if (ipv4Piece === null) ipv4Piece = number;
                else if (ipv4Piece === 0) return;
                else ipv4Piece = ipv4Piece * 10 + number;
                if (ipv4Piece > 255) return;
                pointer++;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              numbersSeen++;
              if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
            }
            if (numbersSeen !== 4) return;
            break;
          } else if (chr() === ":") {
            pointer++;
            if (!chr()) return;
          } else if (chr()) return;
          address[pieceIndex++] = value;
        }
        if (compress !== null) {
          swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex !== 0 && swaps > 0) {
            swap = address[pieceIndex];
            address[pieceIndex--] = address[compress + swaps - 1];
            address[compress + --swaps] = swap;
          }
        } else if (pieceIndex !== 8) return;
        return address;
      };
      var findLongestZeroSequence = function(ipv6) {
        var maxIndex = null;
        var maxLength = 1;
        var currStart = null;
        var currLength = 0;
        var index = 0;
        for (; index < 8; index++) {
          if (ipv6[index] !== 0) {
            if (currLength > maxLength) {
              maxIndex = currStart;
              maxLength = currLength;
            }
            currStart = null;
            currLength = 0;
          } else {
            if (currStart === null) currStart = index;
            ++currLength;
          }
        }
        return currLength > maxLength ? currStart : maxIndex;
      };
      var serializeHost = function(host) {
        var result, index, compress, ignore0;
        if (typeof host == "number") {
          result = [];
          for (index = 0; index < 4; index++) {
            unshift(result, host % 256);
            host = floor(host / 256);
          }
          return join(result, ".");
        }
        if (typeof host == "object") {
          result = "";
          compress = findLongestZeroSequence(host);
          for (index = 0; index < 8; index++) {
            if (ignore0 && host[index] === 0) continue;
            if (ignore0) ignore0 = false;
            if (compress === index) {
              result += index ? ":" : "::";
              ignore0 = true;
            } else {
              result += numberToString(host[index], 16);
              if (index < 7) result += ":";
            }
          }
          return "[" + result + "]";
        }
        return host;
      };
      var C0ControlPercentEncodeSet = {};
      var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
        " ": 1,
        '"': 1,
        "<": 1,
        ">": 1,
        "`": 1
      });
      var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
        "#": 1,
        "?": 1,
        "{": 1,
        "}": 1
      });
      var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
        "/": 1,
        ":": 1,
        ";": 1,
        "=": 1,
        "@": 1,
        "[": 1,
        "\\": 1,
        "]": 1,
        "^": 1,
        "|": 1
      });
      var percentEncode = function(chr, set) {
        var code = codeAt(chr, 0);
        return code > 32 && code < 127 && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
      };
      var specialSchemes = {
        ftp: 21,
        file: null,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var isWindowsDriveLetter = function(string, normalized) {
        var second;
        return string.length === 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) === ":" || !normalized && second === "|");
      };
      var startsWithWindowsDriveLetter = function(string) {
        var third;
        return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length === 2 || ((third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#"));
      };
      var isSingleDot = function(segment) {
        return segment === "." || toLowerCase(segment) === "%2e";
      };
      var isDoubleDot = function(segment) {
        segment = toLowerCase(segment);
        return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
      };
      var SCHEME_START = {};
      var SCHEME = {};
      var NO_SCHEME = {};
      var SPECIAL_RELATIVE_OR_AUTHORITY = {};
      var PATH_OR_AUTHORITY = {};
      var RELATIVE = {};
      var RELATIVE_SLASH = {};
      var SPECIAL_AUTHORITY_SLASHES = {};
      var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
      var AUTHORITY = {};
      var HOST = {};
      var HOSTNAME = {};
      var PORT = {};
      var FILE = {};
      var FILE_SLASH = {};
      var FILE_HOST = {};
      var PATH_START = {};
      var PATH = {};
      var CANNOT_BE_A_BASE_URL_PATH = {};
      var QUERY = {};
      var FRAGMENT = {};
      var URLState = function(url, isBase, base) {
        var urlString = $toString(url);
        var baseState, failure, searchParams;
        if (isBase) {
          failure = this.parse(urlString);
          if (failure) throw new TypeError2(failure);
          this.searchParams = null;
        } else {
          if (base !== void 0) baseState = new URLState(base, true);
          failure = this.parse(urlString, null, baseState);
          if (failure) throw new TypeError2(failure);
          searchParams = getInternalSearchParamsState(new URLSearchParams2());
          searchParams.bindURL(this);
          this.searchParams = searchParams;
        }
      };
      URLState.prototype = {
        type: "URL",
        // https://url.spec.whatwg.org/#url-parsing
        // eslint-disable-next-line max-statements -- TODO
        parse: function(input, stateOverride, base) {
          var url = this;
          var state3 = stateOverride || SCHEME_START;
          var pointer = 0;
          var buffer = "";
          var seenAt = false;
          var seenBracket = false;
          var seenPasswordToken = false;
          var codePoints, chr, bufferCodePoints, failure;
          input = $toString(input);
          if (!stateOverride) {
            url.scheme = "";
            url.username = "";
            url.password = "";
            url.host = null;
            url.port = null;
            url.path = [];
            url.query = null;
            url.fragment = null;
            url.cannotBeABaseURL = false;
            input = replace(input, LEADING_C0_CONTROL_OR_SPACE, "");
            input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, "$1");
          }
          input = replace(input, TAB_AND_NEW_LINE, "");
          codePoints = arrayFrom(input);
          while (pointer <= codePoints.length) {
            chr = codePoints[pointer];
            switch (state3) {
              case SCHEME_START:
                if (chr && exec(ALPHA, chr)) {
                  buffer += toLowerCase(chr);
                  state3 = SCHEME;
                } else if (!stateOverride) {
                  state3 = NO_SCHEME;
                  continue;
                } else return INVALID_SCHEME;
                break;
              case SCHEME:
                if (chr && (exec(ALPHANUMERIC, chr) || chr === "+" || chr === "-" || chr === ".")) {
                  buffer += toLowerCase(chr);
                } else if (chr === ":") {
                  if (stateOverride && (url.isSpecial() !== hasOwn(specialSchemes, buffer) || buffer === "file" && (url.includesCredentials() || url.port !== null) || url.scheme === "file" && !url.host)) return;
                  url.scheme = buffer;
                  if (stateOverride) {
                    if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
                    return;
                  }
                  buffer = "";
                  if (url.scheme === "file") {
                    state3 = FILE;
                  } else if (url.isSpecial() && base && base.scheme === url.scheme) {
                    state3 = SPECIAL_RELATIVE_OR_AUTHORITY;
                  } else if (url.isSpecial()) {
                    state3 = SPECIAL_AUTHORITY_SLASHES;
                  } else if (codePoints[pointer + 1] === "/") {
                    state3 = PATH_OR_AUTHORITY;
                    pointer++;
                  } else {
                    url.cannotBeABaseURL = true;
                    push(url.path, "");
                    state3 = CANNOT_BE_A_BASE_URL_PATH;
                  }
                } else if (!stateOverride) {
                  buffer = "";
                  state3 = NO_SCHEME;
                  pointer = 0;
                  continue;
                } else return INVALID_SCHEME;
                break;
              case NO_SCHEME:
                if (!base || base.cannotBeABaseURL && chr !== "#") return INVALID_SCHEME;
                if (base.cannotBeABaseURL && chr === "#") {
                  url.scheme = base.scheme;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  url.cannotBeABaseURL = true;
                  state3 = FRAGMENT;
                  break;
                }
                state3 = base.scheme === "file" ? FILE : RELATIVE;
                continue;
              case SPECIAL_RELATIVE_OR_AUTHORITY:
                if (chr === "/" && codePoints[pointer + 1] === "/") {
                  state3 = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                  pointer++;
                } else {
                  state3 = RELATIVE;
                  continue;
                }
                break;
              case PATH_OR_AUTHORITY:
                if (chr === "/") {
                  state3 = AUTHORITY;
                  break;
                } else {
                  state3 = PATH;
                  continue;
                }
              case RELATIVE:
                url.scheme = base.scheme;
                if (chr === EOF) {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                } else if (chr === "/" || chr === "\\" && url.isSpecial()) {
                  state3 = RELATIVE_SLASH;
                } else if (chr === "?") {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = "";
                  state3 = QUERY;
                } else if (chr === "#") {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  state3 = FRAGMENT;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.path.length--;
                  state3 = PATH;
                  continue;
                }
                break;
              case RELATIVE_SLASH:
                if (url.isSpecial() && (chr === "/" || chr === "\\")) {
                  state3 = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                } else if (chr === "/") {
                  state3 = AUTHORITY;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  state3 = PATH;
                  continue;
                }
                break;
              case SPECIAL_AUTHORITY_SLASHES:
                state3 = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                if (chr !== "/" || charAt(buffer, pointer + 1) !== "/") continue;
                pointer++;
                break;
              case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                if (chr !== "/" && chr !== "\\") {
                  state3 = AUTHORITY;
                  continue;
                }
                break;
              case AUTHORITY:
                if (chr === "@") {
                  if (seenAt) buffer = "%40" + buffer;
                  seenAt = true;
                  bufferCodePoints = arrayFrom(buffer);
                  for (var i = 0; i < bufferCodePoints.length; i++) {
                    var codePoint = bufferCodePoints[i];
                    if (codePoint === ":" && !seenPasswordToken) {
                      seenPasswordToken = true;
                      continue;
                    }
                    var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                    if (seenPasswordToken) url.password += encodedCodePoints;
                    else url.username += encodedCodePoints;
                  }
                  buffer = "";
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                  if (seenAt && buffer === "") return INVALID_AUTHORITY;
                  pointer -= arrayFrom(buffer).length + 1;
                  buffer = "";
                  state3 = HOST;
                } else buffer += chr;
                break;
              case HOST:
              case HOSTNAME:
                if (stateOverride && url.scheme === "file") {
                  state3 = FILE_HOST;
                  continue;
                } else if (chr === ":" && !seenBracket) {
                  if (buffer === "") return INVALID_HOST;
                  failure = url.parseHost(buffer);
                  if (failure) return failure;
                  buffer = "";
                  state3 = PORT;
                  if (stateOverride === HOSTNAME) return;
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                  if (url.isSpecial() && buffer === "") return INVALID_HOST;
                  if (stateOverride && buffer === "" && (url.includesCredentials() || url.port !== null)) return;
                  failure = url.parseHost(buffer);
                  if (failure) return failure;
                  buffer = "";
                  state3 = PATH_START;
                  if (stateOverride) return;
                  continue;
                } else {
                  if (chr === "[") seenBracket = true;
                  else if (chr === "]") seenBracket = false;
                  buffer += chr;
                }
                break;
              case PORT:
                if (exec(DIGIT, chr)) {
                  buffer += chr;
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial() || stateOverride) {
                  if (buffer !== "") {
                    var port = parseInt2(buffer, 10);
                    if (port > 65535) return INVALID_PORT;
                    url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                    buffer = "";
                  }
                  if (stateOverride) return;
                  state3 = PATH_START;
                  continue;
                } else return INVALID_PORT;
                break;
              case FILE:
                url.scheme = "file";
                if (chr === "/" || chr === "\\") state3 = FILE_SLASH;
                else if (base && base.scheme === "file") {
                  switch (chr) {
                    case EOF:
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.query = base.query;
                      break;
                    case "?":
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.query = "";
                      state3 = QUERY;
                      break;
                    case "#":
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.query = base.query;
                      url.fragment = "";
                      state3 = FRAGMENT;
                      break;
                    default:
                      if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                        url.host = base.host;
                        url.path = arraySlice(base.path);
                        url.shortenPath();
                      }
                      state3 = PATH;
                      continue;
                  }
                } else {
                  state3 = PATH;
                  continue;
                }
                break;
              case FILE_SLASH:
                if (chr === "/" || chr === "\\") {
                  state3 = FILE_HOST;
                  break;
                }
                if (base && base.scheme === "file" && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                  if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
                  else url.host = base.host;
                }
                state3 = PATH;
                continue;
              case FILE_HOST:
                if (chr === EOF || chr === "/" || chr === "\\" || chr === "?" || chr === "#") {
                  if (!stateOverride && isWindowsDriveLetter(buffer)) {
                    state3 = PATH;
                  } else if (buffer === "") {
                    url.host = "";
                    if (stateOverride) return;
                    state3 = PATH_START;
                  } else {
                    failure = url.parseHost(buffer);
                    if (failure) return failure;
                    if (url.host === "localhost") url.host = "";
                    if (stateOverride) return;
                    buffer = "";
                    state3 = PATH_START;
                  }
                  continue;
                } else buffer += chr;
                break;
              case PATH_START:
                if (url.isSpecial()) {
                  state3 = PATH;
                  if (chr !== "/" && chr !== "\\") continue;
                } else if (!stateOverride && chr === "?") {
                  url.query = "";
                  state3 = QUERY;
                } else if (!stateOverride && chr === "#") {
                  url.fragment = "";
                  state3 = FRAGMENT;
                } else if (chr !== EOF) {
                  state3 = PATH;
                  if (chr !== "/") continue;
                }
                break;
              case PATH:
                if (chr === EOF || chr === "/" || chr === "\\" && url.isSpecial() || !stateOverride && (chr === "?" || chr === "#")) {
                  if (isDoubleDot(buffer)) {
                    url.shortenPath();
                    if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                      push(url.path, "");
                    }
                  } else if (isSingleDot(buffer)) {
                    if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                      push(url.path, "");
                    }
                  } else {
                    if (url.scheme === "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                      if (url.host) url.host = "";
                      buffer = charAt(buffer, 0) + ":";
                    }
                    push(url.path, buffer);
                  }
                  buffer = "";
                  if (url.scheme === "file" && (chr === EOF || chr === "?" || chr === "#")) {
                    while (url.path.length > 1 && url.path[0] === "") {
                      shift(url.path);
                    }
                  }
                  if (chr === "?") {
                    url.query = "";
                    state3 = QUERY;
                  } else if (chr === "#") {
                    url.fragment = "";
                    state3 = FRAGMENT;
                  }
                } else {
                  buffer += percentEncode(chr, pathPercentEncodeSet);
                }
                break;
              case CANNOT_BE_A_BASE_URL_PATH:
                if (chr === "?") {
                  url.query = "";
                  state3 = QUERY;
                } else if (chr === "#") {
                  url.fragment = "";
                  state3 = FRAGMENT;
                } else if (chr !== EOF) {
                  url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
                }
                break;
              case QUERY:
                if (!stateOverride && chr === "#") {
                  url.fragment = "";
                  state3 = FRAGMENT;
                } else if (chr !== EOF) {
                  if (chr === "'" && url.isSpecial()) url.query += "%27";
                  else if (chr === "#") url.query += "%23";
                  else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
                }
                break;
              case FRAGMENT:
                if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
                break;
            }
            pointer++;
          }
        },
        // https://url.spec.whatwg.org/#host-parsing
        parseHost: function(input) {
          var result, codePoints, index;
          if (charAt(input, 0) === "[") {
            if (charAt(input, input.length - 1) !== "]") return INVALID_HOST;
            result = parseIPv6(stringSlice(input, 1, -1));
            if (!result) return INVALID_HOST;
            this.host = result;
          } else if (!this.isSpecial()) {
            if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
            result = "";
            codePoints = arrayFrom(input);
            for (index = 0; index < codePoints.length; index++) {
              result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
            }
            this.host = result;
          } else {
            input = toASCII(input);
            if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
            result = parseIPv4(input);
            if (result === null) return INVALID_HOST;
            this.host = result;
          }
        },
        // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
        cannotHaveUsernamePasswordPort: function() {
          return !this.host || this.cannotBeABaseURL || this.scheme === "file";
        },
        // https://url.spec.whatwg.org/#include-credentials
        includesCredentials: function() {
          return this.username !== "" || this.password !== "";
        },
        // https://url.spec.whatwg.org/#is-special
        isSpecial: function() {
          return hasOwn(specialSchemes, this.scheme);
        },
        // https://url.spec.whatwg.org/#shorten-a-urls-path
        shortenPath: function() {
          var path = this.path;
          var pathSize = path.length;
          if (pathSize && (this.scheme !== "file" || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
            path.length--;
          }
        },
        // https://url.spec.whatwg.org/#concept-url-serializer
        serialize: function() {
          var url = this;
          var scheme = url.scheme;
          var username = url.username;
          var password = url.password;
          var host = url.host;
          var port = url.port;
          var path = url.path;
          var query = url.query;
          var fragment = url.fragment;
          var output = scheme + ":";
          if (host !== null) {
            output += "//";
            if (url.includesCredentials()) {
              output += username + (password ? ":" + password : "") + "@";
            }
            output += serializeHost(host);
            if (port !== null) output += ":" + port;
          } else if (scheme === "file") output += "//";
          output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
          if (query !== null) output += "?" + query;
          if (fragment !== null) output += "#" + fragment;
          return output;
        },
        // https://url.spec.whatwg.org/#dom-url-href
        setHref: function(href) {
          var failure = this.parse(href);
          if (failure) throw new TypeError2(failure);
          this.searchParams.update();
        },
        // https://url.spec.whatwg.org/#dom-url-origin
        getOrigin: function() {
          var scheme = this.scheme;
          var port = this.port;
          if (scheme === "blob") try {
            return new URLConstructor(scheme.path[0]).origin;
          } catch (error) {
            return "null";
          }
          if (scheme === "file" || !this.isSpecial()) return "null";
          return scheme + "://" + serializeHost(this.host) + (port !== null ? ":" + port : "");
        },
        // https://url.spec.whatwg.org/#dom-url-protocol
        getProtocol: function() {
          return this.scheme + ":";
        },
        setProtocol: function(protocol) {
          this.parse($toString(protocol) + ":", SCHEME_START);
        },
        // https://url.spec.whatwg.org/#dom-url-username
        getUsername: function() {
          return this.username;
        },
        setUsername: function(username) {
          var codePoints = arrayFrom($toString(username));
          if (this.cannotHaveUsernamePasswordPort()) return;
          this.username = "";
          for (var i = 0; i < codePoints.length; i++) {
            this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
          }
        },
        // https://url.spec.whatwg.org/#dom-url-password
        getPassword: function() {
          return this.password;
        },
        setPassword: function(password) {
          var codePoints = arrayFrom($toString(password));
          if (this.cannotHaveUsernamePasswordPort()) return;
          this.password = "";
          for (var i = 0; i < codePoints.length; i++) {
            this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
          }
        },
        // https://url.spec.whatwg.org/#dom-url-host
        getHost: function() {
          var host = this.host;
          var port = this.port;
          return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
        },
        setHost: function(host) {
          if (this.cannotBeABaseURL) return;
          this.parse(host, HOST);
        },
        // https://url.spec.whatwg.org/#dom-url-hostname
        getHostname: function() {
          var host = this.host;
          return host === null ? "" : serializeHost(host);
        },
        setHostname: function(hostname) {
          if (this.cannotBeABaseURL) return;
          this.parse(hostname, HOSTNAME);
        },
        // https://url.spec.whatwg.org/#dom-url-port
        getPort: function() {
          var port = this.port;
          return port === null ? "" : $toString(port);
        },
        setPort: function(port) {
          if (this.cannotHaveUsernamePasswordPort()) return;
          port = $toString(port);
          if (port === "") this.port = null;
          else this.parse(port, PORT);
        },
        // https://url.spec.whatwg.org/#dom-url-pathname
        getPathname: function() {
          var path = this.path;
          return this.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
        },
        setPathname: function(pathname) {
          if (this.cannotBeABaseURL) return;
          this.path = [];
          this.parse(pathname, PATH_START);
        },
        // https://url.spec.whatwg.org/#dom-url-search
        getSearch: function() {
          var query = this.query;
          return query ? "?" + query : "";
        },
        setSearch: function(search) {
          search = $toString(search);
          if (search === "") {
            this.query = null;
          } else {
            if (charAt(search, 0) === "?") search = stringSlice(search, 1);
            this.query = "";
            this.parse(search, QUERY);
          }
          this.searchParams.update();
        },
        // https://url.spec.whatwg.org/#dom-url-searchparams
        getSearchParams: function() {
          return this.searchParams.facade;
        },
        // https://url.spec.whatwg.org/#dom-url-hash
        getHash: function() {
          var fragment = this.fragment;
          return fragment ? "#" + fragment : "";
        },
        setHash: function(hash) {
          hash = $toString(hash);
          if (hash === "") {
            this.fragment = null;
            return;
          }
          if (charAt(hash, 0) === "#") hash = stringSlice(hash, 1);
          this.fragment = "";
          this.parse(hash, FRAGMENT);
        },
        update: function() {
          this.query = this.searchParams.serialize() || null;
        }
      };
      var URLConstructor = function URL2(url) {
        var that = anInstance(this, URLPrototype);
        var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : void 0;
        var state3 = setInternalState(that, new URLState(url, false, base));
        if (!DESCRIPTORS) {
          that.href = state3.serialize();
          that.origin = state3.getOrigin();
          that.protocol = state3.getProtocol();
          that.username = state3.getUsername();
          that.password = state3.getPassword();
          that.host = state3.getHost();
          that.hostname = state3.getHostname();
          that.port = state3.getPort();
          that.pathname = state3.getPathname();
          that.search = state3.getSearch();
          that.searchParams = state3.getSearchParams();
          that.hash = state3.getHash();
        }
      };
      var URLPrototype = URLConstructor.prototype;
      var accessorDescriptor = function(getter, setter) {
        return {
          get: function() {
            return getInternalURLState(this)[getter]();
          },
          set: setter && function(value) {
            return getInternalURLState(this)[setter](value);
          },
          configurable: true,
          enumerable: true
        };
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(URLPrototype, "href", accessorDescriptor("serialize", "setHref"));
        defineBuiltInAccessor(URLPrototype, "origin", accessorDescriptor("getOrigin"));
        defineBuiltInAccessor(URLPrototype, "protocol", accessorDescriptor("getProtocol", "setProtocol"));
        defineBuiltInAccessor(URLPrototype, "username", accessorDescriptor("getUsername", "setUsername"));
        defineBuiltInAccessor(URLPrototype, "password", accessorDescriptor("getPassword", "setPassword"));
        defineBuiltInAccessor(URLPrototype, "host", accessorDescriptor("getHost", "setHost"));
        defineBuiltInAccessor(URLPrototype, "hostname", accessorDescriptor("getHostname", "setHostname"));
        defineBuiltInAccessor(URLPrototype, "port", accessorDescriptor("getPort", "setPort"));
        defineBuiltInAccessor(URLPrototype, "pathname", accessorDescriptor("getPathname", "setPathname"));
        defineBuiltInAccessor(URLPrototype, "search", accessorDescriptor("getSearch", "setSearch"));
        defineBuiltInAccessor(URLPrototype, "searchParams", accessorDescriptor("getSearchParams"));
        defineBuiltInAccessor(URLPrototype, "hash", accessorDescriptor("getHash", "setHash"));
      }
      defineBuiltIn(URLPrototype, "toJSON", function toJSON() {
        return getInternalURLState(this).serialize();
      }, { enumerable: true });
      defineBuiltIn(URLPrototype, "toString", function toString() {
        return getInternalURLState(this).serialize();
      }, { enumerable: true });
      if (NativeURL) {
        nativeCreateObjectURL = NativeURL.createObjectURL;
        nativeRevokeObjectURL = NativeURL.revokeObjectURL;
        if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, "createObjectURL", bind2(nativeCreateObjectURL, NativeURL));
        if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, "revokeObjectURL", bind2(nativeRevokeObjectURL, NativeURL));
      }
      var nativeCreateObjectURL;
      var nativeRevokeObjectURL;
      setToStringTag(URLConstructor, "URL");
      $({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
        URL: URLConstructor
      });
    }
  });

  // node_modules/core-js/modules/web.url.js
  var require_web_url = __commonJS({
    "node_modules/core-js/modules/web.url.js"() {
      "use strict";
      require_web_url_constructor();
    }
  });

  // node_modules/core-js/modules/web.url.can-parse.js
  var require_web_url_can_parse = __commonJS({
    "node_modules/core-js/modules/web.url.can-parse.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var fails = require_fails();
      var validateArgumentsLength = require_validate_arguments_length();
      var toString = require_to_string();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var URL2 = getBuiltIn("URL");
      var THROWS_WITHOUT_ARGUMENTS = USE_NATIVE_URL && fails(function() {
        URL2.canParse();
      });
      var WRONG_ARITY = fails(function() {
        return URL2.canParse.length !== 1;
      });
      $({ target: "URL", stat: true, forced: !THROWS_WITHOUT_ARGUMENTS || WRONG_ARITY }, {
        canParse: function canParse(url) {
          var length = validateArgumentsLength(arguments.length, 1);
          var urlString = toString(url);
          var base = length < 2 || arguments[1] === void 0 ? void 0 : toString(arguments[1]);
          try {
            return !!new URL2(urlString, base);
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url.parse.js
  var require_web_url_parse = __commonJS({
    "node_modules/core-js/modules/web.url.parse.js"() {
      "use strict";
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var validateArgumentsLength = require_validate_arguments_length();
      var toString = require_to_string();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var URL2 = getBuiltIn("URL");
      $({ target: "URL", stat: true, forced: !USE_NATIVE_URL }, {
        parse: function parse(url) {
          var length = validateArgumentsLength(arguments.length, 1);
          var urlString = toString(url);
          var base = length < 2 || arguments[1] === void 0 ? void 0 : toString(arguments[1]);
          try {
            return new URL2(urlString, base);
          } catch (error) {
            return null;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url.to-json.js
  var require_web_url_to_json = __commonJS({
    "node_modules/core-js/modules/web.url.to-json.js"() {
      "use strict";
      var $ = require_export();
      var call = require_function_call();
      $({ target: "URL", proto: true, enumerable: true }, {
        toJSON: function toJSON() {
          return call(URL.prototype.toString, this);
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url-search-params.js
  var require_web_url_search_params = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.js"() {
      "use strict";
      require_web_url_search_params_constructor();
    }
  });

  // node_modules/core-js/modules/web.url-search-params.delete.js
  var require_web_url_search_params_delete = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.delete.js"() {
      "use strict";
      var defineBuiltIn = require_define_built_in();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var $URLSearchParams = URLSearchParams;
      var URLSearchParamsPrototype = $URLSearchParams.prototype;
      var append = uncurryThis(URLSearchParamsPrototype.append);
      var $delete = uncurryThis(URLSearchParamsPrototype["delete"]);
      var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
      var push = uncurryThis([].push);
      var params = new $URLSearchParams("a=1&a=2&b=3");
      params["delete"]("a", 1);
      params["delete"]("b", void 0);
      if (params + "" !== "a=2") {
        defineBuiltIn(URLSearchParamsPrototype, "delete", function(name) {
          var length = arguments.length;
          var $value = length < 2 ? void 0 : arguments[1];
          if (length && $value === void 0) return $delete(this, name);
          var entries = [];
          forEach(this, function(v, k) {
            push(entries, { key: k, value: v });
          });
          validateArgumentsLength(length, 1);
          var key = toString(name);
          var value = toString($value);
          var index = 0;
          var dindex = 0;
          var found = false;
          var entriesLength = entries.length;
          var entry;
          while (index < entriesLength) {
            entry = entries[index++];
            if (found || entry.key === key) {
              found = true;
              $delete(this, entry.key);
            } else dindex++;
          }
          while (dindex < entriesLength) {
            entry = entries[dindex++];
            if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
          }
        }, { enumerable: true, unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/web.url-search-params.has.js
  var require_web_url_search_params_has = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.has.js"() {
      "use strict";
      var defineBuiltIn = require_define_built_in();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var $URLSearchParams = URLSearchParams;
      var URLSearchParamsPrototype = $URLSearchParams.prototype;
      var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
      var $has = uncurryThis(URLSearchParamsPrototype.has);
      var params = new $URLSearchParams("a=1");
      if (params.has("a", 2) || !params.has("a", void 0)) {
        defineBuiltIn(URLSearchParamsPrototype, "has", function has(name) {
          var length = arguments.length;
          var $value = length < 2 ? void 0 : arguments[1];
          if (length && $value === void 0) return $has(this, name);
          var values = getAll(this, name);
          validateArgumentsLength(length, 1);
          var value = toString($value);
          var index = 0;
          while (index < values.length) {
            if (values[index++] === value) return true;
          }
          return false;
        }, { enumerable: true, unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/web.url-search-params.size.js
  var require_web_url_search_params_size = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.size.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var URLSearchParamsPrototype = URLSearchParams.prototype;
      var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
      if (DESCRIPTORS && !("size" in URLSearchParamsPrototype)) {
        defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
          get: function size() {
            var count = 0;
            forEach(this, function() {
              count++;
            });
            return count;
          },
          configurable: true,
          enumerable: true
        });
      }
    }
  });

  // node_modules/core-js/stable/index.js
  var require_stable = __commonJS({
    "node_modules/core-js/stable/index.js"(exports, module) {
      "use strict";
      require_es_symbol();
      require_es_symbol_description();
      require_es_symbol_async_dispose();
      require_es_symbol_async_iterator();
      require_es_symbol_dispose();
      require_es_symbol_has_instance();
      require_es_symbol_is_concat_spreadable();
      require_es_symbol_iterator();
      require_es_symbol_match();
      require_es_symbol_match_all();
      require_es_symbol_replace();
      require_es_symbol_search();
      require_es_symbol_species();
      require_es_symbol_split();
      require_es_symbol_to_primitive();
      require_es_symbol_to_string_tag();
      require_es_symbol_unscopables();
      require_es_error_cause();
      require_es_error_is_error();
      require_es_error_to_string();
      require_es_aggregate_error();
      require_es_aggregate_error_cause();
      require_es_suppressed_error_constructor();
      require_es_array_at();
      require_es_array_concat();
      require_es_array_copy_within();
      require_es_array_every();
      require_es_array_fill();
      require_es_array_filter();
      require_es_array_find();
      require_es_array_find_index();
      require_es_array_find_last();
      require_es_array_find_last_index();
      require_es_array_flat();
      require_es_array_flat_map();
      require_es_array_for_each();
      require_es_array_from();
      require_es_array_includes();
      require_es_array_index_of();
      require_es_array_is_array();
      require_es_array_iterator();
      require_es_array_join();
      require_es_array_last_index_of();
      require_es_array_map();
      require_es_array_of();
      require_es_array_push();
      require_es_array_reduce();
      require_es_array_reduce_right();
      require_es_array_reverse();
      require_es_array_slice();
      require_es_array_some();
      require_es_array_sort();
      require_es_array_species();
      require_es_array_splice();
      require_es_array_to_reversed();
      require_es_array_to_sorted();
      require_es_array_to_spliced();
      require_es_array_unscopables_flat();
      require_es_array_unscopables_flat_map();
      require_es_array_unshift();
      require_es_array_with();
      require_es_array_buffer_constructor();
      require_es_array_buffer_is_view();
      require_es_array_buffer_slice();
      require_es_data_view();
      require_es_data_view_get_float16();
      require_es_data_view_set_float16();
      require_es_array_buffer_detached();
      require_es_array_buffer_transfer();
      require_es_array_buffer_transfer_to_fixed_length();
      require_es_date_get_year();
      require_es_date_now();
      require_es_date_set_year();
      require_es_date_to_gmt_string();
      require_es_date_to_iso_string();
      require_es_date_to_json();
      require_es_date_to_primitive();
      require_es_date_to_string();
      require_es_disposable_stack_constructor();
      require_es_escape();
      require_es_function_bind();
      require_es_function_has_instance();
      require_es_function_name();
      require_es_global_this();
      require_es_iterator_constructor();
      require_es_iterator_dispose();
      require_es_iterator_drop();
      require_es_iterator_every();
      require_es_iterator_filter();
      require_es_iterator_find();
      require_es_iterator_flat_map();
      require_es_iterator_for_each();
      require_es_iterator_from();
      require_es_iterator_map();
      require_es_iterator_reduce();
      require_es_iterator_some();
      require_es_iterator_take();
      require_es_iterator_to_array();
      require_es_json_stringify();
      require_es_json_to_string_tag();
      require_es_map();
      require_es_map_group_by();
      require_es_math_acosh();
      require_es_math_asinh();
      require_es_math_atanh();
      require_es_math_cbrt();
      require_es_math_clz32();
      require_es_math_cosh();
      require_es_math_expm1();
      require_es_math_fround();
      require_es_math_f16round();
      require_es_math_hypot();
      require_es_math_imul();
      require_es_math_log10();
      require_es_math_log1p();
      require_es_math_log2();
      require_es_math_sign();
      require_es_math_sinh();
      require_es_math_sum_precise();
      require_es_math_tanh();
      require_es_math_to_string_tag();
      require_es_math_trunc();
      require_es_number_constructor();
      require_es_number_epsilon();
      require_es_number_is_finite();
      require_es_number_is_integer();
      require_es_number_is_nan();
      require_es_number_is_safe_integer();
      require_es_number_max_safe_integer();
      require_es_number_min_safe_integer();
      require_es_number_parse_float();
      require_es_number_parse_int();
      require_es_number_to_exponential();
      require_es_number_to_fixed();
      require_es_number_to_precision();
      require_es_object_assign();
      require_es_object_create();
      require_es_object_define_getter();
      require_es_object_define_properties();
      require_es_object_define_property();
      require_es_object_define_setter();
      require_es_object_entries();
      require_es_object_freeze();
      require_es_object_from_entries();
      require_es_object_get_own_property_descriptor();
      require_es_object_get_own_property_descriptors();
      require_es_object_get_own_property_names();
      require_es_object_get_prototype_of();
      require_es_object_group_by();
      require_es_object_has_own();
      require_es_object_is();
      require_es_object_is_extensible();
      require_es_object_is_frozen();
      require_es_object_is_sealed();
      require_es_object_keys();
      require_es_object_lookup_getter();
      require_es_object_lookup_setter();
      require_es_object_prevent_extensions();
      require_es_object_proto();
      require_es_object_seal();
      require_es_object_set_prototype_of();
      require_es_object_to_string();
      require_es_object_values();
      require_es_parse_float();
      require_es_parse_int();
      require_es_promise();
      require_es_promise_all_settled();
      require_es_promise_any();
      require_es_promise_finally();
      require_es_promise_try();
      require_es_promise_with_resolvers();
      require_es_array_from_async();
      require_es_async_disposable_stack_constructor();
      require_es_async_iterator_async_dispose();
      require_es_reflect_apply();
      require_es_reflect_construct();
      require_es_reflect_define_property();
      require_es_reflect_delete_property();
      require_es_reflect_get();
      require_es_reflect_get_own_property_descriptor();
      require_es_reflect_get_prototype_of();
      require_es_reflect_has();
      require_es_reflect_is_extensible();
      require_es_reflect_own_keys();
      require_es_reflect_prevent_extensions();
      require_es_reflect_set();
      require_es_reflect_set_prototype_of();
      require_es_reflect_to_string_tag();
      require_es_regexp_constructor();
      require_es_regexp_escape();
      require_es_regexp_dot_all();
      require_es_regexp_exec();
      require_es_regexp_flags();
      require_es_regexp_sticky();
      require_es_regexp_test();
      require_es_regexp_to_string();
      require_es_set();
      require_es_set_difference_v2();
      require_es_set_intersection_v2();
      require_es_set_is_disjoint_from_v2();
      require_es_set_is_subset_of_v2();
      require_es_set_is_superset_of_v2();
      require_es_set_symmetric_difference_v2();
      require_es_set_union_v2();
      require_es_string_at_alternative();
      require_es_string_code_point_at();
      require_es_string_ends_with();
      require_es_string_from_code_point();
      require_es_string_includes();
      require_es_string_is_well_formed();
      require_es_string_iterator();
      require_es_string_match();
      require_es_string_match_all();
      require_es_string_pad_end();
      require_es_string_pad_start();
      require_es_string_raw();
      require_es_string_repeat();
      require_es_string_replace();
      require_es_string_replace_all();
      require_es_string_search();
      require_es_string_split();
      require_es_string_starts_with();
      require_es_string_substr();
      require_es_string_to_well_formed();
      require_es_string_trim();
      require_es_string_trim_end();
      require_es_string_trim_start();
      require_es_string_anchor();
      require_es_string_big();
      require_es_string_blink();
      require_es_string_bold();
      require_es_string_fixed();
      require_es_string_fontcolor();
      require_es_string_fontsize();
      require_es_string_italics();
      require_es_string_link();
      require_es_string_small();
      require_es_string_strike();
      require_es_string_sub();
      require_es_string_sup();
      require_es_typed_array_float32_array();
      require_es_typed_array_float64_array();
      require_es_typed_array_int8_array();
      require_es_typed_array_int16_array();
      require_es_typed_array_int32_array();
      require_es_typed_array_uint8_array();
      require_es_typed_array_uint8_clamped_array();
      require_es_typed_array_uint16_array();
      require_es_typed_array_uint32_array();
      require_es_typed_array_at();
      require_es_typed_array_copy_within();
      require_es_typed_array_every();
      require_es_typed_array_fill();
      require_es_typed_array_filter();
      require_es_typed_array_find();
      require_es_typed_array_find_index();
      require_es_typed_array_find_last();
      require_es_typed_array_find_last_index();
      require_es_typed_array_for_each();
      require_es_typed_array_from();
      require_es_typed_array_includes();
      require_es_typed_array_index_of();
      require_es_typed_array_iterator();
      require_es_typed_array_join();
      require_es_typed_array_last_index_of();
      require_es_typed_array_map();
      require_es_typed_array_of();
      require_es_typed_array_reduce();
      require_es_typed_array_reduce_right();
      require_es_typed_array_reverse();
      require_es_typed_array_set();
      require_es_typed_array_slice();
      require_es_typed_array_some();
      require_es_typed_array_sort();
      require_es_typed_array_subarray();
      require_es_typed_array_to_locale_string();
      require_es_typed_array_to_reversed();
      require_es_typed_array_to_sorted();
      require_es_typed_array_to_string();
      require_es_typed_array_with();
      require_es_uint8_array_from_base64();
      require_es_uint8_array_from_hex();
      require_es_uint8_array_set_from_base64();
      require_es_uint8_array_set_from_hex();
      require_es_uint8_array_to_base64();
      require_es_uint8_array_to_hex();
      require_es_unescape();
      require_es_weak_map();
      require_es_weak_set();
      require_web_atob();
      require_web_btoa();
      require_web_dom_collections_for_each();
      require_web_dom_collections_iterator();
      require_web_dom_exception_constructor();
      require_web_dom_exception_stack();
      require_web_dom_exception_to_string_tag();
      require_web_immediate();
      require_web_queue_microtask();
      require_web_self();
      require_web_structured_clone();
      require_web_timers();
      require_web_url();
      require_web_url_can_parse();
      require_web_url_parse();
      require_web_url_to_json();
      require_web_url_search_params();
      require_web_url_search_params_delete();
      require_web_url_search_params_has();
      require_web_url_search_params_size();
      module.exports = require_path();
    }
  });

  // node_modules/regenerator-runtime/runtime.js
  var require_runtime = __commonJS({
    "node_modules/regenerator-runtime/runtime.js"(exports, module) {
      var runtime = (function(exports2) {
        "use strict";
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var defineProperty = Object.defineProperty || function(obj, key, desc) {
          obj[key] = desc.value;
        };
        var undefined2;
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define(obj, key, value) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
          return obj[key];
        }
        try {
          define({}, "");
        } catch (err) {
          define = function(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context2 = new Context(tryLocsList || []);
          defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context2) });
          return generator;
        }
        exports2.wrap = wrap;
        function tryCatch(fn, obj, arg) {
          try {
            return { type: "normal", arg: fn.call(obj, arg) };
          } catch (err) {
            return { type: "throw", arg: err };
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = GeneratorFunctionPrototype;
        defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
        defineProperty(
          GeneratorFunctionPrototype,
          "constructor",
          { value: GeneratorFunction, configurable: true }
        );
        GeneratorFunction.displayName = define(
          GeneratorFunctionPrototype,
          toStringTagSymbol,
          "GeneratorFunction"
        );
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            define(prototype, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        exports2.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports2.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports2.awrap = function(arg) {
          return { __await: arg };
        };
        function AsyncIterator2(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function(value2) {
                  invoke("next", value2, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                });
              }
              return PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped;
                resolve(result);
              }, function(error) {
                return invoke("throw", error, resolve, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = // If enqueue has been called before, then we want to wait until
            // all previous Promises have been resolved before calling invoke,
            // so that results are always delivered in the correct order. If
            // enqueue has not been called before, then it is important to
            // call invoke immediately, without waiting on a callback to fire,
            // so that the async generator function has the opportunity to do
            // any necessary setup in a predictable way. This predictability
            // is why the Promise constructor synchronously invokes its
            // executor callback, and why async functions synchronously
            // execute code before the first await. Since we implement simple
            // async functions in terms of async generators, it is especially
            // important to get this right, even though it requires care.
            previousPromise ? previousPromise.then(
              callInvokeWithMethodAndArg,
              // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg
            ) : callInvokeWithMethodAndArg();
          }
          defineProperty(this, "_invoke", { value: enqueue });
        }
        defineIteratorMethods(AsyncIterator2.prototype);
        define(AsyncIterator2.prototype, asyncIteratorSymbol, function() {
          return this;
        });
        exports2.AsyncIterator = AsyncIterator2;
        exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0) PromiseImpl = Promise;
          var iter = new AsyncIterator2(
            wrap(innerFn, outerFn, self2, tryLocsList),
            PromiseImpl
          );
          return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self2, context2) {
          var state3 = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state3 === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state3 === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context2.method = method;
            context2.arg = arg;
            while (true) {
              var delegate = context2.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context2);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }
              if (context2.method === "next") {
                context2.sent = context2._sent = context2.arg;
              } else if (context2.method === "throw") {
                if (state3 === GenStateSuspendedStart) {
                  state3 = GenStateCompleted;
                  throw context2.arg;
                }
                context2.dispatchException(context2.arg);
              } else if (context2.method === "return") {
                context2.abrupt("return", context2.arg);
              }
              state3 = GenStateExecuting;
              var record = tryCatch(innerFn, self2, context2);
              if (record.type === "normal") {
                state3 = context2.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return {
                  value: record.arg,
                  done: context2.done
                };
              } else if (record.type === "throw") {
                state3 = GenStateCompleted;
                context2.method = "throw";
                context2.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context2) {
          var methodName = context2.method;
          var method = delegate.iterator[methodName];
          if (method === undefined2) {
            context2.delegate = null;
            if (methodName === "throw" && delegate.iterator["return"]) {
              context2.method = "return";
              context2.arg = undefined2;
              maybeInvokeDelegate(delegate, context2);
              if (context2.method === "throw") {
                return ContinueSentinel;
              }
            }
            if (methodName !== "return") {
              context2.method = "throw";
              context2.arg = new TypeError(
                "The iterator does not provide a '" + methodName + "' method"
              );
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context2.arg);
          if (record.type === "throw") {
            context2.method = "throw";
            context2.arg = record.arg;
            context2.delegate = null;
            return ContinueSentinel;
          }
          var info = record.arg;
          if (!info) {
            context2.method = "throw";
            context2.arg = new TypeError("iterator result is not an object");
            context2.delegate = null;
            return ContinueSentinel;
          }
          if (info.done) {
            context2[delegate.resultName] = info.value;
            context2.next = delegate.nextLoc;
            if (context2.method !== "return") {
              context2.method = "next";
              context2.arg = undefined2;
            }
          } else {
            return info;
          }
          context2.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        define(Gp, toStringTagSymbol, "Generator");
        define(Gp, iteratorSymbol, function() {
          return this;
        });
        define(Gp, "toString", function() {
          return "[object Generator]";
        });
        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] };
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{ tryLoc: "root" }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports2.keys = function(val) {
          var object = Object(val);
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();
          return function next() {
            while (keys.length) {
              var key2 = keys.pop();
              if (key2 in object) {
                next.value = key2;
                next.done = false;
                return next;
              }
            }
            next.done = true;
            return next;
          };
        };
        function values(iterable) {
          if (iterable != null) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next2.value = iterable[i];
                    next2.done = false;
                    return next2;
                  }
                }
                next2.value = undefined2;
                next2.done = true;
                return next2;
              };
              return next.next = next;
            }
          }
          throw new TypeError(typeof iterable + " is not iterable");
        }
        exports2.values = values;
        function doneResult() {
          return { value: undefined2, done: true };
        }
        Context.prototype = {
          constructor: Context,
          reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            this.sent = this._sent = undefined2;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined2;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
              for (var name in this) {
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                  this[name] = undefined2;
                }
              }
            }
          },
          stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }
            return this.rval;
          },
          dispatchException: function(exception) {
            if (this.done) {
              throw exception;
            }
            var context2 = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context2.next = loc;
              if (caught) {
                context2.method = "next";
                context2.arg = undefined2;
              }
              return !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;
              if (entry.tryLoc === "root") {
                return handle("end");
              }
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },
          abrupt: function(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }
            return this.complete(record);
          },
          complete: function(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }
            return ContinueSentinel;
          },
          finish: function(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },
          "catch": function(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            };
            if (this.method === "next") {
              this.arg = undefined2;
            }
            return ContinueSentinel;
          }
        };
        return exports2;
      })(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        typeof module === "object" ? module.exports : {}
      );
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/deepmerge/dist/cjs.js
  var require_cjs = __commonJS({
    "node_modules/deepmerge/dist/cjs.js"(exports, module) {
      "use strict";
      var isMergeableObject = function isMergeableObject2(value) {
        return isNonNullObject(value) && !isSpecial(value);
      };
      function isNonNullObject(value) {
        return !!value && typeof value === "object";
      }
      function isSpecial(value) {
        var stringValue = Object.prototype.toString.call(value);
        return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
      }
      var canUseSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
      function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE;
      }
      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }
      function cloneUnlessOtherwiseSpecified(value, options) {
        return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
      }
      function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function(element) {
          return cloneUnlessOtherwiseSpecified(element, options);
        });
      }
      function getMergeFunction(key, options) {
        if (!options.customMerge) {
          return deepmerge;
        }
        var customMerge = options.customMerge(key);
        return typeof customMerge === "function" ? customMerge : deepmerge;
      }
      function getEnumerableOwnPropertySymbols(target) {
        return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
          return Object.propertyIsEnumerable.call(target, symbol);
        }) : [];
      }
      function getKeys(target) {
        return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
      }
      function propertyIsOnObject(object, property) {
        try {
          return property in object;
        } catch (_) {
          return false;
        }
      }
      function propertyIsUnsafe(target, key) {
        return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
      }
      function mergeObject(target, source, options) {
        var destination = {};
        if (options.isMergeableObject(target)) {
          getKeys(target).forEach(function(key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
          });
        }
        getKeys(source).forEach(function(key) {
          if (propertyIsUnsafe(target, key)) {
            return;
          }
          if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
          } else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
          }
        });
        return destination;
      }
      function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject;
        options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
        if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options);
        } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options);
        } else {
          return mergeObject(target, source, options);
        }
      }
      deepmerge.all = function deepmergeAll(array, options) {
        if (!Array.isArray(array)) {
          throw new Error("first argument should be an array");
        }
        return array.reduce(function(prev, next) {
          return deepmerge(prev, next, options);
        }, {});
      };
      var deepmerge_1 = deepmerge;
      module.exports = deepmerge_1;
    }
  });

  // node_modules/@capacitor/core/dist/index.js
  var ExceptionCode, CapacitorException, getPlatformId, createCapacitor, initCapacitorGlobal, Capacitor, registerPlugin, WebPlugin, encode, decode2, CapacitorCookiesPluginWeb, CapacitorCookies, readBlobAsBase64, normalizeHttpHeaders, buildUrlParams, buildRequestInit, CapacitorHttpPluginWeb, CapacitorHttp;
  var init_dist = __esm({
    "node_modules/@capacitor/core/dist/index.js"() {
      (function(ExceptionCode2) {
        ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
        ExceptionCode2["Unavailable"] = "UNAVAILABLE";
      })(ExceptionCode || (ExceptionCode = {}));
      CapacitorException = class extends Error {
        constructor(message, code, data) {
          super(message);
          this.message = message;
          this.code = code;
          this.data = data;
        }
      };
      getPlatformId = (win) => {
        var _a, _b;
        if (win === null || win === void 0 ? void 0 : win.androidBridge) {
          return "android";
        } else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
          return "ios";
        } else {
          return "web";
        }
      };
      createCapacitor = (win) => {
        const capCustomPlatform = win.CapacitorCustomPlatform || null;
        const cap = win.Capacitor || {};
        const Plugins = cap.Plugins = cap.Plugins || {};
        const getPlatform = () => {
          return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
        };
        const isNativePlatform = () => getPlatform() !== "web";
        const isPluginAvailable = (pluginName) => {
          const plugin = registeredPlugins.get(pluginName);
          if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
            return true;
          }
          if (getPluginHeader(pluginName)) {
            return true;
          }
          return false;
        };
        const getPluginHeader = (pluginName) => {
          var _a;
          return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName);
        };
        const handleError2 = (err) => win.console.error(err);
        const registeredPlugins = /* @__PURE__ */ new Map();
        const registerPlugin2 = (pluginName, jsImplementations = {}) => {
          const registeredPlugin = registeredPlugins.get(pluginName);
          if (registeredPlugin) {
            console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
            return registeredPlugin.proxy;
          }
          const platform = getPlatform();
          const pluginHeader = getPluginHeader(pluginName);
          let jsImplementation;
          const loadPluginImplementation = () => __async(null, null, function* () {
            if (!jsImplementation && platform in jsImplementations) {
              jsImplementation = typeof jsImplementations[platform] === "function" ? jsImplementation = yield jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
            } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
              jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = yield jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
            }
            return jsImplementation;
          });
          const createPluginMethod = (impl, prop) => {
            var _a, _b;
            if (pluginHeader) {
              const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);
              if (methodHeader) {
                if (methodHeader.rtype === "promise") {
                  return (options) => cap.nativePromise(pluginName, prop.toString(), options);
                } else {
                  return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
                }
              } else if (impl) {
                return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);
              }
            } else if (impl) {
              return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
            } else {
              throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);
            }
          };
          const createPluginMethodWrapper = (prop) => {
            let remove;
            const wrapper = (...args) => {
              const p = loadPluginImplementation().then((impl) => {
                const fn = createPluginMethod(impl, prop);
                if (fn) {
                  const p2 = fn(...args);
                  remove = p2 === null || p2 === void 0 ? void 0 : p2.remove;
                  return p2;
                } else {
                  throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode.Unimplemented);
                }
              });
              if (prop === "addListener") {
                p.remove = () => __async(null, null, function* () {
                  return remove();
                });
              }
              return p;
            };
            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
            Object.defineProperty(wrapper, "name", {
              value: prop,
              writable: false,
              configurable: false
            });
            return wrapper;
          };
          const addListener = createPluginMethodWrapper("addListener");
          const removeListener = createPluginMethodWrapper("removeListener");
          const addListenerNative = (eventName, callback) => {
            const call = addListener({ eventName }, callback);
            const remove = () => __async(null, null, function* () {
              const callbackId = yield call;
              removeListener({
                eventName,
                callbackId
              }, callback);
            });
            const p = new Promise((resolve) => call.then(() => resolve({ remove })));
            p.remove = () => __async(null, null, function* () {
              console.warn(`Using addListener() without 'await' is deprecated.`);
              yield remove();
            });
            return p;
          };
          const proxy = new Proxy({}, {
            get(_, prop) {
              switch (prop) {
                // https://github.com/facebook/react/issues/20030
                case "$$typeof":
                  return void 0;
                case "toJSON":
                  return () => ({});
                case "addListener":
                  return pluginHeader ? addListenerNative : addListener;
                case "removeListener":
                  return removeListener;
                default:
                  return createPluginMethodWrapper(prop);
              }
            }
          });
          Plugins[pluginName] = proxy;
          registeredPlugins.set(pluginName, {
            name: pluginName,
            proxy,
            platforms: /* @__PURE__ */ new Set([...Object.keys(jsImplementations), ...pluginHeader ? [platform] : []])
          });
          return proxy;
        };
        if (!cap.convertFileSrc) {
          cap.convertFileSrc = (filePath) => filePath;
        }
        cap.getPlatform = getPlatform;
        cap.handleError = handleError2;
        cap.isNativePlatform = isNativePlatform;
        cap.isPluginAvailable = isPluginAvailable;
        cap.registerPlugin = registerPlugin2;
        cap.Exception = CapacitorException;
        cap.DEBUG = !!cap.DEBUG;
        cap.isLoggingEnabled = !!cap.isLoggingEnabled;
        return cap;
      };
      initCapacitorGlobal = (win) => win.Capacitor = createCapacitor(win);
      Capacitor = /* @__PURE__ */ initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      registerPlugin = Capacitor.registerPlugin;
      WebPlugin = class {
        constructor() {
          this.listeners = {};
          this.retainedEventArguments = {};
          this.windowListeners = {};
        }
        addListener(eventName, listenerFunc) {
          let firstListener = false;
          const listeners = this.listeners[eventName];
          if (!listeners) {
            this.listeners[eventName] = [];
            firstListener = true;
          }
          this.listeners[eventName].push(listenerFunc);
          const windowListener = this.windowListeners[eventName];
          if (windowListener && !windowListener.registered) {
            this.addWindowListener(windowListener);
          }
          if (firstListener) {
            this.sendRetainedArgumentsForEvent(eventName);
          }
          const remove = () => __async(this, null, function* () {
            return this.removeListener(eventName, listenerFunc);
          });
          const p = Promise.resolve({ remove });
          return p;
        }
        removeAllListeners() {
          return __async(this, null, function* () {
            this.listeners = {};
            for (const listener in this.windowListeners) {
              this.removeWindowListener(this.windowListeners[listener]);
            }
            this.windowListeners = {};
          });
        }
        notifyListeners(eventName, data, retainUntilConsumed) {
          const listeners = this.listeners[eventName];
          if (!listeners) {
            if (retainUntilConsumed) {
              let args = this.retainedEventArguments[eventName];
              if (!args) {
                args = [];
              }
              args.push(data);
              this.retainedEventArguments[eventName] = args;
            }
            return;
          }
          listeners.forEach((listener) => listener(data));
        }
        hasListeners(eventName) {
          var _a;
          return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);
        }
        registerWindowListener(windowEventName, pluginEventName) {
          this.windowListeners[pluginEventName] = {
            registered: false,
            windowEventName,
            pluginEventName,
            handler: (event) => {
              this.notifyListeners(pluginEventName, event);
            }
          };
        }
        unimplemented(msg = "not implemented") {
          return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
        }
        unavailable(msg = "not available") {
          return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
        }
        removeListener(eventName, listenerFunc) {
          return __async(this, null, function* () {
            const listeners = this.listeners[eventName];
            if (!listeners) {
              return;
            }
            const index = listeners.indexOf(listenerFunc);
            this.listeners[eventName].splice(index, 1);
            if (!this.listeners[eventName].length) {
              this.removeWindowListener(this.windowListeners[eventName]);
            }
          });
        }
        addWindowListener(handle) {
          window.addEventListener(handle.windowEventName, handle.handler);
          handle.registered = true;
        }
        removeWindowListener(handle) {
          if (!handle) {
            return;
          }
          window.removeEventListener(handle.windowEventName, handle.handler);
          handle.registered = false;
        }
        sendRetainedArgumentsForEvent(eventName) {
          const args = this.retainedEventArguments[eventName];
          if (!args) {
            return;
          }
          delete this.retainedEventArguments[eventName];
          args.forEach((arg) => {
            this.notifyListeners(eventName, arg);
          });
        }
      };
      encode = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      decode2 = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
      CapacitorCookiesPluginWeb = class extends WebPlugin {
        getCookies() {
          return __async(this, null, function* () {
            const cookies = document.cookie;
            const cookieMap = {};
            cookies.split(";").forEach((cookie) => {
              if (cookie.length <= 0)
                return;
              let [key, value] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
              key = decode2(key).trim();
              value = decode2(value).trim();
              cookieMap[key] = value;
            });
            return cookieMap;
          });
        }
        setCookie(options) {
          return __async(this, null, function* () {
            try {
              const encodedKey = encode(options.key);
              const encodedValue = encode(options.value);
              const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
              const path = (options.path || "/").replace("path=", "");
              const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : "";
              document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path}; ${domain};`;
            } catch (error) {
              return Promise.reject(error);
            }
          });
        }
        deleteCookie(options) {
          return __async(this, null, function* () {
            try {
              document.cookie = `${options.key}=; Max-Age=0`;
            } catch (error) {
              return Promise.reject(error);
            }
          });
        }
        clearCookies() {
          return __async(this, null, function* () {
            try {
              const cookies = document.cookie.split(";") || [];
              for (const cookie of cookies) {
                document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${(/* @__PURE__ */ new Date()).toUTCString()};path=/`);
              }
            } catch (error) {
              return Promise.reject(error);
            }
          });
        }
        clearAllCookies() {
          return __async(this, null, function* () {
            try {
              yield this.clearCookies();
            } catch (error) {
              return Promise.reject(error);
            }
          });
        }
      };
      CapacitorCookies = registerPlugin("CapacitorCookies", {
        web: () => new CapacitorCookiesPluginWeb()
      });
      readBlobAsBase64 = (blob) => __async(null, null, function* () {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            const base64String = reader.result;
            resolve(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
          };
          reader.onerror = (error) => reject(error);
          reader.readAsDataURL(blob);
        });
      });
      normalizeHttpHeaders = (headers = {}) => {
        const originalKeys = Object.keys(headers);
        const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());
        const normalized = loweredKeys.reduce((acc, key, index) => {
          acc[key] = headers[originalKeys[index]];
          return acc;
        }, {});
        return normalized;
      };
      buildUrlParams = (params, shouldEncode = true) => {
        if (!params)
          return null;
        const output = Object.entries(params).reduce((accumulator, entry) => {
          const [key, value] = entry;
          let encodedValue;
          let item;
          if (Array.isArray(value)) {
            item = "";
            value.forEach((str) => {
              encodedValue = shouldEncode ? encodeURIComponent(str) : str;
              item += `${key}=${encodedValue}&`;
            });
            item.slice(0, -1);
          } else {
            encodedValue = shouldEncode ? encodeURIComponent(value) : value;
            item = `${key}=${encodedValue}`;
          }
          return `${accumulator}&${item}`;
        }, "");
        return output.substr(1);
      };
      buildRequestInit = (options, extra = {}) => {
        const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
        const headers = normalizeHttpHeaders(options.headers);
        const type = headers["content-type"] || "";
        if (typeof options.data === "string") {
          output.body = options.data;
        } else if (type.includes("application/x-www-form-urlencoded")) {
          const params = new URLSearchParams();
          for (const [key, value] of Object.entries(options.data || {})) {
            params.set(key, value);
          }
          output.body = params.toString();
        } else if (type.includes("multipart/form-data") || options.data instanceof FormData) {
          const form = new FormData();
          if (options.data instanceof FormData) {
            options.data.forEach((value, key) => {
              form.append(key, value);
            });
          } else {
            for (const key of Object.keys(options.data)) {
              form.append(key, options.data[key]);
            }
          }
          output.body = form;
          const headers2 = new Headers(output.headers);
          headers2.delete("content-type");
          output.headers = headers2;
        } else if (type.includes("application/json") || typeof options.data === "object") {
          output.body = JSON.stringify(options.data);
        }
        return output;
      };
      CapacitorHttpPluginWeb = class extends WebPlugin {
        /**
         * Perform an Http request given a set of options
         * @param options Options to build the HTTP request
         */
        request(options) {
          return __async(this, null, function* () {
            const requestInit = buildRequestInit(options, options.webFetchExtra);
            const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
            const url = urlParams ? `${options.url}?${urlParams}` : options.url;
            const response = yield fetch(url, requestInit);
            const contentType = response.headers.get("content-type") || "";
            let { responseType = "text" } = response.ok ? options : {};
            if (contentType.includes("application/json")) {
              responseType = "json";
            }
            let data;
            let blob;
            switch (responseType) {
              case "arraybuffer":
              case "blob":
                blob = yield response.blob();
                data = yield readBlobAsBase64(blob);
                break;
              case "json":
                data = yield response.json();
                break;
              case "document":
              case "text":
              default:
                data = yield response.text();
            }
            const headers = {};
            response.headers.forEach((value, key) => {
              headers[key] = value;
            });
            return {
              data,
              headers,
              status: response.status,
              url: response.url
            };
          });
        }
        /**
         * Perform an Http GET request given a set of options
         * @param options Options to build the HTTP request
         */
        get(options) {
          return __async(this, null, function* () {
            return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
          });
        }
        /**
         * Perform an Http POST request given a set of options
         * @param options Options to build the HTTP request
         */
        post(options) {
          return __async(this, null, function* () {
            return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
          });
        }
        /**
         * Perform an Http PUT request given a set of options
         * @param options Options to build the HTTP request
         */
        put(options) {
          return __async(this, null, function* () {
            return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
          });
        }
        /**
         * Perform an Http PATCH request given a set of options
         * @param options Options to build the HTTP request
         */
        patch(options) {
          return __async(this, null, function* () {
            return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
          });
        }
        /**
         * Perform an Http DELETE request given a set of options
         * @param options Options to build the HTTP request
         */
        delete(options) {
          return __async(this, null, function* () {
            return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
          });
        }
      };
      CapacitorHttp = registerPlugin("CapacitorHttp", {
        web: () => new CapacitorHttpPluginWeb()
      });
    }
  });

  // node_modules/@capacitor/app/dist/esm/web.js
  var web_exports = {};
  __export(web_exports, {
    AppWeb: () => AppWeb
  });
  var AppWeb;
  var init_web = __esm({
    "node_modules/@capacitor/app/dist/esm/web.js"() {
      init_dist();
      AppWeb = class extends WebPlugin {
        constructor() {
          super();
          this.handleVisibilityChange = () => {
            const data = {
              isActive: document.hidden !== true
            };
            this.notifyListeners("appStateChange", data);
            if (document.hidden) {
              this.notifyListeners("pause", null);
            } else {
              this.notifyListeners("resume", null);
            }
          };
          document.addEventListener("visibilitychange", this.handleVisibilityChange, false);
        }
        exitApp() {
          throw this.unimplemented("Not implemented on web.");
        }
        getInfo() {
          return __async(this, null, function* () {
            throw this.unimplemented("Not implemented on web.");
          });
        }
        getLaunchUrl() {
          return __async(this, null, function* () {
            return { url: "" };
          });
        }
        getState() {
          return __async(this, null, function* () {
            return { isActive: document.hidden !== true };
          });
        }
        minimizeApp() {
          return __async(this, null, function* () {
            throw this.unimplemented("Not implemented on web.");
          });
        }
        toggleBackButtonHandler() {
          return __async(this, null, function* () {
            throw this.unimplemented("Not implemented on web.");
          });
        }
      };
    }
  });

  // src/polyfills.ts
  var import_stable = __toESM(require_stable());
  var import_runtime = __toESM(require_runtime());

  // node_modules/whatwg-fetch/fetch.js
  var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
  typeof global !== "undefined" && global || {};
  var support = {
    searchParams: "URLSearchParams" in g,
    iterable: "Symbol" in g && "iterator" in Symbol,
    blob: "FileReader" in g && "Blob" in g && (function() {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    })(),
    formData: "FormData" in g,
    arrayBuffer: "ArrayBuffer" in g
  };
  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj);
  }
  if (support.arrayBuffer) {
    viewClasses = [
      "[object Int8Array]",
      "[object Uint8Array]",
      "[object Uint8ClampedArray]",
      "[object Int16Array]",
      "[object Uint16Array]",
      "[object Int32Array]",
      "[object Uint32Array]",
      "[object Float32Array]",
      "[object Float64Array]"
    ];
    isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
  }
  var viewClasses;
  var isArrayBufferView;
  function normalizeName(name) {
    if (typeof name !== "string") {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
      throw new TypeError('Invalid character in header field name: "' + name + '"');
    }
    return name.toLowerCase();
  }
  function normalizeValue(value) {
    if (typeof value !== "string") {
      value = String(value);
    }
    return value;
  }
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return { done: value === void 0, value };
      }
    };
    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator;
      };
    }
    return iterator;
  }
  function Headers2(headers) {
    this.map = {};
    if (headers instanceof Headers2) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        if (header.length != 2) {
          throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
        }
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }
  Headers2.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ", " + value : value;
  };
  Headers2.prototype["delete"] = function(name) {
    delete this.map[normalizeName(name)];
  };
  Headers2.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
  };
  Headers2.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };
  Headers2.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };
  Headers2.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };
  Headers2.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  };
  Headers2.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items);
  };
  Headers2.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  };
  if (support.iterable) {
    Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
  }
  function consumed(body) {
    if (body._noBody) return;
    if (body.bodyUsed) {
      return Promise.reject(new TypeError("Already read"));
    }
    body.bodyUsed = true;
  }
  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    });
  }
  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
  }
  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
    var encoding = match ? match[1] : "utf-8";
    reader.readAsText(blob, encoding);
    return promise;
  }
  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);
    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join("");
  }
  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0);
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer;
    }
  }
  function Body() {
    this.bodyUsed = false;
    this._initBody = function(body) {
      this.bodyUsed = this.bodyUsed;
      this._bodyInit = body;
      if (!body) {
        this._noBody = true;
        this._bodyText = "";
      } else if (typeof body === "string") {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }
      if (!this.headers.get("content-type")) {
        if (typeof body === "string") {
          this.headers.set("content-type", "text/plain;charset=UTF-8");
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set("content-type", this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
        }
      }
    };
    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }
        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        } else if (this._bodyFormData) {
          throw new Error("could not read FormData body as blob");
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };
    }
    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);
        if (isConsumed) {
          return isConsumed;
        } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          );
        } else {
          return Promise.resolve(this._bodyArrayBuffer);
        }
      } else if (support.blob) {
        return this.blob().then(readBlobAsArrayBuffer);
      } else {
        throw new Error("could not read as ArrayBuffer");
      }
    };
    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as text");
      } else {
        return Promise.resolve(this._bodyText);
      }
    };
    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode);
      };
    }
    this.json = function() {
      return this.text().then(JSON.parse);
    };
    return this;
  }
  var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }
  function Request(input, options) {
    if (!(this instanceof Request)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    options = options || {};
    var body = options.body;
    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError("Already read");
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers2(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }
    this.credentials = options.credentials || this.credentials || "same-origin";
    if (options.headers || !this.headers) {
      this.headers = new Headers2(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || "GET");
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal || (function() {
      if ("AbortController" in g) {
        var ctrl = new AbortController();
        return ctrl.signal;
      }
    })();
    this.referrer = null;
    if ((this.method === "GET" || this.method === "HEAD") && body) {
      throw new TypeError("Body not allowed for GET or HEAD requests");
    }
    this._initBody(body);
    if (this.method === "GET" || this.method === "HEAD") {
      if (options.cache === "no-store" || options.cache === "no-cache") {
        var reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
        } else {
          var reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
        }
      }
    }
  }
  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit });
  };
  function decode(body) {
    var form = new FormData();
    body.trim().split("&").forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split("=");
        var name = split.shift().replace(/\+/g, " ");
        var value = split.join("=").replace(/\+/g, " ");
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }
  function parseHeaders(rawHeaders) {
    var headers = new Headers2();
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
    preProcessedHeaders.split("\r").map(function(header) {
      return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
    }).forEach(function(line) {
      var parts = line.split(":");
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(":").trim();
        try {
          headers.append(key, value);
        } catch (error) {
          console.warn("Response " + error.message);
        }
      }
    });
    return headers;
  }
  Body.call(Request.prototype);
  function Response(bodyInit, options) {
    if (!(this instanceof Response)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    if (!options) {
      options = {};
    }
    this.type = "default";
    this.status = options.status === void 0 ? 200 : options.status;
    if (this.status < 200 || this.status > 599) {
      throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
    }
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
    this.headers = new Headers2(options.headers);
    this.url = options.url || "";
    this._initBody(bodyInit);
  }
  Body.call(Response.prototype);
  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers2(this.headers),
      url: this.url
    });
  };
  Response.error = function() {
    var response = new Response(null, { status: 200, statusText: "" });
    response.ok = false;
    response.status = 0;
    response.type = "error";
    return response;
  };
  var redirectStatuses = [301, 302, 303, 307, 308];
  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError("Invalid status code");
    }
    return new Response(null, { status, headers: { location: url } });
  };
  var DOMException = g.DOMException;
  try {
    new DOMException();
  } catch (err) {
    DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    DOMException.prototype = Object.create(Error.prototype);
    DOMException.prototype.constructor = DOMException;
  }
  function fetch2(input, init2) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init2);
      if (request.signal && request.signal.aborted) {
        return reject(new DOMException("Aborted", "AbortError"));
      }
      var xhr = new XMLHttpRequest();
      function abortXhr() {
        xhr.abort();
      }
      xhr.onload = function() {
        var options = {
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || "")
        };
        if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
          options.status = 200;
        } else {
          options.status = xhr.status;
        }
        options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
        var body = "response" in xhr ? xhr.response : xhr.responseText;
        setTimeout(function() {
          resolve(new Response(body, options));
        }, 0);
      };
      xhr.onerror = function() {
        setTimeout(function() {
          reject(new TypeError("Network request failed"));
        }, 0);
      };
      xhr.ontimeout = function() {
        setTimeout(function() {
          reject(new TypeError("Network request timed out"));
        }, 0);
      };
      xhr.onabort = function() {
        setTimeout(function() {
          reject(new DOMException("Aborted", "AbortError"));
        }, 0);
      };
      function fixUrl(url) {
        try {
          return url === "" && g.location.href ? g.location.href : url;
        } catch (e) {
          return url;
        }
      }
      xhr.open(request.method, fixUrl(request.url), true);
      if (request.credentials === "include") {
        xhr.withCredentials = true;
      } else if (request.credentials === "omit") {
        xhr.withCredentials = false;
      }
      if ("responseType" in xhr) {
        if (support.blob) {
          xhr.responseType = "blob";
        } else if (support.arrayBuffer) {
          xhr.responseType = "arraybuffer";
        }
      }
      if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers2 || g.Headers && init2.headers instanceof g.Headers)) {
        var names = [];
        Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
          names.push(normalizeName(name));
          xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
        });
        request.headers.forEach(function(value, name) {
          if (names.indexOf(name) === -1) {
            xhr.setRequestHeader(name, value);
          }
        });
      } else {
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
      }
      if (request.signal) {
        request.signal.addEventListener("abort", abortXhr);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            request.signal.removeEventListener("abort", abortXhr);
          }
        };
      }
      xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
    });
  }
  fetch2.polyfill = true;
  if (!g.fetch) {
    g.fetch = fetch2;
    g.Headers = Headers2;
    g.Request = Request;
    g.Response = Response;
  }

  // src/index.ts
  var import_stable2 = __toESM(require_stable());
  var import_runtime41 = __toESM(require_runtime());

  // node_modules/@lightningjs/sdk/src/Settings/index.js
  var settings = {};
  var subscribers = {};
  var initSettings = (appSettings, platformSettings) => {
    settings["app"] = appSettings;
    settings["platform"] = platformSettings;
    settings["user"] = {};
  };
  var publish = (key, value) => {
    subscribers[key] && subscribers[key].forEach((subscriber) => subscriber(value));
  };
  var dotGrab = (obj = {}, key) => {
    if (obj === null) return void 0;
    const keys = key.split(".");
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== void 0 ? obj[keys[i]] : {};
    }
    return typeof obj === "object" && obj !== null ? Object.keys(obj).length ? obj : void 0 : obj;
  };
  var Settings_default = {
    get(type, key, fallback = void 0) {
      const val = dotGrab(settings[type], key);
      return val !== void 0 ? val : fallback;
    },
    has(type, key) {
      return !!this.get(type, key);
    },
    set(key, value) {
      settings["user"][key] = value;
      publish(key, value);
    },
    subscribe(key, callback) {
      subscribers[key] = subscribers[key] || [];
      subscribers[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index = subscribers[key] && subscribers[key].findIndex((cb) => cb === callback);
        index > -1 && subscribers[key].splice(index, 1);
      } else {
        if (key in subscribers) {
          subscribers[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers)) {
        delete subscribers[key];
      }
    }
  };

  // node_modules/@lightningjs/sdk/src/Log/index.js
  var prepLog = (type, args) => {
    const colors2 = {
      Info: "green",
      Debug: "gray",
      Warn: "orange",
      Error: "red"
    };
    args = Array.from(args);
    return [
      "%c" + (args.length > 1 && typeof args[0] === "string" ? args.shift() : type),
      "background-color: " + colors2[type] + "; color: white; padding: 2px 4px; border-radius: 2px",
      args
    ];
  };
  var Log_default = {
    info() {
      Settings_default.get("platform", "log") && console.log.apply(console, prepLog("Info", arguments));
    },
    debug() {
      Settings_default.get("platform", "log") && console.debug.apply(console, prepLog("Debug", arguments));
    },
    error() {
      Settings_default.get("platform", "log") && console.error.apply(console, prepLog("Error", arguments));
    },
    warn() {
      Settings_default.get("platform", "log") && console.warn.apply(console, prepLog("Warn", arguments));
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/StageUtils.mjs
  var StageUtils = class _StageUtils {
    static mergeNumbers(v1, v2, p) {
      return v1 * p + v2 * (1 - p);
    }
    static rgb(r, g2, b) {
      return (r << 16) + (g2 << 8) + b + 255 * 16777216;
    }
    static rgba(r, g2, b, a) {
      return (r << 16) + (g2 << 8) + b + (a * 255 | 0) * 16777216;
    }
    static getRgbString(color) {
      let r = (color / 65536 | 0) % 256;
      let g2 = (color / 256 | 0) % 256;
      let b = color % 256;
      return "rgb(" + r + "," + g2 + "," + b + ")";
    }
    static getRgbaString(color) {
      let r = (color / 65536 | 0) % 256;
      let g2 = (color / 256 | 0) % 256;
      let b = color % 256;
      let a = (color / 16777216 | 0) / 255;
      return "rgba(" + r + "," + g2 + "," + b + "," + a.toFixed(4) + ")";
    }
    static getRgbaStringFromArray(color) {
      let r = Math.floor(color[0] * 255);
      let g2 = Math.floor(color[1] * 255);
      let b = Math.floor(color[2] * 255);
      let a = Math.floor(color[3] * 255) / 255;
      return "rgba(" + r + "," + g2 + "," + b + "," + a.toFixed(4) + ")";
    }
    static getRgbaComponentsNormalized(argb) {
      let r = (argb / 65536 | 0) % 256;
      let g2 = (argb / 256 | 0) % 256;
      let b = argb % 256;
      let a = argb / 16777216 | 0;
      return [r / 255, g2 / 255, b / 255, a / 255];
    }
    static getRgbComponentsNormalized(argb) {
      let r = (argb / 65536 | 0) % 256;
      let g2 = (argb / 256 | 0) % 256;
      let b = argb % 256;
      return [r / 255, g2 / 255, b / 255];
    }
    static getRgbaComponents(argb) {
      let r = (argb / 65536 | 0) % 256;
      let g2 = (argb / 256 | 0) % 256;
      let b = argb % 256;
      let a = argb / 16777216 | 0;
      return [r, g2, b, a];
    }
    static getArgbNumber(rgba) {
      rgba[0] = Math.max(0, Math.min(255, rgba[0]));
      rgba[1] = Math.max(0, Math.min(255, rgba[1]));
      rgba[2] = Math.max(0, Math.min(255, rgba[2]));
      rgba[3] = Math.max(0, Math.min(255, rgba[3]));
      let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
      if (v < 0) {
        v = 4294967295 + v + 1;
      }
      return v;
    }
    static mergeColors(c1, c2, p) {
      let r1 = (c1 / 65536 | 0) % 256;
      let g1 = (c1 / 256 | 0) % 256;
      let b1 = c1 % 256;
      let a1 = c1 / 16777216 | 0;
      let r2 = (c2 / 65536 | 0) % 256;
      let g2 = (c2 / 256 | 0) % 256;
      let b2 = c2 % 256;
      let a2 = c2 / 16777216 | 0;
      let r = r1 * p + r2 * (1 - p);
      let g3 = g1 * p + g2 * (1 - p);
      let b = b1 * p + b2 * (1 - p);
      let a = a1 * p + a2 * (1 - p);
      return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g3) * 256 + Math.round(b);
    }
    static mergeMultiColors(c, p) {
      let r = 0, g2 = 0, b = 0, a = 0, t = 0;
      let n = c.length;
      for (let i = 0; i < n; i++) {
        let r1 = (c[i] / 65536 | 0) % 256;
        let g1 = (c[i] / 256 | 0) % 256;
        let b1 = c[i] % 256;
        let a1 = c[i] / 16777216 | 0;
        r += r1 * p[i];
        g2 += g1 * p[i];
        b += b1 * p[i];
        a += a1 * p[i];
        t += p[i];
      }
      t = 1 / t;
      return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g2 * t) * 256 + Math.round(b * t);
    }
    static mergeMultiColorsEqual(c) {
      let r = 0, g2 = 0, b = 0, a = 0, t = 0;
      let n = c.length;
      for (let i = 0; i < n; i++) {
        let r1 = (c[i] / 65536 | 0) % 256;
        let g1 = (c[i] / 256 | 0) % 256;
        let b1 = c[i] % 256;
        let a1 = c[i] / 16777216 | 0;
        r += r1;
        g2 += g1;
        b += b1;
        a += a1;
        t += 1;
      }
      t = 1 / t;
      return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g2 * t) * 256 + Math.round(b * t);
    }
    static mergeColorAlpha(c, alpha) {
      let a = (c / 16777216 | 0) * alpha | 0;
      return ((c >> 16 & 255) * a / 255 & 255) + ((c & 65280) * a / 255 & 65280) + (((c & 255) << 16) * a / 255 & 16711680) + (a << 24);
    }
    static rad(deg) {
      return deg * (Math.PI / 180);
    }
    static getTimingBezier(a, b, c, d) {
      let xc = 3 * a;
      let xb = 3 * (c - a) - xc;
      let xa = 1 - xc - xb;
      let yc = 3 * b;
      let yb = 3 * (d - b) - yc;
      let ya = 1 - yc - yb;
      return function(time) {
        if (time >= 1) {
          return 1;
        }
        if (time <= 0) {
          return 0;
        }
        let t = 0.5, cbx, cbxd, dx;
        for (let it = 0; it < 20; it++) {
          cbx = t * (t * (t * xa + xb) + xc);
          dx = time - cbx;
          if (dx > -1e-8 && dx < 1e-8) {
            return t * (t * (t * ya + yb) + yc);
          }
          cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
          if (cbxd > 1e-10 && cbxd < 1e-10) {
            break;
          }
          t += dx / cbxd;
        }
        let minT = 0;
        let maxT = 1;
        for (let it = 0; it < 20; it++) {
          t = 0.5 * (minT + maxT);
          cbx = t * (t * (t * xa + xb) + xc);
          dx = time - cbx;
          if (dx > -1e-8 && dx < 1e-8) {
            return t * (t * (t * ya + yb) + yc);
          }
          if (dx < 0) {
            maxT = t;
          } else {
            minT = t;
          }
        }
      };
    }
    static getTimingFunction(str) {
      switch (str) {
        case "linear":
          return function(time) {
            return time;
          };
        case "ease":
          return _StageUtils.getTimingBezier(0.25, 0.1, 0.25, 1);
        case "ease-in":
          return _StageUtils.getTimingBezier(0.42, 0, 1, 1);
        case "ease-out":
          return _StageUtils.getTimingBezier(0, 0, 0.58, 1);
        case "ease-in-out":
          return _StageUtils.getTimingBezier(0.42, 0, 0.58, 1);
        case "step-start":
          return function() {
            return 1;
          };
        case "step-end":
          return function(time) {
            return time === 1 ? 1 : 0;
          };
        default:
          let s = "cubic-bezier(";
          if (str && str.indexOf(s) === 0) {
            let parts = str.substr(s.length, str.length - s.length - 1).split(",");
            if (parts.length !== 4) {
              console.warn("[Lightning] Unknown timing function: " + str);
              return function(time) {
                return time;
              };
            }
            let a = parseFloat(parts[0]);
            let b = parseFloat(parts[1]);
            let c = parseFloat(parts[2]);
            let d = parseFloat(parts[3]);
            if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d)) {
              console.warn("[Lightning] Unknown timing function: " + str);
              return function(time) {
                return time;
              };
            }
            return _StageUtils.getTimingBezier(a, b, c, d);
          } else {
            console.warn("[Lightning] Unknown timing function: " + str);
            return function(time) {
              return time;
            };
          }
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/Utils.mjs
  var Utils = class _Utils {
    static isFunction(value) {
      return typeof value === "function";
    }
    static isNumber(value) {
      return typeof value === "number";
    }
    static isInteger(value) {
      return typeof value === "number" && value % 1 === 0;
    }
    static isBoolean(value) {
      return value === true || value === false;
    }
    static isString(value) {
      return typeof value === "string";
    }
    static clone(v) {
      if (_Utils.isObjectLiteral(v) || Array.isArray(v)) {
        return _Utils.getDeepClone(v);
      } else {
        return v;
      }
    }
    static cloneObjShallow(obj) {
      let keys = Object.keys(obj);
      let clone = {};
      for (let i = 0; i < keys.length; i++) {
        clone[keys[i]] = obj[keys[i]];
      }
      return clone;
    }
    static merge(obj1, obj2) {
      let keys = Object.keys(obj2);
      for (let i = 0; i < keys.length; i++) {
        obj1[keys[i]] = obj2[keys[i]];
      }
      return obj1;
    }
    static isObject(value) {
      let type = typeof value;
      return !!value && (type === "object" || type === "function");
    }
    static isPlainObject(value) {
      let type = typeof value;
      return !!value && type === "object";
    }
    static isObjectLiteral(value) {
      return typeof value === "object" && value && value.constructor === Object;
    }
    static getArrayIndex(index, arr) {
      return _Utils.getModuloIndex(index, arr.length);
    }
    static getModuloIndex(index, len) {
      if (len === 0) return index;
      while (index < 0) {
        index += Math.ceil(-index / len) * len;
      }
      index = index % len;
      return index;
    }
    static getDeepClone(obj) {
      let i, c;
      if (_Utils.isFunction(obj)) {
        return obj;
      }
      if (Array.isArray(obj)) {
        c = [];
        let keys = Object.keys(obj);
        for (i = 0; i < keys.length; i++) {
          c[keys[i]] = _Utils.getDeepClone(obj[keys[i]]);
        }
        return c;
      } else if (_Utils.isObject(obj)) {
        c = {};
        let keys = Object.keys(obj);
        for (i = 0; i < keys.length; i++) {
          c[keys[i]] = _Utils.getDeepClone(obj[keys[i]]);
        }
        return c;
      } else {
        return obj;
      }
    }
    static equalValues(v1, v2) {
      if (typeof v1 !== typeof v2) return false;
      if (_Utils.isObjectLiteral(v1)) {
        return _Utils.isObjectLiteral(v2) && _Utils.equalObjectLiterals(v1, v2);
      } else if (Array.isArray(v1)) {
        return Array.isArray(v2) && _Utils.equalArrays(v1, v2);
      } else {
        return v1 === v2;
      }
    }
    static equalObjectLiterals(obj1, obj2) {
      let keys1 = Object.keys(obj1);
      let keys2 = Object.keys(obj2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (let i = 0, n = keys1.length; i < n; i++) {
        const k1 = keys1[i];
        const k2 = keys2[i];
        if (k1 !== k2) {
          return false;
        }
        const v1 = obj1[k1];
        const v2 = obj2[k2];
        if (!_Utils.equalValues(v1, v2)) {
          return false;
        }
      }
      return true;
    }
    static equalArrays(v1, v2) {
      if (v1.length !== v2.length) {
        return false;
      }
      for (let i = 0, n = v1.length; i < n; i++) {
        if (!this.equalValues(v1[i], v2[i])) {
          return false;
        }
      }
      return true;
    }
    static setToArray(s) {
      let result = [];
      s.forEach(function(value) {
        result.push(value);
      });
      return result;
    }
    static iteratorToArray(iterator) {
      let result = [];
      let iteratorResult = iterator.next();
      while (!iteratorResult.done) {
        result.push(iteratorResult.value);
        iteratorResult = iterator.next();
      }
      return result;
    }
    static isUcChar(charcode) {
      return charcode >= 65 && charcode <= 90;
    }
  };
  Utils.isWeb = typeof window !== "undefined" && typeof sparkscene === "undefined";
  Utils.isWPE = Utils.isWeb && navigator.userAgent.indexOf("WPE") !== -1;
  Utils.isSpark = typeof sparkscene !== "undefined";
  Utils.isNode = typeof window === "undefined" || Utils.isSpark;
  Utils.isPS4 = Utils.isWeb && navigator.userAgent.indexOf("PlayStation 4") !== -1;
  Utils.isZiggo = Utils.isWeb && (navigator.userAgent.indexOf("EOSSTB") !== -1 || navigator.userAgent.indexOf("HZNSTB") !== -1);

  // node_modules/@lightningjs/core/dist/src/tree/Base.mjs
  var Base = class _Base {
    static defaultSetter(obj, name, value) {
      obj[name] = value;
    }
    static patchObject(obj, settings2) {
      if (!Utils.isObjectLiteral(settings2)) {
        console.error("[Lightning] Settings must be object literal");
      } else {
        let names = Object.keys(settings2);
        for (let i = 0, n = names.length; i < n; i++) {
          let name = names[i];
          this.patchObjectProperty(obj, name, settings2[name]);
        }
      }
    }
    static patchObjectProperty(obj, name, value) {
      let setter = obj.setSetting || _Base.defaultSetter;
      if (name.charAt(0) === "_") {
        if (name !== "__create") {
          console.error("[Lightning] Patch of private property '" + name + "' is not allowed");
        }
      } else if (name !== "type") {
        if (Utils.isFunction(value) && value.__local) {
          value = value.__local(obj);
        }
        setter(obj, name, value);
      }
    }
    static local(func) {
      func.__local = true;
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/SpacingCalculator.mjs
  var SpacingCalculator = class {
    static getSpacing(mode, numberOfItems, remainingSpace) {
      const itemGaps = numberOfItems - 1;
      let spacePerGap;
      let spacingBefore, spacingBetween;
      switch (mode) {
        case "flex-start":
          spacingBefore = 0;
          spacingBetween = 0;
          break;
        case "flex-end":
          spacingBefore = remainingSpace;
          spacingBetween = 0;
          break;
        case "center":
          spacingBefore = remainingSpace / 2;
          spacingBetween = 0;
          break;
        case "space-between":
          spacingBefore = 0;
          spacingBetween = Math.max(0, remainingSpace) / itemGaps;
          break;
        case "space-around":
          if (remainingSpace < 0) {
            return this.getSpacing("center", numberOfItems, remainingSpace);
          } else {
            spacePerGap = remainingSpace / (itemGaps + 1);
            spacingBefore = 0.5 * spacePerGap;
            spacingBetween = spacePerGap;
          }
          break;
        case "space-evenly":
          if (remainingSpace < 0) {
            return this.getSpacing("center", numberOfItems, remainingSpace);
          } else {
            spacePerGap = remainingSpace / (itemGaps + 2);
            spacingBefore = spacePerGap;
            spacingBetween = spacePerGap;
          }
          break;
        case "stretch":
          spacingBefore = 0;
          spacingBetween = 0;
          break;
        default:
          throw new Error("Unknown mode: " + mode);
      }
      return { spacingBefore, spacingBetween };
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/ContentAligner.mjs
  var ContentAligner = class {
    constructor(layout) {
      this._layout = layout;
      this._totalCrossAxisSize = 0;
    }
    get _lines() {
      return this._layout._lines;
    }
    init() {
      this._totalCrossAxisSize = this._getTotalCrossAxisSize();
    }
    align() {
      const crossAxisSize = this._layout.crossAxisSize;
      const remainingSpace = crossAxisSize - this._totalCrossAxisSize;
      const { spacingBefore, spacingBetween } = this._getSpacing(remainingSpace);
      const lines = this._lines;
      const mode = this._layout._flexContainer.alignContent;
      let growSize = 0;
      if (mode === "stretch" && lines.length && remainingSpace > 0) {
        growSize = remainingSpace / lines.length;
      }
      let currentPos = spacingBefore;
      for (let i = 0, n = lines.length; i < n; i++) {
        const crossAxisLayoutOffset = currentPos;
        const aligner = lines[i].createItemAligner();
        let finalCrossAxisLayoutSize = lines[i].crossAxisLayoutSize + growSize;
        aligner.setCrossAxisLayoutSize(finalCrossAxisLayoutSize);
        aligner.setCrossAxisLayoutOffset(crossAxisLayoutOffset);
        aligner.align();
        if (aligner.recursiveResizeOccured) {
          lines[i].setItemPositions();
        }
        currentPos += finalCrossAxisLayoutSize;
        currentPos += spacingBetween;
      }
    }
    get totalCrossAxisSize() {
      return this._totalCrossAxisSize;
    }
    _getTotalCrossAxisSize() {
      const lines = this._lines;
      let total = 0;
      for (let i = 0, n = lines.length; i < n; i++) {
        const line = lines[i];
        total += line.crossAxisLayoutSize;
      }
      return total;
    }
    _getSpacing(remainingSpace) {
      const mode = this._layout._flexContainer.alignContent;
      const numberOfItems = this._lines.length;
      return SpacingCalculator.getSpacing(mode, numberOfItems, remainingSpace);
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/FlexUtils.mjs
  var FlexUtils = class {
    static getParentAxisSizeWithPadding(item, horizontal) {
      const target = item.target;
      const parent = target.getParent();
      if (!parent) {
        return 0;
      } else {
        const flexParent = item.flexParent;
        if (flexParent) {
          return this.getAxisLayoutSize(flexParent, horizontal) + this.getTotalPadding(flexParent, horizontal);
        } else {
          return horizontal ? parent.w : parent.h;
        }
      }
    }
    static getRelAxisSize(item, horizontal) {
      if (horizontal) {
        if (item.funcW) {
          if (this._allowRelAxisSizeFunction(item, true)) {
            return item.funcW(this.getParentAxisSizeWithPadding(item, true));
          } else {
            return 0;
          }
        } else {
          return item.originalWidth;
        }
      } else {
        if (item.funcH) {
          if (this._allowRelAxisSizeFunction(item, false)) {
            return item.funcH(this.getParentAxisSizeWithPadding(item, false));
          } else {
            return 0;
          }
        } else {
          return item.originalHeight;
        }
      }
    }
    static _allowRelAxisSizeFunction(item, horizontal) {
      const flexParent = item.flexParent;
      if (flexParent && flexParent._flex._layout.isAxisFitToContents(horizontal)) {
        return false;
      }
      return true;
    }
    static isZeroAxisSize(item, horizontal) {
      if (horizontal) {
        return !item.originalWidth && !item.funcW;
      } else {
        return !item.originalHeight && !item.funcH;
      }
    }
    static getAxisLayoutPos(item, horizontal) {
      return horizontal ? item.x : item.y;
    }
    static getAxisLayoutSize(item, horizontal) {
      return horizontal ? item.w : item.h;
    }
    static setAxisLayoutPos(item, horizontal, pos) {
      if (horizontal) {
        item.x = pos;
      } else {
        item.y = pos;
      }
    }
    static setAxisLayoutSize(item, horizontal, size) {
      if (horizontal) {
        item.w = size;
      } else {
        item.h = size;
      }
    }
    static getAxisMinSize(item, horizontal) {
      let minSize = this.getPlainAxisMinSize(item, horizontal);
      let flexItemMinSize = 0;
      if (item.isFlexItemEnabled()) {
        flexItemMinSize = item._flexItem._getMinSizeSetting(horizontal);
      }
      const hasLimitedMinSize = flexItemMinSize > 0;
      if (hasLimitedMinSize) {
        minSize = Math.max(minSize, flexItemMinSize);
      }
      return minSize;
    }
    static getPlainAxisMinSize(item, horizontal) {
      if (item.isFlexEnabled()) {
        return item._flex._layout.getAxisMinSize(horizontal);
      } else {
        const isShrinkable = item.flexItem.shrink !== 0;
        if (isShrinkable) {
          return 0;
        } else {
          return this.getRelAxisSize(item, horizontal);
        }
      }
    }
    static resizeAxis(item, horizontal, size) {
      if (item.isFlexEnabled()) {
        const isMainAxis = item._flex._horizontal === horizontal;
        if (isMainAxis) {
          item._flex._layout.resizeMainAxis(size);
        } else {
          item._flex._layout.resizeCrossAxis(size);
        }
      } else {
        this.setAxisLayoutSize(item, horizontal, size);
      }
    }
    static getPaddingOffset(item, horizontal) {
      if (item.isFlexEnabled()) {
        const flex = item._flex;
        if (horizontal) {
          return flex.paddingLeft;
        } else {
          return flex.paddingTop;
        }
      } else {
        return 0;
      }
    }
    static getTotalPadding(item, horizontal) {
      if (item.isFlexEnabled()) {
        const flex = item._flex;
        if (horizontal) {
          return flex.paddingRight + flex.paddingLeft;
        } else {
          return flex.paddingTop + flex.paddingBottom;
        }
      } else {
        return 0;
      }
    }
    static getMarginOffset(item, horizontal) {
      const flexItem = item.flexItem;
      if (flexItem) {
        if (horizontal) {
          return flexItem.marginLeft;
        } else {
          return flexItem.marginTop;
        }
      } else {
        return 0;
      }
    }
    static getTotalMargin(item, horizontal) {
      const flexItem = item.flexItem;
      if (flexItem) {
        if (horizontal) {
          return flexItem.marginRight + flexItem.marginLeft;
        } else {
          return flexItem.marginTop + flexItem.marginBottom;
        }
      } else {
        return 0;
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/line/SizeShrinker.mjs
  var SizeShrinker = class {
    constructor(line) {
      this._line = line;
      this._amountRemaining = 0;
      this._shrunkSize = 0;
    }
    shrink(amount) {
      this._shrunkSize = 0;
      this._amountRemaining = amount;
      let totalShrinkAmount = this._getTotalShrinkAmount();
      if (totalShrinkAmount) {
        const items = this._line.items;
        do {
          let amountPerShrink = this._amountRemaining / totalShrinkAmount;
          for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;
            const shrinkAmount = flexItem.shrink;
            const isShrinkableItem = shrinkAmount > 0;
            if (isShrinkableItem) {
              let shrink = shrinkAmount * amountPerShrink;
              const minSize = flexItem._getMainAxisMinSize();
              const size = flexItem._getMainAxisLayoutSize();
              if (size > minSize) {
                const maxShrink = size - minSize;
                const isFullyShrunk = shrink >= maxShrink;
                if (isFullyShrunk) {
                  shrink = maxShrink;
                  totalShrinkAmount -= shrinkAmount;
                }
                const finalSize = size - shrink;
                flexItem._resizeMainAxis(finalSize);
                this._shrunkSize += shrink;
                this._amountRemaining -= shrink;
                if (Math.abs(this._amountRemaining) < 1e-5) {
                  return;
                }
              }
            }
          }
        } while (totalShrinkAmount && Math.abs(this._amountRemaining) > 1e-5);
      }
    }
    _getTotalShrinkAmount() {
      let total = 0;
      const items = this._line.items;
      for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
        const item = items[i];
        const flexItem = item.flexItem;
        if (flexItem.shrink) {
          const minSize = flexItem._getMainAxisMinSize();
          const size = flexItem._getMainAxisLayoutSize();
          if (size > minSize) {
            total += flexItem.shrink;
          }
        }
      }
      return total;
    }
    getShrunkSize() {
      return this._shrunkSize;
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/line/SizeGrower.mjs
  var SizeGrower = class {
    constructor(line) {
      this._line = line;
      this._amountRemaining = 0;
      this._grownSize = 0;
    }
    grow(amount) {
      this._grownSize = 0;
      this._amountRemaining = amount;
      let totalGrowAmount = this._getTotalGrowAmount();
      if (totalGrowAmount) {
        const items = this._line.items;
        do {
          let amountPerGrow = this._amountRemaining / totalGrowAmount;
          for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;
            const growAmount = flexItem.grow;
            const isGrowableItem = growAmount > 0;
            if (isGrowableItem) {
              let grow = growAmount * amountPerGrow;
              const maxSize = flexItem._getMainAxisMaxSizeSetting();
              const size = flexItem._getMainAxisLayoutSize();
              if (maxSize > 0) {
                if (size >= maxSize) {
                  grow = 0;
                } else {
                  const maxGrow = maxSize - size;
                  const isFullyGrown = grow >= maxGrow;
                  if (isFullyGrown) {
                    grow = maxGrow;
                    totalGrowAmount -= growAmount;
                  }
                }
              }
              if (grow > 0) {
                const finalSize = size + grow;
                flexItem._resizeMainAxis(finalSize);
                this._grownSize += grow;
                this._amountRemaining -= grow;
                if (Math.abs(this._amountRemaining) < 1e-5) {
                  return;
                }
              }
            }
          }
        } while (totalGrowAmount && Math.abs(this._amountRemaining) > 1e-5);
      }
    }
    _getTotalGrowAmount() {
      let total = 0;
      const items = this._line.items;
      for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
        const item = items[i];
        const flexItem = item.flexItem;
        if (flexItem.grow) {
          const maxSize = flexItem._getMainAxisMaxSizeSetting();
          const size = flexItem._getMainAxisLayoutSize();
          if (maxSize === 0 || size < maxSize) {
            total += flexItem.grow;
          }
        }
      }
      return total;
    }
    getGrownSize() {
      return this._grownSize;
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/line/ItemPositioner.mjs
  var ItemPositioner = class {
    constructor(lineLayout) {
      this._line = lineLayout;
    }
    get _layout() {
      return this._line._layout;
    }
    position() {
      const { spacingBefore, spacingBetween } = this._getSpacing();
      let currentPos = spacingBefore;
      const items = this._line.items;
      for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
        const item = items[i];
        item.flexItem._setMainAxisLayoutPos(currentPos);
        currentPos += item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
        currentPos += spacingBetween;
      }
    }
    _getSpacing() {
      const remainingSpace = this._line._availableSpace;
      let mode = this._layout._flexContainer.justifyContent;
      const numberOfItems = this._line.numberOfItems;
      return SpacingCalculator.getSpacing(mode, numberOfItems, remainingSpace);
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/line/ItemAligner.mjs
  var ItemAligner = class {
    constructor(line) {
      this._line = line;
      this._crossAxisLayoutSize = 0;
      this._crossAxisLayoutOffset = 0;
      this._alignItemsSetting = null;
      this._recursiveResizeOccured = false;
      this._isCrossAxisFitToContents = false;
    }
    get _layout() {
      return this._line._layout;
    }
    get _flexContainer() {
      return this._layout._flexContainer;
    }
    setCrossAxisLayoutSize(size) {
      this._crossAxisLayoutSize = size;
    }
    setCrossAxisLayoutOffset(offset) {
      this._crossAxisLayoutOffset = offset;
    }
    align() {
      this._alignItemsSetting = this._flexContainer.alignItems;
      this._isCrossAxisFitToContents = this._layout.isAxisFitToContents(!this._flexContainer._horizontal);
      this._recursiveResizeOccured = false;
      const items = this._line.items;
      for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
        const item = items[i];
        this._alignItem(item);
      }
    }
    get recursiveResizeOccured() {
      return this._recursiveResizeOccured;
    }
    _alignItem(item) {
      const flexItem = item.flexItem;
      let align = flexItem.alignSelf || this._alignItemsSetting;
      if (align === "stretch" && this._preventStretch(flexItem)) {
        align = "flex-start";
      }
      if (align !== "stretch" && !this._isCrossAxisFitToContents) {
        if (flexItem._hasRelCrossAxisSize()) {
          flexItem._resetCrossAxisLayoutSize();
        }
      }
      switch (align) {
        case "flex-start":
          this._alignItemFlexStart(flexItem);
          break;
        case "flex-end":
          this._alignItemFlexEnd(flexItem);
          break;
        case "center":
          this._alignItemFlexCenter(flexItem);
          break;
        case "stretch":
          this._alignItemStretch(flexItem);
          break;
      }
    }
    _alignItemFlexStart(flexItem) {
      flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
    }
    _alignItemFlexEnd(flexItem) {
      const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
      flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + (this._crossAxisLayoutSize - itemCrossAxisSize));
    }
    _alignItemFlexCenter(flexItem) {
      const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
      const center = (this._crossAxisLayoutSize - itemCrossAxisSize) / 2;
      flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + center);
    }
    _alignItemStretch(flexItem) {
      flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
      const mainAxisLayoutSizeBeforeResize = flexItem._getMainAxisLayoutSize();
      let size = this._crossAxisLayoutSize - flexItem._getCrossAxisMargin() - flexItem._getCrossAxisPadding();
      const crossAxisMinSizeSetting = flexItem._getCrossAxisMinSizeSetting();
      if (crossAxisMinSizeSetting > 0) {
        size = Math.max(size, crossAxisMinSizeSetting);
      }
      const crossAxisMaxSizeSetting = flexItem._getCrossAxisMaxSizeSetting();
      const crossAxisMaxSizeSettingEnabled = crossAxisMaxSizeSetting > 0;
      if (crossAxisMaxSizeSettingEnabled) {
        size = Math.min(size, crossAxisMaxSizeSetting);
      }
      flexItem._resizeCrossAxis(size);
      const mainAxisLayoutSizeAfterResize = flexItem._getMainAxisLayoutSize();
      const recursiveResize = mainAxisLayoutSizeAfterResize !== mainAxisLayoutSizeBeforeResize;
      if (recursiveResize) {
        this._recursiveResizeOccured = true;
      }
    }
    _preventStretch(flexItem) {
      const hasFixedCrossAxisSize = flexItem._hasFixedCrossAxisSize();
      const forceStretch = flexItem.alignSelf === "stretch";
      return hasFixedCrossAxisSize && !forceStretch;
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/line/LineLayout.mjs
  var LineLayout = class {
    constructor(layout, startIndex, endIndex, availableSpace) {
      this._layout = layout;
      this.items = layout.items;
      this.startIndex = startIndex;
      this.endIndex = endIndex;
      this._availableSpace = availableSpace;
    }
    performLayout() {
      this._setItemSizes();
      this.setItemPositions();
      this._calcLayoutInfo();
    }
    _setItemSizes() {
      if (this._availableSpace > 0) {
        this._growItemSizes(this._availableSpace);
      } else if (this._availableSpace < 0) {
        this._shrinkItemSizes(-this._availableSpace);
      }
    }
    _growItemSizes(amount) {
      const grower = new SizeGrower(this);
      grower.grow(amount);
      this._availableSpace -= grower.getGrownSize();
    }
    _shrinkItemSizes(amount) {
      const shrinker = new SizeShrinker(this);
      shrinker.shrink(amount);
      this._availableSpace += shrinker.getShrunkSize();
    }
    setItemPositions() {
      const positioner = new ItemPositioner(this);
      positioner.position();
    }
    createItemAligner() {
      return new ItemAligner(this);
    }
    _calcLayoutInfo() {
      this._calcCrossAxisMaxLayoutSize();
    }
    getMainAxisMinSize() {
      let mainAxisMinSize = 0;
      for (let i = this.startIndex; i <= this.endIndex; i++) {
        const item = this.items[i];
        mainAxisMinSize += item.flexItem._getMainAxisMinSizeWithPaddingAndMargin();
      }
      return mainAxisMinSize;
    }
    get numberOfItems() {
      return this.endIndex - this.startIndex + 1;
    }
    get crossAxisLayoutSize() {
      const noSpecifiedCrossAxisSize = this._layout.isCrossAxisFitToContents() && !this._layout.resizingCrossAxis;
      const shouldFitToContents = this._layout.isWrapping() || noSpecifiedCrossAxisSize;
      if (shouldFitToContents) {
        return this._crossAxisMaxLayoutSize;
      } else {
        return this._layout.crossAxisSize;
      }
    }
    _calcCrossAxisMaxLayoutSize() {
      this._crossAxisMaxLayoutSize = this._getCrossAxisMaxLayoutSize();
    }
    _getCrossAxisMaxLayoutSize() {
      let crossAxisMaxSize = 0;
      for (let i = this.startIndex; i <= this.endIndex; i++) {
        const item = this.items[i];
        crossAxisMaxSize = Math.max(crossAxisMaxSize, item.flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin());
      }
      return crossAxisMaxSize;
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/LineLayouter.mjs
  var LineLayouter = class {
    constructor(layout) {
      this._layout = layout;
      this._mainAxisMinSize = -1;
      this._crossAxisMinSize = -1;
      this._mainAxisContentSize = 0;
    }
    get lines() {
      return this._lines;
    }
    get mainAxisMinSize() {
      if (this._mainAxisMinSize === -1) {
        this._mainAxisMinSize = this._getMainAxisMinSize();
      }
      return this._mainAxisMinSize;
    }
    get crossAxisMinSize() {
      if (this._crossAxisMinSize === -1) {
        this._crossAxisMinSize = this._getCrossAxisMinSize();
      }
      return this._crossAxisMinSize;
    }
    get mainAxisContentSize() {
      return this._mainAxisContentSize;
    }
    layoutLines() {
      this._setup();
      const items = this._layout.items;
      const wrap = this._layout.isWrapping();
      let startIndex = 0;
      let i;
      const n = items.length;
      for (i = 0; i < n; i++) {
        const item = items[i];
        this._layoutFlexItem(item);
        const itemMainAxisSize = item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
        if (wrap && i > startIndex) {
          const isOverflowing = this._curMainAxisPos + itemMainAxisSize > this._mainAxisSize;
          if (isOverflowing) {
            this._layoutLine(startIndex, i - 1);
            this._curMainAxisPos = 0;
            startIndex = i;
          }
        }
        this._addToMainAxisPos(itemMainAxisSize);
      }
      if (startIndex < i) {
        this._layoutLine(startIndex, i - 1);
      }
    }
    _layoutFlexItem(item) {
      if (item.isFlexEnabled()) {
        item.flexLayout.updateTreeLayout();
      } else {
        item.flexItem._resetLayoutSize();
      }
    }
    _setup() {
      this._mainAxisSize = this._layout.mainAxisSize;
      this._curMainAxisPos = 0;
      this._maxMainAxisPos = 0;
      this._lines = [];
      this._mainAxisMinSize = -1;
      this._crossAxisMinSize = -1;
      this._mainAxisContentSize = 0;
    }
    _addToMainAxisPos(itemMainAxisSize) {
      this._curMainAxisPos += itemMainAxisSize;
      if (this._curMainAxisPos > this._maxMainAxisPos) {
        this._maxMainAxisPos = this._curMainAxisPos;
      }
    }
    _layoutLine(startIndex, endIndex) {
      const availableSpace = this._getAvailableMainAxisLayoutSpace();
      const line = new LineLayout(this._layout, startIndex, endIndex, availableSpace);
      line.performLayout();
      this._lines.push(line);
      if (this._mainAxisContentSize === 0 || this._curMainAxisPos > this._mainAxisContentSize) {
        this._mainAxisContentSize = this._curMainAxisPos;
      }
    }
    _getAvailableMainAxisLayoutSpace() {
      if (!this._layout.resizingMainAxis && this._layout.isMainAxisFitToContents()) {
        return 0;
      } else {
        return this._mainAxisSize - this._curMainAxisPos;
      }
    }
    _getCrossAxisMinSize() {
      let crossAxisMinSize = 0;
      const items = this._layout.items;
      for (let i = 0, n = items.length; i < n; i++) {
        const item = items[i];
        const itemCrossAxisMinSize = item.flexItem._getCrossAxisMinSizeWithPaddingAndMargin();
        crossAxisMinSize = Math.max(crossAxisMinSize, itemCrossAxisMinSize);
      }
      return crossAxisMinSize;
    }
    _getMainAxisMinSize() {
      if (this._lines.length === 1) {
        return this._lines[0].getMainAxisMinSize();
      } else {
        return this._layout.mainAxisSize;
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/ItemCoordinatesUpdater.mjs
  var ItemCoordinatesUpdater = class _ItemCoordinatesUpdater {
    constructor(layout) {
      this._layout = layout;
      this._isReverse = this._flexContainer._reverse;
      this._horizontalPaddingOffset = this._layout._getHorizontalPaddingOffset();
      this._verticalPaddingOffset = this._layout._getVerticalPaddingOffset();
    }
    get _flexContainer() {
      return this._layout._flexContainer;
    }
    finalize() {
      const parentFlex = this._layout.getParentFlexContainer();
      if (parentFlex) {
        const updater = new _ItemCoordinatesUpdater(parentFlex._layout);
        updater._finalizeItemAndChildren(this._flexContainer.item);
      } else {
        this._finalizeRoot();
        this._finalizeItems();
      }
    }
    _finalizeRoot() {
      const item = this._flexContainer.item;
      let x = FlexUtils.getAxisLayoutPos(item, true);
      let y = FlexUtils.getAxisLayoutPos(item, false);
      let w = FlexUtils.getAxisLayoutSize(item, true);
      let h = FlexUtils.getAxisLayoutSize(item, false);
      w += this._layout._getHorizontalPadding();
      h += this._layout._getVerticalPadding();
      item.clearRecalcFlag();
      item.setLayout(x, y, w, h);
    }
    _finalizeItems() {
      const items = this._layout.items;
      for (let i = 0, n = items.length; i < n; i++) {
        const item = items[i];
        const validCache = this._validateItemCache(item);
        this._finalizeItem(item);
        if (!validCache) {
          this._finalizeItemChildren(item);
        }
      }
    }
    _validateItemCache(item) {
      if (item.recalc === 0) {
        if (item.isFlexEnabled()) {
          const layout = item._flex._layout;
          const dimensionsMatchPreviousResult = item.w === item.target.w && item.h === item.target.h;
          if (dimensionsMatchPreviousResult) {
            return true;
          } else {
            const crossAxisSize = layout.crossAxisSize;
            layout.performResizeMainAxis(layout.mainAxisSize);
            layout.performResizeCrossAxis(crossAxisSize);
          }
        }
      }
      return false;
    }
    _finalizeItemAndChildren(item) {
      this._finalizeItem(item);
      this._finalizeItemChildren(item);
    }
    _finalizeItem(item) {
      if (this._isReverse) {
        this._reverseMainAxisLayoutPos(item);
      }
      let x = FlexUtils.getAxisLayoutPos(item, true);
      let y = FlexUtils.getAxisLayoutPos(item, false);
      let w = FlexUtils.getAxisLayoutSize(item, true);
      let h = FlexUtils.getAxisLayoutSize(item, false);
      x += this._horizontalPaddingOffset;
      y += this._verticalPaddingOffset;
      const flex = item.flex;
      if (flex) {
        w += item._flex._layout._getHorizontalPadding();
        h += item._flex._layout._getVerticalPadding();
      }
      const flexItem = item.flexItem;
      if (flexItem) {
        x += flexItem._getHorizontalMarginOffset();
        y += flexItem._getVerticalMarginOffset();
      }
      item.clearRecalcFlag();
      item.setLayout(x, y, w, h);
    }
    _finalizeItemChildren(item) {
      const flex = item._flex;
      if (flex) {
        const updater = new _ItemCoordinatesUpdater(flex._layout);
        updater._finalizeItems();
      }
    }
    _reverseMainAxisLayoutPos(item) {
      const endPos = item.flexItem._getMainAxisLayoutPos() + item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
      const reversedPos = this._layout.mainAxisSize - endPos;
      item.flexItem._setMainAxisLayoutPos(reversedPos);
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/layout/FlexLayout.mjs
  var FlexLayout = class {
    constructor(flexContainer) {
      this._flexContainer = flexContainer;
      this._lineLayouter = new LineLayouter(this);
      this._resizingMainAxis = false;
      this._resizingCrossAxis = false;
      this._cachedMainAxisSizeAfterLayout = 0;
      this._cachedCrossAxisSizeAfterLayout = 0;
      this._shrunk = false;
    }
    get shrunk() {
      return this._shrunk;
    }
    get recalc() {
      return this.item.recalc;
    }
    layoutTree() {
      const isSubTree = this.item.flexParent !== null;
      if (isSubTree) {
        this._updateSubTreeLayout();
      } else {
        this.updateTreeLayout();
      }
      this.updateItemCoords();
    }
    updateTreeLayout() {
      if (this.recalc) {
        this._performUpdateLayoutTree();
      } else {
        this._performUpdateLayoutTreeFromCache();
      }
    }
    _performUpdateLayoutTree() {
      this._setInitialAxisSizes();
      this._layoutAxes();
      this._refreshLayoutCache();
    }
    _refreshLayoutCache() {
      this._cachedMainAxisSizeAfterLayout = this.mainAxisSize;
      this._cachedCrossAxisSizeAfterLayout = this.crossAxisSize;
    }
    _performUpdateLayoutTreeFromCache() {
      const sizeMightHaveChanged = this.item.funcW || this.item.funcH;
      if (sizeMightHaveChanged) {
        this.item.enableLocalRecalcFlag();
        this._performUpdateLayoutTree();
      } else {
        this.mainAxisSize = this._cachedMainAxisSizeAfterLayout;
        this.crossAxisSize = this._cachedCrossAxisSizeAfterLayout;
      }
    }
    updateItemCoords() {
      const updater = new ItemCoordinatesUpdater(this);
      updater.finalize();
    }
    _updateSubTreeLayout() {
      const crossAxisSize = this.crossAxisSize;
      this._layoutMainAxis();
      this.performResizeCrossAxis(crossAxisSize);
    }
    _setInitialAxisSizes() {
      if (this.item.isFlexItemEnabled()) {
        this.item.flexItem._resetLayoutSize();
      } else {
        this.mainAxisSize = this._getMainAxisBasis();
        this.crossAxisSize = this._getCrossAxisBasis();
      }
      this._resizingMainAxis = false;
      this._resizingCrossAxis = false;
      this._shrunk = false;
    }
    _layoutAxes() {
      this._layoutMainAxis();
      this._layoutCrossAxis();
    }
    /**
     * @pre mainAxisSize should exclude padding.
     */
    _layoutMainAxis() {
      this._layoutLines();
      this._fitMainAxisSizeToContents();
    }
    _layoutLines() {
      this._lineLayouter.layoutLines();
    }
    get _lines() {
      return this._lineLayouter.lines;
    }
    _fitMainAxisSizeToContents() {
      if (!this._resizingMainAxis) {
        if (this.isMainAxisFitToContents()) {
          this.mainAxisSize = this._lineLayouter.mainAxisContentSize;
        }
      }
    }
    /**
     * @pre crossAxisSize should exclude padding.
     */
    _layoutCrossAxis() {
      const aligner = new ContentAligner(this);
      aligner.init();
      this._totalCrossAxisSize = aligner.totalCrossAxisSize;
      this._fitCrossAxisSizeToContents();
      aligner.align();
    }
    _fitCrossAxisSizeToContents() {
      if (!this._resizingCrossAxis) {
        if (this.isCrossAxisFitToContents()) {
          this.crossAxisSize = this._totalCrossAxisSize;
        }
      }
    }
    isWrapping() {
      return this._flexContainer.wrap;
    }
    isAxisFitToContents(horizontal) {
      if (this._horizontal === horizontal) {
        return this.isMainAxisFitToContents();
      } else {
        return this.isCrossAxisFitToContents();
      }
    }
    isMainAxisFitToContents() {
      return !this.isWrapping() && !this._hasFixedMainAxisBasis();
    }
    isCrossAxisFitToContents() {
      return !this._hasFixedCrossAxisBasis();
    }
    _hasFixedMainAxisBasis() {
      return !FlexUtils.isZeroAxisSize(this.item, this._horizontal);
    }
    _hasFixedCrossAxisBasis() {
      return !FlexUtils.isZeroAxisSize(this.item, !this._horizontal);
    }
    getAxisMinSize(horizontal) {
      if (this._horizontal === horizontal) {
        return this._getMainAxisMinSize();
      } else {
        return this._getCrossAxisMinSize();
      }
    }
    _getMainAxisMinSize() {
      return this._lineLayouter.mainAxisMinSize;
    }
    _getCrossAxisMinSize() {
      return this._lineLayouter.crossAxisMinSize;
    }
    resizeMainAxis(size) {
      if (this.mainAxisSize !== size) {
        if (this.recalc > 0) {
          this.performResizeMainAxis(size);
        } else {
          if (this._checkValidCacheMainAxisResize()) {
            this.mainAxisSize = size;
            this._fitCrossAxisSizeToContents();
          } else {
            this.item.enableLocalRecalcFlag();
            this.performResizeMainAxis(size);
          }
        }
      }
    }
    _checkValidCacheMainAxisResize(size) {
      const isFinalMainAxisSize = size === this.targetMainAxisSize;
      if (isFinalMainAxisSize) {
        return true;
      }
      const canIgnoreCacheMiss = !this.isCrossAxisFitToContents();
      if (canIgnoreCacheMiss) {
        return true;
      }
      return false;
    }
    performResizeMainAxis(size) {
      const isShrinking = size < this.mainAxisSize;
      this._shrunk = isShrinking;
      this.mainAxisSize = size;
      this._resizingMainAxis = true;
      this._layoutAxes();
      this._resizingMainAxis = false;
    }
    resizeCrossAxis(size) {
      if (this.crossAxisSize !== size) {
        if (this.recalc > 0) {
          this.performResizeCrossAxis(size);
        } else {
          this.crossAxisSize = size;
        }
      }
    }
    performResizeCrossAxis(size) {
      this.crossAxisSize = size;
      this._resizingCrossAxis = true;
      this._layoutCrossAxis();
      this._resizingCrossAxis = false;
    }
    get targetMainAxisSize() {
      return this._horizontal ? this.item.target.w : this.item.target.h;
    }
    get targetCrossAxisSize() {
      return this._horizontal ? this.item.target.h : this.item.target.w;
    }
    getParentFlexContainer() {
      return this.item.isFlexItemEnabled() ? this.item.flexItem.ctr : null;
    }
    _getHorizontalPadding() {
      return FlexUtils.getTotalPadding(this.item, true);
    }
    _getVerticalPadding() {
      return FlexUtils.getTotalPadding(this.item, false);
    }
    _getHorizontalPaddingOffset() {
      return FlexUtils.getPaddingOffset(this.item, true);
    }
    _getVerticalPaddingOffset() {
      return FlexUtils.getPaddingOffset(this.item, false);
    }
    _getMainAxisBasis() {
      return FlexUtils.getRelAxisSize(this.item, this._horizontal);
    }
    _getCrossAxisBasis() {
      return FlexUtils.getRelAxisSize(this.item, !this._horizontal);
    }
    get _horizontal() {
      return this._flexContainer._horizontal;
    }
    get _reverse() {
      return this._flexContainer._reverse;
    }
    get item() {
      return this._flexContainer.item;
    }
    get items() {
      return this.item.items;
    }
    get resizingMainAxis() {
      return this._resizingMainAxis;
    }
    get resizingCrossAxis() {
      return this._resizingCrossAxis;
    }
    get numberOfItems() {
      return this.items.length;
    }
    get mainAxisSize() {
      return FlexUtils.getAxisLayoutSize(this.item, this._horizontal);
    }
    get crossAxisSize() {
      return FlexUtils.getAxisLayoutSize(this.item, !this._horizontal);
    }
    set mainAxisSize(v) {
      FlexUtils.setAxisLayoutSize(this.item, this._horizontal, v);
    }
    set crossAxisSize(v) {
      FlexUtils.setAxisLayoutSize(this.item, !this._horizontal, v);
    }
  };

  // node_modules/@lightningjs/core/dist/src/flex/FlexContainer.mjs
  var FlexContainer = class _FlexContainer {
    constructor(item) {
      this._item = item;
      this._layout = new FlexLayout(this);
      this._horizontal = true;
      this._reverse = false;
      this._wrap = false;
      this._alignItems = "stretch";
      this._justifyContent = "flex-start";
      this._alignContent = "flex-start";
      this._paddingLeft = 0;
      this._paddingTop = 0;
      this._paddingRight = 0;
      this._paddingBottom = 0;
    }
    get item() {
      return this._item;
    }
    _changedDimensions() {
      this._item.changedDimensions();
    }
    _changedContents() {
      this._item.changedContents();
    }
    get direction() {
      return (this._horizontal ? "row" : "column") + (this._reverse ? "-reverse" : "");
    }
    set direction(f) {
      if (this.direction === f) return;
      this._horizontal = f === "row" || f === "row-reverse";
      this._reverse = f === "row-reverse" || f === "column-reverse";
      this._changedContents();
    }
    set wrap(v) {
      this._wrap = v;
      this._changedContents();
    }
    get wrap() {
      return this._wrap;
    }
    get alignItems() {
      return this._alignItems;
    }
    set alignItems(v) {
      if (this._alignItems === v) return;
      if (_FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
        throw new Error("Unknown alignItems, options: " + _FlexContainer.ALIGN_ITEMS.join(","));
      }
      this._alignItems = v;
      this._changedContents();
    }
    get alignContent() {
      return this._alignContent;
    }
    set alignContent(v) {
      if (this._alignContent === v) return;
      if (_FlexContainer.ALIGN_CONTENT.indexOf(v) === -1) {
        throw new Error("Unknown alignContent, options: " + _FlexContainer.ALIGN_CONTENT.join(","));
      }
      this._alignContent = v;
      this._changedContents();
    }
    get justifyContent() {
      return this._justifyContent;
    }
    set justifyContent(v) {
      if (this._justifyContent === v) return;
      if (_FlexContainer.JUSTIFY_CONTENT.indexOf(v) === -1) {
        throw new Error("Unknown justifyContent, options: " + _FlexContainer.JUSTIFY_CONTENT.join(","));
      }
      this._justifyContent = v;
      this._changedContents();
    }
    set padding(v) {
      this.paddingLeft = v;
      this.paddingTop = v;
      this.paddingRight = v;
      this.paddingBottom = v;
    }
    get padding() {
      return this.paddingLeft;
    }
    set paddingLeft(v) {
      this._paddingLeft = v;
      this._changedDimensions();
    }
    get paddingLeft() {
      return this._paddingLeft;
    }
    set paddingTop(v) {
      this._paddingTop = v;
      this._changedDimensions();
    }
    get paddingTop() {
      return this._paddingTop;
    }
    set paddingRight(v) {
      this._paddingRight = v;
      this._changedDimensions();
    }
    get paddingRight() {
      return this._paddingRight;
    }
    set paddingBottom(v) {
      this._paddingBottom = v;
      this._changedDimensions();
    }
    get paddingBottom() {
      return this._paddingBottom;
    }
    patch(settings2) {
      Base.patchObject(this, settings2);
    }
  };
  FlexContainer.ALIGN_ITEMS = ["flex-start", "flex-end", "center", "stretch"];
  FlexContainer.ALIGN_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "stretch"];
  FlexContainer.JUSTIFY_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly"];

  // node_modules/@lightningjs/core/dist/src/flex/FlexItem.mjs
  var FlexItem = class _FlexItem {
    constructor(item) {
      this._ctr = null;
      this._item = item;
      this._grow = 0;
      this._shrink = _FlexItem.SHRINK_AUTO;
      this._alignSelf = void 0;
      this._minWidth = 0;
      this._minHeight = 0;
      this._maxWidth = 0;
      this._maxHeight = 0;
      this._marginLeft = 0;
      this._marginTop = 0;
      this._marginRight = 0;
      this._marginBottom = 0;
    }
    get item() {
      return this._item;
    }
    get grow() {
      return this._grow;
    }
    set grow(v) {
      if (this._grow === v) return;
      this._grow = parseInt(v) || 0;
      this._changed();
    }
    get shrink() {
      if (this._shrink === _FlexItem.SHRINK_AUTO) {
        return this._getDefaultShrink();
      }
      return this._shrink;
    }
    _getDefaultShrink() {
      if (this.item.isFlexEnabled()) {
        return 1;
      } else {
        return 0;
      }
    }
    set shrink(v) {
      if (this._shrink === v) return;
      this._shrink = parseInt(v) || 0;
      this._changed();
    }
    get alignSelf() {
      return this._alignSelf;
    }
    set alignSelf(v) {
      if (this._alignSelf === v) return;
      if (v === void 0) {
        this._alignSelf = void 0;
      } else {
        if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
          throw new Error("Unknown alignSelf, options: " + FlexContainer.ALIGN_ITEMS.join(","));
        }
        this._alignSelf = v;
      }
      this._changed();
    }
    get minWidth() {
      return this._minWidth;
    }
    set minWidth(v) {
      this._minWidth = Math.max(0, v);
      this._item.changedDimensions(true, false);
    }
    get minHeight() {
      return this._minHeight;
    }
    set minHeight(v) {
      this._minHeight = Math.max(0, v);
      this._item.changedDimensions(false, true);
    }
    get maxWidth() {
      return this._maxWidth;
    }
    set maxWidth(v) {
      this._maxWidth = Math.max(0, v);
      this._item.changedDimensions(true, false);
    }
    get maxHeight() {
      return this._maxHeight;
    }
    set maxHeight(v) {
      this._maxHeight = Math.max(0, v);
      this._item.changedDimensions(false, true);
    }
    /**
     * @note margins behave slightly different than in HTML with regard to shrinking.
     * In HTML, (outer) margins can be removed when shrinking. In this engine, they will not shrink at all.
     */
    set margin(v) {
      this.marginLeft = v;
      this.marginTop = v;
      this.marginRight = v;
      this.marginBottom = v;
    }
    get margin() {
      return this.marginLeft;
    }
    set marginLeft(v) {
      this._marginLeft = v;
      this._changed();
    }
    get marginLeft() {
      return this._marginLeft;
    }
    set marginTop(v) {
      this._marginTop = v;
      this._changed();
    }
    get marginTop() {
      return this._marginTop;
    }
    set marginRight(v) {
      this._marginRight = v;
      this._changed();
    }
    get marginRight() {
      return this._marginRight;
    }
    set marginBottom(v) {
      this._marginBottom = v;
      this._changed();
    }
    get marginBottom() {
      return this._marginBottom;
    }
    _changed() {
      if (this.ctr) this.ctr._changedContents();
    }
    set ctr(v) {
      this._ctr = v;
    }
    get ctr() {
      return this._ctr;
    }
    patch(settings2) {
      Base.patchObject(this, settings2);
    }
    _resetLayoutSize() {
      this._resetHorizontalAxisLayoutSize();
      this._resetVerticalAxisLayoutSize();
    }
    _resetCrossAxisLayoutSize() {
      if (this.ctr._horizontal) {
        this._resetVerticalAxisLayoutSize();
      } else {
        this._resetHorizontalAxisLayoutSize();
      }
    }
    _resetHorizontalAxisLayoutSize() {
      let w = FlexUtils.getRelAxisSize(this.item, true);
      if (this._minWidth) {
        w = Math.max(this._minWidth, w);
      }
      if (this._maxWidth) {
        w = Math.min(this._maxWidth, w);
      }
      FlexUtils.setAxisLayoutSize(this.item, true, w);
    }
    _resetVerticalAxisLayoutSize() {
      let h = FlexUtils.getRelAxisSize(this.item, false);
      if (this._minHeight) {
        h = Math.max(this._minHeight, h);
      }
      if (this._maxHeight) {
        h = Math.min(this._maxHeight, h);
      }
      FlexUtils.setAxisLayoutSize(this.item, false, h);
    }
    _getCrossAxisMinSizeSetting() {
      return this._getMinSizeSetting(!this.ctr._horizontal);
    }
    _getCrossAxisMaxSizeSetting() {
      return this._getMaxSizeSetting(!this.ctr._horizontal);
    }
    _getMainAxisMaxSizeSetting() {
      return this._getMaxSizeSetting(this.ctr._horizontal);
    }
    _getMinSizeSetting(horizontal) {
      if (horizontal) {
        return this._minWidth;
      } else {
        return this._minHeight;
      }
    }
    _getMaxSizeSetting(horizontal) {
      if (horizontal) {
        return this._maxWidth;
      } else {
        return this._maxHeight;
      }
    }
    _getMainAxisMinSize() {
      return FlexUtils.getAxisMinSize(this.item, this.ctr._horizontal);
    }
    _getCrossAxisMinSize() {
      return FlexUtils.getAxisMinSize(this.item, !this.ctr._horizontal);
    }
    _getMainAxisLayoutSize() {
      return FlexUtils.getAxisLayoutSize(this.item, this.ctr._horizontal);
    }
    _getMainAxisLayoutPos() {
      return FlexUtils.getAxisLayoutPos(this.item, this.ctr._horizontal);
    }
    _setMainAxisLayoutPos(pos) {
      return FlexUtils.setAxisLayoutPos(this.item, this.ctr._horizontal, pos);
    }
    _setCrossAxisLayoutPos(pos) {
      return FlexUtils.setAxisLayoutPos(this.item, !this.ctr._horizontal, pos);
    }
    _getCrossAxisLayoutSize() {
      return FlexUtils.getAxisLayoutSize(this.item, !this.ctr._horizontal);
    }
    _resizeCrossAxis(size) {
      return FlexUtils.resizeAxis(this.item, !this.ctr._horizontal, size);
    }
    _resizeMainAxis(size) {
      return FlexUtils.resizeAxis(this.item, this.ctr._horizontal, size);
    }
    _getMainAxisPadding() {
      return FlexUtils.getTotalPadding(this.item, this.ctr._horizontal);
    }
    _getCrossAxisPadding() {
      return FlexUtils.getTotalPadding(this.item, !this.ctr._horizontal);
    }
    _getMainAxisMargin() {
      return FlexUtils.getTotalMargin(this.item, this.ctr._horizontal);
    }
    _getCrossAxisMargin() {
      return FlexUtils.getTotalMargin(this.item, !this.ctr._horizontal);
    }
    _getHorizontalMarginOffset() {
      return FlexUtils.getMarginOffset(this.item, true);
    }
    _getVerticalMarginOffset() {
      return FlexUtils.getMarginOffset(this.item, false);
    }
    _getMainAxisMinSizeWithPaddingAndMargin() {
      return this._getMainAxisMinSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
    }
    _getCrossAxisMinSizeWithPaddingAndMargin() {
      return this._getCrossAxisMinSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
    }
    _getMainAxisLayoutSizeWithPaddingAndMargin() {
      return this._getMainAxisLayoutSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
    }
    _getCrossAxisLayoutSizeWithPaddingAndMargin() {
      return this._getCrossAxisLayoutSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
    }
    _hasFixedCrossAxisSize() {
      return !FlexUtils.isZeroAxisSize(this.item, !this.ctr._horizontal);
    }
    _hasRelCrossAxisSize() {
      return !!(this.ctr._horizontal ? this.item.funcH : this.item.funcW);
    }
  };
  FlexItem.SHRINK_AUTO = -1;

  // node_modules/@lightningjs/core/dist/src/flex/FlexTarget.mjs
  var FlexTarget = class {
    constructor(target) {
      this._target = target;
      this._recalc = 0;
      this._enabled = false;
      this.x = 0;
      this.y = 0;
      this.w = 0;
      this.h = 0;
      this._originalX = 0;
      this._originalY = 0;
      this._originalWidth = 0;
      this._originalHeight = 0;
      this._flex = null;
      this._flexItem = null;
      this._flexItemDisabled = false;
      this._items = null;
    }
    get flexLayout() {
      return this.flex ? this.flex._layout : null;
    }
    layoutFlexTree() {
      if (this.isFlexEnabled() && this.isChanged()) {
        this.flexLayout.layoutTree();
      }
    }
    get target() {
      return this._target;
    }
    get flex() {
      return this._flex;
    }
    set flex(v) {
      if (!v) {
        if (this.isFlexEnabled()) {
          this._disableFlex();
        }
      } else {
        if (!this.isFlexEnabled()) {
          this._enableFlex();
        }
        this._flex.patch(v);
      }
    }
    get flexItem() {
      if (this._flexItemDisabled) {
        return false;
      }
      this._ensureFlexItem();
      return this._flexItem;
    }
    set flexItem(v) {
      if (v === false) {
        if (!this._flexItemDisabled) {
          const parent = this.flexParent;
          this._flexItemDisabled = true;
          this._checkEnabled();
          if (parent) {
            parent._clearFlexItemsCache();
            parent.changedContents();
          }
        }
      } else {
        this._ensureFlexItem();
        this._flexItem.patch(v);
        if (this._flexItemDisabled) {
          this._flexItemDisabled = false;
          this._checkEnabled();
          const parent = this.flexParent;
          if (parent) {
            parent._clearFlexItemsCache();
            parent.changedContents();
          }
        }
      }
    }
    _enableFlex() {
      this._flex = new FlexContainer(this);
      this._checkEnabled();
      this.changedDimensions();
      this._enableChildrenAsFlexItems();
    }
    _disableFlex() {
      this.changedDimensions();
      this._flex = null;
      this._checkEnabled();
      this._disableChildrenAsFlexItems();
    }
    _enableChildrenAsFlexItems() {
      const children = this._target._children;
      if (children) {
        for (let i = 0, n = children.length; i < n; i++) {
          const child = children[i];
          child.layout._enableFlexItem();
        }
      }
    }
    _disableChildrenAsFlexItems() {
      const children = this._target._children;
      if (children) {
        for (let i = 0, n = children.length; i < n; i++) {
          const child = children[i];
          child.layout._disableFlexItem();
        }
      }
    }
    _enableFlexItem() {
      this._ensureFlexItem();
      if (this._target._parent) {
        const flexParent = this._target._parent._layout;
        this._flexItem.ctr = flexParent._flex;
        flexParent.changedContents();
      }
      this._checkEnabled();
    }
    _disableFlexItem() {
      if (this._flexItem) {
        this._flexItem.ctr = null;
      }
      this._checkEnabled();
      this._resetOffsets();
    }
    _resetOffsets() {
      this.x = 0;
      this.y = 0;
    }
    _ensureFlexItem() {
      if (!this._flexItem) {
        this._flexItem = new FlexItem(this);
      }
    }
    _checkEnabled() {
      const enabled = this.isEnabled();
      if (this._enabled !== enabled) {
        if (enabled) {
          this._enable();
        } else {
          this._disable();
        }
        this._enabled = enabled;
      }
    }
    _enable() {
      this._setupTargetForFlex();
      this._target.enableFlexLayout();
    }
    _disable() {
      this._restoreTargetToNonFlex();
      this._target.disableFlexLayout();
    }
    isEnabled() {
      return this.isFlexEnabled() || this.isFlexItemEnabled();
    }
    isFlexEnabled() {
      return this._flex !== null;
    }
    isFlexItemEnabled() {
      return this.flexParent !== null;
    }
    _restoreTargetToNonFlex() {
      const target = this._target;
      target.x = this._originalX;
      target.y = this._originalY;
      target.setDimensions(this._originalWidth, this._originalHeight);
    }
    _setupTargetForFlex() {
      const target = this._target;
      this._originalX = target._x;
      this._originalY = target._y;
      this._originalWidth = target._w;
      this._originalHeight = target._h;
    }
    setParent(from, to) {
      if (from && from.isFlexContainer()) {
        from._layout._changedChildren();
      }
      if (to && to.isFlexContainer()) {
        this._enableFlexItem();
        to._layout._changedChildren();
      }
      this._checkEnabled();
    }
    get flexParent() {
      if (this._flexItemDisabled) {
        return null;
      }
      const parent = this._target._parent;
      if (parent && parent.isFlexContainer()) {
        return parent._layout;
      }
      return null;
    }
    setVisible(v) {
      const parent = this.flexParent;
      if (parent) {
        parent._changedChildren();
      }
    }
    get items() {
      if (!this._items) {
        this._items = this._getFlexItems();
      }
      return this._items;
    }
    _getFlexItems() {
      const items = [];
      const children = this._target._children;
      if (children) {
        for (let i = 0, n = children.length; i < n; i++) {
          const item = children[i];
          if (item.visible) {
            if (item.isFlexItem()) {
              items.push(item.layout);
            }
          }
        }
      }
      return items;
    }
    _changedChildren() {
      this._clearFlexItemsCache();
      this.changedContents();
    }
    _clearFlexItemsCache() {
      this._items = null;
    }
    setLayout(x, y, w, h) {
      let originalX = this._originalX;
      let originalY = this._originalY;
      if (this.funcX) {
        originalX = this.funcX(FlexUtils.getParentAxisSizeWithPadding(this, true));
      }
      if (this.funcY) {
        originalY = this.funcY(FlexUtils.getParentAxisSizeWithPadding(this, false));
      }
      if (this.isFlexItemEnabled()) {
        this.target.setLayout(x + originalX, y + originalY, w, h);
      } else {
        this.target.setLayout(originalX, originalY, w, h);
      }
    }
    changedDimensions(changeWidth = true, changeHeight = true) {
      this._updateRecalc(changeWidth, changeHeight);
    }
    changedContents() {
      this._updateRecalc();
    }
    forceLayout() {
      this._updateRecalc();
    }
    isChanged() {
      return this._recalc > 0;
    }
    _updateRecalc(changeExternalWidth = false, changeExternalHeight = false) {
      if (this.isFlexEnabled()) {
        const layout = this._flex._layout;
        changeExternalWidth = changeExternalWidth || layout.isAxisFitToContents(true);
        changeExternalHeight = changeExternalHeight || layout.isAxisFitToContents(false);
      }
      const recalc = 1 + (changeExternalWidth ? 2 : 0) + (changeExternalHeight ? 4 : 0);
      const newRecalcFlags = this.getNewRecalcFlags(recalc);
      this._recalc |= recalc;
      if (newRecalcFlags > 1) {
        if (this.flexParent) {
          this.flexParent._updateRecalcBottomUp(recalc);
        } else {
          this._target.triggerLayout();
        }
      } else {
        this._target.triggerLayout();
      }
    }
    getNewRecalcFlags(flags) {
      return 7 - this._recalc & flags;
    }
    _updateRecalcBottomUp(childRecalc) {
      const newRecalc = this._getRecalcFromChangedChildRecalc(childRecalc);
      const newRecalcFlags = this.getNewRecalcFlags(newRecalc);
      this._recalc |= newRecalc;
      if (newRecalcFlags > 1) {
        const flexParent = this.flexParent;
        if (flexParent) {
          flexParent._updateRecalcBottomUp(newRecalc);
        } else {
          this._target.triggerLayout();
        }
      } else {
        this._target.triggerLayout();
      }
    }
    _getRecalcFromChangedChildRecalc(childRecalc) {
      const layout = this._flex._layout;
      const mainAxisRecalcFlag = layout._horizontal ? 1 : 2;
      const crossAxisRecalcFlag = layout._horizontal ? 2 : 1;
      const crossAxisDimensionsChangedInChild = childRecalc & crossAxisRecalcFlag;
      if (!crossAxisDimensionsChangedInChild) {
        const mainAxisDimensionsChangedInChild = childRecalc & mainAxisRecalcFlag;
        if (mainAxisDimensionsChangedInChild) {
          const mainAxisIsWrapping = layout.isWrapping();
          if (mainAxisIsWrapping) {
            const crossAxisIsFitToContents = layout.isCrossAxisFitToContents();
            if (crossAxisIsFitToContents) {
              childRecalc += crossAxisRecalcFlag;
            }
          }
        }
      }
      let isWidthDynamic = layout.isAxisFitToContents(true);
      let isHeightDynamic = layout.isAxisFitToContents(false);
      if (layout.shrunk) {
        if (layout._horizontal) {
          isWidthDynamic = true;
        } else {
          isHeightDynamic = true;
        }
      }
      const localRecalc = 1 + (isWidthDynamic ? 2 : 0) + (isHeightDynamic ? 4 : 0);
      const combinedRecalc = childRecalc & localRecalc;
      return combinedRecalc;
    }
    get recalc() {
      return this._recalc;
    }
    clearRecalcFlag() {
      this._recalc = 0;
    }
    enableLocalRecalcFlag() {
      this._recalc = 1;
    }
    get originalX() {
      return this._originalX;
    }
    setOriginalXWithoutUpdatingLayout(v) {
      this._originalX = v;
    }
    get originalY() {
      return this._originalY;
    }
    setOriginalYWithoutUpdatingLayout(v) {
      this._originalY = v;
    }
    get originalWidth() {
      return this._originalWidth;
    }
    set originalWidth(v) {
      if (this._originalWidth !== v) {
        this._originalWidth = v;
        this.changedDimensions(true, false);
      }
    }
    get originalHeight() {
      return this._originalHeight;
    }
    set originalHeight(v) {
      if (this._originalHeight !== v) {
        this._originalHeight = v;
        this.changedDimensions(false, true);
      }
    }
    get funcX() {
      return this._target.funcX;
    }
    get funcY() {
      return this._target.funcY;
    }
    get funcW() {
      return this._target.funcW;
    }
    get funcH() {
      return this._target.funcH;
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/TextureSource.mjs
  var TextureSource = class _TextureSource {
    constructor(manager, loader3 = null) {
      this.id = _TextureSource.id++;
      this.manager = manager;
      this.stage = manager.stage;
      this.textures = /* @__PURE__ */ new Set();
      this._activeTextureCount = 0;
      this.loader = loader3;
      this.lookupId = null;
      this._cancelCb = null;
      this.loadingSince = 0;
      this.w = 0;
      this.h = 0;
      this._nativeTexture = null;
      this.permanent = false;
      this.renderInfo = null;
      this._isResultTexture = !this.loader;
      this._loadError = null;
      this._imageRef = null;
      this._hasAlpha = false;
    }
    get hasAlpha() {
      return this._hasAlpha;
    }
    get loadError() {
      return this._loadError;
    }
    addTexture(v) {
      if (!this.textures.has(v)) {
        this.textures.add(v);
      }
    }
    removeTexture(v) {
      this.textures.delete(v);
    }
    incActiveTextureCount() {
      this._activeTextureCount++;
      if (this._activeTextureCount === 1) {
        this.becomesUsed();
      }
    }
    decActiveTextureCount() {
      this._activeTextureCount--;
      if (this._activeTextureCount === 0) {
        this.becomesUnused();
      }
    }
    get isResultTexture() {
      return this._isResultTexture;
    }
    set isResultTexture(v) {
      this._isResultTexture = v;
    }
    forEachEnabledElement(cb) {
      this.textures.forEach((texture) => {
        texture.elements.forEach(cb);
      });
    }
    hasEnabledElements() {
      return this.textures.size > 0;
    }
    forEachActiveElement(cb) {
      this.textures.forEach((texture) => {
        texture.elements.forEach((element) => {
          if (element.active) {
            cb(element);
          }
        });
      });
    }
    getRenderWidth() {
      return this.w;
    }
    getRenderHeight() {
      return this.h;
    }
    allowCleanup() {
      return !this.permanent && !this.isUsed();
    }
    becomesUsed() {
      this.load();
    }
    becomesUnused() {
      this.cancel();
    }
    cancel() {
      if (this.isLoading()) {
        if (this._cancelCb) {
          this._cancelCb(this);
          this._cancelCb = null;
        }
        this.loadingSince = 0;
      }
    }
    isLoaded() {
      return !!this._nativeTexture;
    }
    isLoading() {
      return this.loadingSince > 0;
    }
    isError() {
      return !!this._loadError;
    }
    reload() {
      this.free();
      if (this.isUsed()) {
        this.load();
      }
    }
    load(forceSync = false) {
      if (this.isResultTexture) {
        return;
      }
      if (!this._nativeTexture && !this.isLoading()) {
        this.loadingSince = (/* @__PURE__ */ new Date()).getTime();
        this._cancelCb = this.loader((err, options) => {
          if (this.isLoading()) {
            this._cancelCb = null;
            if (this.manager.stage.destroyed) {
              return;
            }
            if (err) {
              this.onError(err);
            } else if (options && options.source) {
              if (!this.stage.isUpdatingFrame() && !forceSync && options.throttle !== false) {
                const textureThrottler = this.stage.textureThrottler;
                this._cancelCb = textureThrottler.genericCancelCb;
                textureThrottler.add(this, options);
              } else {
                this.processLoadedSource(options);
              }
            }
          }
        }, this);
      }
    }
    processLoadedSource(options) {
      this.loadingSince = 0;
      this.setSource(options);
    }
    setSource(options) {
      const source = options.source;
      this._hasAlpha = options ? options.hasAlpha || false : false;
      this.w = source.width || options && options.w || 0;
      this.h = source.height || options && options.h || 0;
      if (options && options.renderInfo) {
        this.renderInfo = options.renderInfo;
      }
      this.permanent = !!options.permanent;
      if (options && options.imageRef)
        this._imageRef = options.imageRef;
      if (options && options.flipTextureY) {
        this._flipTextureY = options.flipTextureY;
      } else {
        this._flipTextureY = false;
      }
      if (this._isNativeTexture(source)) {
        this._nativeTexture = source;
        this.w = this.w || source.w;
        this.h = this.h || source.h;
        this.permanent = options.hasOwnProperty("permanent") ? options.permanent : true;
      } else {
        this.manager.uploadTextureSource(this, options);
      }
      this._loadError = null;
      this.onLoad();
    }
    isUsed() {
      return this._activeTextureCount > 0;
    }
    onLoad() {
      if (this.isUsed()) {
        this.textures.forEach((texture) => {
          texture.onLoad();
        });
      }
    }
    forceRenderUpdate() {
      if (this._nativeTexture) {
        this._nativeTexture.update = this.stage.frameCounter;
      }
      this.forEachActiveElement(function(element) {
        element.forceRenderUpdate();
      });
    }
    forceUpdateRenderCoords() {
      this.forEachActiveElement(function(element) {
        element._updateTextureCoords();
      });
    }
    get nativeTexture() {
      return this._nativeTexture;
    }
    clearNativeTexture() {
      this._nativeTexture = null;
      this._imageRef = null;
    }
    /**
     * Used for result textures.
     */
    replaceNativeTexture(newNativeTexture, w, h) {
      let prevNativeTexture = this._nativeTexture;
      this._nativeTexture = newNativeTexture;
      this.w = w;
      this.h = h;
      if (!prevNativeTexture && this._nativeTexture) {
        this.forEachActiveElement((element) => element.onTextureSourceLoaded());
      }
      if (!this._nativeTexture) {
        this.forEachActiveElement((element) => element._setDisplayedTexture(null));
      }
      this.forEachEnabledElement((element) => element._updateDimensions());
    }
    onError(e) {
      this._loadError = e;
      this.loadingSince = 0;
      console.error("[Lightning] texture load error", e, this.lookupId);
      this.forEachActiveElement((element) => element.onTextureSourceLoadError(e));
    }
    free() {
      if (this.isLoaded()) {
        this.manager.freeTextureSource(this);
      }
    }
    _isNativeTexture(source) {
      if (Utils.isNode) {
        return source.constructor.name === "WebGLTexture";
      }
      if ("WebGLTexture" in window) {
        return source instanceof WebGLTexture;
      }
      return false;
    }
  };
  TextureSource.prototype.isTextureSource = true;
  TextureSource.id = 1;

  // node_modules/@lightningjs/core/dist/src/tree/core/ElementTexturizer.mjs
  var ElementTexturizer = class {
    constructor(elementCore) {
      this._element = elementCore.element;
      this._core = elementCore;
      this.ctx = this._core.ctx;
      this._enabled = false;
      this.lazy = false;
      this._colorize = false;
      this._renderTexture = null;
      this._renderTextureReused = false;
      this._resultTextureSource = null;
      this._renderOffscreen = false;
      this.empty = false;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(v) {
      this._enabled = v;
      this._core.updateRenderToTextureEnabled();
    }
    get renderOffscreen() {
      return this._renderOffscreen;
    }
    set renderOffscreen(v) {
      this._renderOffscreen = v;
      this._core.setHasRenderUpdates(1);
      this._core._setRecalc(6);
    }
    get colorize() {
      return this._colorize;
    }
    set colorize(v) {
      if (this._colorize !== v) {
        this._colorize = v;
        this._core.setHasRenderUpdates(1);
      }
    }
    _getTextureSource() {
      if (!this._resultTextureSource) {
        this._resultTextureSource = new TextureSource(this._element.stage.textureManager);
        this.updateResultTexture();
      }
      return this._resultTextureSource;
    }
    hasResultTexture() {
      return !!this._resultTextureSource;
    }
    resultTextureInUse() {
      return this._resultTextureSource && this._resultTextureSource.hasEnabledElements();
    }
    updateResultTexture() {
      let resultTexture = this.getResultTexture();
      if (this._resultTextureSource) {
        if (this._resultTextureSource.nativeTexture !== resultTexture) {
          let w = resultTexture ? resultTexture.w : 0;
          let h = resultTexture ? resultTexture.h : 0;
          this._resultTextureSource.replaceNativeTexture(resultTexture, w, h);
        }
        this._resultTextureSource.forEachEnabledElement((element) => {
          element._updateDimensions();
          element.core.setHasRenderUpdates(3);
        });
      }
    }
    mustRenderToTexture() {
      if (this._enabled && !this.lazy) {
        return true;
      } else if (this._enabled && this.lazy && this._core._hasRenderUpdates < 3) {
        return true;
      }
      return false;
    }
    deactivate() {
      this.release();
    }
    get renderTextureReused() {
      return this._renderTextureReused;
    }
    release() {
      this.releaseRenderTexture();
    }
    releaseRenderTexture() {
      if (this._renderTexture) {
        if (!this._renderTextureReused) {
          this.ctx.releaseRenderTexture(this._renderTexture);
        }
        this._renderTexture = null;
        this._renderTextureReused = false;
        this.updateResultTexture();
      }
    }
    // Reuses the specified texture as the render texture (in ancestor).
    reuseTextureAsRenderTexture(nativeTexture) {
      if (this._renderTexture !== nativeTexture) {
        this.releaseRenderTexture();
        this._renderTexture = nativeTexture;
        this._renderTextureReused = true;
      }
    }
    hasRenderTexture() {
      return !!this._renderTexture;
    }
    getRenderTexture() {
      if (!this._renderTexture) {
        this._renderTexture = this.ctx.allocateRenderTexture(this._core._w, this._core._h);
        this._renderTextureReused = false;
      }
      return this._renderTexture;
    }
    getResultTexture() {
      return this._renderTexture;
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/core/ElementCore.mjs
  var ElementCore = class _ElementCore {
    constructor(element) {
      this._element = element;
      this.ctx = element.stage.ctx;
      this._recalc = 0;
      this._parent = null;
      this._onUpdate = null;
      this._pRecalc = 0;
      this._worldContext = new ElementCoreContext();
      this._hasUpdates = false;
      this._localAlpha = 1;
      this._onAfterCalcs = null;
      this._onAfterUpdate = null;
      this._localPx = 0;
      this._localPy = 0;
      this._localTa = 1;
      this._localTb = 0;
      this._localTc = 0;
      this._localTd = 1;
      this._isComplex = false;
      this._dimsUnknown = false;
      this._clipping = false;
      this._zSort = false;
      this._outOfBounds = 0;
      this._displayedTextureSource = null;
      this._zContextUsage = 0;
      this._children = null;
      this._hasRenderUpdates = 0;
      this._zIndexedChildren = null;
      this._renderContext = this._worldContext;
      this.renderState = this.ctx.renderState;
      this._scissor = null;
      this._shaderOwner = null;
      this._updateTreeOrder = 0;
      this._colorUl = this._colorUr = this._colorBl = this._colorBr = 4294967295;
      this._x = 0;
      this._y = 0;
      this._w = 0;
      this._h = 0;
      this._optFlags = 0;
      this._funcX = null;
      this._funcY = null;
      this._funcW = null;
      this._funcH = null;
      this._scaleX = 1;
      this._scaleY = 1;
      this._pivotX = 0.5;
      this._pivotY = 0.5;
      this._mountX = 0;
      this._mountY = 0;
      this._rotation = 0;
      this._alpha = 1;
      this._visible = true;
      this._ulx = 0;
      this._uly = 0;
      this._brx = 1;
      this._bry = 1;
      this._zIndex = 0;
      this._forceZIndexContext = false;
      this._zParent = null;
      this._isRoot = false;
      this._zIndexResort = false;
      this._shader = null;
      this._renderToTextureEnabled = false;
      this._texturizer = null;
      this._useRenderToTexture = false;
      this._boundsMargin = null;
      this._recBoundsMargin = null;
      this._withinBoundsMargin = false;
      this._viewport = null;
      this._clipbox = true;
      this.render = this._renderSimple;
      this._layout = null;
    }
    get offsetX() {
      if (this._funcX) {
        return this._funcX;
      } else {
        if (this.hasFlexLayout()) {
          return this._layout.originalX;
        } else {
          return this._x;
        }
      }
    }
    set offsetX(v) {
      if (Utils.isFunction(v)) {
        this.funcX = v;
      } else {
        this._disableFuncX();
        if (this.hasFlexLayout()) {
          this.x += v - this._layout.originalX;
          this._layout.setOriginalXWithoutUpdatingLayout(v);
        } else {
          this.x = v;
        }
      }
    }
    get x() {
      return this._x;
    }
    set x(v) {
      if (v !== this._x) {
        this._updateLocalTranslateDelta(v - this._x, 0);
        this._x = v;
      }
    }
    get funcX() {
      return this._optFlags & 1 ? this._funcX : null;
    }
    set funcX(v) {
      if (this._funcX !== v) {
        this._optFlags |= 1;
        this._funcX = v;
        if (this.hasFlexLayout()) {
          this._layout.setOriginalXWithoutUpdatingLayout(0);
          this.layout.forceLayout();
        } else {
          this._x = 0;
          this._triggerRecalcTranslate();
        }
      }
    }
    _disableFuncX() {
      this._optFlags = this._optFlags & 65535 - 1;
      this._funcX = null;
    }
    get offsetY() {
      if (this._funcY) {
        return this._funcY;
      } else {
        if (this.hasFlexLayout()) {
          return this._layout.originalY;
        } else {
          return this._y;
        }
      }
    }
    set offsetY(v) {
      if (Utils.isFunction(v)) {
        this.funcY = v;
      } else {
        this._disableFuncY();
        if (this.hasFlexLayout()) {
          this.y += v - this._layout.originalY;
          this._layout.setOriginalYWithoutUpdatingLayout(v);
        } else {
          this.y = v;
        }
      }
    }
    get y() {
      return this._y;
    }
    set y(v) {
      if (v !== this._y) {
        this._updateLocalTranslateDelta(0, v - this._y);
        this._y = v;
      }
    }
    get funcY() {
      return this._optFlags & 2 ? this._funcY : null;
    }
    set funcY(v) {
      if (this._funcY !== v) {
        this._optFlags |= 2;
        this._funcY = v;
        if (this.hasFlexLayout()) {
          this._layout.setOriginalYWithoutUpdatingLayout(0);
          this.layout.forceLayout();
        } else {
          this._y = 0;
          this._triggerRecalcTranslate();
        }
      }
    }
    _disableFuncY() {
      this._optFlags = this._optFlags & 65535 - 2;
      this._funcY = null;
    }
    get funcW() {
      return this._optFlags & 4 ? this._funcW : null;
    }
    set funcW(v) {
      if (this._funcW !== v) {
        this._optFlags |= 4;
        this._funcW = v;
        if (this.hasFlexLayout()) {
          this._layout._originalWidth = 0;
          this.layout.changedDimensions(true, false);
        } else {
          this._w = 0;
          this._triggerRecalcTranslate();
        }
      }
    }
    disableFuncW() {
      this._optFlags = this._optFlags & 65535 - 4;
      this._funcW = null;
    }
    get funcH() {
      return this._optFlags & 8 ? this._funcH : null;
    }
    set funcH(v) {
      if (this._funcH !== v) {
        this._optFlags |= 8;
        this._funcH = v;
        if (this.hasFlexLayout()) {
          this._layout._originalHeight = 0;
          this.layout.changedDimensions(false, true);
        } else {
          this._h = 0;
          this._triggerRecalcTranslate();
        }
      }
    }
    disableFuncH() {
      this._optFlags = this._optFlags & 65535 - 8;
      this._funcH = null;
    }
    get w() {
      return this._w;
    }
    getRenderWidth() {
      if (this.hasFlexLayout()) {
        return this._layout.originalWidth;
      } else {
        return this._w;
      }
    }
    get h() {
      return this._h;
    }
    getRenderHeight() {
      if (this.hasFlexLayout()) {
        return this._layout.originalHeight;
      } else {
        return this._h;
      }
    }
    get scaleX() {
      return this._scaleX;
    }
    set scaleX(v) {
      if (this._scaleX !== v) {
        this._scaleX = v;
        this._updateLocalTransform();
      }
    }
    get scaleY() {
      return this._scaleY;
    }
    set scaleY(v) {
      if (this._scaleY !== v) {
        this._scaleY = v;
        this._updateLocalTransform();
      }
    }
    get scale() {
      return this.scaleX;
    }
    set scale(v) {
      if (this._scaleX !== v || this._scaleY !== v) {
        this._scaleX = v;
        this._scaleY = v;
        this._updateLocalTransform();
      }
    }
    get pivotX() {
      return this._pivotX;
    }
    set pivotX(v) {
      if (this._pivotX !== v) {
        this._pivotX = v;
        this._updateLocalTranslate();
      }
    }
    get pivotY() {
      return this._pivotY;
    }
    set pivotY(v) {
      if (this._pivotY !== v) {
        this._pivotY = v;
        this._updateLocalTranslate();
      }
    }
    get pivot() {
      return this._pivotX;
    }
    set pivot(v) {
      if (this._pivotX !== v || this._pivotY !== v) {
        this._pivotX = v;
        this._pivotY = v;
        this._updateLocalTranslate();
      }
    }
    get mountX() {
      return this._mountX;
    }
    set mountX(v) {
      if (this._mountX !== v) {
        this._mountX = v;
        this._updateLocalTranslate();
      }
    }
    get mountY() {
      return this._mountY;
    }
    set mountY(v) {
      if (this._mountY !== v) {
        this._mountY = v;
        this._updateLocalTranslate();
      }
    }
    get mount() {
      return this._mountX;
    }
    set mount(v) {
      if (this._mountX !== v || this._mountY !== v) {
        this._mountX = v;
        this._mountY = v;
        this._updateLocalTranslate();
      }
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(v) {
      if (this._rotation !== v) {
        this._rotation = v;
        this._updateLocalTransform();
      }
    }
    get alpha() {
      return this._alpha;
    }
    set alpha(v) {
      v = v > 1 ? 1 : v < 1e-14 ? 0 : v;
      if (this._alpha !== v) {
        let prev = this._alpha;
        this._alpha = v;
        this._updateLocalAlpha();
        if (prev === 0 !== (v === 0)) {
          this._element._updateEnabledFlag();
        }
      }
    }
    get visible() {
      return this._visible;
    }
    set visible(v) {
      if (this._visible !== v) {
        this._visible = v;
        this._updateLocalAlpha();
        this._element._updateEnabledFlag();
        if (this.hasFlexLayout()) {
          this.layout.setVisible(v);
        }
      }
    }
    _updateLocalTransform() {
      if (this._rotation !== 0 && this._rotation % (2 * Math.PI)) {
        let _sr = Math.sin(this._rotation);
        let _cr = Math.cos(this._rotation);
        this._setLocalTransform(
          _cr * this._scaleX,
          -_sr * this._scaleY,
          _sr * this._scaleX,
          _cr * this._scaleY
        );
      } else {
        this._setLocalTransform(
          this._scaleX,
          0,
          0,
          this._scaleY
        );
      }
      this._updateLocalTranslate();
    }
    _updateLocalTranslate() {
      this._recalcLocalTranslate();
      this._triggerRecalcTranslate();
    }
    _recalcLocalTranslate() {
      let pivotXMul = this._pivotX * this._w;
      let pivotYMul = this._pivotY * this._h;
      let px = this._x - (pivotXMul * this._localTa + pivotYMul * this._localTb) + pivotXMul;
      let py = this._y - (pivotXMul * this._localTc + pivotYMul * this._localTd) + pivotYMul;
      px -= this._mountX * this._w;
      py -= this._mountY * this._h;
      this._localPx = px;
      this._localPy = py;
    }
    _updateLocalTranslateDelta(dx, dy) {
      this._addLocalTranslate(dx, dy);
    }
    _updateLocalAlpha() {
      this._setLocalAlpha(this._visible ? this._alpha : 0);
    }
    /**
     * @param {number} type
     * 0: no updates
     * 1: re-invoke shader
     * 3: re-create render texture and re-invoke shader
     */
    setHasRenderUpdates(type) {
      if (this._worldContext.alpha) {
        let p = this;
        p._hasRenderUpdates = Math.max(type, p._hasRenderUpdates);
        while ((p = p._parent) && p._hasRenderUpdates !== 3) {
          p._hasRenderUpdates = 3;
        }
      }
    }
    /**
     * @param {Number} type
     *   1: alpha
     *   2: translate
     *   4: transform
     * 128: becomes visible
     * 256: flex layout updated
     */
    _setRecalc(type) {
      this._recalc |= type;
      this._setHasUpdates();
      if (this._parent) {
        this._parent.setHasRenderUpdates(3);
      }
    }
    _setHasUpdates() {
      let p = this;
      while (p && !p._hasUpdates) {
        p._hasUpdates = true;
        p = p._parent;
      }
    }
    getParent() {
      return this._parent;
    }
    setParent(parent) {
      if (parent !== this._parent) {
        let prevIsZContext = this.isZContext();
        let prevParent = this._parent;
        this._parent = parent;
        if (this._layout || parent && parent.isFlexContainer()) {
          this.layout.setParent(prevParent, parent);
        }
        if (prevParent) {
          prevParent.setHasRenderUpdates(3);
        }
        this._setRecalc(1 + 2 + 4);
        if (this._parent) {
          this._parent._setHasUpdates();
        }
        if (this._zIndex === 0) {
          this.setZParent(parent);
        } else {
          this.setZParent(parent ? parent.findZContext() : null);
        }
        if (prevIsZContext !== this.isZContext()) {
          if (!this.isZContext()) {
            this.disableZContext();
          } else {
            this.enableZContext(prevParent.findZContext());
          }
        }
        this._zIndexResort = true;
        if (this._zParent) {
          this._zParent.enableZSort();
        }
        if (!this._shader) {
          let newShaderOwner = parent && !parent._renderToTextureEnabled ? parent._shaderOwner : null;
          if (newShaderOwner !== this._shaderOwner) {
            this.setHasRenderUpdates(1);
            this._setShaderOwnerRecursive(newShaderOwner);
          }
        }
      }
    }
    enableZSort(force = false) {
      if (!this._zSort && this._zContextUsage > 0) {
        this._zSort = true;
        if (force) {
          this.ctx.forceZSort(this);
        }
      }
    }
    addChildAt(index, child) {
      if (!this._children) this._children = [];
      this._children.splice(index, 0, child);
      child.setParent(this);
    }
    setChildAt(index, child) {
      if (!this._children) this._children = [];
      this._children[index].setParent(null);
      this._children[index] = child;
      child.setParent(this);
    }
    removeChildAt(index) {
      let child = this._children[index];
      this._children.splice(index, 1);
      child.setParent(null);
    }
    removeChildren() {
      if (this._children) {
        for (let i = 0, n = this._children.length; i < n; i++) {
          this._children[i].setParent(null);
        }
        this._children.splice(0);
        if (this._zIndexedChildren) {
          this._zIndexedChildren.splice(0);
        }
      }
    }
    syncChildren(removed, added, order) {
      this._children = order;
      for (let i = 0, n = removed.length; i < n; i++) {
        removed[i].setParent(null);
      }
      for (let i = 0, n = added.length; i < n; i++) {
        added[i].setParent(this);
      }
    }
    moveChild(fromIndex, toIndex) {
      let c = this._children[fromIndex];
      this._children.splice(fromIndex, 1);
      this._children.splice(toIndex, 0, c);
      this._zIndexResort = true;
      if (this._zParent) {
        this._zParent.enableZSort();
      }
    }
    _setLocalTransform(a, b, c, d) {
      this._setRecalc(4);
      this._localTa = a;
      this._localTb = b;
      this._localTc = c;
      this._localTd = d;
      this._isComplex = b !== 0 || c !== 0 || a < 0 || d < 0;
    }
    _addLocalTranslate(dx, dy) {
      this._localPx += dx;
      this._localPy += dy;
      this._triggerRecalcTranslate();
    }
    _setLocalAlpha(a) {
      if (!this._worldContext.alpha && (this._parent && this._parent._worldContext.alpha && a)) {
        this._setRecalc(1 + 128);
      } else {
        this._setRecalc(1);
      }
      if (a < 1e-14) {
        a = 0;
      }
      this._localAlpha = a;
    }
    setDimensions(w, h, isEstimate = this._dimsUnknown) {
      this._dimsUnknown = isEstimate;
      if (this.hasFlexLayout()) {
        this._layout.originalWidth = w;
        this._layout.originalHeight = h;
      } else {
        if (this._w !== w || this._h !== h) {
          this._updateDimensions(w, h);
          return true;
        }
      }
      return false;
    }
    _updateDimensions(w, h) {
      if (this._w !== w || this._h !== h) {
        this._w = w;
        this._h = h;
        this._triggerRecalcTranslate();
        if (this._texturizer) {
          this._texturizer.releaseRenderTexture();
          this._texturizer.updateResultTexture();
        }
        this._updateLocalTranslate();
      }
    }
    setTextureCoords(ulx, uly, brx, bry) {
      this.setHasRenderUpdates(3);
      this._ulx = ulx;
      this._uly = uly;
      this._brx = brx;
      this._bry = bry;
    }
    get displayedTextureSource() {
      return this._displayedTextureSource;
    }
    setDisplayedTextureSource(textureSource) {
      this.setHasRenderUpdates(3);
      this._displayedTextureSource = textureSource;
    }
    get isRoot() {
      return this._isRoot;
    }
    setAsRoot() {
      this._parent = new _ElementCore(this._element);
      this._parent._hasRenderUpdates = 3;
      this._parent._hasUpdates = true;
      this._isRoot = true;
      this.ctx.root = this;
      this._parent._viewport = [0, 0, this.ctx.stage.coordsWidth, this.ctx.stage.coordsHeight];
      this._parent._scissor = this._parent._viewport;
      this._parent._recBoundsMargin = null;
      this._setRecalc(1 + 2 + 4);
    }
    isAncestorOf(c) {
      let p = c;
      while (p = p._parent) {
        if (this === p) {
          return true;
        }
      }
      return false;
    }
    isZContext() {
      return this._forceZIndexContext || this._renderToTextureEnabled || this._zIndex !== 0 || this._isRoot || !this._parent;
    }
    findZContext() {
      if (this.isZContext()) {
        return this;
      } else {
        return this._parent.findZContext();
      }
    }
    setZParent(newZParent) {
      if (this._zParent !== newZParent) {
        if (this._zParent !== null) {
          if (this._zIndex !== 0) {
            this._zParent.decZContextUsage();
          }
          this._zParent.enableZSort();
        }
        if (newZParent !== null) {
          let hadZContextUsage = newZParent._zContextUsage > 0;
          if (this._zIndex !== 0) {
            newZParent.incZContextUsage();
          }
          if (newZParent._zContextUsage > 0) {
            if (!hadZContextUsage && this._parent === newZParent) {
            } else {
              newZParent._zIndexedChildren.push(this);
            }
            newZParent.enableZSort();
          }
        }
        this._zParent = newZParent;
        this._zIndexResort = true;
      }
    }
    incZContextUsage() {
      this._zContextUsage++;
      if (this._zContextUsage === 1) {
        if (!this._zIndexedChildren) {
          this._zIndexedChildren = [];
        }
        if (this._children) {
          for (let i = 0, n = this._children.length; i < n; i++) {
            this._zIndexedChildren.push(this._children[i]);
          }
          this._zSort = false;
        }
      }
    }
    decZContextUsage() {
      this._zContextUsage--;
      if (this._zContextUsage === 0) {
        this._zSort = false;
        this._zIndexedChildren.splice(0);
      }
    }
    get zIndex() {
      return this._zIndex;
    }
    set zIndex(zIndex) {
      if (this._zIndex !== zIndex) {
        this.setHasRenderUpdates(1);
        let newZParent = this._zParent;
        let prevIsZContext = this.isZContext();
        if (zIndex === 0 && this._zIndex !== 0) {
          if (this._parent === this._zParent) {
            if (this._zParent) {
              this._zParent.decZContextUsage();
            }
          } else {
            newZParent = this._parent;
          }
        } else if (zIndex !== 0 && this._zIndex === 0) {
          newZParent = this._parent ? this._parent.findZContext() : null;
          if (newZParent === this._zParent) {
            if (this._zParent) {
              this._zParent.incZContextUsage();
              this._zParent.enableZSort();
            }
          }
        } else if (zIndex !== this._zIndex) {
          if (this._zParent && this._zParent._zContextUsage) {
            this._zParent.enableZSort();
          }
        }
        if (newZParent !== this._zParent) {
          this.setZParent(null);
        }
        this._zIndex = zIndex;
        if (newZParent !== this._zParent) {
          this.setZParent(newZParent);
        }
        if (prevIsZContext !== this.isZContext()) {
          if (!this.isZContext()) {
            this.disableZContext();
          } else {
            this.enableZContext(this._parent.findZContext());
          }
        }
        this._zIndexResort = true;
        if (this._zParent) {
          this._zParent.enableZSort();
        }
      }
    }
    get forceZIndexContext() {
      return this._forceZIndexContext;
    }
    set forceZIndexContext(v) {
      this.setHasRenderUpdates(1);
      let prevIsZContext = this.isZContext();
      this._forceZIndexContext = v;
      if (prevIsZContext !== this.isZContext()) {
        if (!this.isZContext()) {
          this.disableZContext();
        } else {
          this.enableZContext(this._parent.findZContext());
        }
      }
    }
    enableZContext(prevZContext) {
      if (prevZContext && prevZContext._zContextUsage > 0) {
        const results = this._getZIndexedDescs();
        results.forEach((c) => {
          if (this.isAncestorOf(c) && c._zIndex !== 0) {
            c.setZParent(this);
          }
        });
      }
    }
    _getZIndexedDescs() {
      const results = [];
      if (this._children) {
        for (let i = 0, n = this._children.length; i < n; i++) {
          this._children[i]._getZIndexedDescsRec(results);
        }
      }
      return results;
    }
    _getZIndexedDescsRec(results) {
      if (this._zIndex) {
        results.push(this);
      } else if (this._children && !this.isZContext()) {
        for (let i = 0, n = this._children.length; i < n; i++) {
          this._children[i]._getZIndexedDescsRec(results);
        }
      }
    }
    disableZContext() {
      if (this._zContextUsage > 0) {
        let newZParent = this._parent.findZContext();
        if (this._zSort) {
          this.sortZIndexedChildren();
        }
        this._zIndexedChildren.slice().forEach(function(c) {
          if (c._zIndex !== 0) {
            c.setZParent(newZParent);
          }
        });
      }
    }
    get colorUl() {
      return this._colorUl;
    }
    set colorUl(color) {
      if (this._colorUl !== color) {
        this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
        this._colorUl = color;
      }
    }
    get colorUr() {
      return this._colorUr;
    }
    set colorUr(color) {
      if (this._colorUr !== color) {
        this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
        this._colorUr = color;
      }
    }
    get colorBl() {
      return this._colorBl;
    }
    set colorBl(color) {
      if (this._colorBl !== color) {
        this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
        this._colorBl = color;
      }
    }
    get colorBr() {
      return this._colorBr;
    }
    set colorBr(color) {
      if (this._colorBr !== color) {
        this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
        this._colorBr = color;
      }
    }
    set onUpdate(f) {
      this._onUpdate = f;
      this._setRecalc(7);
    }
    set onAfterUpdate(f) {
      this._onAfterUpdate = f;
      this._setRecalc(7);
    }
    set onAfterCalcs(f) {
      this._onAfterCalcs = f;
      this._setRecalc(7);
    }
    get shader() {
      return this._shader;
    }
    set shader(v) {
      this.setHasRenderUpdates(1);
      let prevShader = this._shader;
      this._shader = v;
      if (!v && prevShader) {
        let newShaderOwner = this._parent && !this._parent._renderToTextureEnabled ? this._parent._shaderOwner : null;
        this._setShaderOwnerRecursive(newShaderOwner);
      } else if (v) {
        this._setShaderOwnerRecursive(this);
      }
    }
    get activeShader() {
      return this._shaderOwner ? this._shaderOwner.shader : this.renderState.defaultShader;
    }
    get activeShaderOwner() {
      return this._shaderOwner;
    }
    get clipping() {
      return this._clipping;
    }
    set clipping(v) {
      if (this._clipping !== v) {
        this._clipping = v;
        this._setRecalc(1 + 2);
      }
    }
    get clipbox() {
      return this._clipbox;
    }
    set clipbox(v) {
      this._clipbox = v;
    }
    _setShaderOwnerRecursive(elementCore) {
      this._shaderOwner = elementCore;
      if (this._children && !this._renderToTextureEnabled) {
        for (let i = 0, n = this._children.length; i < n; i++) {
          let c = this._children[i];
          if (!c._shader) {
            c._setShaderOwnerRecursive(elementCore);
            c._hasRenderUpdates = 3;
          }
        }
      }
    }
    _setShaderOwnerChildrenRecursive(elementCore) {
      if (this._children) {
        for (let i = 0, n = this._children.length; i < n; i++) {
          let c = this._children[i];
          if (!c._shader) {
            c._setShaderOwnerRecursive(elementCore);
            c._hasRenderUpdates = 3;
          }
        }
      }
    }
    _hasRenderContext() {
      return this._renderContext !== this._worldContext;
    }
    get renderContext() {
      return this._renderContext;
    }
    updateRenderToTextureEnabled() {
      let v = this.texturizer._enabled;
      if (v) {
        this._enableRenderToTexture();
      } else {
        this._disableRenderToTexture();
        this._texturizer.releaseRenderTexture();
      }
    }
    _enableRenderToTexture() {
      if (!this._renderToTextureEnabled) {
        let prevIsZContext = this.isZContext();
        this._renderToTextureEnabled = true;
        this._renderContext = new ElementCoreContext();
        this._setShaderOwnerChildrenRecursive(null);
        if (!prevIsZContext) {
          this.enableZContext(this._parent ? this._parent.findZContext() : null);
        }
        this.setHasRenderUpdates(3);
        this._setRecalc(7);
        this.render = this._renderAdvanced;
      }
    }
    _disableRenderToTexture() {
      if (this._renderToTextureEnabled) {
        this._renderToTextureEnabled = false;
        this._setShaderOwnerChildrenRecursive(this._shaderOwner);
        this._renderContext = this._worldContext;
        if (!this.isZContext()) {
          this.disableZContext();
        }
        this._setRecalc(7);
        this.setHasRenderUpdates(3);
        this.render = this._renderSimple;
      }
    }
    isWhite() {
      return this._colorUl === 4294967295 && this._colorUr === 4294967295 && this._colorBl === 4294967295 && this._colorBr === 4294967295;
    }
    hasSimpleTexCoords() {
      return this._ulx === 0 && this._uly === 0 && this._brx === 1 && this._bry === 1;
    }
    _stashTexCoords() {
      this._stashedTexCoords = [this._ulx, this._uly, this._brx, this._bry];
      this._ulx = 0;
      this._uly = 0;
      this._brx = 1;
      this._bry = 1;
    }
    _unstashTexCoords() {
      this._ulx = this._stashedTexCoords[0];
      this._uly = this._stashedTexCoords[1];
      this._brx = this._stashedTexCoords[2];
      this._bry = this._stashedTexCoords[3];
      this._stashedTexCoords = null;
    }
    _stashColors() {
      this._stashedColors = [this._colorUl, this._colorUr, this._colorBr, this._colorBl];
      this._colorUl = 4294967295;
      this._colorUr = 4294967295;
      this._colorBr = 4294967295;
      this._colorBl = 4294967295;
    }
    _unstashColors() {
      this._colorUl = this._stashedColors[0];
      this._colorUr = this._stashedColors[1];
      this._colorBr = this._stashedColors[2];
      this._colorBl = this._stashedColors[3];
      this._stashedColors = null;
    }
    isVisible() {
      return this._localAlpha > 1e-14;
    }
    get outOfBounds() {
      return this._outOfBounds;
    }
    set boundsMargin(v) {
      this._boundsMargin = v ? v.slice() : null;
      this._triggerRecalcTranslate();
    }
    get boundsMargin() {
      return this._boundsMargin;
    }
    update() {
      this._recalc |= this._parent._pRecalc;
      if (this._layout && this._layout.isEnabled()) {
        if (this._recalc & 256) {
          this._layout.layoutFlexTree();
        }
      } else if (this._recalc & 2 && this._optFlags) {
        this._applyRelativeDimFuncs();
      }
      if (this._onUpdate) {
        this._hasUpdates = true;
        this._onUpdate(this.element, this);
      }
      const pw = this._parent._worldContext;
      let w = this._worldContext;
      const visible = pw.alpha && this._localAlpha;
      if (this._hasUpdates || this._recalc && visible || w.alpha && !visible) {
        let recalc = this._recalc;
        if (recalc & 1) {
          if (!w.alpha && visible) {
            this._hasRenderUpdates = 3;
          }
          w.alpha = pw.alpha * this._localAlpha;
          if (w.alpha < 1e-14) {
            w.alpha = 0;
          }
        }
        if (recalc & 6) {
          w.px = pw.px + this._localPx * pw.ta;
          w.py = pw.py + this._localPy * pw.td;
          if (pw.tb !== 0) w.px += this._localPy * pw.tb;
          if (pw.tc !== 0) w.py += this._localPx * pw.tc;
        }
        if (recalc & 4) {
          w.ta = this._localTa * pw.ta;
          w.tb = this._localTd * pw.tb;
          w.tc = this._localTa * pw.tc;
          w.td = this._localTd * pw.td;
          if (this._isComplex) {
            w.ta += this._localTc * pw.tb;
            w.tb += this._localTb * pw.ta;
            w.tc += this._localTc * pw.td;
            w.td += this._localTb * pw.tc;
          }
        }
        const pr = this._parent._renderContext;
        if (this._parent._hasRenderContext()) {
          const init2 = this._renderContext === this._worldContext;
          if (init2) {
            this._renderContext = new ElementCoreContext();
          }
          const r2 = this._renderContext;
          if (init2 || recalc & 1) {
            r2.alpha = pr.alpha * this._localAlpha;
            if (r2.alpha < 1e-14) {
              r2.alpha = 0;
            }
          }
          if (init2 || recalc & 6) {
            r2.px = pr.px + this._localPx * pr.ta;
            r2.py = pr.py + this._localPy * pr.td;
            if (pr.tb !== 0) r2.px += this._localPy * pr.tb;
            if (pr.tc !== 0) r2.py += this._localPx * pr.tc;
          }
          if (init2) {
            recalc |= 2;
          }
          if (init2 || recalc & 4) {
            r2.ta = this._localTa * pr.ta;
            r2.tb = this._localTd * pr.tb;
            r2.tc = this._localTa * pr.tc;
            r2.td = this._localTd * pr.td;
            if (this._isComplex) {
              r2.ta += this._localTc * pr.tb;
              r2.tb += this._localTb * pr.ta;
              r2.tc += this._localTc * pr.td;
              r2.td += this._localTb * pr.tc;
            }
          }
        } else {
          this._renderContext = this._worldContext;
        }
        if (this.ctx.updateTreeOrder === -1) {
          this.ctx.updateTreeOrder = this._updateTreeOrder + 1;
        } else {
          this._updateTreeOrder = this.ctx.updateTreeOrder++;
        }
        const useRenderToTexture = this._renderToTextureEnabled && this._texturizer.mustRenderToTexture();
        if (this._useRenderToTexture !== useRenderToTexture) {
          this._recalc |= 2 + 4;
          recalc |= 2;
          if (!this._useRenderToTexture) {
            this._texturizer.release();
          }
        }
        this._useRenderToTexture = useRenderToTexture;
        const r = this._renderContext;
        const bboxW = this._dimsUnknown ? 2048 : this._w;
        const bboxH = this._dimsUnknown ? 2048 : this._h;
        let sx, sy, ex, ey;
        const rComplex = r.tb !== 0 || r.tc !== 0 || r.ta < 0 || r.td < 0;
        if (rComplex) {
          sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
          ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
          sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
          ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
        } else {
          sx = r.px;
          ex = r.px + r.ta * bboxW;
          sy = r.py;
          ey = r.py + r.td * bboxH;
        }
        if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
          const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
          const ny = this._x * pr.tc + this._y * pr.td + pr.py;
          if (nx < sx) sx = nx;
          if (ny < sy) sy = ny;
          if (nx > ex) ex = nx;
          if (ny > ey) ey = ny;
        }
        if (recalc & 6 || !this._scissor) {
          if (this._clipping && r.isSquare()) {
            const area = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
            if (area) {
              const lx = Math.max(area[0], sx);
              const ly = Math.max(area[1], sy);
              this._scissor = [
                lx,
                ly,
                Math.min(area[2] + area[0], ex) - lx,
                Math.min(area[3] + area[1], ey) - ly
              ];
            } else {
              this._scissor = [sx, sy, ex - sx, ey - sy];
            }
          } else {
            this._scissor = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
          }
        }
        if (this._boundsMargin) {
          this._recBoundsMargin = this._boundsMargin;
        } else {
          this._recBoundsMargin = this._parent._recBoundsMargin;
        }
        if (this._onAfterCalcs) {
          if (this._onAfterCalcs(this.element)) {
            if (rComplex) {
              sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
              ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
              sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
              ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
            } else {
              sx = r.px;
              ex = r.px + r.ta * bboxW;
              sy = r.py;
              ey = r.py + r.td * bboxH;
            }
            if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
              const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
              const ny = this._x * pr.tc + this._y * pr.td + pr.py;
              if (nx < sx) sx = nx;
              if (ny < sy) sy = ny;
              if (nx > ex) ex = nx;
              if (ny > ey) ey = ny;
            }
          }
        }
        if (this._parent._outOfBounds === 2) {
          this._outOfBounds = 2;
          if (this._withinBoundsMargin) {
            this._withinBoundsMargin = false;
            this.element._disableWithinBoundsMargin();
          }
        } else {
          if (recalc & 6) {
            this._outOfBounds = 0;
            let withinMargin = true;
            if (!this._renderToTextureEnabled || !this._texturizer || !this._texturizer.renderOffscreen) {
              if (this._scissor && (this._scissor[2] <= 0 || this._scissor[3] <= 0)) {
                this._outOfBounds = 2;
              } else {
                if (this._scissor[0] > ex || this._scissor[1] > ey || sx > this._scissor[0] + this._scissor[2] || sy > this._scissor[1] + this._scissor[3]) {
                  this._outOfBounds = 1;
                }
                if (this._outOfBounds) {
                  if (this._clipping || this._useRenderToTexture || this._clipbox && (bboxW && bboxH)) {
                    this._outOfBounds = 2;
                  }
                }
              }
              withinMargin = this._outOfBounds === 0;
              if (!withinMargin) {
                if (this._recBoundsMargin) {
                  withinMargin = !(ex < this._scissor[0] - this._recBoundsMargin[2] || ey < this._scissor[1] - this._recBoundsMargin[3] || sx > this._scissor[0] + this._scissor[2] + this._recBoundsMargin[0] || sy > this._scissor[1] + this._scissor[3] + this._recBoundsMargin[1]);
                } else {
                  withinMargin = !(ex < this._scissor[0] - 100 || ey < this._scissor[1] - 100 || sx > this._scissor[0] + this._scissor[2] + 100 || sy > this._scissor[1] + this._scissor[3] + 100);
                }
                if (withinMargin && this._outOfBounds === 2) {
                  this._outOfBounds = 1;
                }
              }
            }
            if (this._withinBoundsMargin !== withinMargin) {
              this._withinBoundsMargin = withinMargin;
              if (this._withinBoundsMargin) {
                this._hasUpdates = true;
                const recalc2 = this._recalc;
                this._recalc = 0;
                this.element._enableWithinBoundsMargin();
                if (this._recalc) {
                  return this.update();
                }
                this._recalc = recalc2;
              } else {
                this.element._disableWithinBoundsMargin();
              }
            }
          }
        }
        if (this._useRenderToTexture) {
          if (this._viewport) {
            this._viewport[2] = bboxW;
            this._viewport[3] = bboxH;
          } else {
            this._viewport = [0, 0, bboxW, bboxH];
          }
        }
        this._pRecalc = this._recalc & 135;
        this._recalc = 0;
        this._hasUpdates = false;
        if (this._outOfBounds < 2) {
          if (this._useRenderToTexture) {
            if (this._worldContext.isIdentity()) {
              this._renderContext = this._worldContext;
            } else {
              this._renderContext = ElementCoreContext.IDENTITY;
            }
          }
          if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
              this._children[i].update();
            }
          }
          if (this._useRenderToTexture) {
            this._renderContext = r;
          }
        } else {
          if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
              if (this._children[i]._hasUpdates) {
                this._children[i].update();
              } else {
                this._children[i]._recalc |= this._pRecalc;
                this._children[i].updateOutOfBounds();
              }
            }
          }
        }
        if (this._onAfterUpdate) {
          this._onAfterUpdate(this.element);
        }
      } else {
        if (this.ctx.updateTreeOrder === -1 || this._updateTreeOrder >= this.ctx.updateTreeOrder) {
          this.ctx.updateTreeOrder = -1;
        } else {
          this.updateTreeOrder();
        }
      }
    }
    _applyRelativeDimFuncs() {
      if (this._optFlags & 1) {
        const x = this._funcX(this._parent.w);
        if (x !== this._x) {
          this._localPx += x - this._x;
          this._x = x;
        }
      }
      if (this._optFlags & 2) {
        const y = this._funcY(this._parent.h);
        if (y !== this._y) {
          this._localPy += y - this._y;
          this._y = y;
        }
      }
      let changedDims = false;
      if (this._optFlags & 4) {
        const w = this._funcW(this._parent.w);
        if (w !== this._w) {
          this._w = w;
          changedDims = true;
        }
      }
      if (this._optFlags & 8) {
        const h = this._funcH(this._parent.h);
        if (h !== this._h) {
          this._h = h;
          changedDims = true;
        }
      }
      if (changedDims) {
        this._recalcLocalTranslate();
        this.element.onDimensionsChanged(this._w, this._h);
      }
    }
    updateOutOfBounds() {
      if (this._outOfBounds !== 2 && this._renderContext.alpha > 0) {
        this._outOfBounds = 2;
        if (this._withinBoundsMargin) {
          this._withinBoundsMargin = false;
          this.element._disableWithinBoundsMargin();
        }
        if (this._children) {
          for (let i = 0, n = this._children.length; i < n; i++) {
            this._children[i].updateOutOfBounds();
          }
        }
      }
    }
    updateTreeOrder() {
      if (this._localAlpha && this._outOfBounds !== 2) {
        this._updateTreeOrder = this.ctx.updateTreeOrder++;
        if (this._children) {
          for (let i = 0, n = this._children.length; i < n; i++) {
            this._children[i].updateTreeOrder();
          }
        }
      }
    }
    _renderSimple() {
      this._hasRenderUpdates = 0;
      if (this._zSort) {
        this.sortZIndexedChildren();
      }
      if (this._outOfBounds < 2 && this._renderContext.alpha) {
        let renderState = this.renderState;
        if (this._outOfBounds === 0 && this._displayedTextureSource) {
          renderState.setShader(this.activeShader, this._shaderOwner);
          renderState.setScissor(this._scissor);
          this.renderState.addQuad(this);
        }
        if (this._children) {
          if (this._zContextUsage) {
            for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
              this._zIndexedChildren[i].render();
            }
          } else {
            for (let i = 0, n = this._children.length; i < n; i++) {
              if (this._children[i]._zIndex === 0) {
                this._children[i].render();
              }
            }
          }
        }
      }
    }
    _renderAdvanced() {
      const hasRenderUpdates = this._hasRenderUpdates;
      this._hasRenderUpdates = 0;
      if (this._zSort) {
        this.sortZIndexedChildren();
      }
      if (this._outOfBounds < 2 && this._renderContext.alpha) {
        let renderState = this.renderState;
        let mustRenderChildren = true;
        let renderTextureInfo;
        let prevRenderTextureInfo;
        if (this._useRenderToTexture) {
          if (this._w === 0 || this._h === 0) {
            return;
          } else if (!this._texturizer.hasRenderTexture() || hasRenderUpdates >= 3) {
            this.ctx.renderToTextureCount++;
            renderState.setShader(renderState.defaultShader, this);
            prevRenderTextureInfo = renderState.renderTextureInfo;
            renderTextureInfo = {
              nativeTexture: null,
              offset: 0,
              // Set by CoreRenderState.
              w: this._w,
              h: this._h,
              empty: true,
              cleared: false,
              ignore: false,
              cache: false
            };
            if (this._texturizer.hasResultTexture() || !renderState.isCachingTexturizer && hasRenderUpdates < 3) {
              renderTextureInfo.cache = true;
              renderState.isCachingTexturizer = true;
            }
            if (!this._texturizer.hasResultTexture()) {
              this._texturizer.releaseRenderTexture();
            }
            renderState.setRenderTextureInfo(renderTextureInfo);
            renderState.setScissor(null);
            if (this._displayedTextureSource) {
              let r = this._renderContext;
              this._renderContext = ElementCoreContext.IDENTITY;
              this.renderState.addQuad(this);
              this._renderContext = r;
            }
          } else {
            mustRenderChildren = false;
          }
        } else {
          if (this._outOfBounds === 0 && this._displayedTextureSource) {
            renderState.setShader(this.activeShader, this._shaderOwner);
            renderState.setScissor(this._scissor);
            this.renderState.addQuad(this);
          }
        }
        if (mustRenderChildren && this._children) {
          if (this._zContextUsage) {
            for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
              this._zIndexedChildren[i].render();
            }
          } else {
            for (let i = 0, n = this._children.length; i < n; i++) {
              if (this._children[i]._zIndex === 0) {
                this._children[i].render();
              }
            }
          }
        }
        if (this._useRenderToTexture) {
          let updateResultTexture = false;
          if (mustRenderChildren) {
            renderState.finishedRenderTexture();
            this._texturizer.empty = renderTextureInfo.empty;
            if (renderTextureInfo.empty) {
              this._texturizer.releaseRenderTexture();
            } else if (renderTextureInfo.nativeTexture) {
              this._texturizer.reuseTextureAsRenderTexture(renderTextureInfo.nativeTexture);
              renderTextureInfo.ignore = true;
            } else {
              if (this._texturizer.renderTextureReused) {
                this._texturizer.releaseRenderTexture();
              }
              renderTextureInfo.nativeTexture = this._texturizer.getRenderTexture();
            }
            renderState.setRenderTextureInfo(prevRenderTextureInfo);
            updateResultTexture = true;
          }
          if (!this._texturizer.empty) {
            let resultTexture = this._texturizer.getResultTexture();
            if (updateResultTexture) {
              if (resultTexture) {
                resultTexture.update = renderState.stage.frameCounter;
              }
              this._texturizer.updateResultTexture();
            }
            if (!this._texturizer.renderOffscreen) {
              renderState.setShader(this.activeShader, this._shaderOwner);
              renderState.setScissor(this._scissor);
              const cache = !renderTextureInfo || renderTextureInfo.cache;
              renderState.setTexturizer(this._texturizer, cache);
              this._stashTexCoords();
              if (!this._texturizer.colorize) this._stashColors();
              this.renderState.addQuad(this, true);
              if (!this._texturizer.colorize) this._unstashColors();
              this._unstashTexCoords();
              renderState.setTexturizer(null);
            }
          }
        }
        if (renderTextureInfo && renderTextureInfo.cache) {
          renderState.isCachingTexturizer = false;
        }
      }
    }
    get zSort() {
      return this._zSort;
    }
    sortZIndexedChildren() {
      const n = this._zIndexedChildren.length;
      let ptr = 0;
      const a = this._zIndexedChildren;
      const b = [];
      for (let i = 0; i < n; i++) {
        if (a[i]._zParent === this) {
          if (a[i]._zIndexResort) {
            b.push(a[i]);
          } else {
            if (ptr !== i) {
              a[ptr] = a[i];
            }
            ptr++;
          }
        }
      }
      const m = b.length;
      if (m) {
        for (let j = 0; j < m; j++) {
          b[j]._zIndexResort = false;
        }
        b.sort(_ElementCore.sortZIndexedChildren);
        const n2 = ptr;
        if (!n2) {
          ptr = 0;
          let j = 0;
          do {
            a[ptr++] = b[j++];
          } while (j < m);
          if (a.length > ptr) {
            a.splice(ptr);
          }
        } else {
          a.splice(n2);
          +// Beware that the function passed here to Array.sort must be stable
          +a.sort(_ElementCore.sortZIndexedChildren);
          ptr = 0;
          let i = 0;
          let j = 0;
          const mergeResult = [];
          do {
            const v = a[i]._zIndex === b[j]._zIndex ? a[i]._updateTreeOrder - b[j]._updateTreeOrder : a[i]._zIndex - b[j]._zIndex;
            const add = v > 0 ? b[j++] : a[i++];
            if (ptr === 0 || mergeResult[ptr - 1] !== add) {
              mergeResult[ptr++] = add;
            }
            if (i >= n2) {
              do {
                const add2 = b[j++];
                if (ptr === 0 || mergeResult[ptr - 1] !== add2) {
                  mergeResult[ptr++] = add2;
                }
              } while (j < m);
              break;
            } else if (j >= m) {
              do {
                const add2 = a[i++];
                if (ptr === 0 || mergeResult[ptr - 1] !== add2) {
                  mergeResult[ptr++] = add2;
                }
              } while (i < n2);
              break;
            }
          } while (true);
          this._zIndexedChildren = mergeResult;
        }
      } else {
        if (a.length > ptr) {
          a.splice(ptr);
        }
      }
      this._zSort = false;
    }
    get localTa() {
      return this._localTa;
    }
    get localTb() {
      return this._localTb;
    }
    get localTc() {
      return this._localTc;
    }
    get localTd() {
      return this._localTd;
    }
    get element() {
      return this._element;
    }
    get renderUpdates() {
      return this._hasRenderUpdates;
    }
    get texturizer() {
      if (!this._texturizer) {
        this._texturizer = new ElementTexturizer(this);
      }
      return this._texturizer;
    }
    getCornerPoints() {
      let w = this._worldContext;
      return [
        w.px,
        w.py,
        w.px + this._w * w.ta,
        w.py + this._w * w.tc,
        w.px + this._w * w.ta + this._h * w.tb,
        w.py + this._w * w.tc + this._h * w.td,
        w.px + this._h * w.tb,
        w.py + this._h * w.td
      ];
    }
    getRenderTextureCoords(relX, relY) {
      let r = this._renderContext;
      return [
        r.px + r.ta * relX + r.tb * relY,
        r.py + r.tc * relX + r.td * relY
      ];
    }
    getAbsoluteCoords(relX, relY) {
      let w = this._renderContext;
      return [
        w.px + w.ta * relX + w.tb * relY,
        w.py + w.tc * relX + w.td * relY
      ];
    }
    collectAtCoord(x, y, children) {
      if (this._renderContext.alpha === 0) {
        return;
      }
      if (this.inBound(x, y)) {
        if (this._scissor) {
          if (this.inScissor()) {
            children.push(this);
          }
        } else {
          children.push(this);
        }
      }
      if (this._children) {
        const j = this._children.length;
        for (let i = 0; i < j; i++) {
          this._children[i].collectAtCoord(x, y, children);
        }
      }
      return children.sort(_ElementCore.sortZIndexedChildren);
    }
    inBound(tx, ty) {
      const c = this.getCornerPoints();
      return tx > c[0] && tx < c[2] && ty > c[1] && ty < c[7];
    }
    inScissor() {
      const sc = this._scissor;
      const c = this.getCornerPoints();
      return c[2] >= sc[0] && c[0] <= sc[0] + sc[2] && c[7] >= sc[1] && c[1] <= sc[1] + sc[3];
    }
    get layout() {
      this._ensureLayout();
      return this._layout;
    }
    get flex() {
      return this._layout ? this._layout.flex : null;
    }
    set flex(v) {
      this.layout.flex = v;
    }
    get flexItem() {
      return this._layout ? this._layout.flexItem : null;
    }
    set flexItem(v) {
      this.layout.flexItem = v;
    }
    isFlexItem() {
      return !!this._layout && this._layout.isFlexItemEnabled();
    }
    isFlexContainer() {
      return !!this._layout && this._layout.isFlexEnabled();
    }
    enableFlexLayout() {
      this._ensureLayout();
    }
    _ensureLayout() {
      if (!this._layout) {
        this._layout = new FlexTarget(this);
      }
    }
    disableFlexLayout() {
      this._triggerRecalcTranslate();
    }
    hasFlexLayout() {
      return this._layout && this._layout.isEnabled();
    }
    setLayout(x, y, w, h) {
      this.x = x;
      this.y = y;
      this._updateDimensions(w, h);
    }
    triggerLayout() {
      this._setRecalc(256);
    }
    _triggerRecalcTranslate() {
      this._setRecalc(2);
    }
  };
  var ElementCoreContext = class {
    constructor() {
      this.alpha = 1;
      this.px = 0;
      this.py = 0;
      this.ta = 1;
      this.tb = 0;
      this.tc = 0;
      this.td = 1;
    }
    isIdentity() {
      return this.alpha === 1 && this.px === 0 && this.py === 0 && this.ta === 1 && this.tb === 0 && this.tc === 0 && this.td === 1;
    }
    isSquare() {
      return this.tb === 0 && this.tc === 0;
    }
  };
  ElementCoreContext.IDENTITY = new ElementCoreContext();
  ElementCore.sortZIndexedChildren = function(a, b) {
    return a._zIndex === b._zIndex ? a._updateTreeOrder - b._updateTreeOrder : a._zIndex - b._zIndex;
  };

  // node_modules/@lightningjs/core/dist/src/EventEmitter.mjs
  var EventEmitter = class _EventEmitter {
    constructor() {
      this._hasEventListeners = false;
    }
    on(name, listener) {
      if (!this._hasEventListeners) {
        this._eventFunction = {};
        this._eventListeners = {};
        this._hasEventListeners = true;
      }
      const current = this._eventFunction[name];
      if (!current) {
        this._eventFunction[name] = listener;
      } else {
        if (this._eventFunction[name] !== _EventEmitter.combiner) {
          this._eventListeners[name] = [this._eventFunction[name], listener];
          this._eventFunction[name] = _EventEmitter.combiner;
        } else {
          this._eventListeners[name].push(listener);
        }
      }
    }
    once(name, listener) {
      const wrapper = (arg1, arg2, arg3) => {
        listener(arg1, arg2, arg3);
        this.off(name, wrapper);
      };
      wrapper.__originalFunc = listener;
      this.on(name, wrapper);
    }
    has(name, listener) {
      if (this._hasEventListeners) {
        const current = this._eventFunction[name];
        if (current) {
          if (current === _EventEmitter.combiner) {
            const listeners = this._eventListeners[name];
            for (const l of listeners) {
              if (l === listener || l.__originalFunc == listener) {
                return true;
              }
            }
          } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
            return true;
          }
        }
      }
      return false;
    }
    off(name, listener) {
      if (this._hasEventListeners) {
        const current = this._eventFunction[name];
        if (current) {
          if (current === _EventEmitter.combiner) {
            const listeners = this._eventListeners[name];
            let index = listeners.indexOf(listener);
            if (index >= 0) {
              listeners.splice(index, 1);
            }
            index = listeners.map((l) => l.__originalFunc).indexOf(listener);
            if (index >= 0) {
              listeners.splice(index, 1);
            }
            if (listeners.length === 1) {
              this._eventFunction[name] = listeners[0];
              this._eventListeners[name] = void 0;
            }
          } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
            this._eventFunction[name] = void 0;
          }
        }
      }
    }
    removeListener(name, listener) {
      this.off(name, listener);
    }
    emit(name, arg1, arg2, arg3) {
      if (this._hasEventListeners) {
        const func = this._eventFunction[name];
        if (func) {
          if (func === _EventEmitter.combiner) {
            func(this, name, arg1, arg2, arg3);
          } else {
            func(arg1, arg2, arg3);
          }
        }
      }
    }
    listenerCount(name) {
      if (this._hasEventListeners) {
        const func = this._eventFunction[name];
        if (func) {
          if (func === _EventEmitter.combiner) {
            return this._eventListeners[name].length;
          } else {
            return 1;
          }
        }
      }
      return 0;
    }
    removeAllListeners(name) {
      if (this._hasEventListeners) {
        delete this._eventFunction[name];
        delete this._eventListeners[name];
      }
    }
  };
  EventEmitter.combiner = function(object, name, arg1, arg2, arg3) {
    const listeners = object._eventListeners[name];
    if (listeners) {
      for (const listener of [...listeners]) {
        listener(arg1, arg2, arg3);
      }
    }
  };
  EventEmitter.addAsMixin = function(cls) {
    cls.prototype.on = EventEmitter.prototype.on;
    cls.prototype.once = EventEmitter.prototype.once;
    cls.prototype.has = EventEmitter.prototype.has;
    cls.prototype.off = EventEmitter.prototype.off;
    cls.prototype.removeListener = EventEmitter.prototype.removeListener;
    cls.prototype.emit = EventEmitter.prototype.emit;
    cls.prototype.listenerCount = EventEmitter.prototype.listenerCount;
    cls.prototype.removeAllListeners = EventEmitter.prototype.removeAllListeners;
  };

  // node_modules/@lightningjs/core/dist/src/tree/Shader.mjs
  var Shader = class {
    constructor(coreContext) {
      this._initialized = false;
      this.ctx = coreContext;
      this._elements = /* @__PURE__ */ new Set();
    }
    static create(stage2, v) {
      let shader;
      if (Utils.isObjectLiteral(v)) {
        if (v.type) {
          shader = stage2.renderer.createShader(stage2.ctx, v);
        } else {
          shader = this.shader;
        }
        if (shader) {
          Base.patchObject(shader, v);
        }
      } else if (v === null) {
        shader = stage2.ctx.renderState.defaultShader;
      } else if (v === void 0) {
        shader = null;
      } else {
        if (v.isShader) {
          if (!stage2.renderer.isValidShaderType(v.constructor)) {
            console.error("[Lightning] Invalid shader type");
            v = null;
          }
          shader = v;
        } else {
          console.error("[Lightning] Please specify a shader type.");
          return;
        }
      }
      return shader;
    }
    static getWebGL() {
      return void 0;
    }
    static getC2d() {
      return void 0;
    }
    addElement(elementCore) {
      this._elements.add(elementCore);
    }
    removeElement(elementCore) {
      this._elements.delete(elementCore);
      if (!this._elements) {
        this.cleanup();
      }
    }
    redraw() {
      this._elements.forEach((elementCore) => {
        elementCore.setHasRenderUpdates(2);
      });
    }
    patch(settings2) {
      Base.patchObject(this, settings2);
    }
    useDefault() {
      return false;
    }
    addEmpty() {
      return false;
    }
    cleanup() {
    }
    get isShader() {
      return true;
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/Texture.mjs
  var Texture = class _Texture {
    /**
     * @param {Stage} stage
     */
    constructor(stage2) {
      this.stage = stage2;
      this.manager = this.stage.textureManager;
      this.id = _Texture.id++;
      this.elements = /* @__PURE__ */ new Set();
      this._activeCount = 0;
      this._source = null;
      this._resizeMode = null;
      this._x = 0;
      this._y = 0;
      this._w = 0;
      this._h = 0;
      this._precision = 1;
      this.mw = 0;
      this.mh = 0;
      this.clipping = false;
      this._mustUpdate = true;
    }
    get source() {
      if (this._mustUpdate || this.stage.hasUpdateSourceTexture(this)) {
        this._performUpdateSource(true);
        this.stage.removeUpdateSourceTexture(this);
      }
      return this._source;
    }
    addElement(v) {
      if (!this.elements.has(v)) {
        this.elements.add(v);
        if (this.elements.size === 1) {
          if (this._source) {
            this._source.addTexture(this);
          }
        }
        if (v.active) {
          this.incActiveCount();
        }
      }
    }
    removeElement(v) {
      if (this.elements.delete(v)) {
        if (this.elements.size === 0) {
          if (this._source) {
            this._source.removeTexture(this);
          }
        }
        if (v.active) {
          this.decActiveCount();
        }
      }
    }
    incActiveCount() {
      const source = this.source;
      if (source) {
        this._checkForNewerReusableTextureSource();
      }
      this._activeCount++;
      if (this._activeCount === 1) {
        this.becomesUsed();
      }
    }
    decActiveCount() {
      const source = this.source;
      this._activeCount--;
      if (!this._activeCount) {
        this.becomesUnused();
      }
    }
    becomesUsed() {
      if (this.source) {
        this.source.incActiveTextureCount();
      }
    }
    onLoad() {
      if (this._resizeMode) {
        this._applyResizeMode();
      }
      this.elements.forEach((element) => {
        if (element.active) {
          element.onTextureSourceLoaded();
        }
      });
    }
    _checkForNewerReusableTextureSource() {
      const source = this.source;
      if (!source.isLoaded()) {
        const reusable = this._getReusableTextureSource();
        if (reusable && reusable.isLoaded() && reusable !== source) {
          this._replaceTextureSource(reusable);
        }
      } else {
        if (this._resizeMode) {
          this._applyResizeMode();
        }
      }
    }
    becomesUnused() {
      if (this.source) {
        this.source.decActiveTextureCount();
      }
    }
    isUsed() {
      return this._activeCount > 0;
    }
    /**
     * Returns the lookup id for the current texture settings, to be able to reuse it.
     * @returns {string|null}
     */
    _getLookupId() {
      return null;
    }
    /**
     * Generates a loader function that is able to generate the texture for the current settings of this texture.
     * It should return a function that receives a single callback argument.
     * That callback should be called with the following arguments:
     *   - err
     *   - options: object
     *     - source: ArrayBuffer|WebGlTexture|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap
     *     - w: Number
     *     - h: Number
     *     - permanent: Boolean
     *     - hasAlpha: boolean
     *     - permultiplyAlpha: boolean
     *     - flipBlueRed: boolean
     *     - renderInfo: object
     * The loader itself may return a Function that is called when loading of the texture is cancelled. This can be used
     * to stop fetching an image when it is no longer in element, for example.
     */
    _getSourceLoader() {
      throw new Error("Texture.generate must be implemented.");
    }
    get isValid() {
      return this._getIsValid();
    }
    /**
     * If texture is not 'valid', no source can be created for it.
     * @returns {boolean}
     */
    _getIsValid() {
      return true;
    }
    /**
     * This must be called when the texture source must be re-generated.
     */
    _changed() {
      if (this.isUsed()) {
        this._updateSource();
      } else {
        this._mustUpdate = true;
      }
    }
    _updateSource() {
      this.stage.addUpdateSourceTexture(this);
    }
    _performUpdateSource(force = false) {
      if (force || this.isUsed()) {
        this._mustUpdate = false;
        let source = this._getTextureSource();
        this._replaceTextureSource(source);
      }
    }
    _getTextureSource() {
      let source = null;
      if (this._getIsValid()) {
        const lookupId = this._getLookupId();
        source = this._getReusableTextureSource(lookupId);
        if (!source) {
          source = this.manager.getTextureSource(this._getSourceLoader(), lookupId);
        }
      }
      return source;
    }
    _getReusableTextureSource(lookupId = this._getLookupId()) {
      if (this._getIsValid()) {
        if (lookupId) {
          return this.manager.getReusableTextureSource(lookupId);
        }
      }
      return null;
    }
    _replaceTextureSource(newSource = null) {
      let oldSource = this._source;
      this._source = newSource;
      if (this.elements.size) {
        if (oldSource) {
          if (this._activeCount) {
            oldSource.decActiveTextureCount();
          }
          oldSource.removeTexture(this);
          if (this["text"] && !oldSource.isUsed()) {
            this.manager.freeTextureSource(oldSource);
          }
        }
        if (newSource) {
          newSource.addTexture(this);
          if (this._activeCount) {
            newSource.incActiveTextureCount();
          }
        }
      }
      if (this.isUsed()) {
        if (newSource) {
          if (newSource.isLoaded()) {
            if (this._resizeMode) {
              this._applyResizeMode();
            }
            this.elements.forEach((element) => {
              if (element.active) {
                element._setDisplayedTexture(this);
              }
            });
          } else {
            const loadError = newSource.loadError;
            if (loadError) {
              this.elements.forEach((element) => {
                if (element.active) {
                  element.onTextureSourceLoadError(loadError);
                }
              });
            }
          }
        } else {
          this.elements.forEach((element) => {
            if (element.active) {
              element._setDisplayedTexture(null);
            }
          });
        }
      }
    }
    load() {
      if (this.source) {
        if (!this.isLoaded()) {
          this.source.load(true);
        }
      }
    }
    isLoaded() {
      return this._source && this._source.isLoaded();
    }
    get loadError() {
      return this._source && this._source.loadError;
    }
    free() {
      if (this._source) {
        this._source.free();
      }
    }
    set resizeMode({ type = "cover", w = 0, h = 0, clipX = 0.5, clipY = 0.5 }) {
      this._resizeMode = { type, w, h, clipX, clipY };
      if (this.isLoaded()) {
        this._applyResizeMode();
      }
    }
    get resizeMode() {
      return this._resizeMode;
    }
    _clearResizeMode() {
      this._resizeMode = null;
    }
    _applyResizeMode() {
      if (this._resizeMode.type === "cover") {
        this._applyResizeCover();
      } else if (this._resizeMode.type === "contain") {
        this._applyResizeContain();
      }
      this._updatePrecision();
      this._updateClipping();
    }
    _applyResizeCover() {
      const scaleX = this._resizeMode.w / this._source.w;
      const scaleY = this._resizeMode.h / this._source.h;
      let scale = Math.max(scaleX, scaleY);
      if (!scale) return;
      this._precision = 1 / scale;
      if (scaleX && scaleX < scale) {
        const desiredSize = this._precision * this._resizeMode.w;
        const choppedOffPixels = this._source.w - desiredSize;
        this._x = choppedOffPixels * this._resizeMode.clipX;
        this._w = this._source.w - choppedOffPixels;
      }
      if (scaleY && scaleY < scale) {
        const desiredSize = this._precision * this._resizeMode.h;
        const choppedOffPixels = this._source.h - desiredSize;
        this._y = choppedOffPixels * this._resizeMode.clipY;
        this._h = this._source.h - choppedOffPixels;
      }
    }
    _applyResizeContain() {
      const scaleX = this._resizeMode.w / this._source.w;
      const scaleY = this._resizeMode.h / this._source.h;
      let scale = scaleX;
      if (!scale || scaleY < scale) {
        scale = scaleY;
      }
      if (!scale) return;
      this._precision = 1 / scale;
    }
    enableClipping(x, y, w, h) {
      this._clearResizeMode();
      x *= this._precision;
      y *= this._precision;
      w *= this._precision;
      h *= this._precision;
      if (this._x !== x || this._y !== y || this._w !== w || this._h !== h) {
        this._x = x;
        this._y = y;
        this._w = w;
        this._h = h;
        this._updateClipping(true);
      }
    }
    disableClipping() {
      this._clearResizeMode();
      if (this._x || this._y || this._w || this._h) {
        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;
        this._updateClipping();
      }
    }
    _updateClipping() {
      this.clipping = !!(this._x || this._y || this._w || this._h);
      let self2 = this;
      this.elements.forEach(function(element) {
        if (element.displayedTexture === self2) {
          element.onDisplayedTextureClippingChanged();
        }
      });
    }
    _updatePrecision() {
      let self2 = this;
      this.elements.forEach(function(element) {
        if (element.displayedTexture === self2) {
          element.onPrecisionChanged();
        }
      });
    }
    getNonDefaults() {
      let nonDefaults = {};
      nonDefaults["type"] = this.constructor.name;
      if (this.x !== 0) nonDefaults["x"] = this.x;
      if (this.y !== 0) nonDefaults["y"] = this.y;
      if (this.w !== 0) nonDefaults["w"] = this.w;
      if (this.h !== 0) nonDefaults["h"] = this.h;
      if (this.precision !== 1) nonDefaults["precision"] = this.precision;
      return nonDefaults;
    }
    get px() {
      return this._x;
    }
    get py() {
      return this._y;
    }
    get pw() {
      return this._w;
    }
    get ph() {
      return this._h;
    }
    get x() {
      return this._x / this._precision;
    }
    set x(v) {
      this._clearResizeMode();
      v = v * this._precision;
      if (this._x !== v) {
        this._x = v;
        this._updateClipping();
      }
    }
    get y() {
      return this._y / this._precision;
    }
    set y(v) {
      this._clearResizeMode();
      v = v * this._precision;
      if (this._y !== v) {
        this._y = v;
        this._updateClipping();
      }
    }
    get w() {
      return this._w / this._precision;
    }
    set w(v) {
      this._clearResizeMode();
      v = v * this._precision;
      if (this._w !== v) {
        this._w = v;
        this._updateClipping();
      }
    }
    get h() {
      return this._h / this._precision;
    }
    set h(v) {
      this._clearResizeMode();
      v = v * this._precision;
      if (this._h !== v) {
        this._h = v;
        this._updateClipping();
      }
    }
    get precision() {
      return this._precision;
    }
    set precision(v) {
      this._clearResizeMode();
      if (this._precision !== v) {
        this._precision = v;
        this._updatePrecision();
      }
    }
    isAutosizeTexture() {
      return true;
    }
    getRenderWidth() {
      if (!this.isAutosizeTexture()) {
        return 0;
      }
      return (this._w || (this._source ? this._source.getRenderWidth() - this._x : 0)) / this._precision;
    }
    getRenderHeight() {
      if (!this.isAutosizeTexture()) {
        return 0;
      }
      return (this._h || (this._source ? this._source.getRenderHeight() - this._y : 0)) / this._precision;
    }
    patch(settings2) {
      Base.patchObject(this, settings2);
    }
  };
  Texture.prototype.isTexture = true;
  Texture.id = 0;

  // node_modules/@lightningjs/core/dist/src/textures/ImageTexture.mjs
  var ImageTexture = class extends Texture {
    constructor(stage2) {
      super(stage2);
      this._src = void 0;
      this._hasAlpha = false;
    }
    get src() {
      return this._src;
    }
    set src(v) {
      if (this._src !== v) {
        this._src = v;
        this._changed();
      }
    }
    get hasAlpha() {
      return this._hasAlpha;
    }
    set hasAlpha(v) {
      if (this._hasAlpha !== v) {
        this._hasAlpha = v;
        this._changed();
      }
    }
    _getIsValid() {
      return !!this._src;
    }
    _getLookupId() {
      return this._src;
    }
    _getSourceLoader() {
      let src = this._src;
      let hasAlpha = this._hasAlpha;
      if (this.stage.getOption("srcBasePath")) {
        var fc = src.charCodeAt(0);
        if (src.indexOf("//") === -1 && (fc >= 65 && fc <= 90 || fc >= 97 && fc <= 122 || fc == 46)) {
          src = this.stage.getOption("srcBasePath") + src;
        }
      }
      return (cb) => {
        return this.stage.platform.loadSrcTexture({ src, hasAlpha }, cb);
      };
    }
    getNonDefaults() {
      const obj = super.getNonDefaults();
      if (this._src) {
        obj.src = this._src;
      }
      return obj;
    }
  };

  // node_modules/@lightningjs/core/dist/src/textures/TextTextureRendererUtils.mjs
  function getFontSetting(fontFace, fontStyle, fontSize, precision2, defaultFontFace) {
    let ff = fontFace;
    if (!Array.isArray(ff)) {
      ff = [ff];
    }
    let ffs = [];
    for (let i = 0, n = ff.length; i < n; i++) {
      let curFf = ff[i];
      if (curFf == null) {
        curFf = defaultFontFace;
      }
      if (curFf.indexOf(" ") < 0) {
        ffs.push(curFf);
      } else {
        ffs.push(`"${curFf}"`);
      }
    }
    return `${fontStyle} ${fontSize * precision2}px ${ffs.join(",")}`;
  }
  function isZeroWidthSpace(space) {
    return space === "" || space === "\u200B";
  }
  function isSpace(space) {
    return isZeroWidthSpace(space) || space === " ";
  }
  function tokenizeString(tokenRegex, text) {
    const delimeters = text.match(tokenRegex) || [];
    const words = text.split(tokenRegex) || [];
    let final = [];
    for (let i = 0; i < words.length; i++) {
      final.push(words[i], delimeters[i]);
    }
    final.pop();
    return final.filter((word) => word != "");
  }
  function measureText(context2, word, space = 0) {
    if (!space) {
      return context2.measureText(word).width;
    }
    return word.split("").reduce((acc, char) => {
      if (isZeroWidthSpace(char)) {
        return acc;
      }
      return acc + context2.measureText(char).width + space;
    }, 0);
  }
  function wrapText(context2, text, wordWrapWidth, letterSpacing, indent) {
    const spaceRegex = / |\u200B/g;
    let lines = text.split(/\r?\n/g);
    let allLines = [];
    let realNewlines = [];
    for (let i = 0; i < lines.length; i++) {
      let resultLines = [];
      let result = "";
      let spaceLeft = wordWrapWidth - indent;
      let words = lines[i].split(spaceRegex);
      let spaces = lines[i].match(spaceRegex) || [];
      for (let j = 0; j < words.length; j++) {
        const space = spaces[j - 1] || "";
        const word = words[j];
        const wordWidth = measureText(context2, word, letterSpacing);
        const wordWidthWithSpace = wordWidth + measureText(context2, space, letterSpacing);
        if (j === 0 || wordWidthWithSpace > spaceLeft) {
          if (j > 0) {
            resultLines.push(result);
            result = "";
          }
          result += word;
          spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
        } else {
          spaceLeft -= wordWidthWithSpace;
          result += space + word;
        }
      }
      resultLines.push(result);
      result = "";
      allLines = allLines.concat(resultLines);
      if (i < lines.length - 1) {
        realNewlines.push(allLines.length);
      }
    }
    return { l: allLines, n: realNewlines };
  }

  // node_modules/@lightningjs/core/dist/src/textures/TextTextureRenderer.mjs
  var TextTextureRenderer = class {
    constructor(stage2, canvas, settings2) {
      this._stage = stage2;
      this._canvas = canvas;
      this._context = this._canvas.getContext("2d");
      this._settings = settings2;
    }
    getPrecision() {
      return this._settings.precision;
    }
    setFontProperties() {
      this._context.font = getFontSetting(
        this._settings.fontFace,
        this._settings.fontStyle,
        this._settings.fontSize,
        this.getPrecision(),
        this._stage.getOption("defaultFontFace")
      );
      this._context.textBaseline = this._settings.textBaseline;
      this._context.direction = this._settings.rtl ? "rtl" : "ltr";
    }
    _load() {
      if (Utils.isWeb && document.fonts) {
        const fontSetting = getFontSetting(
          this._settings.fontFace,
          this._settings.fontStyle,
          this._settings.fontSize,
          this.getPrecision(),
          this._stage.getOption("defaultFontFace")
        );
        try {
          if (!document.fonts.check(fontSetting, this._settings.text)) {
            return document.fonts.load(fontSetting, this._settings.text).catch((err) => {
              console.warn("[Lightning] Font load error", err, fontSetting);
            }).then(() => {
              if (!document.fonts.check(fontSetting, this._settings.text)) {
                console.warn("[Lightning] Font not found", fontSetting);
              }
            });
          }
        } catch (e) {
          console.warn("[Lightning] Can't check font loading for " + fontSetting);
        }
      }
    }
    draw() {
      const loadPromise = this._load();
      if (!loadPromise) {
        return Utils.isSpark ? this._stage.platform.drawText(this) : this._draw();
      } else {
        return loadPromise.then(() => {
          return Utils.isSpark ? this._stage.platform.drawText(this) : this._draw();
        });
      }
    }
    _calculateRenderInfo() {
      let renderInfo = {};
      const precision2 = this.getPrecision();
      const paddingLeft = this._settings.paddingLeft * precision2;
      const paddingRight = this._settings.paddingRight * precision2;
      const fontSize = this._settings.fontSize * precision2;
      let offsetY = this._settings.offsetY === null ? null : this._settings.offsetY * precision2;
      let lineHeight = this._settings.lineHeight * precision2;
      const w = this._settings.w * precision2;
      const h = this._settings.h * precision2;
      let wordWrapWidth = this._settings.wordWrapWidth * precision2;
      const cutSx = this._settings.cutSx * precision2;
      const cutEx = this._settings.cutEx * precision2;
      const cutSy = this._settings.cutSy * precision2;
      const cutEy = this._settings.cutEy * precision2;
      const letterSpacing = (this._settings.letterSpacing || 0) * precision2;
      const textIndent = this._settings.textIndent * precision2;
      this.setFontProperties();
      let width = w || this._stage.getOption("w");
      let innerWidth = width - paddingLeft;
      if (innerWidth < 10) {
        width += 10 - innerWidth;
        innerWidth = 10;
      }
      if (!wordWrapWidth) {
        wordWrapWidth = innerWidth;
      }
      if (this._settings.textOverflow && !this._settings.wordWrap) {
        let suffix;
        switch (this._settings.textOverflow) {
          case "clip":
            suffix = "";
            break;
          case "ellipsis":
            suffix = this._settings.maxLinesSuffix;
            break;
          default:
            suffix = this._settings.textOverflow;
        }
        this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix);
      }
      let linesInfo;
      if (this._settings.wordWrap) {
        linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
      } else {
        linesInfo = { l: this._settings.text.split(/(?:\r\n|\r|\n)/), n: [] };
        let i, n = linesInfo.l.length;
        for (let i2 = 0; i2 < n - 1; i2++) {
          linesInfo.n.push(i2);
        }
      }
      let lines = linesInfo.l;
      if (this._settings.maxLines && lines.length > this._settings.maxLines) {
        let usedLines = lines.slice(0, this._settings.maxLines);
        let otherLines = null;
        if (this._settings.maxLinesSuffix) {
          let w2 = this._settings.maxLinesSuffix ? this.measureText(this._settings.maxLinesSuffix) : 0;
          let al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - w2, letterSpacing, textIndent);
          usedLines[usedLines.length - 1] = al.l[0] + this._settings.maxLinesSuffix;
          otherLines = [al.l.length > 1 ? al.l[1] : ""];
        } else {
          otherLines = [""];
        }
        let i, n = lines.length;
        let j = 0;
        let m = linesInfo.n.length;
        for (i = this._settings.maxLines; i < n; i++) {
          otherLines[j] += (otherLines[j] ? " " : "") + lines[i];
          if (i + 1 < m && linesInfo.n[i + 1]) {
            j++;
          }
        }
        renderInfo.remainingText = otherLines.join("\n");
        renderInfo.moreTextLines = true;
        lines = usedLines;
      } else {
        renderInfo.moreTextLines = false;
        renderInfo.remainingText = "";
      }
      let maxLineWidth = 0;
      let lineWidths = [];
      for (let i = 0; i < lines.length; i++) {
        let lineWidth = this.measureText(lines[i], letterSpacing) + (i === 0 ? textIndent : 0);
        lineWidths.push(lineWidth);
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
      }
      renderInfo.lineWidths = lineWidths;
      if (!w) {
        width = maxLineWidth + paddingLeft + paddingRight;
        innerWidth = maxLineWidth;
      }
      lineHeight = lineHeight || fontSize;
      let height;
      if (h) {
        height = h;
      } else {
        const baselineOffset = this._settings.textBaseline != "bottom" ? 0.5 * fontSize : 0;
        height = lineHeight * (lines.length - 1) + baselineOffset + Math.max(lineHeight, fontSize) + offsetY;
      }
      if (offsetY === null) {
        offsetY = fontSize;
      }
      renderInfo.w = width;
      renderInfo.h = height;
      renderInfo.lines = lines;
      renderInfo.precision = precision2;
      if (!width) {
        width = 1;
      }
      if (!height) {
        height = 1;
      }
      if (cutSx || cutEx) {
        width = Math.min(width, cutEx - cutSx);
      }
      if (cutSy || cutEy) {
        height = Math.min(height, cutEy - cutSy);
      }
      renderInfo.width = width;
      renderInfo.innerWidth = innerWidth;
      renderInfo.height = height;
      renderInfo.fontSize = fontSize;
      renderInfo.cutSx = cutSx;
      renderInfo.cutSy = cutSy;
      renderInfo.cutEx = cutEx;
      renderInfo.cutEy = cutEy;
      renderInfo.lineHeight = lineHeight;
      renderInfo.lineWidths = lineWidths;
      renderInfo.offsetY = offsetY;
      renderInfo.paddingLeft = paddingLeft;
      renderInfo.paddingRight = paddingRight;
      renderInfo.letterSpacing = letterSpacing;
      renderInfo.textIndent = textIndent;
      return renderInfo;
    }
    _draw() {
      const renderInfo = this._calculateRenderInfo();
      const precision2 = this.getPrecision();
      this._canvas.width = Math.ceil(renderInfo.width + this._stage.getOption("textRenderIssueMargin"));
      this._canvas.height = Math.ceil(renderInfo.height);
      this.setFontProperties();
      if (renderInfo.fontSize >= 128) {
        this._context.globalAlpha = 0.01;
        this._context.fillRect(0, 0, 0.01, 0.01);
        this._context.globalAlpha = 1;
      }
      if (renderInfo.cutSx || renderInfo.cutSy) {
        this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
      }
      let linePositionX;
      let linePositionY;
      let drawLines = [];
      for (let i = 0, n = renderInfo.lines.length; i < n; i++) {
        linePositionX = i === 0 ? renderInfo.textIndent : 0;
        linePositionY = i * renderInfo.lineHeight + renderInfo.offsetY;
        if (this._settings.verticalAlign == "middle") {
          linePositionY += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
        } else if (this._settings.verticalAlign == "bottom") {
          linePositionY += renderInfo.lineHeight - renderInfo.fontSize;
        }
        if (this._settings.textAlign === "right") {
          linePositionX += renderInfo.innerWidth - renderInfo.lineWidths[i];
        } else if (this._settings.textAlign === "center") {
          linePositionX += (renderInfo.innerWidth - renderInfo.lineWidths[i]) / 2;
        }
        linePositionX += renderInfo.paddingLeft;
        if (this._settings.rtl) {
          linePositionX += renderInfo.lineWidths[i];
        }
        drawLines.push({ text: renderInfo.lines[i], x: linePositionX, y: linePositionY, w: renderInfo.lineWidths[i] });
      }
      if (this._settings.highlight) {
        let color = this._settings.highlightColor || 0;
        let hlHeight = this._settings.highlightHeight * precision2 || renderInfo.fontSize * 1.5;
        const offset = this._settings.highlightOffset * precision2;
        const hlPaddingLeft = this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision2 : renderInfo.paddingLeft;
        const hlPaddingRight = this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision2 : renderInfo.paddingRight;
        this._context.fillStyle = StageUtils.getRgbaString(color);
        for (let i = 0; i < drawLines.length; i++) {
          let drawLine = drawLines[i];
          this._context.fillRect(drawLine.x - hlPaddingLeft, drawLine.y - renderInfo.offsetY + offset, drawLine.w + hlPaddingRight + hlPaddingLeft, hlHeight);
        }
      }
      let prevShadowSettings = null;
      if (this._settings.shadow) {
        prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
        this._context.shadowColor = StageUtils.getRgbaString(this._settings.shadowColor);
        this._context.shadowOffsetX = this._settings.shadowOffsetX * precision2;
        this._context.shadowOffsetY = this._settings.shadowOffsetY * precision2;
        this._context.shadowBlur = this._settings.shadowBlur * precision2;
      }
      this._context.fillStyle = StageUtils.getRgbaString(this._settings.textColor);
      for (let i = 0, n = drawLines.length; i < n; i++) {
        let drawLine = drawLines[i];
        if (renderInfo.letterSpacing === 0) {
          this._context.fillText(drawLine.text, drawLine.x, drawLine.y);
        } else {
          const textSplit = drawLine.text.split("");
          let x = drawLine.x;
          for (let i2 = 0, j = textSplit.length; i2 < j; i2++) {
            this._context.fillText(textSplit[i2], x, drawLine.y);
            x += this.measureText(textSplit[i2], renderInfo.letterSpacing);
          }
        }
      }
      if (prevShadowSettings) {
        this._context.shadowColor = prevShadowSettings[0];
        this._context.shadowOffsetX = prevShadowSettings[1];
        this._context.shadowOffsetY = prevShadowSettings[2];
        this._context.shadowBlur = prevShadowSettings[3];
      }
      if (renderInfo.cutSx || renderInfo.cutSy) {
        this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
      }
      this.renderInfo = renderInfo;
    }
    wrapWord(word, wordWrapWidth, suffix) {
      const suffixWidth = this.measureText(suffix);
      const wordLen = word.length;
      const wordWidth = this.measureText(word);
      if (wordWidth <= wordWrapWidth) {
        return word;
      }
      let cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
      let truncWordWidth = this.measureText(word.substring(0, cutoffIndex)) + suffixWidth;
      if (truncWordWidth > wordWrapWidth) {
        while (cutoffIndex > 0) {
          truncWordWidth = this.measureText(word.substring(0, cutoffIndex)) + suffixWidth;
          if (truncWordWidth > wordWrapWidth) {
            cutoffIndex -= 1;
          } else {
            break;
          }
        }
      } else {
        while (cutoffIndex < wordLen) {
          truncWordWidth = this.measureText(word.substring(0, cutoffIndex)) + suffixWidth;
          if (truncWordWidth < wordWrapWidth) {
            cutoffIndex += 1;
          } else {
            cutoffIndex -= 1;
            break;
          }
        }
      }
      return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : "");
    }
    /**
     * See {@link wrapText}
     *
     * @param {string} text
     * @param {number} wordWrapWidth
     * @param {number} letterSpacing
     * @param {number} indent
     * @returns
     */
    wrapText(text, wordWrapWidth, letterSpacing, indent = 0) {
      return wrapText(this._context, text, wordWrapWidth, letterSpacing, indent);
    }
    /**
     * See {@link measureText}
     *
     * @param {string} word
     * @param {number} space
     * @returns {number}
     */
    measureText(word, space = 0) {
      return measureText(this._context, word, space);
    }
  };

  // node_modules/@lightningjs/core/dist/src/textures/TextTextureRendererAdvanced.mjs
  var TextTextureRendererAdvanced = class {
    constructor(stage2, canvas, settings2) {
      this._stage = stage2;
      this._canvas = canvas;
      this._context = this._canvas.getContext("2d");
      this._settings = settings2;
    }
    getPrecision() {
      return this._settings.precision;
    }
    setFontProperties() {
      const font = getFontSetting(
        this._settings.fontFace,
        this._settings.fontStyle,
        this._settings.fontSize,
        this.getPrecision(),
        this._stage.getOption("defaultFontFace")
      );
      this._context.font = font;
      this._context.textBaseline = this._settings.textBaseline;
      return font;
    }
    _load() {
      if (Utils.isWeb && document.fonts) {
        const fontSetting = getFontSetting(
          this._settings.fontFace,
          this._settings.fontStyle,
          this._settings.fontSize,
          this.getPrecision(),
          this._stage.getOption("defaultFontFace")
        );
        try {
          if (!document.fonts.check(fontSetting, this._settings.text)) {
            return document.fonts.load(fontSetting, this._settings.text).catch((err) => {
              console.warn("Font load error", err, fontSetting);
            }).then(() => {
              if (!document.fonts.check(fontSetting, this._settings.text)) {
                console.warn("Font not found", fontSetting);
              }
            });
          }
        } catch (e) {
          console.warn("Can't check font loading for " + fontSetting);
        }
      }
    }
    draw() {
      const loadPromise = this._load();
      if (!loadPromise) {
        return Utils.isSpark ? this._stage.platform.drawText(this) : this._draw();
      } else {
        return loadPromise.then(() => {
          return Utils.isSpark ? this._stage.platform.drawText(this) : this._draw();
        });
      }
    }
    _calculateRenderInfo() {
      let renderInfo = {};
      const precision2 = this.getPrecision();
      const paddingLeft = this._settings.paddingLeft * precision2;
      const paddingRight = this._settings.paddingRight * precision2;
      const fontSize = this._settings.fontSize * precision2;
      const lineHeight = this._settings.lineHeight * precision2 || fontSize;
      const w = this._settings.w != 0 ? this._settings.w * precision2 : this._stage.getOption("w");
      const wordWrapWidth = this._settings.wordWrapWidth * precision2;
      const cutSx = this._settings.cutSx * precision2;
      const cutEx = this._settings.cutEx * precision2;
      const cutSy = this._settings.cutSy * precision2;
      const cutEy = this._settings.cutEy * precision2;
      const letterSpacing = this._settings.letterSpacing || 0;
      renderInfo.baseFont = this.setFontProperties();
      renderInfo.w = w;
      renderInfo.width = w;
      renderInfo.text = this._settings.text;
      renderInfo.precision = precision2;
      renderInfo.fontSize = fontSize;
      renderInfo.fontBaselineRatio = this._settings.fontBaselineRatio;
      renderInfo.lineHeight = lineHeight;
      renderInfo.letterSpacing = letterSpacing;
      renderInfo.textAlign = this._settings.textAlign;
      renderInfo.textColor = this._settings.textColor;
      renderInfo.verticalAlign = this._settings.verticalAlign;
      renderInfo.highlight = this._settings.highlight;
      renderInfo.highlightColor = this._settings.highlightColor;
      renderInfo.highlightHeight = this._settings.highlightHeight;
      renderInfo.highlightPaddingLeft = this._settings.highlightPaddingLeft;
      renderInfo.highlightPaddingRight = this._settings.highlightPaddingRight;
      renderInfo.highlightOffset = this._settings.highlightOffset;
      renderInfo.paddingLeft = this._settings.paddingLeft;
      renderInfo.paddingRight = this._settings.paddingRight;
      renderInfo.maxLines = this._settings.maxLines;
      renderInfo.maxLinesSuffix = this._settings.maxLinesSuffix;
      renderInfo.textOverflow = this._settings.textOverflow;
      renderInfo.wordWrap = this._settings.wordWrap;
      renderInfo.wordWrapWidth = wordWrapWidth;
      renderInfo.shadow = this._settings.shadow;
      renderInfo.shadowColor = this._settings.shadowColor;
      renderInfo.shadowOffsetX = this._settings.shadowOffsetX;
      renderInfo.shadowOffsetY = this._settings.shadowOffsetY;
      renderInfo.shadowBlur = this._settings.shadowBlur;
      renderInfo.cutSx = cutSx;
      renderInfo.cutEx = cutEx;
      renderInfo.cutSy = cutSy;
      renderInfo.cutEy = cutEy;
      renderInfo.textIndent = this._settings.textIndent * precision2;
      renderInfo.wordBreak = this._settings.wordBreak;
      let text = renderInfo.text;
      let wrapWidth = renderInfo.wordWrap ? renderInfo.wordWrapWidth || renderInfo.width : renderInfo.width;
      if (renderInfo.textOverflow && !renderInfo.wordWrap) {
        let suffix;
        switch (this._settings.textOverflow) {
          case "clip":
            suffix = "";
            break;
          case "ellipsis":
            suffix = this._settings.maxLinesSuffix;
            break;
          default:
            suffix = this._settings.textOverflow;
        }
        text = this.wrapWord(text, wordWrapWidth || renderInfo.w, suffix);
      }
      text = this.tokenize(text);
      text = this.parse(text);
      text = this.measure(text, letterSpacing, renderInfo.baseFont);
      if (renderInfo.textIndent) {
        text = this.indent(text, renderInfo.textIndent);
      }
      if (renderInfo.wordBreak) {
        text = text.reduce((acc, t) => acc.concat(this.wordBreak(t, wrapWidth, renderInfo.baseFont)), []);
        this.resetFontStyle();
      }
      let x = paddingLeft;
      let lineNo = 0;
      for (const t of text) {
        if (renderInfo.wordWrap && x + t.width > wrapWidth || t.text == "\n") {
          x = paddingLeft;
          lineNo += 1;
        }
        t.lineNo = lineNo;
        if (t.text == "\n") {
          continue;
        }
        t.x = x;
        x += t.width;
      }
      renderInfo.lineNum = lineNo + 1;
      if (this._settings.h) {
        renderInfo.h = this._settings.h;
      } else if (renderInfo.maxLines && renderInfo.maxLines < renderInfo.lineNum) {
        renderInfo.h = renderInfo.maxLines * renderInfo.lineHeight + fontSize / 2;
      } else {
        renderInfo.h = renderInfo.lineNum * renderInfo.lineHeight + fontSize / 2;
      }
      const baselineOffsetInPx = renderInfo.fontBaselineRatio * renderInfo.fontSize;
      let vaOffset = 0;
      if (renderInfo.verticalAlign == "top" && this._context.textBaseline == "alphabetic") {
        vaOffset = -baselineOffsetInPx;
      } else if (renderInfo.verticalAlign == "middle") {
        vaOffset = (renderInfo.lineHeight - renderInfo.fontSize - baselineOffsetInPx) / 2;
      } else if (this._settings.verticalAlign == "bottom") {
        vaOffset = renderInfo.lineHeight - renderInfo.fontSize;
      }
      renderInfo.lines = [];
      for (let i = 0; i < renderInfo.lineNum; i++) {
        renderInfo.lines[i] = {
          width: 0,
          x: 0,
          y: renderInfo.lineHeight * i + vaOffset,
          text: []
        };
      }
      for (let t of text) {
        renderInfo.lines[t.lineNo].text.push(t);
      }
      for (const l of renderInfo.lines) {
        if (l.text.length == 0) {
          continue;
        }
        const firstWord = l.text[0].text;
        const lastWord = l.text[l.text.length - 1].text;
        if (firstWord == "\n") {
          l.text.shift();
        }
        if (isSpace(lastWord) || lastWord == "\n") {
          l.text.pop();
        }
      }
      for (let l of renderInfo.lines) {
        l.width = l.text.reduce((acc, t) => acc + t.width, 0);
      }
      renderInfo.width = this._settings.w != 0 ? this._settings.w * precision2 : Math.max(...renderInfo.lines.map((l) => l.width)) + paddingRight;
      renderInfo.w = renderInfo.width;
      if (renderInfo.maxLines && renderInfo.lineNum > renderInfo.maxLines && renderInfo.maxLinesSuffix) {
        const index = renderInfo.maxLines - 1;
        let lastLineText = text.filter((t) => t.lineNo == index);
        let suffix = renderInfo.maxLinesSuffix;
        suffix = this.tokenize(suffix);
        suffix = this.parse(suffix);
        suffix = this.measure(suffix, renderInfo.letterSpacing, renderInfo.baseFont);
        for (const s of suffix) {
          s.lineNo = index;
          s.x = 0;
          lastLineText.push(s);
        }
        const spl = suffix.length + 1;
        let _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
        while (_w > renderInfo.width || isSpace(lastLineText[lastLineText.length - spl].text)) {
          lastLineText.splice(lastLineText.length - spl, 1);
          _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
          if (lastLineText.length < spl) {
            break;
          }
        }
        this.alignLine(lastLineText, lastLineText[0].x);
        renderInfo.lines[index].text = lastLineText;
        renderInfo.lines[index].width = _w;
      }
      if (renderInfo.textAlign == "center") {
        for (let l of renderInfo.lines) {
          l.x = (renderInfo.width - l.width - paddingLeft) / 2;
        }
      } else if (renderInfo.textAlign == "right") {
        for (let l of renderInfo.lines) {
          l.x = renderInfo.width - l.width - paddingLeft;
        }
      }
      return renderInfo;
    }
    _draw() {
      const renderInfo = this._calculateRenderInfo();
      const precision2 = this.getPrecision();
      const paddingLeft = renderInfo.paddingLeft * precision2;
      let canvasWidth = renderInfo.w || renderInfo.width;
      if (renderInfo.cutSx || renderInfo.cutEx) {
        canvasWidth = Math.min(renderInfo.w, renderInfo.cutEx - renderInfo.cutSx);
      }
      let canvasHeight = renderInfo.h;
      if (renderInfo.cutSy || renderInfo.cutEy) {
        canvasHeight = Math.min(renderInfo.h, renderInfo.cutEy - renderInfo.cutSy);
      }
      this._canvas.width = Math.ceil(canvasWidth + this._stage.getOption("textRenderIssueMargin"));
      this._canvas.height = Math.ceil(canvasHeight);
      this.setFontProperties();
      if (renderInfo.fontSize >= 128) {
        this._context.globalAlpha = 0.01;
        this._context.fillRect(0, 0, 0.01, 0.01);
        this._context.globalAlpha = 1;
      }
      if (renderInfo.cutSx || renderInfo.cutSy) {
        this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
      }
      if (renderInfo.highlight) {
        const hlColor = renderInfo.highlightColor || 0;
        const hlHeight = renderInfo.highlightHeight ? renderInfo.highlightHeight * precision2 : renderInfo.fontSize * 1.5;
        const hlOffset = renderInfo.highlightOffset ? renderInfo.highlightOffset * precision2 : 0;
        const hlPaddingLeft = renderInfo.highlightPaddingLeft !== null ? renderInfo.highlightPaddingLeft * precision2 : renderInfo.paddingLeft;
        const hlPaddingRight = renderInfo.highlightPaddingRight !== null ? renderInfo.highlightPaddingRight * precision2 : renderInfo.paddingRight;
        this._context.fillStyle = StageUtils.getRgbaString(hlColor);
        const lineNum = renderInfo.maxLines ? Math.min(renderInfo.maxLines, renderInfo.lineNum) : renderInfo.lineNum;
        for (let i = 0; i < lineNum; i++) {
          const l = renderInfo.lines[i];
          this._context.fillRect(l.x - hlPaddingLeft + paddingLeft, l.y + hlOffset, l.width + hlPaddingLeft + hlPaddingRight, hlHeight);
        }
      }
      let prevShadowSettings = null;
      if (this._settings.shadow) {
        prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
        this._context.shadowColor = StageUtils.getRgbaString(this._settings.shadowColor);
        this._context.shadowOffsetX = this._settings.shadowOffsetX * precision2;
        this._context.shadowOffsetY = this._settings.shadowOffsetY * precision2;
        this._context.shadowBlur = this._settings.shadowBlur * precision2;
      }
      const defaultColor = StageUtils.getRgbaString(this._settings.textColor);
      let currentColor = defaultColor;
      this._context.fillStyle = defaultColor;
      for (const line of renderInfo.lines) {
        for (const t of line.text) {
          let lx = 0;
          if (t.text == "\n") {
            continue;
          }
          if (renderInfo.maxLines && t.lineNo >= renderInfo.maxLines) {
            continue;
          }
          if (t.color != currentColor) {
            currentColor = t.color;
            this._context.fillStyle = currentColor;
          }
          this._context.font = t.fontStyle;
          if (t.letters) {
            for (let l of t.letters) {
              const _x = renderInfo.lines[t.lineNo].x + t.x + lx;
              this._context.fillText(l.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
              lx += l.width;
            }
          } else {
            const _x = renderInfo.lines[t.lineNo].x + t.x;
            this._context.fillText(t.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
          }
        }
      }
      if (prevShadowSettings) {
        this._context.shadowColor = prevShadowSettings[0];
        this._context.shadowOffsetX = prevShadowSettings[1];
        this._context.shadowOffsetY = prevShadowSettings[2];
        this._context.shadowBlur = prevShadowSettings[3];
      }
      if (renderInfo.cutSx || renderInfo.cutSy) {
        this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
      }
      renderInfo.lines = renderInfo.lines.map((l) => l.text.reduce((acc, v) => acc + v.text, ""));
      if (renderInfo.maxLines) {
        renderInfo.lines = renderInfo.lines.slice(0, renderInfo.maxLines);
      }
      this.renderInfo = renderInfo;
    }
    /**
     * See {@link measureText}
     *
     * @param {string} word
     * @param {number} space
     * @returns {number}
     */
    measureText(word, space = 0) {
      return measureText(this._context, word, space);
    }
    tokenize(text) {
      return tokenizeString(/ |\u200B|\n|<i>|<\/i>|<b>|<\/b>|<color=0[xX][0-9a-fA-F]{8}>|<\/color>/g, text);
    }
    parse(tokens) {
      let italic = 0;
      let bold = 0;
      let colorStack = [StageUtils.getRgbaString(this._settings.textColor)];
      let color = 0;
      const colorRegexp = /<color=(0[xX][0-9a-fA-F]{8})>/;
      return tokens.map((t) => {
        if (t == "<i>") {
          italic += 1;
          t = "";
        } else if (t == "</i>" && italic > 0) {
          italic -= 1;
          t = "";
        } else if (t == "<b>") {
          bold += 1;
          t = "";
        } else if (t == "</b>" && bold > 0) {
          bold -= 1;
          t = "";
        } else if (t == "</color>") {
          if (colorStack.length > 1) {
            color -= 1;
            colorStack.pop();
          }
          t = "";
        } else if (colorRegexp.test(t)) {
          const matched = colorRegexp.exec(t);
          colorStack.push(
            StageUtils.getRgbaString(parseInt(matched[1]))
          );
          color += 1;
          t = "";
        }
        return {
          text: t,
          italic,
          bold,
          color: colorStack[color]
        };
      }).filter((o) => o.text != "");
    }
    applyFontStyle(word, baseFont) {
      let font = baseFont;
      if (word.bold) {
        font = "bold " + font;
      }
      if (word.italic) {
        font = "italic " + font;
      }
      this._context.font = font;
      word.fontStyle = font;
    }
    resetFontStyle(baseFont) {
      this._context.font = baseFont;
    }
    measure(parsed, letterSpacing = 0, baseFont) {
      for (const p of parsed) {
        this.applyFontStyle(p, baseFont);
        p.width = this.measureText(p.text, letterSpacing);
        if (letterSpacing > 0) {
          p.letters = p.text.split("").map((l) => {
            return { text: l };
          });
          for (let l of p.letters) {
            l.width = this.measureText(l.text, letterSpacing);
          }
        }
      }
      this.resetFontStyle(baseFont);
      return parsed;
    }
    indent(parsed, textIndent) {
      parsed.splice(0, 0, { text: "", width: textIndent });
      return parsed;
    }
    wrapWord(word, wordWrapWidth, suffix) {
      const suffixWidth = this.measureText(suffix);
      const wordLen = word.length;
      const wordWidth = this.measureText(word);
      if (wordWidth <= wordWrapWidth) {
        return word;
      }
      let cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
      let truncWordWidth = this.measureText(word.substring(0, cutoffIndex)) + suffixWidth;
      if (truncWordWidth > wordWrapWidth) {
        while (cutoffIndex > 0) {
          truncWordWidth = this.measureText(word.substring(0, cutoffIndex)) + suffixWidth;
          if (truncWordWidth > wordWrapWidth) {
            cutoffIndex -= 1;
          } else {
            break;
          }
        }
      } else {
        while (cutoffIndex < wordLen) {
          truncWordWidth = this.measureText(word.substring(0, cutoffIndex)) + suffixWidth;
          if (truncWordWidth < wordWrapWidth) {
            cutoffIndex += 1;
          } else {
            cutoffIndex -= 1;
            break;
          }
        }
      }
      return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : "");
    }
    _getBreakIndex(word, width) {
      const wordLen = word.length;
      const wordWidth = this.measureText(word);
      if (wordWidth <= width) {
        return { breakIndex: word.length, truncWordWidth: wordWidth };
      }
      let breakIndex = Math.floor(width * wordLen / wordWidth);
      let truncWordWidth = this.measureText(word.substring(0, breakIndex));
      if (truncWordWidth > width) {
        while (breakIndex > 0) {
          truncWordWidth = this.measureText(word.substring(0, breakIndex));
          if (truncWordWidth > width) {
            breakIndex -= 1;
          } else {
            break;
          }
        }
      } else {
        while (breakIndex < wordLen) {
          truncWordWidth = this.measureText(word.substring(0, breakIndex));
          if (truncWordWidth < width) {
            breakIndex += 1;
          } else {
            breakIndex -= 1;
            truncWordWidth = this.measureText(word.substring(0, breakIndex));
            break;
          }
        }
      }
      return { breakIndex, truncWordWidth };
    }
    wordBreak(word, width, baseFont) {
      if (!word.text) {
        return word;
      }
      this.applyFontStyle(word, baseFont);
      const parts = [];
      let text = word.text;
      if (!word.letters) {
        while (true) {
          const { breakIndex, truncWordWidth } = this._getBreakIndex(text, width);
          parts.push(__spreadValues({}, word));
          parts[parts.length - 1].text = text.slice(0, breakIndex);
          parts[parts.length - 1].width = truncWordWidth;
          if (breakIndex === text.length) {
            break;
          }
          text = text.slice(breakIndex);
        }
      } else {
        let totalWidth = 0;
        let letters = [];
        let breakIndex = 0;
        for (const l of word.letters) {
          if (totalWidth + l.width >= width) {
            parts.push(__spreadValues({}, word));
            parts[parts.length - 1].text = text.slice(0, breakIndex);
            parts[parts.length - 1].width = totalWidth;
            parts[parts.length - 1].letters = letters;
            text = text.slice(breakIndex);
            totalWidth = 0;
            letters = [];
            breakIndex = 0;
          } else {
            breakIndex += 1;
            letters.push(l);
            totalWidth += l.width;
          }
        }
        if (totalWidth > 0) {
          parts.push(__spreadValues({}, word));
          parts[parts.length - 1].text = text.slice(0, breakIndex);
          parts[parts.length - 1].width = totalWidth;
          parts[parts.length - 1].letters = letters;
        }
      }
      return parts;
    }
    alignLine(parsed, initialX = 0) {
      let prevWidth = 0;
      let prevX = initialX;
      for (const word of parsed) {
        if (word.text == "\n") {
          continue;
        }
        word.x = prevX + prevWidth;
        prevX = word.x;
        prevWidth = word.width;
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/textures/TextTexture.mjs
  var TextTexture = class _TextTexture extends Texture {
    constructor(stage2) {
      super(stage2);
      this._precision = this.stage.getOption("precision");
    }
    static renderer(stage2, canvas, settings2) {
      if (settings2.advancedRenderer) {
        return new TextTextureRendererAdvanced(stage2, canvas, settings2);
      } else {
        return new TextTextureRenderer(stage2, canvas, settings2);
      }
    }
    get text() {
      return this._text;
    }
    set text(v) {
      if (this._text !== v) {
        this._text = "" + v;
        this._changed();
      }
    }
    get w() {
      return this._w;
    }
    set w(v) {
      if (this._w !== v) {
        this._w = v;
        this._changed();
      }
    }
    get h() {
      return this._h;
    }
    set h(v) {
      if (this._h !== v) {
        this._h = v;
        this._changed();
      }
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(v) {
      if (this._fontStyle !== v) {
        this._fontStyle = v;
        this._changed();
      }
    }
    get fontBaselineRatio() {
      return this._fontBaselineRatio;
    }
    set fontBaselineRatio(v) {
      if (this._fontBaselineRatio !== v) {
        this._fontBaselineRatio = v;
        this._changed();
      }
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(v) {
      if (this._fontSize !== v) {
        this._fontSize = v;
        this._changed();
      }
    }
    get fontFace() {
      return this._fontFace;
    }
    set fontFace(v) {
      if (this._fontFace !== v) {
        this._fontFace = v;
        this._changed();
      }
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(v) {
      if (this._wordWrap !== v) {
        this._wordWrap = v;
        this._changed();
      }
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(v) {
      if (this._wordWrapWidth !== v) {
        this._wordWrapWidth = v;
        this._changed();
      }
    }
    get wordBreak() {
      return this._wordBreak;
    }
    set wordBreak(v) {
      if (this._wordBreak !== v) {
        this._wordBreak = v;
        this._changed();
      }
    }
    get textOverflow() {
      return this._textOverflow;
    }
    set textOverflow(v) {
      if (v != this._textOverflow) {
        this._textOverflow = v;
        this._changed();
      }
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(v) {
      if (this._lineHeight !== v) {
        this._lineHeight = v;
        this._changed();
      }
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(v) {
      if (this._textBaseline !== v) {
        this._textBaseline = v;
        this._changed();
      }
    }
    get textAlign() {
      return this._textAlign;
    }
    set textAlign(v) {
      if (this._textAlign !== v) {
        this._textAlign = v;
        this._changed();
      }
    }
    get verticalAlign() {
      return this._verticalAlign;
    }
    set verticalAlign(v) {
      if (this._verticalAlign !== v) {
        this._verticalAlign = v;
        this._changed();
      }
    }
    get offsetY() {
      return this._offsetY;
    }
    set offsetY(v) {
      if (this._offsetY !== v) {
        this._offsetY = v;
        this._changed();
      }
    }
    get maxLines() {
      return this._maxLines;
    }
    set maxLines(v) {
      if (this._maxLines !== v) {
        this._maxLines = v;
        this._changed();
      }
    }
    get maxLinesSuffix() {
      return this._maxLinesSuffix;
    }
    set maxLinesSuffix(v) {
      if (this._maxLinesSuffix !== v) {
        this._maxLinesSuffix = v;
        this._changed();
      }
    }
    get textColor() {
      return this._textColor;
    }
    set textColor(v) {
      if (this._textColor !== v) {
        this._textColor = v;
        this._changed();
      }
    }
    get paddingLeft() {
      return this._paddingLeft;
    }
    set paddingLeft(v) {
      if (this._paddingLeft !== v) {
        this._paddingLeft = v;
        this._changed();
      }
    }
    get paddingRight() {
      return this._paddingRight;
    }
    set paddingRight(v) {
      if (this._paddingRight !== v) {
        this._paddingRight = v;
        this._changed();
      }
    }
    get shadow() {
      return this._shadow;
    }
    set shadow(v) {
      if (this._shadow !== v) {
        this._shadow = v;
        this._changed();
      }
    }
    get shadowColor() {
      return this._shadowColor;
    }
    set shadowColor(v) {
      if (this._shadowColor !== v) {
        this._shadowColor = v;
        this._changed();
      }
    }
    get shadowOffsetX() {
      return this._shadowOffsetX;
    }
    set shadowOffsetX(v) {
      if (this._shadowOffsetX !== v) {
        this._shadowOffsetX = v;
        this._changed();
      }
    }
    get shadowOffsetY() {
      return this._shadowOffsetY;
    }
    set shadowOffsetY(v) {
      if (this._shadowOffsetY !== v) {
        this._shadowOffsetY = v;
        this._changed();
      }
    }
    get shadowBlur() {
      return this._shadowBlur;
    }
    set shadowBlur(v) {
      if (this._shadowBlur !== v) {
        this._shadowBlur = v;
        this._changed();
      }
    }
    get highlight() {
      return this._highlight;
    }
    set highlight(v) {
      if (this._highlight !== v) {
        this._highlight = v;
        this._changed();
      }
    }
    get highlightHeight() {
      return this._highlightHeight;
    }
    set highlightHeight(v) {
      if (this._highlightHeight !== v) {
        this._highlightHeight = v;
        this._changed();
      }
    }
    get highlightColor() {
      return this._highlightColor;
    }
    set highlightColor(v) {
      if (this._highlightColor !== v) {
        this._highlightColor = v;
        this._changed();
      }
    }
    get highlightOffset() {
      return this._highlightOffset;
    }
    set highlightOffset(v) {
      if (this._highlightOffset !== v) {
        this._highlightOffset = v;
        this._changed();
      }
    }
    get highlightPaddingLeft() {
      return this._highlightPaddingLeft;
    }
    set highlightPaddingLeft(v) {
      if (this._highlightPaddingLeft !== v) {
        this._highlightPaddingLeft = v;
        this._changed();
      }
    }
    get highlightPaddingRight() {
      return this._highlightPaddingRight;
    }
    set highlightPaddingRight(v) {
      if (this._highlightPaddingRight !== v) {
        this._highlightPaddingRight = v;
        this._changed();
      }
    }
    get cutSx() {
      return this._cutSx;
    }
    set cutSx(v) {
      if (this._cutSx !== v) {
        this._cutSx = v;
        this._changed();
      }
    }
    get cutEx() {
      return this._cutEx;
    }
    set cutEx(v) {
      if (this._cutEx !== v) {
        this._cutEx = v;
        this._changed();
      }
    }
    get cutSy() {
      return this._cutSy;
    }
    set cutSy(v) {
      if (this._cutSy !== v) {
        this._cutSy = v;
        this._changed();
      }
    }
    get cutEy() {
      return this._cutEy;
    }
    set cutEy(v) {
      if (this._cutEy !== v) {
        this._cutEy = v;
        this._changed();
      }
    }
    get advancedRenderer() {
      return this._advancedRenderer;
    }
    set advancedRenderer(v) {
      if (this._advancedRenderer !== v) {
        this._advancedRenderer = v;
        this._changed();
      }
    }
    set letterSpacing(v) {
      if (this._letterSpacing !== v) {
        this._letterSpacing = v;
        this._changed();
      }
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set textIndent(v) {
      if (this._textIndent !== v) {
        this._textIndent = v;
        this._changed();
      }
    }
    get textIndent() {
      return this._textIndent;
    }
    set rtl(v) {
      if (this._rtl !== v) {
        this._rtl = v;
        this._changed();
      }
    }
    get rtl() {
      return this._rtl;
    }
    get precision() {
      return super.precision;
    }
    set precision(v) {
      if (this.precision !== v) {
        super.precision = v;
        this._changed();
      }
    }
    _getIsValid() {
      return !!this.text;
    }
    _getLookupId() {
      let parts = [];
      if (this.w !== 0) parts.push("w " + this.w);
      if (this.h !== 0) parts.push("h " + this.h);
      if (this.fontStyle !== "normal") parts.push("fS" + this.fontStyle);
      if (this.fontSize !== 40) parts.push("fs" + this.fontSize);
      if (this.fontBaselineRatio !== 0) parts.push("fb" + this.fontBaselineRatio);
      if (this.fontFace !== null) parts.push("ff" + (Array.isArray(this.fontFace) ? this.fontFace.join(",") : this.fontFace));
      if (this.wordWrap !== true) parts.push("wr" + (this.wordWrap ? 1 : 0));
      if (this.wordWrapWidth !== 0) parts.push("ww" + this.wordWrapWidth);
      if (this.wordBreak !== false) parts.push("wb" + this.wordBreak ? 1 : 0);
      if (this.textOverflow != "") parts.push("to" + this.textOverflow);
      if (this.lineHeight !== null) parts.push("lh" + this.lineHeight);
      if (this.textBaseline !== "alphabetic") parts.push("tb" + this.textBaseline);
      if (this.textAlign !== "left") parts.push("ta" + this.textAlign);
      if (this.verticalAlign !== "top") parts.push("va" + this.verticalAlign);
      if (this.offsetY !== null) parts.push("oy" + this.offsetY);
      if (this.maxLines !== 0) parts.push("ml" + this.maxLines);
      if (this.maxLinesSuffix !== "..") parts.push("ms" + this.maxLinesSuffix);
      parts.push("pc" + this.precision);
      if (this.textColor !== 4294967295) parts.push("co" + this.textColor.toString(16));
      if (this.paddingLeft !== 0) parts.push("pl" + this.paddingLeft);
      if (this.paddingRight !== 0) parts.push("pr" + this.paddingRight);
      if (this.shadow !== false) parts.push("sh" + (this.shadow ? 1 : 0));
      if (this.shadowColor !== 4278190080) parts.push("sc" + this.shadowColor.toString(16));
      if (this.shadowOffsetX !== 0) parts.push("sx" + this.shadowOffsetX);
      if (this.shadowOffsetY !== 0) parts.push("sy" + this.shadowOffsetY);
      if (this.shadowBlur !== 5) parts.push("sb" + this.shadowBlur);
      if (this.highlight !== false) parts.push("hL" + (this.highlight ? 1 : 0));
      if (this.highlightHeight !== 0) parts.push("hh" + this.highlightHeight);
      if (this.highlightColor !== 4278190080) parts.push("hc" + this.highlightColor.toString(16));
      if (this.highlightOffset !== null) parts.push("ho" + this.highlightOffset);
      if (this.highlightPaddingLeft !== null) parts.push("hl" + this.highlightPaddingLeft);
      if (this.highlightPaddingRight !== null) parts.push("hr" + this.highlightPaddingRight);
      if (this.letterSpacing !== null) parts.push("ls" + this.letterSpacing);
      if (this.textIndent !== null) parts.push("ti" + this.textIndent);
      if (this.cutSx) parts.push("csx" + this.cutSx);
      if (this.cutEx) parts.push("cex" + this.cutEx);
      if (this.cutSy) parts.push("csy" + this.cutSy);
      if (this.cutEy) parts.push("cey" + this.cutEy);
      if (this.advancedRenderer) parts.push("aR" + this.advancedRenderer ? 1 : 0);
      let id = "TX$" + parts.join("|") + ":" + this.text;
      return id;
    }
    _getSourceLoader() {
      const args = this.cloneArgs();
      const gl = this.stage.gl;
      return function(cb) {
        const canvas = this.stage.platform.getDrawingCanvas();
        const renderer = _TextTexture.renderer(this.stage, canvas, args);
        const p = renderer.draw();
        const texParams = {};
        const sharpCfg = this.stage.getOption("fontSharp");
        let sharpen = false;
        if (Utils.isBoolean(sharpCfg)) {
          sharpen = sharpCfg;
        } else if (Utils.isObject(sharpCfg)) {
          const precision2 = this.stage.getRenderPrecision();
          sharpen = precision2 <= sharpCfg.precision && args.fontSize <= sharpCfg.fontSize;
        }
        if (gl && sharpen) {
          texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
        }
        if (p) {
          p.then(() => {
            cb(null, Object.assign({
              renderInfo: renderer.renderInfo,
              throttle: false,
              texParams
            }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
          }).catch((err) => {
            cb(err);
          });
        } else {
          cb(null, Object.assign({
            renderInfo: renderer.renderInfo,
            throttle: false,
            texParams
          }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
        }
      };
    }
    getNonDefaults() {
      const nonDefaults = super.getNonDefaults();
      if (this.text !== "") nonDefaults["text"] = this.text;
      if (this.w !== 0) nonDefaults["w"] = this.w;
      if (this.h !== 0) nonDefaults["h"] = this.h;
      if (this.fontStyle !== "normal") nonDefaults["fontStyle"] = this.fontStyle;
      if (this.fontSize !== 40) nonDefaults["fontSize"] = this.fontSize;
      if (this.fontBaselineRatio !== 0) nonDefaults["fontBaselineRatio"] = this.fontBaselineRatio;
      if (this.fontFace !== null) nonDefaults["fontFace"] = this.fontFace;
      if (this.wordWrap !== true) nonDefaults["wordWrap"] = this.wordWrap;
      if (this.wordWrapWidth !== 0) nonDefaults["wordWrapWidth"] = this.wordWrapWidth;
      if (this.wordBreak !== false) nonDefaults["wordBreak"] = this.wordBreak;
      if (this.textOverflow != "") nonDefaults["textOverflow"] = this.textOverflow;
      if (this.lineHeight !== null) nonDefaults["lineHeight"] = this.lineHeight;
      if (this.textBaseline !== "alphabetic") nonDefaults["textBaseline"] = this.textBaseline;
      if (this.textAlign !== "left") nonDefaults["textAlign"] = this.textAlign;
      if (this.verticalAlign !== "top") nonDefaults["verticalAlign"] = this.verticalAlign;
      if (this.offsetY !== null) nonDefaults["offsetY"] = this.offsetY;
      if (this.maxLines !== 0) nonDefaults["maxLines"] = this.maxLines;
      if (this.maxLinesSuffix !== "..") nonDefaults["maxLinesSuffix"] = this.maxLinesSuffix;
      if (this.precision !== this.stage.getOption("precision")) nonDefaults["precision"] = this.precision;
      if (this.textColor !== 4294967295) nonDefaults["textColor"] = this.textColor;
      if (this.paddingLeft !== 0) nonDefaults["paddingLeft"] = this.paddingLeft;
      if (this.paddingRight !== 0) nonDefaults["paddingRight"] = this.paddingRight;
      if (this.shadow !== false) nonDefaults["shadow"] = this.shadow;
      if (this.shadowColor !== 4278190080) nonDefaults["shadowColor"] = this.shadowColor;
      if (this.shadowOffsetX !== 0) nonDefaults["shadowOffsetX"] = this.shadowOffsetX;
      if (this.shadowOffsetY !== 0) nonDefaults["shadowOffsetY"] = this.shadowOffsetY;
      if (this.shadowBlur !== 5) nonDefaults["shadowBlur"] = this.shadowBlur;
      if (this.highlight !== false) nonDefaults["highlight"] = this.highlight;
      if (this.highlightHeight !== 0) nonDefaults["highlightHeight"] = this.highlightHeight;
      if (this.highlightColor !== 4278190080) nonDefaults["highlightColor"] = this.highlightColor;
      if (this.highlightOffset !== 0) nonDefaults["highlightOffset"] = this.highlightOffset;
      if (this.highlightPaddingLeft !== 0) nonDefaults["highlightPaddingLeft"] = this.highlightPaddingLeft;
      if (this.highlightPaddingRight !== 0) nonDefaults["highlightPaddingRight"] = this.highlightPaddingRight;
      if (this.letterSpacing !== 0) nonDefaults["letterSpacing"] = this.letterSpacing;
      if (this.textIndent !== 0) nonDefaults["textIndent"] = this.textIndent;
      if (this.rtl !== 0) nonDefaults["rtl"] = this.rtl;
      if (this.cutSx) nonDefaults["cutSx"] = this.cutSx;
      if (this.cutEx) nonDefaults["cutEx"] = this.cutEx;
      if (this.cutSy) nonDefaults["cutSy"] = this.cutSy;
      if (this.cutEy) nonDefaults["cutEy"] = this.cutEy;
      if (this.advancedRenderer) nonDefaults["renderer"] = this.advancedRenderer;
      return nonDefaults;
    }
    cloneArgs() {
      let obj = {};
      obj.text = this._text;
      obj.w = this._w;
      obj.h = this._h;
      obj.fontStyle = this._fontStyle;
      obj.fontSize = this._fontSize;
      obj.fontBaselineRatio = this._fontBaselineRatio;
      obj.fontFace = this._fontFace;
      obj.wordWrap = this._wordWrap;
      obj.wordWrapWidth = this._wordWrapWidth;
      obj.wordBreak = this._wordBreak;
      obj.textOverflow = this._textOverflow;
      obj.lineHeight = this._lineHeight;
      obj.textBaseline = this._textBaseline;
      obj.textAlign = this._textAlign;
      obj.verticalAlign = this._verticalAlign;
      obj.offsetY = this._offsetY;
      obj.maxLines = this._maxLines;
      obj.maxLinesSuffix = this._maxLinesSuffix;
      obj.precision = this._precision;
      obj.textColor = this._textColor;
      obj.paddingLeft = this._paddingLeft;
      obj.paddingRight = this._paddingRight;
      obj.shadow = this._shadow;
      obj.shadowColor = this._shadowColor;
      obj.shadowOffsetX = this._shadowOffsetX;
      obj.shadowOffsetY = this._shadowOffsetY;
      obj.shadowBlur = this._shadowBlur;
      obj.highlight = this._highlight;
      obj.highlightHeight = this._highlightHeight;
      obj.highlightColor = this._highlightColor;
      obj.highlightOffset = this._highlightOffset;
      obj.highlightPaddingLeft = this._highlightPaddingLeft;
      obj.highlightPaddingRight = this._highlightPaddingRight;
      obj.letterSpacing = this._letterSpacing;
      obj.textIndent = this._textIndent;
      obj.rtl = this._rtl;
      obj.cutSx = this._cutSx;
      obj.cutEx = this._cutEx;
      obj.cutSy = this._cutSy;
      obj.cutEy = this._cutEy;
      obj.advancedRenderer = this._advancedRenderer;
      return obj;
    }
  };
  var proto = TextTexture.prototype;
  proto._text = "";
  proto._w = 0;
  proto._h = 0;
  proto._fontStyle = "normal";
  proto._fontSize = 40;
  proto._fontFace = null;
  proto._wordWrap = true;
  proto._wordWrapWidth = 0;
  proto._wordBreak = false;
  proto._textOverflow = "";
  proto._lineHeight = null;
  proto._textBaseline = "alphabetic";
  proto._textAlign = "left";
  proto._verticalAlign = "top";
  proto._offsetY = null;
  proto._maxLines = 0;
  proto._maxLinesSuffix = "..";
  proto._textColor = 4294967295;
  proto._paddingLeft = 0;
  proto._paddingRight = 0;
  proto._shadow = false;
  proto._shadowColor = 4278190080;
  proto._shadowOffsetX = 0;
  proto._shadowOffsetY = 0;
  proto._shadowBlur = 5;
  proto._highlight = false;
  proto._highlightHeight = 0;
  proto._highlightColor = 4278190080;
  proto._highlightOffset = 0;
  proto._highlightPaddingLeft = 0;
  proto._highlightPaddingRight = 0;
  proto._letterSpacing = 0;
  proto._textIndent = 0;
  proto._rtl = 0;
  proto._cutSx = 0;
  proto._cutEx = 0;
  proto._cutSy = 0;
  proto._cutEy = 0;
  proto._advancedRenderer = false;
  proto._fontBaselineRatio = 0;

  // node_modules/@lightningjs/core/dist/src/textures/SourceTexture.mjs
  var SourceTexture = class extends Texture {
    constructor(stage2) {
      super(stage2);
      this._textureSource = void 0;
    }
    get textureSource() {
      return this._textureSource;
    }
    set textureSource(v) {
      if (v !== this._textureSource) {
        if (v.isResultTexture) {
          this._precision = this.stage.getRenderPrecision();
        }
        this._textureSource = v;
        this._changed();
      }
    }
    _getTextureSource() {
      return this._textureSource;
    }
  };

  // node_modules/@lightningjs/core/dist/src/animation/Transition.mjs
  var Transition = class extends EventEmitter {
    constructor(manager, settings2, element, property) {
      super();
      this.manager = manager;
      this._settings = settings2;
      this._element = element;
      this._getter = element.constructor.getGetter(property);
      this._setter = element.constructor.getSetter(property);
      this._merger = settings2.merger;
      if (!this._merger) {
        this._merger = element.constructor.getMerger(property);
      }
      this._startValue = this._getter(this._element);
      this._targetValue = this._startValue;
      this._p = 1;
      this._delayLeft = 0;
    }
    start(targetValue) {
      this._startValue = this._getter(this._element);
      if (!this.isAttached()) {
        this._targetValue = targetValue;
        this._p = 1;
        this._updateDrawValue();
      } else {
        if (targetValue === this._startValue) {
          this.reset(targetValue, 1);
        } else {
          this._targetValue = targetValue;
          this._p = 0;
          this._delayLeft = this._settings.delay;
          this.emit("start");
          this.add();
        }
      }
    }
    finish() {
      if (this._p < 1) {
        this._p = 1;
      }
    }
    stop() {
      this.emit("stop");
      this.manager.removeActive(this);
    }
    pause() {
      this.stop();
    }
    play() {
      this.manager.addActive(this);
    }
    reset(targetValue, p) {
      if (!this.isAttached()) {
        this._startValue = this._getter(this._element);
        this._targetValue = targetValue;
        this._p = 1;
        this._updateDrawValue();
      } else {
        this._startValue = this._getter(this._element);
        this._targetValue = targetValue;
        this._p = p;
        this.add();
      }
    }
    _updateDrawValue() {
      this._setter(this._element, this.getDrawValue());
    }
    add() {
      this.manager.addActive(this);
    }
    isAttached() {
      return this._element.attached;
    }
    isRunning() {
      return this._p < 1;
    }
    progress(dt) {
      if (!this.isAttached()) {
        this._p = 1;
      }
      if (this.p < 1) {
        if (this.delayLeft > 0) {
          this._delayLeft -= dt;
          if (this.delayLeft < 0) {
            dt = -this.delayLeft;
            this._delayLeft = 0;
            this.emit("delayEnd");
          } else {
            return;
          }
        }
        if (this._settings.duration == 0) {
          this._p = 1;
        } else {
          this._p += dt / this._settings.duration;
        }
        if (this._p >= 1) {
          this._p = 1;
        }
      }
      this._updateDrawValue();
      this.invokeListeners();
    }
    invokeListeners() {
      this.emit("progress", this.p);
      if (this.p === 1) {
        this.emit("finish");
      }
    }
    updateTargetValue(targetValue) {
      let t = this._settings.timingFunctionImpl(this.p);
      if (t === 1) {
        this._targetValue = targetValue;
      } else if (t === 0) {
        this._startValue = this._targetValue;
        this._targetValue = targetValue;
      } else {
        this._startValue = targetValue - (targetValue - this._targetValue) / (1 - t);
        this._targetValue = targetValue;
      }
    }
    getDrawValue() {
      if (this.p >= 1) {
        return this.targetValue;
      } else {
        let v = this._settings._timingFunctionImpl(this.p);
        return this._merger(this.targetValue, this.startValue, v);
      }
    }
    skipDelay() {
      this._delayLeft = 0;
    }
    get startValue() {
      return this._startValue;
    }
    get targetValue() {
      return this._targetValue;
    }
    get p() {
      return this._p;
    }
    get delayLeft() {
      return this._delayLeft;
    }
    get element() {
      return this._element;
    }
    get settings() {
      return this._settings;
    }
    set settings(v) {
      this._settings = v;
    }
  };
  Transition.prototype.isTransition = true;

  // node_modules/@lightningjs/core/dist/src/tree/ObjectList.mjs
  var ObjectList = class {
    constructor() {
      this._items = [];
      this._refs = {};
    }
    get() {
      return this._items;
    }
    get first() {
      return this._items[0];
    }
    get last() {
      return this._items.length ? this._items[this._items.length - 1] : void 0;
    }
    add(item) {
      this.addAt(item, this._items.length);
    }
    addAt(item, index) {
      if (index >= 0 && index <= this._items.length) {
        let currentIndex = this._items.indexOf(item);
        if (currentIndex === index) {
          return item;
        }
        if (Utils.isObjectLiteral(item)) {
          const o = item;
          item = this.createItem(o);
          item.patch(o);
        }
        if (currentIndex != -1) {
          this.setAt(item, index);
        } else {
          if (item.ref) {
            this._refs[item.ref] = item;
          }
          this._items.splice(index, 0, item);
          this.onAdd(item, index);
        }
      } else {
        throw new Error("addAt: The index " + index + " is out of bounds " + this._items.length);
      }
    }
    replaceByRef(item) {
      if (item.ref) {
        const existingItem = this.getByRef(item.ref);
        if (!existingItem) {
          throw new Error("replaceByRef: no item found with reference: " + item.ref);
        }
        this.replace(item, existingItem);
      } else {
        throw new Error("replaceByRef: no ref specified in item");
      }
      this.addAt(item, this._items.length);
    }
    replace(item, prevItem) {
      const index = this.getIndex(prevItem);
      if (index === -1) {
        throw new Error("replace: The previous item does not exist");
      }
      this.setAt(item, index);
    }
    setAt(item, index) {
      if (index >= 0 && index <= this._items.length) {
        if (Utils.isObjectLiteral(item)) {
          const o = item;
          item = this.createItem(o);
          item.patch(o);
        }
        let currentIndex = this._items.indexOf(item);
        if (currentIndex != -1) {
          if (currentIndex !== index) {
            const fromIndex = currentIndex;
            if (fromIndex !== index) {
              this._items.splice(fromIndex, 1);
              this._items.splice(index, 0, item);
              this.onMove(item, fromIndex, index);
            }
          }
        } else {
          if (index < this._items.length) {
            if (this._items[index].ref) {
              this._refs[this._items[index].ref] = void 0;
            }
            const prevItem = this._items[index];
            this._items[index] = item;
            if (item.ref) {
              this._refs[item.ref] = item;
            }
            this.onSet(item, index, prevItem);
          } else {
            throw new Error("setAt: The index " + index + " is out of bounds " + this._items.length);
          }
        }
      } else {
        throw new Error("setAt: The index " + index + " is out of bounds " + this._items.length);
      }
    }
    getAt(index) {
      return this._items[index];
    }
    getIndex(item) {
      return this._items.indexOf(item);
    }
    remove(item) {
      let index = this._items.indexOf(item);
      if (index !== -1) {
        this.removeAt(index);
      }
    }
    removeAt(index) {
      if (index >= 0 && index < this._items.length) {
        const item = this._items[index];
        if (item.ref) {
          this._refs[item.ref] = void 0;
        }
        this._items.splice(index, 1);
        this.onRemove(item, index);
        return item;
      } else {
        throw new Error(`removeAt: The index ${index} is out of bounds ${this._items.length - 1}`);
      }
    }
    clear() {
      let n = this._items.length;
      if (n) {
        let prev = this._items;
        this._items = [];
        this._refs = {};
        this.onSync(prev, [], []);
      }
    }
    a(o) {
      if (Utils.isObjectLiteral(o)) {
        let c = this.createItem(o);
        c.patch(o);
        this.add(c);
        return c;
      } else if (Array.isArray(o)) {
        for (let i = 0, n = o.length; i < n; i++) {
          this.a(o[i]);
        }
        return null;
      } else if (this.isItem(o)) {
        this.add(o);
        return o;
      }
    }
    get length() {
      return this._items.length;
    }
    _getRefs() {
      return this._refs;
    }
    getByRef(ref) {
      return this._refs[ref];
    }
    clearRef(ref) {
      delete this._refs[ref];
    }
    setRef(ref, child) {
      this._refs[ref] = child;
    }
    patch(settings2) {
      if (Utils.isObjectLiteral(settings2)) {
        this._setByObject(settings2);
      } else if (Array.isArray(settings2)) {
        this._setByArray(settings2);
      }
    }
    _setByObject(settings2) {
      let refs = this._getRefs();
      let crefs = Object.keys(settings2);
      for (let i = 0, n = crefs.length; i < n; i++) {
        let cref = crefs[i];
        let s = settings2[cref];
        let c = refs[cref];
        if (!c) {
          if (this.isItem(s)) {
            s.ref = cref;
            this.add(s);
          } else {
            c = this.createItem(s);
            c.ref = cref;
            c.patch(s);
            this.add(c);
          }
        } else {
          if (this.isItem(s)) {
            if (c !== s) {
              let idx = this.getIndex(c);
              s.ref = cref;
              this.setAt(s, idx);
            }
          } else {
            c.patch(s);
          }
        }
      }
    }
    _equalsArray(array) {
      let same = true;
      if (array.length === this._items.length) {
        for (let i = 0, n = this._items.length; i < n && same; i++) {
          same = same && this._items[i] === array[i];
        }
      } else {
        same = false;
      }
      return same;
    }
    _setByArray(array) {
      if (this._equalsArray(array)) {
        return;
      }
      for (let i = 0, n = this._items.length; i < n; i++) {
        this._items[i].marker = true;
      }
      let refs;
      let newItems = [];
      for (let i = 0, n = array.length; i < n; i++) {
        let s = array[i];
        if (this.isItem(s)) {
          s.marker = false;
          newItems.push(s);
        } else {
          let cref = s.ref;
          let c;
          if (cref) {
            if (!refs) refs = this._getRefs();
            c = refs[cref];
          }
          if (!c) {
            c = this.createItem(s);
          } else {
            c.marker = false;
          }
          if (Utils.isObjectLiteral(s)) {
            c.patch(s);
          }
          newItems.push(c);
        }
      }
      this._setItems(newItems);
    }
    _setItems(newItems) {
      let prevItems = this._items;
      this._items = newItems;
      let removed = prevItems.filter((item) => {
        let m = item.marker;
        delete item.marker;
        return m;
      });
      let added = newItems.filter((item) => prevItems.indexOf(item) === -1);
      if (removed.length || added.length) {
        this._refs = {};
        for (let i = 0, n = this._items.length; i < n; i++) {
          let ref = this._items[i].ref;
          if (ref) {
            this._refs[ref] = this._items[i];
          }
        }
      }
      this.onSync(removed, added, newItems);
    }
    sort(f) {
      const items = this._items.slice();
      items.sort(f);
      this._setByArray(items);
    }
    onAdd(item, index) {
    }
    onRemove(item, index) {
    }
    onSync(removed, added, order) {
    }
    onSet(item, index, prevItem) {
    }
    onMove(item, fromIndex, toIndex) {
    }
    createItem(object) {
      throw new Error("ObjectList.createItem must create and return a new object");
    }
    isItem(object) {
      return false;
    }
    forEach(f) {
      this.get().forEach(f);
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/ElementChildList.mjs
  var ElementChildList = class extends ObjectList {
    constructor(element) {
      super();
      this._element = element;
    }
    _connectParent(item) {
      const prevParent = item.parent;
      if (prevParent && prevParent !== this._element) {
        const prevChildList = item.parent.childList;
        const index = prevChildList.getIndex(item);
        if (item.ref) {
          prevChildList._refs[item.ref] = void 0;
        }
        prevChildList._items.splice(index, 1);
        prevParent.core.removeChildAt(index);
      }
      item._setParent(this._element);
    }
    onAdd(item, index) {
      this._connectParent(item);
      this._element.core.addChildAt(index, item.core);
    }
    onRemove(item, index) {
      item._setParent(null);
      this._element.core.removeChildAt(index);
    }
    onSync(removed, added, order) {
      for (let i = 0, n = removed.length; i < n; i++) {
        removed[i]._setParent(null);
      }
      for (let i = 0, n = added.length; i < n; i++) {
        this._connectParent(added[i]);
      }
      let gc = (i) => i.core;
      this._element.core.syncChildren(removed.map(gc), added.map(gc), order.map(gc));
    }
    onSet(item, index, prevItem) {
      prevItem._setParent(null);
      this._connectParent(item);
      this._element.core.setChildAt(index, item.core);
    }
    onMove(item, fromIndex, toIndex) {
      this._element.core.moveChild(fromIndex, toIndex);
    }
    createItem(object) {
      if (object.type) {
        return new object.type(this._element.stage);
      } else {
        return this._element.stage.createElement();
      }
    }
    isItem(object) {
      return object.isElement;
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/Element.mjs
  var Element = class _Element {
    constructor(stage2) {
      this.stage = stage2;
      this.__id = _Element.id++;
      this.__start();
      this._hasEventListeners = false;
      this.__core = new ElementCore(this);
      this.__ref = null;
      this.__attached = false;
      this.__enabled = false;
      this.__active = false;
      this.__parent = null;
      this.__texture = null;
      this.__displayedTexture = null;
      this.__tags = null;
      this.__treeTags = null;
      this.__tagRoot = false;
      this.__childList = null;
      this._w = 0;
      this._h = 0;
    }
    __start() {
    }
    get id() {
      return this.__id;
    }
    set ref(ref) {
      if (this.__ref !== ref) {
        const charcode = ref.charCodeAt(0);
        if (!Utils.isUcChar(charcode)) {
          this._throwError("Ref must start with an upper case character: " + ref);
        }
        if (this.__ref !== null) {
          this.removeTag(this.__ref);
          if (this.__parent) {
            this.__parent.__childList.clearRef(this.__ref);
          }
        }
        this.__ref = ref;
        if (this.__ref) {
          this._addTag(this.__ref);
          if (this.__parent) {
            this.__parent.__childList.setRef(this.__ref, this);
          }
        }
      }
    }
    get ref() {
      return this.__ref;
    }
    get core() {
      return this.__core;
    }
    setAsRoot() {
      this.__core.setAsRoot();
      this._updateAttachedFlag();
      this._updateEnabledFlag();
    }
    get isRoot() {
      return this.__core.isRoot;
    }
    _setParent(parent) {
      if (this.__parent === parent) return;
      if (this.__parent) {
        this._unsetTagsParent();
      }
      this.__parent = parent;
      if (parent) {
        this._setTagsParent();
      }
      this._updateAttachedFlag();
      this._updateEnabledFlag();
      this._updateCollision();
      if (this.isRoot && parent) {
        this._throwError("Root should not be added as a child! Results are unspecified!");
      }
    }
    getDepth() {
      let depth = 0;
      let p = this.__parent;
      while (p) {
        depth++;
        p = p.__parent;
      }
      return depth;
    }
    getAncestor(l) {
      let p = this;
      while (l > 0 && p.__parent) {
        p = p.__parent;
        l--;
      }
      return p;
    }
    getAncestors() {
      const a = [];
      let p = this;
      while (p) {
        a.push(p);
        p = p.__parent;
      }
      return a;
    }
    getAncestorAtDepth(depth) {
      let levels = this.getDepth() - depth;
      if (levels < 0) {
        return null;
      }
      return this.getAncestor(levels);
    }
    isAncestorOf(c) {
      let p = c;
      while (p = p.parent) {
        if (this === p) {
          return true;
        }
      }
      return false;
    }
    getSharedAncestor(c) {
      let o1 = this;
      let o2 = c;
      let l1 = o1.getDepth();
      let l2 = o2.getDepth();
      if (l1 > l2) {
        o1 = o1.getAncestor(l1 - l2);
      } else if (l2 > l1) {
        o2 = o2.getAncestor(l2 - l1);
      }
      do {
        if (o1 === o2) {
          return o1;
        }
        o1 = o1.__parent;
        o2 = o2.__parent;
      } while (o1 && o2);
      return null;
    }
    get attached() {
      return this.__attached;
    }
    get enabled() {
      return this.__enabled;
    }
    get active() {
      return this.__active;
    }
    _isAttached() {
      return this.__parent ? this.__parent.__attached : this.stage.root === this;
    }
    _isEnabled() {
      return this.__core.visible && this.__core.alpha > 0 && (this.__parent ? this.__parent.__enabled : this.stage.root === this);
    }
    _isActive() {
      return this._isEnabled() && this.withinBoundsMargin;
    }
    /**
     * Updates the 'attached' flag for this branch.
     */
    _updateAttachedFlag() {
      let newAttached = this._isAttached();
      if (this.__attached !== newAttached) {
        this.__attached = newAttached;
        if (newAttached) {
          this._onSetup();
        }
        let children = this._children.get();
        if (children) {
          let m = children.length;
          if (m > 0) {
            for (let i = 0; i < m; i++) {
              children[i]._updateAttachedFlag();
            }
          }
        }
        if (newAttached) {
          this._onAttach();
        } else {
          this._onDetach();
        }
      }
    }
    /**
     * Updates the 'enabled' flag for this branch.
     */
    _updateEnabledFlag() {
      let newEnabled = this._isEnabled();
      if (this.__enabled !== newEnabled) {
        if (newEnabled) {
          this._onEnabled();
          this._setEnabledFlag();
        } else {
          this._onDisabled();
          this._unsetEnabledFlag();
        }
        let children = this._children.get();
        if (children) {
          let m = children.length;
          if (m > 0) {
            for (let i = 0; i < m; i++) {
              children[i]._updateEnabledFlag();
            }
          }
        }
      }
    }
    _setEnabledFlag() {
      this.__enabled = true;
      this._updateDimensions();
      this._updateTextureCoords();
      if (this.__texture) {
        this.__texture.addElement(this);
      }
      if (this.withinBoundsMargin) {
        this._setActiveFlag();
      }
      if (this.__core.shader) {
        this.__core.shader.addElement(this.__core);
      }
    }
    _unsetEnabledFlag() {
      if (this.__active) {
        this._unsetActiveFlag();
      }
      if (this.__texture) {
        this.__texture.removeElement(this);
      }
      if (this.__core.shader) {
        this.__core.shader.removeElement(this.__core);
      }
      if (this._texturizer) {
        this.texturizer.filters.forEach((filter) => filter.removeElement(this.__core));
      }
      this.__enabled = false;
    }
    _setActiveFlag() {
      this.__active = true;
      if (this.__texture) {
        this.__texture.incActiveCount();
      }
      if (this.__texture) {
        this._enableTexture();
      }
      this._onActive();
    }
    _unsetActiveFlag() {
      if (this.__texture) {
        this.__texture.decActiveCount();
      }
      this.__active = false;
      if (this.__texture) {
        this._disableTexture();
      }
      if (this._hasTexturizer()) {
        this.texturizer.deactivate();
      }
      this._onInactive();
    }
    _onSetup() {
    }
    _onAttach() {
    }
    _onDetach() {
    }
    _onEnabled() {
    }
    _onDisabled() {
    }
    _onActive() {
    }
    _onInactive() {
    }
    _onResize() {
    }
    _getRenderWidth() {
      if (this._w) {
        return this._w;
      } else if (this.__displayedTexture) {
        return this.__displayedTexture.getRenderWidth();
      } else if (this.__texture) {
        return this.__texture.getRenderWidth();
      } else {
        return 0;
      }
    }
    _getRenderHeight() {
      if (this._h) {
        return this._h;
      } else if (this.__displayedTexture) {
        return this.__displayedTexture.getRenderHeight();
      } else if (this.__texture) {
        return this.__texture.getRenderHeight();
      } else {
        return 0;
      }
    }
    get renderWidth() {
      if (this.__enabled) {
        return this.__core.getRenderWidth();
      } else {
        return this._getRenderWidth();
      }
    }
    get renderHeight() {
      if (this.__enabled) {
        return this.__core.getRenderHeight();
      } else {
        return this._getRenderHeight();
      }
    }
    get finalX() {
      return this.__core.x;
    }
    get finalY() {
      return this.__core.y;
    }
    get finalW() {
      return this.__core.w;
    }
    get finalH() {
      return this.__core.h;
    }
    textureIsLoaded() {
      return this.__texture && this.__texture.isLoaded();
    }
    loadTexture() {
      if (this.__texture) {
        this.__texture.load();
        if (!this.__texture.isUsed() || !this._isEnabled()) {
          this._updateDimensions();
        }
      }
    }
    _enableTextureError() {
      const loadError = this.__texture.loadError;
      if (loadError) {
        this.emit("txError", loadError, this.__texture._source);
      }
    }
    _enableTexture() {
      if (this.__texture.isLoaded()) {
        this._setDisplayedTexture(this.__texture);
      } else {
        this._setDisplayedTexture(null);
        this._enableTextureError();
      }
    }
    _disableTexture() {
      this._setDisplayedTexture(null);
    }
    get texture() {
      return this.__texture;
    }
    set texture(v) {
      let texture;
      if (Utils.isObjectLiteral(v)) {
        if (v.type) {
          texture = new v.type(this.stage);
        } else {
          texture = this.texture;
        }
        if (texture) {
          Base.patchObject(texture, v);
        }
      } else if (!v) {
        texture = null;
      } else {
        if (v.isTexture) {
          texture = v;
        } else if (v.isTextureSource) {
          texture = new SourceTexture(this.stage);
          texture.textureSource = v;
        } else {
          console.error("[Lightning] Please specify a texture type.");
          return;
        }
      }
      const prevTexture = this.__texture;
      if (texture !== prevTexture) {
        this.__texture = texture;
        if (this.__texture) {
          if (this.__enabled) {
            this.__texture.addElement(this);
            if (this.withinBoundsMargin) {
              if (this.__texture.isLoaded()) {
                this._setDisplayedTexture(this.__texture);
              } else {
                this._enableTextureError();
              }
            }
          }
        } else {
          this._setDisplayedTexture(null);
        }
        if (prevTexture && prevTexture !== this.__displayedTexture) {
          prevTexture.removeElement(this);
        }
        this._updateDimensions();
      }
    }
    get displayedTexture() {
      return this.__displayedTexture;
    }
    _setDisplayedTexture(v) {
      let prevTexture = this.__displayedTexture;
      if (prevTexture && v !== prevTexture) {
        if (this.__texture !== prevTexture) {
          prevTexture.removeElement(this);
        }
      }
      const prevSource = this.__core.displayedTextureSource;
      const sourceChanged = (v ? v._source : null) !== prevSource;
      this.__displayedTexture = v;
      this._updateDimensions();
      if (this.__displayedTexture) {
        if (sourceChanged) {
          this._updateTextureCoords();
          this.__core.setDisplayedTextureSource(this.__displayedTexture._source);
        }
      } else {
        this.__core.setDisplayedTextureSource(null);
      }
      if (sourceChanged) {
        if (this.__displayedTexture) {
          this.stage.removeUpdateSourceTexture(this.__displayedTexture);
          this.emit("txLoaded", this.__displayedTexture);
        } else {
          this.emit("txUnloaded", this.__displayedTexture);
        }
      }
    }
    onTextureSourceLoaded() {
      if (this.active) {
        this._setDisplayedTexture(this.__texture);
      }
    }
    onTextureSourceLoadError(e) {
      this.emit("txError", e, this.__texture._source);
    }
    forceRenderUpdate() {
      this.__core.setHasRenderUpdates(3);
    }
    onDisplayedTextureClippingChanged() {
      this._updateDimensions();
      this._updateTextureCoords();
    }
    onPrecisionChanged() {
      this._updateDimensions();
    }
    onDimensionsChanged(w, h) {
      if (this.texture instanceof TextTexture) {
        this.texture.w = w;
        this.texture.h = h;
        this.w = w;
        this.h = h;
      }
    }
    _updateDimensions() {
      let w = this._getRenderWidth();
      let h = this._getRenderHeight();
      let unknownSize = false;
      if (!w || !h) {
        if (!this.__displayedTexture && this.__texture) {
          w = w || this.__texture.mw;
          h = h || this.__texture.mh;
          if ((!w || !h) && this.__texture.isAutosizeTexture()) {
            unknownSize = true;
          }
        }
      }
      if (this.__core.setDimensions(w, h, unknownSize)) {
        this._onResize();
      }
    }
    _updateTextureCoords() {
      if (this.displayedTexture && this.displayedTexture._source) {
        let displayedTexture = this.displayedTexture;
        let displayedTextureSource = this.displayedTexture._source;
        let tx1 = 0, ty1 = 0, tx2 = 1, ty2 = 1;
        if (displayedTexture.clipping) {
          let w = displayedTextureSource.getRenderWidth();
          let h = displayedTextureSource.getRenderHeight();
          let iw, ih, rw, rh;
          iw = 1 / w;
          ih = 1 / h;
          if (displayedTexture.pw) {
            rw = displayedTexture.pw * iw;
          } else {
            rw = (w - displayedTexture.px) * iw;
          }
          if (displayedTexture.ph) {
            rh = displayedTexture.ph * ih;
          } else {
            rh = (h - displayedTexture.py) * ih;
          }
          iw *= displayedTexture.px;
          ih *= displayedTexture.py;
          tx1 = iw;
          ty1 = ih;
          tx2 = tx2 * rw + iw;
          ty2 = ty2 * rh + ih;
          tx1 = Math.max(0, tx1);
          ty1 = Math.max(0, ty1);
          tx2 = Math.min(1, tx2);
          ty2 = Math.min(1, ty2);
        }
        if (displayedTextureSource._flipTextureY) {
          let tempty = ty2;
          ty2 = ty1;
          ty1 = tempty;
        }
        this.__core.setTextureCoords(tx1, ty1, tx2, ty2);
      }
    }
    getCornerPoints() {
      return this.__core.getCornerPoints();
    }
    _unsetTagsParent() {
      if (this.__tags) {
        this.__tags.forEach((tag) => {
          let p = this;
          while (p = p.__parent) {
            let parentTreeTags = p.__treeTags.get(tag);
            parentTreeTags.delete(this);
            if (p.__tagRoot) {
              break;
            }
          }
        });
      }
      let tags = null;
      let n = 0;
      if (this.__treeTags) {
        if (!this.__tagRoot) {
          tags = Utils.iteratorToArray(this.__treeTags.keys());
          n = tags.length;
          if (n > 0) {
            for (let i = 0; i < n; i++) {
              let tagSet = this.__treeTags.get(tags[i]);
              let p = this;
              while (p = p.__parent) {
                let parentTreeTags = p.__treeTags.get(tags[i]);
                tagSet.forEach(function(comp) {
                  parentTreeTags.delete(comp);
                });
                if (p.__tagRoot) {
                  break;
                }
              }
            }
          }
        }
      }
    }
    _setTagsParent() {
      if (this.__tags) {
        this.__tags.forEach((tag) => {
          let p = this;
          while (p = p.__parent) {
            if (!p.__treeTags) {
              p.__treeTags = /* @__PURE__ */ new Map();
            }
            let s = p.__treeTags.get(tag);
            if (!s) {
              s = /* @__PURE__ */ new Set();
              p.__treeTags.set(tag, s);
            }
            s.add(this);
            if (p.__tagRoot) {
              break;
            }
          }
        });
      }
      if (this.__treeTags && this.__treeTags.size) {
        if (!this.__tagRoot) {
          this.__treeTags.forEach((tagSet, tag) => {
            let p = this;
            while (!p.__tagRoot && (p = p.__parent)) {
              if (p.__tagRoot) {
              }
              if (!p.__treeTags) {
                p.__treeTags = /* @__PURE__ */ new Map();
              }
              let s = p.__treeTags.get(tag);
              if (!s) {
                s = /* @__PURE__ */ new Set();
                p.__treeTags.set(tag, s);
              }
              tagSet.forEach(function(comp) {
                s.add(comp);
              });
            }
          });
        }
      }
    }
    _getByTag(tag) {
      if (!this.__treeTags) {
        return [];
      }
      let t = this.__treeTags.get(tag);
      return t ? Utils.setToArray(t) : [];
    }
    getTags() {
      return this.__tags ? this.__tags : [];
    }
    setTags(tags) {
      tags = tags.reduce((acc, tag) => {
        return acc.concat(tag.split(" "));
      }, []);
      if (this.__ref) {
        tags.push(this.__ref);
      }
      let i, n = tags.length;
      let removes = [];
      let adds = [];
      for (i = 0; i < n; i++) {
        if (!this.hasTag(tags[i])) {
          adds.push(tags[i]);
        }
      }
      let currentTags = this.tags || [];
      n = currentTags.length;
      for (i = 0; i < n; i++) {
        if (tags.indexOf(currentTags[i]) == -1) {
          removes.push(currentTags[i]);
        }
      }
      for (i = 0; i < removes.length; i++) {
        this.removeTag(removes[i]);
      }
      for (i = 0; i < adds.length; i++) {
        this.addTag(adds[i]);
      }
    }
    addTag(tag) {
      if (tag.indexOf(" ") === -1) {
        if (Utils.isUcChar(tag.charCodeAt(0))) {
          this._throwError("Tag may not start with an upper case character.");
        }
        this._addTag(tag);
      } else {
        const tags = tag.split(" ");
        for (let i = 0, m = tags.length; i < m; i++) {
          const tag2 = tags[i];
          if (Utils.isUcChar(tag2.charCodeAt(0))) {
            this._throwError("Tag may not start with an upper case character.");
          }
          this._addTag(tag2);
        }
      }
    }
    _addTag(tag) {
      if (!this.__tags) {
        this.__tags = [];
      }
      if (this.__tags.indexOf(tag) === -1) {
        this.__tags.push(tag);
        let p = this.__parent;
        if (p) {
          do {
            if (!p.__treeTags) {
              p.__treeTags = /* @__PURE__ */ new Map();
            }
            let s = p.__treeTags.get(tag);
            if (!s) {
              s = /* @__PURE__ */ new Set();
              p.__treeTags.set(tag, s);
            }
            s.add(this);
          } while (!p.__tagRoot && (p = p.__parent));
        }
      }
    }
    removeTag(tag) {
      let i = this.__tags.indexOf(tag);
      if (i !== -1) {
        this.__tags.splice(i, 1);
        let p = this.__parent;
        if (p) {
          do {
            let list = p.__treeTags.get(tag);
            if (list) {
              list.delete(this);
            }
          } while (!p.__tagRoot && (p = p.__parent));
        }
      }
    }
    hasTag(tag) {
      return this.__tags && this.__tags.indexOf(tag) !== -1;
    }
    /**
     * Returns one of the elements from the subtree that have this tag.
     * @param {string} tag
     * @returns {Element}
     */
    _tag(tag) {
      if (tag.indexOf(".") !== -1) {
        return this.mtag(tag)[0];
      } else {
        if (this.__treeTags) {
          let t = this.__treeTags.get(tag);
          if (t) {
            const item = t.values().next();
            return item ? item.value : void 0;
          }
        }
      }
    }
    get tag() {
      return this._tag;
    }
    set tag(t) {
      this.tags = t;
    }
    /**
     * Returns all elements from the subtree that have this tag.
     * @param {string} tag
     * @returns {Element[]}
     */
    mtag(tag) {
      let idx = tag.indexOf(".");
      if (idx >= 0) {
        let parts = tag.split(".");
        let res = this._getByTag(parts[0]);
        let level = 1;
        let c = parts.length;
        while (res.length && level < c) {
          let resn = [];
          for (let j = 0, n = res.length; j < n; j++) {
            resn = resn.concat(res[j]._getByTag(parts[level]));
          }
          res = resn;
          level++;
        }
        return res;
      } else {
        return this._getByTag(tag);
      }
    }
    stag(tag, settings2) {
      let t = this.mtag(tag);
      let n = t.length;
      for (let i = 0; i < n; i++) {
        Base.patchObject(t[i], settings2);
      }
    }
    get tagRoot() {
      return this.__tagRoot;
    }
    set tagRoot(v) {
      if (this.__tagRoot !== v) {
        if (!v) {
          this._setTagsParent();
        } else {
          this._unsetTagsParent();
        }
        this.__tagRoot = v;
      }
    }
    sel(path) {
      const results = this.select(path);
      if (results.length) {
        return results[0];
      } else {
        return void 0;
      }
    }
    select(path) {
      if (path.indexOf(",") !== -1) {
        let selectors = path.split(",");
        let res = [];
        for (let i = 0; i < selectors.length; i++) {
          res = res.concat(this._select(selectors[i]));
        }
        return res;
      } else {
        return this._select(path);
      }
    }
    _select(path) {
      if (path === "") return [this];
      let pointIdx = path.indexOf(".");
      let arrowIdx = path.indexOf(">");
      if (pointIdx === -1 && arrowIdx === -1) {
        return this.mtag(path);
      }
      let isRef;
      if (arrowIdx === 0) {
        isRef = true;
        path = path.substr(1);
      } else if (pointIdx === 0) {
        isRef = false;
        path = path.substr(1);
      } else {
        isRef = false;
      }
      return this._selectChilds(path, isRef);
    }
    _selectChilds(path, isRef) {
      const pointIdx = path.indexOf(".");
      const arrowIdx = path.indexOf(">");
      if (pointIdx === -1 && arrowIdx === -1) {
        if (isRef) {
          const ref = this.getByRef(path);
          return ref ? [ref] : [];
        } else {
          return this.mtag(path);
        }
      }
      if (arrowIdx === -1 || pointIdx !== -1 && pointIdx < arrowIdx) {
        let next;
        const str = path.substr(0, pointIdx);
        if (isRef) {
          const ref = this.getByRef(str);
          next = ref ? [ref] : [];
        } else {
          next = this.mtag(str);
        }
        let total = [];
        const subPath = path.substr(pointIdx + 1);
        for (let i = 0, n = next.length; i < n; i++) {
          total = total.concat(next[i]._selectChilds(subPath, false));
        }
        return total;
      } else {
        let next;
        const str = path.substr(0, arrowIdx);
        if (isRef) {
          const ref = this.getByRef(str);
          next = ref ? [ref] : [];
        } else {
          next = this.mtag(str);
        }
        let total = [];
        const subPath = path.substr(arrowIdx + 1);
        for (let i = 0, n = next.length; i < n; i++) {
          total = total.concat(next[i]._selectChilds(subPath, true));
        }
        return total;
      }
    }
    getByRef(ref) {
      return this.childList.getByRef(ref);
    }
    getLocationString() {
      let i;
      i = this.__parent ? this.__parent._children.getIndex(this) : "R";
      let localTags = this.getTags();
      let str = this.__parent ? this.__parent.getLocationString() : "";
      if (this.ref) {
        str += ":[" + i + "]" + this.ref;
      } else if (localTags.length) {
        str += ":[" + i + "]" + localTags.join(",");
      } else {
        str += ":[" + i + "]#" + this.id;
      }
      return str;
    }
    toString() {
      let obj = this.getSettings();
      return _Element.getPrettyString(obj, "");
    }
    static getPrettyString(obj, indent) {
      let children = obj.children;
      delete obj.children;
      let colorKeys = ["color", "colorUl", "colorUr", "colorBl", "colorBr"];
      let str = JSON.stringify(obj, function(k, v) {
        if (colorKeys.indexOf(k) !== -1) {
          return "COLOR[" + v.toString(16) + "]";
        }
        return v;
      });
      str = str.replace(/"COLOR\[([a-f0-9]{1,8})\]"/g, "0x$1");
      if (children) {
        let childStr = "";
        if (Utils.isObjectLiteral(children)) {
          let refs = Object.keys(children);
          childStr = "";
          for (let i = 0, n = refs.length; i < n; i++) {
            childStr += `
${indent}  "${refs[i]}":`;
            delete children[refs[i]].ref;
            childStr += _Element.getPrettyString(children[refs[i]], indent + "  ") + (i < n - 1 ? "," : "");
          }
          let isEmpty = str === "{}";
          str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + childStr + "\n" + indent + "}";
        } else {
          let n = children.length;
          childStr = "[";
          for (let i = 0; i < n; i++) {
            childStr += _Element.getPrettyString(children[i], indent + "  ") + (i < n - 1 ? "," : "") + "\n";
          }
          childStr += indent + "]}";
          let isEmpty = str === "{}";
          str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + '"children":\n' + indent + childStr + "}";
        }
      }
      return str;
    }
    getSettings() {
      let settings2 = this.getNonDefaults();
      let children = this._children.get();
      if (children) {
        let n = children.length;
        if (n) {
          const childArray = [];
          let missing = false;
          for (let i = 0; i < n; i++) {
            childArray.push(children[i].getSettings());
            missing = missing || !children[i].ref;
          }
          if (!missing) {
            settings2.children = {};
            childArray.forEach((child) => {
              settings2.children[child.ref] = child;
            });
          } else {
            settings2.children = childArray;
          }
        }
      }
      settings2.id = this.id;
      return settings2;
    }
    getNonDefaults() {
      let settings2 = {};
      if (this.constructor !== _Element) {
        settings2.type = this.constructor.name;
      }
      if (this.__ref) {
        settings2.ref = this.__ref;
      }
      if (this.__tags && this.__tags.length) {
        settings2.tags = this.__tags;
      }
      if (this.x !== 0) settings2.x = this.x;
      if (this.y !== 0) settings2.y = this.y;
      if (this.w !== 0) settings2.w = this.w;
      if (this.h !== 0) settings2.h = this.h;
      if (this.scaleX === this.scaleY) {
        if (this.scaleX !== 1) settings2.scale = this.scaleX;
      } else {
        if (this.scaleX !== 1) settings2.scaleX = this.scaleX;
        if (this.scaleY !== 1) settings2.scaleY = this.scaleY;
      }
      if (this.pivotX === this.pivotY) {
        if (this.pivotX !== 0.5) settings2.pivot = this.pivotX;
      } else {
        if (this.pivotX !== 0.5) settings2.pivotX = this.pivotX;
        if (this.pivotY !== 0.5) settings2.pivotY = this.pivotY;
      }
      if (this.mountX === this.mountY) {
        if (this.mountX !== 0) settings2.mount = this.mountX;
      } else {
        if (this.mountX !== 0) settings2.mountX = this.mountX;
        if (this.mountY !== 0) settings2.mountY = this.mountY;
      }
      if (this.alpha !== 1) settings2.alpha = this.alpha;
      if (!this.visible) settings2.visible = false;
      if (this.rotation !== 0) settings2.rotation = this.rotation;
      if (this.colorUl === this.colorUr && this.colorBl === this.colorBr && this.colorUl === this.colorBl) {
        if (this.colorUl !== 4294967295) settings2.color = this.colorUl.toString(16);
      } else {
        if (this.colorUl !== 4294967295) settings2.colorUl = this.colorUl.toString(16);
        if (this.colorUr !== 4294967295) settings2.colorUr = this.colorUr.toString(16);
        if (this.colorBl !== 4294967295) settings2.colorBl = this.colorBl.toString(16);
        if (this.colorBr !== 4294967295) settings2.colorBr = this.colorBr.toString(16);
      }
      if (this.zIndex) settings2.zIndex = this.zIndex;
      if (this.forceZIndexContext) settings2.forceZIndexContext = true;
      if (this.clipping) settings2.clipping = this.clipping;
      if (!this.clipbox) settings2.clipbox = this.clipbox;
      if (this.__texture) {
        let tnd = this.__texture.getNonDefaults();
        if (Object.keys(tnd).length) {
          settings2.texture = tnd;
        }
      }
      if (this.shader && Utils.isFunction(this.shader.getNonDefaults)) {
        let tnd = this.shader.getNonDefaults();
        if (Object.keys(tnd).length) {
          settings2.shader = tnd;
        }
      }
      if (this._hasTexturizer()) {
        if (this.texturizer.enabled) {
          settings2.renderToTexture = this.texturizer.enabled;
        }
        if (this.texturizer.lazy) {
          settings2.renderToTextureLazy = this.texturizer.lazy;
        }
        if (this.texturizer.colorize) {
          settings2.colorizeResultTexture = this.texturizer.colorize;
        }
        if (this.texturizer.renderOffscreen) {
          settings2.renderOffscreen = this.texturizer.renderOffscreen;
        }
      }
      return settings2;
    }
    static getGetter(propertyPath) {
      let getter = _Element.PROP_GETTERS.get(propertyPath);
      if (!getter) {
        getter = new Function("obj", "return obj." + propertyPath);
        _Element.PROP_GETTERS.set(propertyPath, getter);
      }
      return getter;
    }
    static getSetter(propertyPath) {
      let setter = _Element.PROP_SETTERS.get(propertyPath);
      if (!setter) {
        setter = new Function("obj", "v", "obj." + propertyPath + " = v");
        _Element.PROP_SETTERS.set(propertyPath, setter);
      }
      return setter;
    }
    get withinBoundsMargin() {
      return this.__core._withinBoundsMargin;
    }
    _enableWithinBoundsMargin() {
      if (this.__enabled) {
        this._setActiveFlag();
      }
    }
    _disableWithinBoundsMargin() {
      if (this.__active) {
        this._unsetActiveFlag();
      }
    }
    set boundsMargin(v) {
      if (!Array.isArray(v) && v !== null) {
        throw new Error("boundsMargin should be an array of left-top-right-bottom values or null (inherit margin)");
      }
      this.__core.boundsMargin = v;
    }
    get boundsMargin() {
      return this.__core.boundsMargin;
    }
    get x() {
      return this.__core.offsetX;
    }
    set x(v) {
      this.__core.offsetX = v;
    }
    get y() {
      return this.__core.offsetY;
    }
    set y(v) {
      this.__core.offsetY = v;
    }
    get w() {
      return this._w;
    }
    set w(v) {
      if (Utils.isFunction(v)) {
        this._w = 0;
        this.__core.funcW = v;
      } else {
        v = Math.max(v, 0);
        if (this._w !== v) {
          this.__core.disableFuncW();
          this._w = v;
          this._updateDimensions();
        }
      }
    }
    get h() {
      return this._h;
    }
    set h(v) {
      if (Utils.isFunction(v)) {
        this._h = 0;
        this.__core.funcH = v;
      } else {
        v = Math.max(v, 0);
        if (this._h !== v) {
          this.__core.disableFuncH();
          this._h = v;
          this._updateDimensions();
        }
      }
    }
    get collision() {
      return this._collision;
    }
    set collision(v) {
      this._collision = v;
    }
    _updateCollision() {
      if (this.collision && this.__parent && this.__parent.collision === void 0) {
        this.__parent.collision = 2;
      }
    }
    get scaleX() {
      return this.__core.scaleX;
    }
    set scaleX(v) {
      this.__core.scaleX = v;
    }
    get scaleY() {
      return this.__core.scaleY;
    }
    set scaleY(v) {
      this.__core.scaleY = v;
    }
    get scale() {
      return this.__core.scale;
    }
    set scale(v) {
      this.__core.scale = v;
    }
    get pivotX() {
      return this.__core.pivotX;
    }
    set pivotX(v) {
      this.__core.pivotX = v;
    }
    get pivotY() {
      return this.__core.pivotY;
    }
    set pivotY(v) {
      this.__core.pivotY = v;
    }
    get pivot() {
      return this.__core.pivot;
    }
    set pivot(v) {
      this.__core.pivot = v;
    }
    get mountX() {
      return this.__core.mountX;
    }
    set mountX(v) {
      this.__core.mountX = v;
    }
    get mountY() {
      return this.__core.mountY;
    }
    set mountY(v) {
      this.__core.mountY = v;
    }
    get mount() {
      return this.__core.mount;
    }
    set mount(v) {
      this.__core.mount = v;
    }
    get rotation() {
      return this.__core.rotation;
    }
    set rotation(v) {
      this.__core.rotation = v;
    }
    get alpha() {
      return this.__core.alpha;
    }
    set alpha(v) {
      this.__core.alpha = v;
    }
    get visible() {
      return this.__core.visible;
    }
    set visible(v) {
      this.__core.visible = v;
    }
    get colorUl() {
      return this.__core.colorUl;
    }
    set colorUl(v) {
      this.__core.colorUl = v;
    }
    get colorUr() {
      return this.__core.colorUr;
    }
    set colorUr(v) {
      this.__core.colorUr = v;
    }
    get colorBl() {
      return this.__core.colorBl;
    }
    set colorBl(v) {
      this.__core.colorBl = v;
    }
    get colorBr() {
      return this.__core.colorBr;
    }
    set colorBr(v) {
      this.__core.colorBr = v;
    }
    get color() {
      return this.__core.colorUl;
    }
    set color(v) {
      if (this.colorUl !== v || this.colorUr !== v || this.colorBl !== v || this.colorBr !== v) {
        this.colorUl = v;
        this.colorUr = v;
        this.colorBl = v;
        this.colorBr = v;
      }
    }
    get colorTop() {
      return this.colorUl;
    }
    set colorTop(v) {
      if (this.colorUl !== v || this.colorUr !== v) {
        this.colorUl = v;
        this.colorUr = v;
      }
    }
    get colorBottom() {
      return this.colorBl;
    }
    set colorBottom(v) {
      if (this.colorBl !== v || this.colorBr !== v) {
        this.colorBl = v;
        this.colorBr = v;
      }
    }
    get colorLeft() {
      return this.colorUl;
    }
    set colorLeft(v) {
      if (this.colorUl !== v || this.colorBl !== v) {
        this.colorUl = v;
        this.colorBl = v;
      }
    }
    get colorRight() {
      return this.colorUr;
    }
    set colorRight(v) {
      if (this.colorUr !== v || this.colorBr !== v) {
        this.colorUr = v;
        this.colorBr = v;
      }
    }
    get zIndex() {
      return this.__core.zIndex;
    }
    set zIndex(v) {
      this.__core.zIndex = v;
    }
    get forceZIndexContext() {
      return this.__core.forceZIndexContext;
    }
    set forceZIndexContext(v) {
      this.__core.forceZIndexContext = v;
    }
    get clipping() {
      return this.__core.clipping;
    }
    set clipping(v) {
      this.__core.clipping = v;
    }
    get clipbox() {
      return this.__core.clipbox;
    }
    set clipbox(v) {
      this.__core.clipbox = v;
    }
    get tags() {
      return this.getTags();
    }
    set tags(v) {
      if (!Array.isArray(v)) v = [v];
      this.setTags(v);
    }
    set t(v) {
      this.tags = v;
    }
    get _children() {
      if (!this.__childList) {
        this.__childList = new ElementChildList(this, false);
      }
      return this.__childList;
    }
    get childList() {
      if (!this._allowChildrenAccess()) {
        this._throwError("Direct access to children is not allowed in " + this.getLocationString());
      }
      return this._children;
    }
    hasChildren() {
      return this._allowChildrenAccess() && this.__childList && this.__childList.length > 0;
    }
    _allowChildrenAccess() {
      return true;
    }
    get children() {
      return this.childList.get();
    }
    set children(children) {
      this.childList.patch(children);
    }
    add(o) {
      return this.childList.a(o);
    }
    get p() {
      return this.__parent;
    }
    get parent() {
      return this.__parent;
    }
    get src() {
      if (this.texture && this.texture instanceof ImageTexture) {
        return this.texture._src;
      } else {
        return void 0;
      }
    }
    set src(v) {
      const texture = new ImageTexture(this.stage);
      texture.src = v;
      this.texture = texture;
    }
    set mw(v) {
      if (this.texture) {
        this.texture.mw = v;
        this._updateDimensions();
      } else {
        this._throwError("Please set mw after setting a texture.");
      }
    }
    set mh(v) {
      if (this.texture) {
        this.texture.mh = v;
        this._updateDimensions();
      } else {
        this._throwError("Please set mh after setting a texture.");
      }
    }
    get rect() {
      return this.texture === this.stage.rectangleTexture;
    }
    set rect(v) {
      if (v) {
        this.texture = this.stage.rectangleTexture;
      } else {
        this.texture = null;
      }
    }
    enableTextTexture() {
      if (!this.texture || !(this.texture instanceof TextTexture)) {
        this.texture = new TextTexture(this.stage);
        if (!this.texture.w && !this.texture.h) {
          this.texture.w = this.w;
          this.texture.h = this.h;
        }
      }
      return this.texture;
    }
    get text() {
      if (this.texture && this.texture instanceof TextTexture) {
        return this.texture;
      } else {
        return null;
      }
    }
    set text(v) {
      if (!this.texture || !(this.texture instanceof TextTexture)) {
        this.enableTextTexture();
      }
      if (Utils.isString(v)) {
        this.texture.text = v;
      } else {
        this.texture.patch(v);
      }
    }
    set onUpdate(f) {
      this.__core.onUpdate = f;
    }
    set onAfterCalcs(f) {
      this.__core.onAfterCalcs = f;
    }
    set onAfterUpdate(f) {
      this.__core.onAfterUpdate = f;
    }
    forceUpdate() {
      this.__core._setHasUpdates();
    }
    get shader() {
      return this.__core.shader;
    }
    set shader(v) {
      if (Utils.isObjectLiteral(v) && !v.type) {
        if (this.shader) {
          this.shader.patch(v);
        }
      } else {
        const shader = Shader.create(this.stage, v);
        if (this.__enabled && this.__core.shader) {
          this.__core.shader.removeElement(this.__core);
        }
        this.__core.shader = shader;
        if (this.__enabled && this.__core.shader) {
          this.__core.shader.addElement(this.__core);
        }
      }
    }
    _hasTexturizer() {
      return !!this.__core._texturizer;
    }
    get renderToTexture() {
      return this.rtt;
    }
    set renderToTexture(v) {
      this.rtt = v;
    }
    get rtt() {
      return this._hasTexturizer() && this.texturizer.enabled;
    }
    set rtt(v) {
      this.texturizer.enabled = v;
    }
    get rttLazy() {
      return this._hasTexturizer() && this.texturizer.lazy;
    }
    set rttLazy(v) {
      this.texturizer.lazy = v;
    }
    get renderOffscreen() {
      return this._hasTexturizer() && this.texturizer.renderOffscreen;
    }
    set renderOffscreen(v) {
      this.texturizer.renderOffscreen = v;
    }
    get colorizeResultTexture() {
      return this._hasTexturizer() && this.texturizer.colorize;
    }
    set colorizeResultTexture(v) {
      this.texturizer.colorize = v;
    }
    getTexture() {
      return this.texturizer._getTextureSource();
    }
    get texturizer() {
      return this.__core.texturizer;
    }
    patch(settings2) {
      let paths = Object.keys(settings2);
      for (let i = 0, n = paths.length; i < n; i++) {
        let path = paths[i];
        const v = settings2[path];
        const firstCharCode = path.charCodeAt(0);
        if (Utils.isUcChar(firstCharCode)) {
          const child = this.getByRef(path);
          if (!child) {
            if (v !== void 0) {
              let c;
              if (Utils.isObjectLiteral(v)) {
                c = this.childList.createItem(v);
                c.patch(v);
              } else if (Utils.isObject(v)) {
                c = v;
              }
              if (c.isElement) {
                c.ref = path;
              }
              this.childList.a(c);
            }
          } else {
            if (v === void 0) {
              if (child.parent) {
                child.parent.childList.remove(child);
              }
            } else if (Utils.isObjectLiteral(v)) {
              child.patch(v);
            } else if (v.isElement) {
              v.ref = path;
              this.childList.replace(v, child);
            } else {
              this._throwError("Unexpected value for path: " + path);
            }
          }
        } else {
          Base.patchObjectProperty(this, path, v);
        }
      }
    }
    _throwError(message) {
      throw new Error(this.constructor.name + " (" + this.getLocationString() + "): " + message);
    }
    animation(settings2) {
      return this.stage.animations.createAnimation(this, settings2);
    }
    transition(property, settings2 = null) {
      if (settings2 === null) {
        return this._getTransition(property);
      } else {
        this._setTransition(property, settings2);
        return null;
      }
    }
    set transitions(object) {
      let keys = Object.keys(object);
      keys.forEach((property) => {
        this.transition(property, object[property]);
      });
    }
    set smooth(object) {
      let keys = Object.keys(object);
      keys.forEach((property) => {
        let value = object[property];
        if (Array.isArray(value)) {
          this.setSmooth(property, value[0], value[1]);
        } else {
          this.setSmooth(property, value);
        }
      });
    }
    fastForward(property) {
      if (this._transitions) {
        let t = this._transitions[property];
        if (t && t.isTransition) {
          t.finish();
        }
      }
    }
    _getTransition(property) {
      if (!this._transitions) {
        this._transitions = {};
      }
      let t = this._transitions[property];
      if (!t) {
        t = new Transition(this.stage.transitions, this.stage.transitions.defaultTransitionSettings, this, property);
      } else if (t.isTransitionSettings) {
        t = new Transition(
          this.stage.transitions,
          t,
          this,
          property
        );
      }
      this._transitions[property] = t;
      return t;
    }
    _setTransition(property, settings2) {
      if (!settings2) {
        this._removeTransition(property);
      } else {
        if (Utils.isObjectLiteral(settings2)) {
          settings2 = this.stage.transitions.createSettings(settings2);
        }
        if (!this._transitions) {
          this._transitions = {};
        }
        let current = this._transitions[property];
        if (current && current.isTransition) {
          current.settings = settings2;
          return current;
        } else {
          this._transitions[property] = settings2;
        }
      }
    }
    _removeTransition(property) {
      if (this._transitions) {
        delete this._transitions[property];
      }
    }
    getSmooth(property, v) {
      let t = this._getTransition(property);
      if (t && t.isAttached()) {
        return t.targetValue;
      } else {
        return v;
      }
    }
    setSmooth(property, v, settings2) {
      if (settings2) {
        this._setTransition(property, settings2);
      }
      let t = this._getTransition(property);
      t.start(v);
      return t;
    }
    get flex() {
      return this.__core.flex;
    }
    set flex(v) {
      this.__core.flex = v;
    }
    get flexItem() {
      return this.__core.flexItem;
    }
    set flexItem(v) {
      this.__core.flexItem = v;
    }
    static isColorProperty(property) {
      return property.toLowerCase().indexOf("color") >= 0;
    }
    static getMerger(property) {
      if (_Element.isColorProperty(property)) {
        return StageUtils.mergeColors;
      } else {
        return StageUtils.mergeNumbers;
      }
    }
    toJSON() {
      const ref = [`${this.constructor.name}`];
      const tree = {};
      tree[ref] = {};
      if (this.hasChildren()) {
        _Element.collectChildren(tree[ref], this.__childList);
      } else {
        tree[ref] = __spreadValues({}, _Element.getProperties(this));
      }
      return tree;
    }
    static collectChildren(tree, children) {
      const childList = children;
      for (let i = 0, j = childList.length; i < j; i++) {
        const element = childList.getAt(i);
        const ref = `${element.__ref || `Element-${element.id}`}`;
        const properties = this.getProperties(element);
        tree[ref] = __spreadValues({}, properties);
        if (element.hasChildren()) {
          tree[ref].children = {};
          this.collectChildren(
            tree[ref].children,
            element.__childList
          );
        }
      }
    }
    static getProperties(element) {
      const props = {};
      const list = [
        "alpha",
        "active",
        "attached",
        "boundsMargin",
        "color",
        "clipping",
        "enabled",
        "h",
        "id",
        "isComponent",
        "mount",
        "mountY",
        "mountX",
        "pivot",
        "pivotX",
        "pivotY",
        "ref",
        "renderOffscreen",
        "renderToTexture",
        "scale",
        "scaleX",
        "scaleY",
        "state",
        "tag",
        "visible",
        "w",
        "x",
        "y",
        "zIndex",
        "!!flex",
        "!!flexItem",
        "hasFocus()",
        "hasFinalFocus()"
      ];
      let n = list.length;
      while (n--) {
        let key = list[n];
        const getBoolean = /^!{2}/;
        const isFunction3 = /\(\)$/;
        if (getBoolean.test(key)) {
          key = key.substring(2, key.length);
          props[key] = !!element[key];
        } else if (isFunction3.test(key)) {
          key = key.substring(0, key.length - 2);
          if (typeof element[key] === "function") {
            props[key] = element[key]();
          }
        } else {
          props[key] = element[key];
        }
      }
      return __spreadValues(__spreadValues({}, props), element.getNonDefaults());
    }
  };
  EventEmitter.addAsMixin(Element);
  Element.prototype.isElement = 1;
  Element.id = 1;
  Element.PROP_GETTERS = /* @__PURE__ */ new Map();
  Element.PROP_SETTERS = /* @__PURE__ */ new Map();

  // node_modules/@lightningjs/core/dist/src/application/StateMachine.mjs
  var StateMachine = class _StateMachine {
    constructor() {
      _StateMachine.setupStateMachine(this);
    }
    static setupStateMachine(target) {
      const targetConstructor = target.constructor;
      const router = _StateMachine.create(targetConstructor);
      Object.setPrototypeOf(target, router.prototype);
      target.constructor = targetConstructor;
      target._initStateMachine();
    }
    /**
     * Creates a state machine implementation.
     * It extends the original type and should be used when creating new instances.
     * The original type is available as static property 'original', and it must be used when subclassing as follows:
     * const type = StateMachine.create(class YourNewStateMachineClass extends YourBaseStateMachineClass.original {  })
     * @param {Class} type
     * @returns {StateMachine}
     */
    static create(type) {
      if (!type.hasOwnProperty("_sm")) {
        const stateMachineType = new StateMachineType(type);
        type._sm = stateMachineType;
      }
      return type._sm.router;
    }
    /**
     * Calls the specified method if it exists.
     * @param {string} event
     * @param {*...} args
     */
    fire(event, ...args) {
      if (this._hasMethod(event)) {
        return this[event](...args);
      }
    }
    /**
     * Returns the current state path (for example "Initialized.Loading").
     * @returns {string}
     * @protected
     */
    _getState() {
      return this._state.__path;
    }
    /**
     * Returns true iff statePath is (an ancestor of) currentStatePath.
     * @param {string} statePath
     * @param {string} currentStatePath
     * @returns {Boolean}
     * @protected
     */
    _inState(statePath, currentStatePath = this._state.__path) {
      const state3 = this._sm.getStateByPath(statePath);
      const currentState = this._sm.getStateByPath(currentStatePath);
      const level = state3.__level;
      const stateAtLevel = _StateMachine._getStateAtLevel(currentState, level);
      return stateAtLevel === state3;
    }
    /**
     * Returns true if the specified class member is defined for the currently set state.
     * @param {string} name
     * @returns {boolean}
     * @protected
     */
    _hasMember(name) {
      return !!this.constructor.prototype[name];
    }
    /**
     * Returns true if the specified class member is a method for the currently set state.
     * @param {string} name
     * @returns {boolean}
     * @protected
     */
    _hasMethod(name) {
      const member = this.constructor.prototype[name];
      return !!member && typeof member === "function";
    }
    /**
     * Switches to the specified state.
     * @param {string} statePath
     *   Substates are seperated by a underscores (for example "Initialized.Loading").
     * @param {*[]} [args]
     *   Args that are supplied in $enter and $exit events.
     * @protected
     */
    _setState(statePath, args) {
      const setStateId = ++this._setStateCounter;
      this._setStateId = setStateId;
      if (this._state.__path !== statePath) {
        let newState = this._sm._stateMap[statePath];
        if (!newState) {
          newState = this._sm.getStateByPath(statePath);
        }
        const prevState = this._state;
        const hasDifferentEnterMethod = newState.prototype.$enter !== this._state.prototype.$enter;
        const hasDifferentExitMethod = newState.prototype.$exit !== this._state.prototype.$exit;
        if (hasDifferentEnterMethod || hasDifferentExitMethod) {
          const sharedState = _StateMachine._getSharedState(this._state, newState);
          const context2 = {
            newState: newState.__path,
            prevState: prevState.__path,
            sharedState: sharedState.__path
          };
          const sharedLevel = sharedState.__level;
          if (hasDifferentExitMethod) {
            const exitStates = _StateMachine._getStatesUntilLevel(this._state, sharedLevel);
            for (let i = 0, n = exitStates.length; i < n; i++) {
              this.__setState(exitStates[i]);
              this._callExit(this._state, args, context2);
              const stateChangeOverridden = this._setStateId !== setStateId;
              if (stateChangeOverridden) {
                return;
              }
            }
          }
          if (hasDifferentEnterMethod) {
            const enterStates = _StateMachine._getStatesUntilLevel(newState, sharedLevel).reverse();
            for (let i = 0, n = enterStates.length; i < n; i++) {
              this.__setState(enterStates[i]);
              this._callEnter(this._state, args, context2);
              const stateChangeOverridden = this._setStateId !== setStateId;
              if (stateChangeOverridden) {
                return;
              }
            }
          }
        }
        this.__setState(newState);
        if (this._changedState) {
          const context2 = {
            newState: newState.__path,
            prevState: prevState.__path
          };
          if (args) {
            this._changedState(context2, ...args);
          } else {
            this._changedState(context2);
          }
        }
        if (this._onStateChange) {
          const context2 = {
            newState: newState.__path,
            prevState: prevState.__path
          };
          this._onStateChange(context2);
        }
      }
    }
    _callEnter(state3, args = [], context2) {
      const hasParent = !!state3.__parent;
      if (state3.prototype.$enter) {
        if (!hasParent || state3.__parent.prototype.$enter !== state3.prototype.$enter) {
          state3.prototype.$enter.apply(this, [context2, ...args]);
        }
      }
    }
    _callExit(state3, args = [], context2) {
      const hasParent = !!state3.__parent;
      if (state3.prototype.$exit) {
        if (!hasParent || state3.__parent.prototype.$exit !== state3.prototype.$exit) {
          state3.prototype.$exit.apply(this, [context2, ...args]);
        }
      }
    }
    __setState(state3) {
      this._state = state3;
      this._stateIndex = state3.__index;
      this.constructor = state3;
    }
    _initStateMachine() {
      this._state = null;
      this._stateIndex = 0;
      this._setStateCounter = 0;
      this._sm = this._routedType._sm;
      this.__setState(this._sm.getStateByPath(""));
      const context2 = { newState: "", prevState: void 0, sharedState: void 0 };
      this._callEnter(this._state, [], context2);
      this._onStateChange = void 0;
    }
    /**
     * Between multiple member names, select the one specified in the deepest state.
     * If multiple member names are specified in the same deepest state, the first one in the array is returned.
     * @param {string[]} memberNames
     * @returns {string|undefined}
     * @protected
     */
    _getMostSpecificHandledMember(memberNames) {
      let cur = this._state;
      do {
        for (let i = 0, n = memberNames.length; i < n; i++) {
          const memberName = memberNames[i];
          if (!cur.__parent) {
            if (cur.prototype[memberName]) {
              return memberName;
            }
          } else {
            const alias = StateMachineType.getStateMemberAlias(cur.__path, memberName);
            if (this[alias]) {
              return memberName;
            }
          }
        }
        cur = cur.__parent;
      } while (cur);
    }
    static _getStatesUntilLevel(state3, level) {
      const states = [];
      while (state3.__level > level) {
        states.push(state3);
        state3 = state3.__parent;
      }
      return states;
    }
    static _getSharedState(state1, state22) {
      const state1Array = _StateMachine._getAncestorStates(state1);
      const state2Array = _StateMachine._getAncestorStates(state22);
      const n = Math.min(state1Array.length, state2Array.length);
      for (let i = 0; i < n; i++) {
        if (state1Array[i] !== state2Array[i]) {
          return state1Array[i - 1];
        }
      }
      return state1Array[n - 1];
    }
    static _getAncestorStates(state3) {
      const result = [];
      do {
        result.push(state3);
      } while (state3 = state3.__parent);
      return result.reverse();
    }
    static _getStateAtLevel(state3, level) {
      if (level > state3.__level) {
        return void 0;
      }
      while (level < state3.__level) {
        state3 = state3.__parent;
      }
      return state3;
    }
  };
  var StateMachineType = class _StateMachineType {
    constructor(type) {
      this._type = type;
      this._router = null;
      this.init();
    }
    get router() {
      return this._router;
    }
    init() {
      this._router = this._createRouter();
      this._stateMap = this._getStateMap();
      this._addStateMemberDelegatorsToRouter();
    }
    _createRouter() {
      const type = this._type;
      const router = class StateMachineRouter extends type {
        constructor() {
          super(...arguments);
          if (!this.constructor.hasOwnProperty("_isRouter")) {
            throw new Error(`You need to extend ${type.name}.original instead of ${type.name}.`);
          }
        }
      };
      router._isRouter = true;
      router.prototype._routedType = type;
      router.original = type;
      this._mixinStateMachineMethods(router);
      return router;
    }
    _mixinStateMachineMethods(router) {
      const names = Object.getOwnPropertyNames(StateMachine.prototype);
      for (let i = 0, n = names.length; i < n; i++) {
        const name = names[i];
        if (name !== "constructor") {
          const descriptor = Object.getOwnPropertyDescriptor(StateMachine.prototype, name);
          Object.defineProperty(router.prototype, name, descriptor);
        }
      }
    }
    _addStateMemberDelegatorsToRouter() {
      const members = this._getAllMemberNames();
      members.forEach((member) => {
        this._addMemberRouter(member);
      });
    }
    /**
     * @note We are generating code because it yields much better performance.
     */
    _addMemberRouter(member) {
      const statePaths = Object.keys(this._stateMap);
      const descriptors = [];
      const aliases = [];
      statePaths.forEach((statePath, index) => {
        const state3 = this._stateMap[statePath];
        const descriptor = this._getDescriptor(state3, member);
        if (descriptor) {
          descriptors[index] = descriptor;
          const alias = _StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
          aliases[index] = alias;
          if (!this._router.prototype.hasOwnProperty(alias)) {
            Object.defineProperty(this._router.prototype, alias, descriptor);
          }
        } else {
          descriptors[index] = null;
          aliases[index] = null;
        }
      });
      let type = void 0;
      descriptors.forEach((descriptor) => {
        if (descriptor) {
          const descType = this._getDescriptorType(descriptor);
          if (type && type !== descType) {
            console.warn(`[Lightning] Member ${member} in ${this._type.name} has inconsistent types.`);
            return;
          }
          type = descType;
        }
      });
      switch (type) {
        case "method":
          this._addMethodRouter(member, descriptors, aliases);
          break;
        case "getter":
          this._addGetterSetterRouters(member);
          break;
        case "property":
          console.warn("[Lightning] Fixed properties are not supported; please use a getter instead!");
          break;
      }
    }
    _getDescriptor(state3, member, isValid = () => true) {
      let type = state3;
      let curState = state3;
      do {
        const descriptor = Object.getOwnPropertyDescriptor(type.prototype, member);
        if (descriptor) {
          if (isValid(descriptor)) {
            descriptor._source = curState;
            return descriptor;
          }
        }
        type = Object.getPrototypeOf(type);
        if (type && type.hasOwnProperty("__state")) {
          curState = type;
        }
      } while (type && type.prototype);
      return void 0;
    }
    _getDescriptorType(descriptor) {
      if (descriptor.get || descriptor.set) {
        return "getter";
      } else {
        if (typeof descriptor.value === "function") {
          return "method";
        } else {
          return "property";
        }
      }
    }
    static _supportsSpread() {
      if (this.__supportsSpread === void 0) {
        this.__supportsSpread = false;
        try {
          const func = new Function("return [].concat(...arguments);");
          func();
          this.__supportsSpread = true;
        } catch (e) {
        }
      }
      return this.__supportsSpread;
    }
    _addMethodRouter(member, descriptors, aliases) {
      const code = [
        // The line ensures that, while debugging, your IDE won't open many tabs.
        "//@ sourceURL=StateMachineRouter.js",
        "var i = this._stateIndex;"
      ];
      let cur = aliases[0];
      const supportsSpread = _StateMachineType._supportsSpread();
      for (let i = 1, n = aliases.length; i < n; i++) {
        const alias = aliases[i];
        if (alias !== cur) {
          if (cur) {
            if (supportsSpread) {
              code.push(`if (i < ${i}) return this["${cur}"](...arguments); else`);
            } else {
              code.push(`if (i < ${i}) return this["${cur}"].apply(this, arguments); else`);
            }
          } else {
            code.push(`if (i < ${i}) return ; else`);
          }
        }
        cur = alias;
      }
      if (cur) {
        if (supportsSpread) {
          code.push(`return this["${cur}"](...arguments);`);
        } else {
          code.push(`return this["${cur}"].apply(this, arguments);`);
        }
      } else {
        code.push(`;`);
      }
      const functionBody = code.join("\n");
      const router = new Function([], functionBody);
      const descriptor = { value: router };
      Object.defineProperty(this._router.prototype, member, descriptor);
    }
    _addGetterSetterRouters(member) {
      const getter = this._getGetterRouter(member);
      const setter = this._getSetterRouter(member);
      const descriptor = {
        get: getter,
        set: setter
      };
      Object.defineProperty(this._router.prototype, member, descriptor);
    }
    _getGetterRouter(member) {
      const statePaths = Object.keys(this._stateMap);
      const descriptors = [];
      const aliases = [];
      statePaths.forEach((statePath, index) => {
        const state3 = this._stateMap[statePath];
        const descriptor = this._getDescriptor(state3, member, ((descriptor2) => descriptor2.get));
        if (descriptor) {
          descriptors[index] = descriptor;
          const alias = _StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
          aliases[index] = alias;
          if (!this._router.prototype.hasOwnProperty(alias)) {
            Object.defineProperty(this._router.prototype, alias, descriptor);
          }
        } else {
          descriptors[index] = null;
          aliases[index] = null;
        }
      });
      const code = [
        // The line ensures that, while debugging, your IDE won't open many tabs.
        "//@ sourceURL=StateMachineRouter.js",
        "var i = this._stateIndex;"
      ];
      let cur = aliases[0];
      for (let i = 1, n = aliases.length; i < n; i++) {
        const alias = aliases[i];
        if (alias !== cur) {
          if (cur) {
            code.push(`if (i < ${i}) return this["${cur}"]; else`);
          } else {
            code.push(`if (i < ${i}) return ; else`);
          }
        }
        cur = alias;
      }
      if (cur) {
        code.push(`return this["${cur}"];`);
      } else {
        code.push(`;`);
      }
      const functionBody = code.join("\n");
      const router = new Function([], functionBody);
      return router;
    }
    _getSetterRouter(member) {
      const statePaths = Object.keys(this._stateMap);
      const descriptors = [];
      const aliases = [];
      statePaths.forEach((statePath, index) => {
        const state3 = this._stateMap[statePath];
        const descriptor = this._getDescriptor(state3, member, ((descriptor2) => descriptor2.set));
        if (descriptor) {
          descriptors[index] = descriptor;
          const alias = _StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
          aliases[index] = alias;
          if (!this._router.prototype.hasOwnProperty(alias)) {
            Object.defineProperty(this._router.prototype, alias, descriptor);
          }
        } else {
          descriptors[index] = null;
          aliases[index] = null;
        }
      });
      const code = [
        // The line ensures that, while debugging, your IDE won't open many tabs.
        "//@ sourceURL=StateMachineRouter.js",
        "var i = this._stateIndex;"
      ];
      let cur = aliases[0];
      for (let i = 1, n = aliases.length; i < n; i++) {
        const alias = aliases[i];
        if (alias !== cur) {
          if (cur) {
            code.push(`if (i < ${i}) this["${cur}"] = arg; else`);
          } else {
            code.push(`if (i < ${i}) ; else`);
          }
        }
        cur = alias;
      }
      if (cur) {
        code.push(`this["${cur}"] = arg;`);
      } else {
        code.push(`;`);
      }
      const functionBody = code.join("\n");
      const router = new Function(["arg"], functionBody);
      return router;
    }
    static getStateMemberAlias(path, member) {
      return "$" + (path ? path + "." : "") + member;
    }
    _getAllMemberNames() {
      const stateMap = this._stateMap;
      const map = Object.keys(stateMap);
      let members = /* @__PURE__ */ new Set();
      map.forEach((statePath) => {
        if (statePath === "") {
          return;
        }
        const state3 = stateMap[statePath];
        const names = this._getStateMemberNames(state3);
        names.forEach((name) => {
          members.add(name);
        });
      });
      return [...members];
    }
    _getStateMemberNames(state3) {
      let type = state3;
      let members = /* @__PURE__ */ new Set();
      const isRoot = this._type === state3;
      do {
        const names = this._getStateMemberNamesForType(type);
        names.forEach((name) => {
          members.add(name);
        });
        type = Object.getPrototypeOf(type);
      } while (type && type.prototype && (!type.hasOwnProperty("__state") || isRoot));
      return members;
    }
    _getStateMemberNamesForType(type) {
      const memberNames = Object.getOwnPropertyNames(type.prototype);
      return memberNames.filter((memberName) => {
        return memberName !== "constructor" && !_StateMachineType._isStateLocalMember(memberName);
      });
    }
    static _isStateLocalMember(memberName) {
      return memberName === "$enter" || memberName === "$exit";
    }
    getStateByPath(statePath) {
      if (this._stateMap[statePath]) {
        return this._stateMap[statePath];
      }
      const parts = statePath.split(".");
      while (parts.pop()) {
        const statePath2 = parts.join(".");
        if (this._stateMap[statePath2]) {
          return this._stateMap[statePath2];
        }
      }
    }
    _getStateMap() {
      if (!this._stateMap) {
        this._stateMap = this._createStateMap();
      }
      return this._stateMap;
    }
    _createStateMap() {
      const stateMap = {};
      this._addState(this._type, null, "", stateMap);
      return stateMap;
    }
    _addState(state3, parentState, name, stateMap) {
      state3.__state = true;
      state3.__name = name;
      this._addStaticStateProperty(state3, parentState);
      const parentPath = parentState ? parentState.__path : "";
      let path = (parentPath ? parentPath + "." : "") + name;
      state3.__path = path;
      state3.__level = parentState ? parentState.__level + 1 : 0;
      state3.__parent = parentState;
      state3.__index = Object.keys(stateMap).length;
      stateMap[path] = state3;
      const states = state3._states;
      if (states) {
        const isInheritedFromParent = parentState && parentState._states === states;
        if (!isInheritedFromParent) {
          const subStates = state3._states();
          subStates.forEach((subState) => {
            const stateName = _StateMachineType._getStateName(subState);
            this._addState(subState, state3, stateName, stateMap);
          });
        }
      }
    }
    static _getStateName(state3) {
      const name = state3.name;
      const index = name.indexOf("$");
      if (index > 0) {
        return name.substr(0, index);
      }
      return name;
    }
    _addStaticStateProperty(state3, parentState) {
      if (parentState) {
        const isClassStateLevel = parentState && !parentState.__parent;
        if (isClassStateLevel) {
          this._router[state3.__name] = state3;
        } else {
          parentState[state3.__name] = state3;
        }
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/application/Component.mjs
  var Component = class _Component extends Element {
    constructor(stage2, properties) {
      super(stage2);
      this.tagRoot = true;
      if (Utils.isObjectLiteral(properties)) {
        Object.assign(this, properties);
      }
      this.__initialized = false;
      this.__firstActive = false;
      this.__firstEnable = false;
      this.__signals = void 0;
      this.__passSignals = void 0;
      this.__construct();
      const func = this.constructor.getTemplateFunc(this);
      func.f(this, func.a);
      this._build();
    }
    __start() {
      StateMachine.setupStateMachine(this);
      this._onStateChange = _Component.prototype.__onStateChange;
    }
    get state() {
      return this._getState();
    }
    __onStateChange() {
      if (this.application) {
        this.application.updateFocusPath();
      }
    }
    _refocus() {
      if (this.application) {
        this.application.updateFocusPath();
      }
    }
    static bindProp(name, func = null) {
      return { __propertyBinding: true, __name: name, __func: func };
    }
    __bindProperty(propObj, targetObj, targetProp) {
      const obj = targetObj;
      const prop = targetProp;
      const propDependencies = Array.isArray(propObj.__name) ? propObj.__name : [propObj.__name];
      for (let i = 0; i < propDependencies.length; i++) {
        const propName = propDependencies[i];
        const func = propObj.__func ? propObj.__func : (context2) => context2[propName];
        if (!this.hasOwnProperty(propName)) {
          this[`__prop_bindings_${propName}`] = [{ __obj: obj, __prop: prop, __func: func }];
          Object.defineProperty(this, propName, {
            set: (value) => {
              this[`__prop_${propName}`] = value;
              for (const { __obj, __prop, __func } of this[`__prop_bindings_${propName}`]) {
                __obj[__prop] = __func(this);
              }
            },
            get: () => this[`__prop_${propName}`]
          });
        } else {
          this[`__prop_bindings_${propName}`].push({ __obj: obj, __prop: prop, __func: func });
        }
      }
    }
    /**
     * Returns a high-performance template patcher.
     */
    static getTemplateFunc(ctx) {
      const name = "_templateFunc";
      const hasName = "__has" + name;
      if (this[hasName] !== this) {
        this[hasName] = this;
        this[name] = this.parseTemplate(this._template(ctx));
      }
      return this[name];
    }
    static parseTemplate(obj) {
      const context2 = {
        loc: [],
        store: [],
        rid: 0
      };
      this.parseTemplateRec(obj, context2, "element");
      const code = context2.loc.join(";\n");
      const f = new Function("element", "store", code);
      return { f, a: context2.store };
    }
    static parseTemplateRec(obj, context2, cursor) {
      const store = context2.store;
      const loc = context2.loc;
      const keys = Object.keys(obj);
      keys.forEach((key) => {
        let value = obj[key];
        if (Utils.isUcChar(key.charCodeAt(0))) {
          if (Utils.isObjectLiteral(value)) {
            const childCursor = `r${key.replace(/[^a-z0-9]/gi, "") + context2.rid}`;
            let type = value.type ? value.type : Element;
            if (type === Element) {
              loc.push(`var ${childCursor} = element.stage.createElement()`);
            } else {
              store.push(type);
              loc.push(`var ${childCursor} = new store[${store.length - 1}](${cursor}.stage)`);
            }
            loc.push(`${childCursor}.ref = "${key}"`);
            context2.rid++;
            this.parseTemplateRec(value, context2, childCursor);
            loc.push(`${cursor}.childList.add(${childCursor})`);
          } else if (Utils.isObject(value)) {
            store.push(value);
            loc.push(`${cursor}.childList.add(store[${store.length - 1}])`);
          }
        } else {
          if (key === "text") {
            const propKey = cursor + "__text";
            loc.push(`var ${propKey} = ${cursor}.enableTextTexture()`);
            if (value.__propertyBinding === true) {
              store.push(value);
              loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
            } else {
              this.parseTemplatePropRec(value, context2, propKey);
            }
          } else if (key === "shader" && Utils.isObjectLiteral(value)) {
            const shaderCursor = `${cursor}["shader"]`;
            store.push(value);
            loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
            this.parsePropertyBindings(value, context2, shaderCursor);
          } else if (key === "texture" && Utils.isObjectLiteral(value)) {
            const propKey = cursor + "__texture";
            const type = value.type;
            if (type) {
              store.push(type);
              loc.push(`var ${propKey} = new store[${store.length - 1}](${cursor}.stage)`);
              this.parseTemplatePropRec(value, context2, propKey);
              loc.push(`${cursor}["${key}"] = ${propKey}`);
            } else {
              loc.push(`${propKey} = ${cursor}.texture`);
              this.parseTemplatePropRec(value, context2, propKey);
            }
          } else if (Utils.isObjectLiteral(value) && value.__propertyBinding === true) {
            store.push(value);
            loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
          } else {
            if (Utils.isNumber(value)) {
              loc.push(`${cursor}["${key}"] = ${value}`);
            } else if (Utils.isBoolean(value)) {
              loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
            } else if (Utils.isObject(value) || Array.isArray(value)) {
              store.push(value);
              loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
            } else {
              loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
            }
          }
        }
      });
    }
    static parseTemplatePropRec(obj, context2, cursor) {
      const store = context2.store;
      const loc = context2.loc;
      const keys = Object.keys(obj);
      keys.forEach((key) => {
        if (key !== "type") {
          const value = obj[key];
          if (Utils.isNumber(value)) {
            loc.push(`${cursor}["${key}"] = ${value}`);
          } else if (Utils.isBoolean(value)) {
            loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
          } else if (Utils.isObject(value) && value.__propertyBinding === true) {
            store.push(value);
            loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
          } else if (Utils.isObject(value) || Array.isArray(value)) {
            store.push(value);
            loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
          } else {
            loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
          }
        }
      });
    }
    static parsePropertyBindings(obj, context2, cursor) {
      const store = context2.store;
      const loc = context2.loc;
      const keys = Object.keys(obj);
      keys.forEach((key) => {
        if (key !== "type") {
          const value = obj[key];
          if (Utils.isObjectLiteral(value) && value.__propertyBinding === true) {
            store.push(value);
            loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
          }
        }
      });
    }
    _onSetup() {
      if (!this.__initialized) {
        this._setup();
      }
    }
    _setup() {
    }
    _onAttach() {
      if (!this.__initialized) {
        this.__init();
        this.__initialized = true;
      }
      this._attach();
    }
    _attach() {
    }
    _onDetach() {
      this._detach();
    }
    _detach() {
    }
    _onEnabled() {
      if (!this.__firstEnable) {
        this._firstEnable();
        this.__firstEnable = true;
      }
      this._enable();
    }
    _firstEnable() {
    }
    _enable() {
    }
    _onDisabled() {
      this._disable();
    }
    _disable() {
    }
    _onActive() {
      if (!this.__firstActive) {
        this._firstActive();
        this.__firstActive = true;
      }
      this._active();
    }
    _firstActive() {
    }
    _active() {
    }
    _onInactive() {
      this._inactive();
    }
    _inactive() {
    }
    get application() {
      return this.stage.application;
    }
    __construct() {
      this._construct();
    }
    _construct() {
    }
    _build() {
    }
    __init() {
      this._init();
    }
    _init() {
    }
    _focus(newTarget, prevTarget) {
    }
    _unfocus(newTarget) {
    }
    _focusChange(target, newTarget) {
    }
    _getFocused() {
      return this;
    }
    _setFocusSettings(settings2) {
    }
    _handleFocusSettings(settings2) {
    }
    static _template() {
      return {};
    }
    hasFinalFocus() {
      let path = this.application._focusPath;
      return path && path.length && path[path.length - 1] === this;
    }
    hasFocus() {
      let path = this.application._focusPath;
      return path && path.indexOf(this) >= 0;
    }
    get cparent() {
      return _Component.getParent(this);
    }
    seekAncestorByType(type) {
      let c = this.cparent;
      while (c) {
        if (c.constructor === type) {
          return c;
        }
        c = c.cparent;
      }
    }
    getSharedAncestorComponent(element) {
      let ancestor = this.getSharedAncestor(element);
      while (ancestor && !ancestor.isComponent) {
        ancestor = ancestor.parent;
      }
      return ancestor;
    }
    get signals() {
      return this.__signals;
    }
    set signals(v) {
      if (!Utils.isObjectLiteral(v)) {
        this._throwError("Signals: specify an object with signal-to-fire mappings");
      }
      this.__signals = v;
    }
    set alterSignals(v) {
      if (!Utils.isObjectLiteral(v)) {
        this._throwError("Signals: specify an object with signal-to-fire mappings");
      }
      if (!this.__signals) {
        this.__signals = {};
      }
      for (let key in v) {
        const d = v[key];
        if (d === void 0) {
          delete this.__signals[key];
        } else {
          this.__signals[key] = v;
        }
      }
    }
    get passSignals() {
      return this.__passSignals || {};
    }
    set passSignals(v) {
      this.__passSignals = Object.assign(this.__passSignals || {}, v);
    }
    set alterPassSignals(v) {
      if (!Utils.isObjectLiteral(v)) {
        this._throwError("Signals: specify an object with signal-to-fire mappings");
      }
      if (!this.__passSignals) {
        this.__passSignals = {};
      }
      for (let key in v) {
        const d = v[key];
        if (d === void 0) {
          delete this.__passSignals[key];
        } else {
          this.__passSignals[key] = v;
        }
      }
    }
    /**
     * Signals the parent of the specified event.
     * A parent/ancestor that wishes to handle the signal should set the 'signals' property on this component.
     * @param {string} event
     * @param {...*} args
     */
    signal(event, ...args) {
      return this._signal(event, args);
    }
    _signal(event, args) {
      const signalParent = this._getParentSignalHandler();
      if (signalParent) {
        if (this.__signals) {
          let fireEvent = this.__signals[event];
          if (fireEvent === false) {
            return;
          }
          if (fireEvent) {
            if (fireEvent === true) {
              fireEvent = event;
            }
            if (Utils.isFunction(fireEvent)) {
              return fireEvent(...args);
            }
            if (signalParent._hasMethod(fireEvent)) {
              return signalParent[fireEvent](...args);
            }
          }
        }
        let passSignal = this.__passSignals && this.__passSignals[event];
        if (passSignal) {
          if (passSignal && passSignal !== true) {
            event = passSignal;
          }
          return signalParent._signal(event, args);
        }
      }
    }
    _getParentSignalHandler() {
      return this.cparent ? this.cparent._getSignalHandler() : null;
    }
    _getSignalHandler() {
      if (this._signalProxy) {
        return this.cparent ? this.cparent._getSignalHandler() : null;
      }
      return this;
    }
    get _signalProxy() {
      return false;
    }
    fireAncestors(name, ...args) {
      if (!name.startsWith("$")) {
        throw new Error("Ancestor event name must be prefixed by dollar sign.");
      }
      const parent = this._getParentSignalHandler();
      if (parent) {
        return parent._doFireAncestors(name, args);
      }
    }
    _doFireAncestors(name, args) {
      if (this._hasMethod(name)) {
        return this.fire(name, ...args);
      } else {
        const signalParent = this._getParentSignalHandler();
        if (signalParent) {
          return signalParent._doFireAncestors(name, args);
        }
      }
    }
    static collectSubComponents(subs, element) {
      if (element.hasChildren()) {
        const childList = element.__childList;
        for (let i = 0, n = childList.length; i < n; i++) {
          const child = childList.getAt(i);
          if (child.isComponent) {
            subs.push(child);
          } else {
            _Component.collectSubComponents(subs, child);
          }
        }
      }
    }
    static getComponent(element) {
      let parent = element;
      while (parent && !parent.isComponent) {
        parent = parent.parent;
      }
      return parent;
    }
    static getParent(element) {
      return _Component.getComponent(element.parent);
    }
  };
  Component.prototype.isComponent = true;

  // node_modules/@lightningjs/core/dist/src/tree/core/CoreQuadList.mjs
  var CoreQuadList = class {
    constructor(ctx) {
      this.ctx = ctx;
      this.quadTextures = [];
      this.quadElements = [];
    }
    get length() {
      return this.quadTextures.length;
    }
    reset() {
      this.quadTextures = [];
      this.quadElements = [];
      this.dataLength = 0;
    }
    getElement(index) {
      return this.quadElements[index]._element;
    }
    getElementCore(index) {
      return this.quadElements[index];
    }
    getTexture(index) {
      return this.quadTextures[index];
    }
    getTextureWidth(index) {
      let nativeTexture = this.quadTextures[index];
      if (nativeTexture.w) {
        return nativeTexture.w;
      } else {
        return this.quadElements[index]._displayedTextureSource.w;
      }
    }
    getTextureHeight(index) {
      let nativeTexture = this.quadTextures[index];
      if (nativeTexture.h) {
        return nativeTexture.h;
      } else {
        return this.quadElements[index]._displayedTextureSource.h;
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/WebGLCoreQuadList.mjs
  var WebGLCoreQuadList = class extends CoreQuadList {
    constructor(ctx) {
      super(ctx);
      const byteSize = ctx.stage.getOption("bufferMemory");
      this.dataLength = 0;
      this.data = new ArrayBuffer(byteSize);
      this.floats = new Float32Array(this.data);
      this.uints = new Uint32Array(this.data);
    }
    getAttribsDataByteOffset(index) {
      return index * 80;
    }
    getQuadContents() {
      let floats = this.floats;
      let uints = this.uints;
      let lines = [];
      for (let i = 1; i <= this.length; i++) {
        let str = "entry " + i + ": ";
        for (let j = 0; j < 4; j++) {
          let b = i * 20 + j * 4;
          str += floats[b] + "," + floats[b + 1] + ":" + floats[b + 2] + "," + floats[b + 3] + "[" + uints[b + 4].toString(16) + "] ";
        }
        lines.push(str);
      }
      return lines;
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/core/CoreQuadOperation.mjs
  var CoreQuadOperation = class {
    constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
      this.ctx = ctx;
      this.shader = shader;
      this.shaderOwner = shaderOwner;
      this.renderTextureInfo = renderTextureInfo;
      this.scissor = scissor;
      this.index = index;
      this.length = 0;
    }
    get quads() {
      return this.ctx.renderState.quads;
    }
    getTexture(index) {
      return this.quads.getTexture(this.index + index);
    }
    getElementCore(index) {
      return this.quads.getElementCore(this.index + index);
    }
    getElement(index) {
      return this.quads.getElement(this.index + index);
    }
    getElementWidth(index) {
      return this.getElement(index).renderWidth;
    }
    getElementHeight(index) {
      return this.getElement(index).renderHeight;
    }
    getTextureWidth(index) {
      return this.quads.getTextureWidth(this.index + index);
    }
    getTextureHeight(index) {
      return this.quads.getTextureHeight(this.index + index);
    }
    getRenderWidth() {
      if (this.renderTextureInfo) {
        return this.renderTextureInfo.w;
      } else {
        return this.ctx.stage.w;
      }
    }
    getRenderHeight() {
      if (this.renderTextureInfo) {
        return this.renderTextureInfo.h;
      } else {
        return this.ctx.stage.h;
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/WebGLCoreQuadOperation.mjs
  var WebGLCoreQuadOperation = class extends CoreQuadOperation {
    constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
      super(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
      this.extraAttribsDataByteOffset = 0;
    }
    getAttribsDataByteOffset(index) {
      return this.quads.getAttribsDataByteOffset(this.index + index);
    }
    /**
     * Returns the relative pixel coordinates in the shader owner to gl position coordinates in the render texture.
     * @param x
     * @param y
     * @return {number[]}
     */
    getNormalRenderTextureCoords(x, y) {
      let coords = this.shaderOwner.getRenderTextureCoords(x, y);
      coords[0] /= this.getRenderWidth();
      coords[1] /= this.getRenderHeight();
      coords[0] = coords[0] * 2 - 1;
      coords[1] = 1 - coords[1] * 2;
      return coords;
    }
    getProjection() {
      if (this.renderTextureInfo === null) {
        return this.ctx.renderExec._projection;
      } else {
        return this.renderTextureInfo.nativeTexture.projection;
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/core/CoreRenderExecutor.mjs
  var CoreRenderExecutor = class {
    constructor(ctx) {
      this.ctx = ctx;
      this.renderState = ctx.renderState;
      this.gl = this.ctx.stage.gl;
    }
    destroy() {
      this.ctx = null;
      this.renderState = null;
      this.gl = null;
      delete this.ctx;
      delete this.renderState;
      delete this.gl;
    }
    _reset() {
      this._bindRenderTexture(null);
      this._setScissor(null);
      this._clearRenderTexture();
    }
    execute() {
      this._reset();
      let qops = this.renderState.quadOperations;
      let i = 0, j = 0, n = qops.length;
      while (i < n) {
        this._processQuadOperation(qops[i]);
        i++;
      }
    }
    _processQuadOperation(quadOperation) {
      if (quadOperation.renderTextureInfo && quadOperation.renderTextureInfo.ignore) {
        return;
      }
      this._setupQuadOperation(quadOperation);
      this._execQuadOperation(quadOperation);
    }
    _setupQuadOperation(quadOperation) {
    }
    _execQuadOperation(op) {
      let nativeTexture = op.renderTextureInfo ? op.renderTextureInfo.nativeTexture : null;
      if (this._renderTexture !== nativeTexture) {
        this._bindRenderTexture(nativeTexture);
      }
      if (op.renderTextureInfo && !op.renderTextureInfo.cleared) {
        this._setScissor(null);
        this._clearRenderTexture();
        op.renderTextureInfo.cleared = true;
        this._setScissor(op.scissor);
      } else {
        this._setScissor(op.scissor);
      }
      this._renderQuadOperation(op);
    }
    _renderQuadOperation(op) {
    }
    _bindRenderTexture(renderTexture) {
      this._renderTexture = renderTexture;
    }
    _clearRenderTexture(renderTexture) {
    }
    _setScissor(area) {
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/WebGLCoreRenderExecutor.mjs
  var WebGLCoreRenderExecutor = class extends CoreRenderExecutor {
    constructor(ctx) {
      super(ctx);
      this.gl = this.ctx.stage.gl;
      this.init();
    }
    init() {
      let gl = this.gl;
      this._attribsBuffer = gl.createBuffer();
      let maxQuads = Math.floor(this.renderState.quads.data.byteLength / 80);
      let allIndices = new Uint16Array(maxQuads * 6);
      for (let i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
        allIndices[i] = j;
        allIndices[i + 1] = j + 1;
        allIndices[i + 2] = j + 2;
        allIndices[i + 3] = j;
        allIndices[i + 4] = j + 2;
        allIndices[i + 5] = j + 3;
      }
      this._quadsBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW);
      this._projection = new Float32Array([2 / this.ctx.stage.coordsWidth, -2 / this.ctx.stage.coordsHeight]);
    }
    destroy() {
      super.destroy();
      this.gl.deleteBuffer(this._attribsBuffer);
      this.gl.deleteBuffer(this._quadsBuffer);
      this.gl = null;
      delete this.gl;
    }
    _reset() {
      super._reset();
      let gl = this.gl;
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      this._stopShaderProgram();
      this._setupBuffers();
    }
    _setupBuffers() {
      let gl = this.gl;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
      let element = new Float32Array(this.renderState.quads.data, 0, this.renderState.quads.dataLength);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._attribsBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, element, gl.DYNAMIC_DRAW);
    }
    _setupQuadOperation(quadOperation) {
      super._setupQuadOperation(quadOperation);
      this._useShaderProgram(quadOperation.shader, quadOperation);
    }
    _renderQuadOperation(op) {
      let shader = op.shader;
      if (op.length || op.shader.addEmpty()) {
        shader.beforeDraw(op);
        shader.draw(op);
        shader.afterDraw(op);
      }
    }
    /**
     * @param {WebGLShader} shader;
     * @param {CoreQuadOperation} operation;
     */
    _useShaderProgram(shader, operation) {
      if (!shader.hasSameProgram(this._currentShaderProgram)) {
        if (this._currentShaderProgram) {
          this._currentShaderProgram.stopProgram();
        }
        shader.useProgram();
        this._currentShaderProgram = shader;
      }
      shader.setupUniforms(operation);
    }
    _stopShaderProgram() {
      if (this._currentShaderProgram) {
        this._currentShaderProgram.stopProgram();
        this._currentShaderProgram = null;
      }
    }
    _bindRenderTexture(renderTexture) {
      super._bindRenderTexture(renderTexture);
      let gl = this.gl;
      if (!this._renderTexture) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, this.ctx.stage.w, this.ctx.stage.h);
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderTexture.framebuffer);
        gl.viewport(0, 0, this._renderTexture.w, this._renderTexture.h);
      }
    }
    _clearRenderTexture() {
      super._clearRenderTexture();
      let gl = this.gl;
      if (!this._renderTexture) {
        let glClearColor = this.ctx.stage.getClearColor();
        if (glClearColor) {
          gl.clearColor(glClearColor[0] * glClearColor[3], glClearColor[1] * glClearColor[3], glClearColor[2] * glClearColor[3], glClearColor[3]);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
      } else {
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    }
    _setScissor(area) {
      super._setScissor(area);
      if (this._scissor === area) {
        return;
      }
      this._scissor = area;
      let gl = this.gl;
      if (!area) {
        gl.disable(gl.SCISSOR_TEST);
      } else {
        gl.enable(gl.SCISSOR_TEST);
        let precision2 = this.ctx.stage.getRenderPrecision();
        let y = area[1];
        if (this._renderTexture === null) {
          y = this.ctx.stage.h / precision2 - (area[1] + area[3]);
        }
        gl.scissor(Math.round(area[0] * precision2), Math.round(y * precision2), Math.round(area[2] * precision2), Math.round(area[3] * precision2));
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/core/CoreRenderState.mjs
  var CoreRenderState = class {
    constructor(ctx) {
      this.ctx = ctx;
      this.stage = ctx.stage;
      this.defaultShader = this.stage.renderer.getDefaultShader(ctx);
      this.renderer = ctx.stage.renderer;
      this.quads = this.renderer.createCoreQuadList(ctx);
    }
    reset() {
      this._renderTextureInfo = null;
      this._scissor = null;
      this._shader = null;
      this._shaderOwner = null;
      this._realShader = null;
      this._check = false;
      this.quadOperations = [];
      this._texturizer = null;
      this._texturizerTemporary = false;
      this._quadOperation = null;
      this.quads.reset();
      this._temporaryTexturizers = [];
      this._isCachingTexturizer = false;
    }
    get length() {
      return this.quads.quadTextures.length;
    }
    setShader(shader, owner) {
      if (this._shaderOwner !== owner || this._realShader !== shader) {
        this._realShader = shader;
        if (shader.useDefault()) {
          shader = this.defaultShader;
        }
        if (this._shader !== shader || this._shaderOwner !== owner) {
          this._shader = shader;
          this._shaderOwner = owner;
          this._check = true;
        }
      }
    }
    get renderTextureInfo() {
      return this._renderTextureInfo;
    }
    setScissor(area) {
      if (this._scissor !== area) {
        if (area) {
          this._scissor = area;
        } else {
          this._scissor = null;
        }
        this._check = true;
      }
    }
    getScissor() {
      return this._scissor;
    }
    setRenderTextureInfo(renderTextureInfo) {
      if (this._renderTextureInfo !== renderTextureInfo) {
        this._renderTextureInfo = renderTextureInfo;
        this._scissor = null;
        this._check = true;
      }
    }
    /**
     * Sets the texturizer to be drawn during subsequent addQuads.
     * @param {ElementTexturizer} texturizer
     */
    setTexturizer(texturizer, cache = false) {
      this._texturizer = texturizer;
      this._cacheTexturizer = cache;
    }
    set isCachingTexturizer(v) {
      this._isCachingTexturizer = v;
    }
    get isCachingTexturizer() {
      return this._isCachingTexturizer;
    }
    addQuad(elementCore) {
      if (!this._quadOperation) {
        this._createQuadOperation();
      } else if (this._check && this._hasChanges()) {
        this._finishQuadOperation();
        this._check = false;
      }
      let nativeTexture = null;
      if (this._texturizer) {
        nativeTexture = this._texturizer.getResultTexture();
        if (!this._cacheTexturizer) {
          this._temporaryTexturizers.push(this._texturizer);
        }
      }
      if (!nativeTexture) {
        nativeTexture = elementCore._displayedTextureSource.nativeTexture;
      }
      if (this._renderTextureInfo) {
        if (this._shader === this.defaultShader && this._renderTextureInfo.empty) {
          this._renderTextureInfo.nativeTexture = nativeTexture;
          this._renderTextureInfo.offset = this.length;
        } else {
          this._renderTextureInfo.nativeTexture = null;
        }
        this._renderTextureInfo.empty = false;
      }
      this.quads.quadTextures.push(nativeTexture);
      this.quads.quadElements.push(elementCore);
      this._quadOperation.length++;
      this.renderer.addQuad(this, this.quads, this.length - 1);
    }
    finishedRenderTexture() {
      if (this._renderTextureInfo.nativeTexture) {
        if (!this._isRenderTextureReusable()) {
          this._renderTextureInfo.nativeTexture = null;
        }
      }
    }
    _isRenderTextureReusable() {
      const offset = this._renderTextureInfo.offset;
      return this.quads.quadTextures[offset].w === this._renderTextureInfo.w && this.quads.quadTextures[offset].h === this._renderTextureInfo.h && this.renderer.isRenderTextureReusable(this, this._renderTextureInfo);
    }
    _hasChanges() {
      let q = this._quadOperation;
      if (this._shader !== q.shader) return true;
      if (this._shaderOwner !== q.shaderOwner) return true;
      if (this._renderTextureInfo !== q.renderTextureInfo) return true;
      if (this._scissor !== q.scissor) {
        if (this._scissor[0] !== q.scissor[0] || this._scissor[1] !== q.scissor[1] || this._scissor[2] !== q.scissor[2] || this._scissor[3] !== q.scissor[3]) {
          return true;
        }
      }
      return false;
    }
    _finishQuadOperation(create = true) {
      if (this._quadOperation) {
        if (this._quadOperation.length || this._shader.addEmpty()) {
          if (!this._quadOperation.scissor || this._quadOperation.scissor[2] > 0 && this._quadOperation.scissor[3] > 0) {
            this.quadOperations.push(this._quadOperation);
          }
        }
        if (this._temporaryTexturizers.length) {
          for (let i = 0, n = this._temporaryTexturizers.length; i < n; i++) {
            this._temporaryTexturizers[i].releaseRenderTexture();
          }
          this._temporaryTexturizers = [];
        }
        this._quadOperation = null;
      }
      if (create) {
        this._createQuadOperation();
      }
    }
    _createQuadOperation() {
      this._quadOperation = this.renderer.createCoreQuadOperation(
        this.ctx,
        this._shader,
        this._shaderOwner,
        this._renderTextureInfo,
        this._scissor,
        this.length
      );
      this._check = false;
    }
    finish() {
      if (this._quadOperation) {
        this._finishQuadOperation(false);
      }
      this.renderer.finishRenderState(this);
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/WebGLShaderProgram.mjs
  var WebGLShaderProgram = class {
    constructor(vertexShaderSource, fragmentShaderSource) {
      this.vertexShaderSource = vertexShaderSource;
      this.fragmentShaderSource = fragmentShaderSource;
      this._program = null;
      this.gl = null;
      this._uniformLocations = /* @__PURE__ */ new Map();
      this._attributeLocations = /* @__PURE__ */ new Map();
      this._currentUniformValues = {};
    }
    compile(gl) {
      if (this._program) return;
      this.gl = gl;
      this._program = gl.createProgram();
      let glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexShaderSource);
      let glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
      gl.attachShader(this._program, glVertShader);
      gl.attachShader(this._program, glFragShader);
      gl.linkProgram(this._program);
      if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
        console.error("[Lightning] Error: Could not initialize shader.");
        console.error("[Lightning] gl.VALIDATE_STATUS", gl.getProgramParameter(this._program, gl.VALIDATE_STATUS));
        console.error("[Lightning] gl.getError()", gl.getError());
        if (gl.getProgramInfoLog(this._program) !== "") {
          console.warn("[Lightning] Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(this._program));
        }
        gl.deleteProgram(this._program);
        this._program = null;
      }
      gl.deleteShader(glVertShader);
      gl.deleteShader(glFragShader);
    }
    _glCompile(type, src) {
      let shader = this.gl.createShader(type);
      this.gl.shaderSource(shader, src);
      this.gl.compileShader(shader);
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        console.error("[Lightning]", this.constructor.name, "Type: " + (type === this.gl.VERTEX_SHADER ? "vertex shader" : "fragment shader"));
        console.error("[Lightning]", this.gl.getShaderInfoLog(shader));
        let idx = 0;
        console.error("[Lightning]", "========== source ==========\n" + src.split("\n").map((line) => "" + ++idx + ": " + line).join("\n"));
        return null;
      }
      return shader;
    }
    getUniformLocation(name) {
      let location = this._uniformLocations.get(name);
      if (location === void 0) {
        location = this.gl.getUniformLocation(this._program, name);
        this._uniformLocations.set(name, location);
      }
      return location;
    }
    getAttribLocation(name) {
      let location = this._attributeLocations.get(name);
      if (location === void 0) {
        location = this.gl.getAttribLocation(this._program, name);
        this._attributeLocations.set(name, location);
      }
      return location;
    }
    destroy() {
      if (this._program) {
        this.gl.deleteProgram(this._program);
      }
      this._attributeLocations = null;
      this._currentUniformValues = null;
      this.fragmentShaderSource = null;
      this._program = null;
      this.gl = null;
      this._uniformLocations = null;
      this.vertexShaderSource = null;
      delete this.vertexShaderSource;
      delete this._program;
      delete this._currentUniformValues;
      delete this.fragmentShaderSource;
      delete this.gl;
      delete this._uniformLocations;
      delete this._attributeLocations;
    }
    get glProgram() {
      return this._program;
    }
    get compiled() {
      return !!this._program;
    }
    _valueEquals(v1, v2) {
      if (v1.length && v2.length) {
        for (let i = 0, n = v1.length; i < n; i++) {
          if (v1[i] !== v2[i]) return false;
        }
        return true;
      } else {
        return v1 === v2;
      }
    }
    _valueClone(v) {
      if (v.length) {
        return v.slice(0);
      } else {
        return v;
      }
    }
    setUniformValue(name, value, glFunction) {
      let v = this._currentUniformValues[name];
      if (v === void 0 || !this._valueEquals(v, value)) {
        let clonedValue = this._valueClone(value);
        this._currentUniformValues[name] = clonedValue;
        let loc = this.getUniformLocation(name);
        if (loc) {
          let isMatrix = glFunction === this.gl.uniformMatrix2fv || glFunction === this.gl.uniformMatrix3fv || glFunction === this.gl.uniformMatrix4fv;
          if (isMatrix) {
            glFunction.call(this.gl, loc, false, clonedValue);
          } else {
            glFunction.call(this.gl, loc, clonedValue);
          }
        }
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/WebGLShader.mjs
  var WebGLShader = class extends Shader {
    constructor(ctx) {
      super(ctx);
      const stage2 = ctx.stage;
      this._program = stage2.renderer.shaderPrograms.get(this.constructor);
      if (!this._program) {
        this._program = new WebGLShaderProgram(this.constructor.vertexShaderSource, this.constructor.fragmentShaderSource);
        stage2.renderer.shaderPrograms.set(this.constructor, this._program);
      }
      this.gl = stage2.gl;
    }
    get glProgram() {
      return this._program.glProgram;
    }
    _init() {
      if (!this._initialized) {
        this.initialize();
        this._initialized = true;
      }
    }
    initialize() {
      this._program.compile(this.gl);
    }
    get initialized() {
      return this._initialized;
    }
    _uniform(name) {
      return this._program.getUniformLocation(name);
    }
    _attrib(name) {
      return this._program.getAttribLocation(name);
    }
    _setUniform(name, value, glFunction) {
      this._program.setUniformValue(name, value, glFunction);
    }
    useProgram() {
      this._init();
      this.gl.useProgram(this.glProgram);
      this.beforeUsage();
      this.enableAttribs();
    }
    stopProgram() {
      this.afterUsage();
      this.disableAttribs();
    }
    hasSameProgram(other) {
      return other && (other === this || other._program === this._program);
    }
    beforeUsage() {
    }
    afterUsage() {
    }
    enableAttribs() {
    }
    disableAttribs() {
    }
    getExtraAttribBytesPerVertex() {
      return 0;
    }
    getVertexAttribPointerOffset(operation) {
      return operation.extraAttribsDataByteOffset - operation.index * 4 * this.getExtraAttribBytesPerVertex();
    }
    setExtraAttribsInBuffer(operation) {
    }
    setupUniforms(operation) {
    }
    _getProjection(operation) {
      return operation.getProjection();
    }
    getFlipY(operation) {
      return this._getProjection(operation)[1] < 0;
    }
    beforeDraw(operation) {
    }
    draw(operation) {
    }
    afterDraw(operation) {
    }
    cleanup() {
      this._initialized = false;
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/DefaultShader.mjs
  var DefaultShader = class extends WebGLShader {
    enableAttribs() {
      let gl = this.gl;
      gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
      gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
      if (this._attrib("aTextureCoord") !== -1) {
        gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
        gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
      }
      if (this._attrib("aColor") !== -1) {
        gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
        gl.enableVertexAttribArray(this._attrib("aColor"));
      }
    }
    disableAttribs() {
      let gl = this.gl;
      gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
      if (this._attrib("aTextureCoord") !== -1) {
        gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
      }
      if (this._attrib("aColor") !== -1) {
        gl.disableVertexAttribArray(this._attrib("aColor"));
      }
    }
    setupUniforms(operation) {
      this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
    }
    draw(operation) {
      let gl = this.gl;
      let length = operation.length;
      if (length) {
        let glTexture = operation.getTexture(0);
        let pos = 0;
        for (let i = 0; i < length; i++) {
          let tx = operation.getTexture(i);
          if (glTexture !== tx) {
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
            glTexture = tx;
            pos = i;
          }
        }
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
      }
    }
  };
  DefaultShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  DefaultShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/Renderer.mjs
  var Renderer = class {
    constructor(stage2) {
      this.stage = stage2;
      this._defaultShader = void 0;
    }
    gc(aggressive) {
    }
    destroy() {
    }
    getDefaultShader(ctx = this.stage.ctx) {
      if (!this._defaultShader) {
        this._defaultShader = this._createDefaultShader(ctx);
      }
      return this._defaultShader;
    }
    _createDefaultShader(ctx) {
    }
    isValidShaderType(shaderType) {
      return shaderType.prototype instanceof this._getShaderBaseType();
    }
    createShader(ctx, settings2) {
      const shaderType = settings2.type;
      if (!this.isValidShaderType(shaderType)) {
        const convertedShaderType = this._getShaderAlternative(shaderType);
        if (!convertedShaderType) {
          console.warn("[Lightning] Shader has no implementation for render target: " + shaderType.name);
          return this._createDefaultShader(ctx);
        }
        return new convertedShaderType(ctx);
      } else {
        const shader = new shaderType(ctx);
        Base.patchObject(this, settings2);
        return shader;
      }
    }
    _getShaderBaseType() {
    }
    _getShaderAlternative(shaderType) {
      return this.getDefaultShader();
    }
    copyRenderTexture(renderTexture, nativeTexture, options) {
      console.warn("[Lightning] copyRenderTexture not supported by renderer");
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/WebGLRenderer.mjs
  var WebGLRenderer = class extends Renderer {
    constructor(stage2) {
      super(stage2);
      this.shaderPrograms = /* @__PURE__ */ new Map();
      this._compressedTextureExtensions = {
        astc: stage2.gl.getExtension("WEBGL_compressed_texture_astc"),
        etc1: stage2.gl.getExtension("WEBGL_compressed_texture_etc1"),
        s3tc: stage2.gl.getExtension("WEBGL_compressed_texture_s3tc"),
        pvrtc: stage2.gl.getExtension("WEBGL_compressed_texture_pvrtc")
      };
    }
    getCompressedTextureExtensions() {
      return this._compressedTextureExtensions;
    }
    destroy() {
      this.shaderPrograms.forEach((shaderProgram) => shaderProgram.destroy());
      this.shaderPrograms = null;
      this._compressedTextureExtensions = null;
      delete this.shaderPrograms;
      delete this._compressedTextureExtensions;
    }
    _createDefaultShader(ctx) {
      return new DefaultShader(ctx);
    }
    _getShaderBaseType() {
      return WebGLShader;
    }
    _getShaderAlternative(shaderType) {
      return shaderType.getWebGL && shaderType.getWebGL();
    }
    createCoreQuadList(ctx) {
      return new WebGLCoreQuadList(ctx);
    }
    createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
      return new WebGLCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    }
    createCoreRenderExecutor(ctx) {
      return new WebGLCoreRenderExecutor(ctx);
    }
    createCoreRenderState(ctx) {
      return new CoreRenderState(ctx);
    }
    createRenderTexture(w, h, pw, ph) {
      const gl = this.stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pw, ph, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      glTexture.params = {};
      glTexture.params[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
      glTexture.params[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
      glTexture.params[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
      glTexture.params[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
      glTexture.options = { format: gl.RGBA, internalFormat: gl.RGBA, type: gl.UNSIGNED_BYTE };
      glTexture.framebuffer = gl.createFramebuffer();
      glTexture.projection = new Float32Array([2 / w, 2 / h]);
      gl.bindFramebuffer(gl.FRAMEBUFFER, glTexture.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);
      return glTexture;
    }
    freeRenderTexture(glTexture) {
      let gl = this.stage.gl;
      gl.deleteFramebuffer(glTexture.framebuffer);
      gl.deleteTexture(glTexture);
    }
    _getBytesPerPixel(fmt, type) {
      const gl = this.stage.gl;
      if (fmt === gl.RGBA) {
        switch (type) {
          case gl.UNSIGNED_BYTE:
            return 4;
          case gl.UNSIGNED_SHORT_4_4_4_4:
            return 2;
          case gl.UNSIGNED_SHORT_5_5_5_1:
            return 2;
          default:
            throw new Error("Invalid type specified for GL_RGBA format");
        }
      } else if (fmt === gl.RGB) {
        switch (type) {
          case gl.UNSIGNED_BYTE:
            return 3;
          case gl.UNSIGNED_BYTE_5_6_5:
            return 2;
          default:
            throw new Error("Invalid type specified for GL_RGB format");
        }
      } else {
        throw new Error("Invalid format specified in call to _getBytesPerPixel()");
      }
    }
    uploadTextureSource(textureSource, options) {
      const gl = this.stage.gl;
      const source = options.source;
      let compressed = false;
      if (options.renderInfo) {
        compressed = options.renderInfo.compressed || false;
      }
      const format = {
        premultiplyAlpha: true,
        hasAlpha: true
      };
      if (options && options.hasOwnProperty("premultiplyAlpha")) {
        format.premultiplyAlpha = options.premultiplyAlpha;
      }
      if (options && options.hasOwnProperty("flipBlueRed")) {
        format.flipBlueRed = options.flipBlueRed;
      }
      if (options && options.hasOwnProperty("hasAlpha")) {
        format.hasAlpha = options.hasAlpha;
      }
      if (!format.hasAlpha) {
        format.premultiplyAlpha = false;
      }
      format.texParams = options.texParams || {};
      format.texOptions = options.texOptions || {};
      let glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, format.premultiplyAlpha);
      if (Utils.isNode) {
        gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, !!format.flipBlueRed);
      }
      const texParams = format.texParams;
      if (!texParams[gl.TEXTURE_MAG_FILTER]) texParams[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
      if (!texParams[gl.TEXTURE_MIN_FILTER]) texParams[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
      if (!texParams[gl.TEXTURE_WRAP_S]) texParams[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
      if (!texParams[gl.TEXTURE_WRAP_T]) texParams[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
      Object.keys(texParams).forEach((key) => {
        const value = texParams[key];
        gl.texParameteri(gl.TEXTURE_2D, parseInt(key), value);
      });
      if (compressed) {
        this.stage.platform.uploadCompressedGlTexture(gl, textureSource, source);
        return glTexture;
      }
      const texOptions = format.texOptions;
      texOptions.format = texOptions.format || (format.hasAlpha ? gl.RGBA : gl.RGB);
      texOptions.type = texOptions.type || gl.UNSIGNED_BYTE;
      texOptions.internalFormat = texOptions.internalFormat || texOptions.format;
      if (options && options.imageRef) {
        texOptions.imageRef = options.imageRef;
      }
      this.stage.platform.uploadGlTexture(gl, textureSource, source, texOptions);
      glTexture.params = Utils.cloneObjShallow(texParams);
      glTexture.options = Utils.cloneObjShallow(texOptions);
      glTexture.bytesPerPixel = this._getBytesPerPixel(texOptions.format, texOptions.type);
      return glTexture;
    }
    freeTextureSource(textureSource) {
      this.stage.gl.deleteTexture(textureSource.nativeTexture);
    }
    addQuad(renderState, quads, index) {
      let offset = index * 20;
      const elementCore = quads.quadElements[index];
      let r = elementCore._renderContext;
      let floats = renderState.quads.floats;
      let uints = renderState.quads.uints;
      const mca = StageUtils.mergeColorAlpha;
      if (r.tb !== 0 || r.tc !== 0) {
        floats[offset++] = r.px;
        floats[offset++] = r.py;
        floats[offset++] = elementCore._ulx;
        floats[offset++] = elementCore._uly;
        uints[offset++] = mca(elementCore._colorUl, r.alpha);
        floats[offset++] = r.px + elementCore._w * r.ta;
        floats[offset++] = r.py + elementCore._w * r.tc;
        floats[offset++] = elementCore._brx;
        floats[offset++] = elementCore._uly;
        uints[offset++] = mca(elementCore._colorUr, r.alpha);
        floats[offset++] = r.px + elementCore._w * r.ta + elementCore._h * r.tb;
        floats[offset++] = r.py + elementCore._w * r.tc + elementCore._h * r.td;
        floats[offset++] = elementCore._brx;
        floats[offset++] = elementCore._bry;
        uints[offset++] = mca(elementCore._colorBr, r.alpha);
        floats[offset++] = r.px + elementCore._h * r.tb;
        floats[offset++] = r.py + elementCore._h * r.td;
        floats[offset++] = elementCore._ulx;
        floats[offset++] = elementCore._bry;
        uints[offset] = mca(elementCore._colorBl, r.alpha);
      } else {
        let cx = r.px + elementCore._w * r.ta;
        let cy = r.py + elementCore._h * r.td;
        floats[offset++] = r.px;
        floats[offset++] = r.py;
        floats[offset++] = elementCore._ulx;
        floats[offset++] = elementCore._uly;
        uints[offset++] = mca(elementCore._colorUl, r.alpha);
        floats[offset++] = cx;
        floats[offset++] = r.py;
        floats[offset++] = elementCore._brx;
        floats[offset++] = elementCore._uly;
        uints[offset++] = mca(elementCore._colorUr, r.alpha);
        floats[offset++] = cx;
        floats[offset++] = cy;
        floats[offset++] = elementCore._brx;
        floats[offset++] = elementCore._bry;
        uints[offset++] = mca(elementCore._colorBr, r.alpha);
        floats[offset++] = r.px;
        floats[offset++] = cy;
        floats[offset++] = elementCore._ulx;
        floats[offset++] = elementCore._bry;
        uints[offset] = mca(elementCore._colorBl, r.alpha);
      }
    }
    isRenderTextureReusable(renderState, renderTextureInfo) {
      let offset = renderState._renderTextureInfo.offset * 80 / 4;
      let floats = renderState.quads.floats;
      let uints = renderState.quads.uints;
      return floats[offset] === 0 && floats[offset + 1] === 0 && floats[offset + 2] === 0 && floats[offset + 3] === 0 && uints[offset + 4] === 4294967295 && floats[offset + 5] === renderTextureInfo.w && floats[offset + 6] === 0 && floats[offset + 7] === 1 && floats[offset + 8] === 0 && uints[offset + 9] === 4294967295 && floats[offset + 10] === renderTextureInfo.w && floats[offset + 11] === renderTextureInfo.h && floats[offset + 12] === 1 && floats[offset + 13] === 1 && uints[offset + 14] === 4294967295 && floats[offset + 15] === 0 && floats[offset + 16] === renderTextureInfo.h && floats[offset + 17] === 0 && floats[offset + 18] === 1 && uints[offset + 19] === 4294967295;
    }
    finishRenderState(renderState) {
      let offset = renderState.length * 80;
      for (let i = 0, n = renderState.quadOperations.length; i < n; i++) {
        renderState.quadOperations[i].extraAttribsDataByteOffset = offset;
        let extra = renderState.quadOperations[i].shader.getExtraAttribBytesPerVertex() * 4 * renderState.quadOperations[i].length;
        offset += extra;
        if (extra) {
          renderState.quadOperations[i].shader.setExtraAttribsInBuffer(renderState.quadOperations[i], renderState.quads);
        }
      }
      renderState.quads.dataLength = offset;
    }
    copyRenderTexture(renderTexture, nativeTexture, options) {
      const gl = this.stage.gl;
      gl.bindTexture(gl.TEXTURE_2D, nativeTexture);
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture.framebuffer);
      const precision2 = renderTexture.precision;
      gl.copyTexSubImage2D(
        gl.TEXTURE_2D,
        0,
        precision2 * (options.sx || 0),
        precision2 * (options.sy || 0),
        precision2 * (options.x || 0),
        precision2 * (options.y || 0),
        precision2 * (options.w || renderTexture.ow),
        precision2 * (options.h || renderTexture.oh)
      );
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/c2d/C2dCoreQuadList.mjs
  var C2dCoreQuadList = class extends CoreQuadList {
    constructor(ctx) {
      super(ctx);
      this.renderContexts = [];
      this.modes = [];
    }
    setRenderContext(index, v) {
      this.renderContexts[index] = v;
    }
    setSimpleTc(index, v) {
      if (v) {
        this.modes[index] |= 1;
      } else {
        this.modes[index] -= this.modes[index] & 1;
      }
    }
    setWhite(index, v) {
      if (v) {
        this.modes[index] |= 2;
      } else {
        this.modes[index] -= this.modes[index] & 2;
      }
    }
    getRenderContext(index) {
      return this.renderContexts[index];
    }
    getSimpleTc(index) {
      return this.modes[index] & 1;
    }
    getWhite(index) {
      return this.modes[index] & 2;
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/c2d/C2dCoreQuadOperation.mjs
  var C2dCoreQuadOperation = class extends CoreQuadOperation {
    getRenderContext(index) {
      return this.quads.getRenderContext(this.index + index);
    }
    getSimpleTc(index) {
      return this.quads.getSimpleTc(this.index + index);
    }
    getWhite(index) {
      return this.quads.getWhite(this.index + index);
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/c2d/C2dCoreRenderExecutor.mjs
  var C2dCoreRenderExecutor = class _C2dCoreRenderExecutor extends CoreRenderExecutor {
    init() {
      this._mainRenderTexture = this.ctx.stage.getCanvas();
    }
    _renderQuadOperation(op) {
      let shader = op.shader;
      if (op.length || op.shader.addEmpty()) {
        const target = this._renderTexture || this._mainRenderTexture;
        shader.beforeDraw(op, target);
        shader.draw(op, target);
        shader.afterDraw(op, target);
      }
    }
    _clearRenderTexture() {
      const ctx = this._getContext();
      let clearColor = [0, 0, 0, 0];
      if (this._mainRenderTexture.ctx === ctx) {
        clearColor = this.ctx.stage.getClearColor();
      }
      const renderTexture = ctx.canvas;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      if (!clearColor[0] && !clearColor[1] && !clearColor[2] && !clearColor[3]) {
        ctx.clearRect(0, 0, renderTexture.width, renderTexture.height);
      } else {
        ctx.fillStyle = StageUtils.getRgbaStringFromArray(clearColor);
        ctx.globalCompositeOperation = "copy";
        ctx.beginPath();
        ctx.rect(0, 0, renderTexture.width, renderTexture.height);
        ctx.closePath();
        ctx.fill();
        ctx.globalCompositeOperation = "source-over";
      }
    }
    _getContext() {
      if (this._renderTexture) {
        return this._renderTexture.ctx;
      } else {
        return this._mainRenderTexture.ctx;
      }
    }
    _restoreContext() {
      const ctx = this._getContext();
      ctx.restore();
      ctx.save();
      ctx._scissor = null;
    }
    _setScissor(area) {
      const ctx = this._getContext();
      if (!_C2dCoreRenderExecutor._equalScissorAreas(ctx.canvas, ctx._scissor, area)) {
        this._restoreContext();
        let precision2 = this.ctx.stage.getRenderPrecision();
        if (area) {
          ctx.beginPath();
          ctx.rect(Math.round(area[0] * precision2), Math.round(area[1] * precision2), Math.round(area[2] * precision2), Math.round(area[3] * precision2));
          ctx.closePath();
          ctx.clip();
        }
        ctx._scissor = area;
      }
    }
    static _equalScissorAreas(canvas, area, current) {
      if (!area) {
        area = [0, 0, canvas.width, canvas.height];
      }
      if (!current) {
        current = [0, 0, canvas.width, canvas.height];
      }
      return Utils.equalValues(area, current);
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/c2d/C2dShader.mjs
  var C2dShader = class extends Shader {
    beforeDraw(operation) {
    }
    draw(operation) {
    }
    afterDraw(operation) {
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/c2d/shaders/DefaultShader.mjs
  var DefaultShader2 = class extends C2dShader {
    constructor(ctx) {
      super(ctx);
      this._rectangleTexture = ctx.stage.rectangleTexture.source.nativeTexture;
      this._tintManager = this.ctx.stage.renderer.tintManager;
    }
    draw(operation, target) {
      const ctx = target.ctx;
      let length = operation.length;
      for (let i = 0; i < length; i++) {
        const tx = operation.getTexture(i);
        if (!tx) continue;
        const vc = operation.getElementCore(i);
        const rc = operation.getRenderContext(i);
        const white = operation.getWhite(i);
        const stc = operation.getSimpleTc(i);
        const precision2 = this.ctx.stage.getRenderPrecision();
        ctx.setTransform(rc.ta * precision2, rc.tc * precision2, rc.tb * precision2, rc.td * precision2, rc.px * precision2, rc.py * precision2);
        const rect = tx === this._rectangleTexture;
        const info = { operation, target, index: i, rect };
        if (rect) {
          if (white) {
            ctx.fillStyle = "white";
          } else {
            this._setColorGradient(ctx, vc);
          }
          ctx.globalAlpha = rc.alpha;
          this._beforeDrawEl(info);
          ctx.fillRect(0, 0, vc.w, vc.h);
          this._afterDrawEl(info);
          ctx.globalAlpha = 1;
        } else {
          ctx.globalAlpha = rc.alpha;
          this._beforeDrawEl(info);
          const sourceX = stc ? 0 : vc._ulx * tx.w;
          const sourceY = stc ? 0 : vc._uly * tx.h;
          const sourceW = (stc ? 1 : vc._brx - vc._ulx) * tx.w;
          const sourceH = (stc ? 1 : vc._bry - vc._uly) * tx.h;
          let colorize = !white;
          if (colorize) {
            let color = vc._colorUl;
            if (vc._colorUl !== vc._colorUr || vc._colorUr !== vc._colorBl || vc._colorBr !== vc._colorBl) {
              color = StageUtils.mergeMultiColorsEqual([vc._colorUl, vc._colorUr, vc._colorBl, vc._colorBr]);
            }
            const alpha = (color / 16777216 | 0) / 255;
            ctx.globalAlpha *= alpha;
            const rgb = color & 16777215;
            const tintTexture = this._tintManager.getTintTexture(tx, rgb);
            ctx.fillStyle = "white";
            ctx.drawImage(tintTexture, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
          } else {
            ctx.fillStyle = "white";
            ctx.drawImage(tx, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
          }
          this._afterDrawEl(info);
          ctx.globalAlpha = 1;
        }
      }
    }
    _setColorGradient(ctx, vc, w = vc.w, h = vc.h, transparency = true) {
      let color = vc._colorUl;
      let gradient;
      if (vc._colorUl === vc._colorUr) {
        if (vc._colorBl === vc._colorBr) {
          if (vc._colorUl === vc._colorBl) {
          } else {
            gradient = ctx.createLinearGradient(0, 0, 0, h);
            if (transparency) {
              gradient.addColorStop(0, StageUtils.getRgbaString(vc._colorUl));
              gradient.addColorStop(1, StageUtils.getRgbaString(vc._colorBl));
            } else {
              gradient.addColorStop(0, StageUtils.getRgbString(vc._colorUl));
              gradient.addColorStop(1, StageUtils.getRgbString(vc._colorBl));
            }
          }
        } else {
        }
      } else {
        if (vc._colorUl === vc._colorBl && vc._colorUr === vc._colorBr) {
          gradient = ctx.createLinearGradient(0, 0, w, 0);
          if (transparency) {
            gradient.addColorStop(0, StageUtils.getRgbaString(vc._colorUl));
            gradient.addColorStop(1, StageUtils.getRgbaString(vc._colorBr));
          } else {
            gradient.addColorStop(0, StageUtils.getRgbString(vc._colorUl));
            gradient.addColorStop(1, StageUtils.getRgbString(vc._colorBr));
          }
        }
      }
      if (gradient) {
        ctx.fillStyle = gradient;
      } else {
        ctx.fillStyle = transparency ? StageUtils.getRgbaString(color) : StageUtils.getRgbString(color);
      }
    }
    _beforeDrawEl(info) {
    }
    _afterDrawEl(info) {
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/c2d/C2dTextureTintManager.mjs
  var C2dTextureTintManager = class {
    constructor(stage2) {
      this.stage = stage2;
      this._usedMemory = 0;
      this._cachedNativeTextures = /* @__PURE__ */ new Set();
    }
    destroy() {
      this.gc(true);
      this.stage = null;
      delete this.stage;
    }
    _addMemoryUsage(delta) {
      this._usedMemory += delta;
      this.stage.addMemoryUsage(delta);
    }
    delete(nativeTexture) {
      if (this._hasCache(nativeTexture)) {
        const cache = this._getCache(nativeTexture);
        const prevMemUsage = cache.memoryUsage;
        cache.clear();
        this._cachedNativeTextures.delete(nativeTexture);
        this._addMemoryUsage(cache.memoryUsage - prevMemUsage);
      }
    }
    getTintTexture(nativeTexture, color) {
      const frame = this.stage.frameCounter;
      this._cachedNativeTextures.add(nativeTexture);
      const cache = this._getCache(nativeTexture);
      const item = cache.get(color);
      item.lf = frame;
      if (item.tx) {
        if (nativeTexture.update > item.u) {
          this._tintTexture(item.tx, nativeTexture, color);
        }
        return item.tx;
      } else {
        const before = cache.memoryUsage;
        let target = cache.reuseTexture(frame);
        if (target) {
          target.ctx.clearRect(0, 0, target.width, target.height);
        } else {
          target = document.createElement("canvas");
          target.width = nativeTexture.w;
          target.height = nativeTexture.h;
          target.ctx = target.getContext("2d");
        }
        this._tintTexture(target, nativeTexture, color);
        cache.set(color, target, frame);
        const after = cache.memoryUsage;
        if (after !== before) {
          this._addMemoryUsage(after - before);
        }
        return target;
      }
    }
    _tintTexture(target, source, color) {
      let col = color.toString(16);
      while (col.length < 6) {
        col = "0" + col;
      }
      target.ctx.fillStyle = "#" + col;
      target.ctx.globalCompositeOperation = "copy";
      target.ctx.fillRect(0, 0, source.w, source.h);
      target.ctx.globalCompositeOperation = "multiply";
      target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
      target.ctx.globalCompositeOperation = "destination-in";
      target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
    }
    _hasCache(nativeTexture) {
      return !!nativeTexture._tintCache;
    }
    _getCache(nativeTexture) {
      if (!nativeTexture._tintCache) {
        nativeTexture._tintCache = new C2dTintCache(nativeTexture);
      }
      return nativeTexture._tintCache;
    }
    gc(aggressive = false) {
      const frame = this.stage.frameCounter;
      let delta = 0;
      this._cachedNativeTextures.forEach((texture) => {
        const cache = this._getCache(texture);
        if (aggressive) {
          delta += cache.memoryUsage;
          cache.clear();
        } else {
          const before = cache.memoryUsage;
          cache.cleanup(frame);
          cache.releaseBlancoTextures();
          delta += cache.memoryUsage - before;
        }
      });
      if (aggressive) {
        this._cachedNativeTextures.clear();
      }
      if (delta) {
        this._addMemoryUsage(delta);
      }
    }
  };
  var C2dTintCache = class {
    constructor(nativeTexture) {
      this._tx = nativeTexture;
      this._colors = /* @__PURE__ */ new Map();
      this._blancoTextures = null;
      this._lastCleanupFrame = 0;
      this._memTextures = 0;
    }
    get memoryUsage() {
      return this._memTextures * this._tx.w * this._tx.h;
    }
    releaseBlancoTextures() {
      this._memTextures -= this._blancoTextures.length;
      this._blancoTextures = [];
    }
    clear() {
      this._blancoTextures = null;
      this._colors.clear();
      this._memTextures = 0;
    }
    get(color) {
      let item = this._colors.get(color);
      if (!item) {
        item = { lf: -1, tx: void 0, u: -1 };
        this._colors.set(color, item);
      }
      return item;
    }
    set(color, texture, frame) {
      const item = this.get(color);
      item.lf = frame;
      item.tx = texture;
      item.u = frame;
      this._memTextures++;
    }
    cleanup(frame) {
      if (this._lastCleanupFrame !== frame) {
        this._blancoTextures = [];
        this._colors.forEach((item, color) => {
          if (item.lf < frame - 1) {
            if (item.tx) {
              this._blancoTextures.push(item.tx);
            }
            this._colors.delete(color);
          }
        });
        this._lastCleanupFrame = frame;
      }
    }
    reuseTexture(frame) {
      this.cleanup(frame);
      if (this._blancoTextures && this._blancoTextures.length) {
        this._memTextures--;
        return this._blancoTextures.pop();
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/c2d/C2dRenderer.mjs
  var C2dRenderer = class extends Renderer {
    constructor(stage2) {
      super(stage2);
      this.tintManager = new C2dTextureTintManager(stage2);
      this.setupC2d(this.stage.c2d.canvas);
    }
    destroy() {
      this.tintManager.destroy();
      this.tintManager = null;
      delete this.tintManager;
    }
    _createDefaultShader(ctx) {
      return new DefaultShader2(ctx);
    }
    _getShaderBaseType() {
      return C2dShader;
    }
    _getShaderAlternative(shaderType) {
      return shaderType.getC2d && shaderType.getC2d();
    }
    createCoreQuadList(ctx) {
      return new C2dCoreQuadList(ctx);
    }
    createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
      return new C2dCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    }
    createCoreRenderExecutor(ctx) {
      return new C2dCoreRenderExecutor(ctx);
    }
    createCoreRenderState(ctx) {
      return new CoreRenderState(ctx);
    }
    createRenderTexture(w, h, pw, ph) {
      const canvas = document.createElement("canvas");
      canvas.width = pw;
      canvas.height = ph;
      this.setupC2d(canvas);
      return canvas;
    }
    freeRenderTexture(nativeTexture) {
      this.tintManager.delete(nativeTexture);
    }
    gc(aggressive) {
      this.tintManager.gc(aggressive);
    }
    uploadTextureSource(textureSource, options) {
      if (options.source.buffer) {
        const canvas = document.createElement("canvas");
        canvas.width = options.w;
        canvas.height = options.h;
        const imageData = new ImageData(new Uint8ClampedArray(options.source.buffer), options.w, options.h);
        canvas.getContext("2d").putImageData(imageData, 0, 0);
        return canvas;
      }
      return options.source;
    }
    freeTextureSource(textureSource) {
      this.tintManager.delete(textureSource.nativeTexture);
    }
    addQuad(renderState, quads, index) {
      const elementCore = quads.quadElements[index];
      quads.setRenderContext(index, elementCore._renderContext);
      quads.setWhite(index, elementCore.isWhite());
      quads.setSimpleTc(index, elementCore.hasSimpleTexCoords());
    }
    isRenderTextureReusable(renderState, renderTextureInfo) {
      return false;
    }
    finishRenderState(renderState) {
    }
    setupC2d(canvas) {
      const ctx = canvas.getContext("2d");
      canvas.ctx = ctx;
      ctx._scissor = null;
      canvas.ctx.save();
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/spark/shaders/SparkShader.mjs
  var SparkShader = class extends WebGLShader {
    enableAttribs() {
      let gl = this.gl;
      gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
      gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
      if (this._attrib("aTextureCoord") !== -1) {
        gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
        gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
      }
      if (this._attrib("aColor") !== -1) {
        gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
        gl.enableVertexAttribArray(this._attrib("aColor"));
      }
    }
    disableAttribs() {
      let gl = this.gl;
      gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
      if (this._attrib("aTextureCoord") !== -1) {
        gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
      }
      if (this._attrib("aColor") !== -1) {
        gl.disableVertexAttribArray(this._attrib("aColor"));
      }
    }
    setupUniforms(operation) {
      this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
    }
    draw(operation) {
      let gl = this.gl;
      let length = operation.length;
      if (length) {
        let glTexture = operation.getTexture(0);
        let pos = 0;
        for (let i = 0; i < length; i++) {
          let tx = operation.getTexture(i);
          if (glTexture !== tx) {
            if (glTexture.options && glTexture.options.imageRef) {
              let elementPostion = i > 0 ? i - 1 : i;
              const precision2 = this.ctx.stage.getOption("precision");
              let vc = operation.getElementCore(elementPostion);
              this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px * precision2, vc._worldContext.py * precision2, vc._colorUl, vc);
            } else {
              gl.bindTexture(gl.TEXTURE_2D, glTexture);
              gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
            }
            glTexture = tx;
            pos = i;
          }
        }
        if (pos < length) {
          if (glTexture.options && glTexture.options.imageRef) {
            const precision2 = this.ctx.stage.getOption("precision");
            let vc = operation.getElementCore(pos);
            this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px * precision2, vc._worldContext.py * precision2, vc._colorUl, vc);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
          }
        }
      }
    }
  };
  SparkShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  SparkShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/spark/SparkRenderer.mjs
  var SparkRenderer = class extends WebGLRenderer {
    constructor(stage2) {
      super(stage2);
    }
    _createDefaultShader(ctx) {
      return new SparkShader(ctx);
    }
    createCoreRenderExecutor(ctx) {
      global.beginDrawing();
      let ret = super.createCoreRenderExecutor(ctx);
      global.endDrawing();
      return ret;
    }
  };

  // node_modules/@lightningjs/core/dist/src/platforms/browser/ImageWorker.mjs
  var ImageWorker = class {
    constructor(options = {}) {
      this._items = /* @__PURE__ */ new Map();
      this._id = 0;
      this._initWorker();
    }
    destroy() {
      if (this._worker) {
        this._worker.terminate();
      }
      this._items = null;
      this._worker = null;
      delete this._items;
      delete this._worker;
    }
    _initWorker() {
      const code = `(${createWorker.toString()})()`;
      const blob = new Blob([code.replace('"use strict";', "")]);
      const blobURL = (window.URL ? URL : webkitURL).createObjectURL(blob, {
        type: "application/javascript; charset=utf-8"
      });
      this._worker = new Worker(blobURL);
      this._worker.postMessage({ type: "config", config: { path: window.location.href, protocol: window.location.protocol } });
      this._worker.onmessage = (e) => {
        if (e.data && e.data.id) {
          const id = e.data.id;
          const item = this._items.get(id);
          if (item) {
            if (e.data.type == "data") {
              this.finish(item, e.data.info);
            } else {
              this.error(item, e.data.info);
            }
          }
        }
      };
    }
    create(src) {
      const id = ++this._id;
      const item = new ImageWorkerImage(this, id, src);
      this._items.set(id, item);
      this._worker.postMessage({ type: "add", id, src });
      return item;
    }
    cancel(image) {
      this._worker.postMessage({ type: "cancel", id: image.id });
      this._items.delete(image.id);
    }
    error(image, info) {
      image.error(info);
      this._items.delete(image.id);
    }
    finish(image, info) {
      image.load(info);
      this._items.delete(image.id);
    }
  };
  var ImageWorkerImage = class {
    constructor(manager, id, src) {
      this._manager = manager;
      this._id = id;
      this._src = src;
      this._onError = null;
      this._onLoad = null;
    }
    get id() {
      return this._id;
    }
    get src() {
      return this._src;
    }
    set onError(f) {
      this._onError = f;
    }
    set onLoad(f) {
      this._onLoad = f;
    }
    cancel() {
      this._manager.cancel(this);
    }
    load(info) {
      if (this._onLoad) {
        this._onLoad(info);
      }
    }
    error(info) {
      if (this._onError) {
        this._onError(info);
      }
    }
  };
  var createWorker = function() {
    function ImageWorkerServer() {
      this.items = /* @__PURE__ */ new Map();
      var t = this;
      onmessage = function(e) {
        t._receiveMessage(e);
      };
    }
    ImageWorkerServer.isPathAbsolute = function(path) {
      return /^(?:\/|[a-z]+:\/\/)/.test(path) || path.substr(0, 5) == "data:";
    };
    ImageWorkerServer.prototype._receiveMessage = function(e) {
      if (e.data.type === "config") {
        this.config = e.data.config;
        var base = this.config.path;
        var hasHashPath = /#.*?\//;
        if (hasHashPath.test(base)) {
          base = base.replace(/#.*$/, "");
        }
        var parts = base.split("/");
        parts.pop();
        this._relativeBase = parts.join("/") + "/";
      } else if (e.data.type === "add") {
        this.add(e.data.id, e.data.src);
      } else if (e.data.type === "cancel") {
        this.cancel(e.data.id);
      }
    };
    ImageWorkerServer.prototype.add = function(id, src) {
      if (!ImageWorkerServer.isPathAbsolute(src)) {
        src = this._relativeBase + src;
      }
      if (src.substr(0, 2) === "//") {
        src = this.config.protocol + src;
      }
      var item = new ImageWorkerServerItem(id, src);
      var t = this;
      item.onFinish = function(result) {
        t.finish(item, result);
      };
      item.onError = function(info) {
        t.error(item, info);
      };
      this.items.set(id, item);
      item.start();
    };
    ImageWorkerServer.prototype.cancel = function(id) {
      var item = this.items.get(id);
      if (item) {
        item.cancel();
        this.items.delete(id);
      }
    };
    ImageWorkerServer.prototype.finish = function(item, { imageBitmap, hasAlphaChannel }) {
      postMessage({
        type: "data",
        id: item.id,
        info: {
          imageBitmap,
          hasAlphaChannel
        }
      }, [imageBitmap]);
      this.items.delete(item.id);
    };
    ImageWorkerServer.prototype.error = function(item, { type, message }) {
      postMessage({
        type: "error",
        id: item.id,
        info: {
          type,
          message
        }
      });
      this.items.delete(item.id);
    };
    ImageWorkerServer.isWPEBrowser = function() {
      return navigator.userAgent.indexOf("WPE") !== -1;
    };
    function ImageWorkerServerItem(id, src) {
      this._onError = void 0;
      this._onFinish = void 0;
      this._id = id;
      this._src = src;
      this._xhr = void 0;
      this._mimeType = void 0;
      this._canceled = false;
    }
    Object.defineProperty(ImageWorkerServerItem.prototype, "id", {
      get: function() {
        return this._id;
      }
    });
    Object.defineProperty(ImageWorkerServerItem.prototype, "onFinish", {
      get: function() {
        return this._onFinish;
      },
      set: function(f) {
        this._onFinish = f;
      }
    });
    Object.defineProperty(ImageWorkerServerItem.prototype, "onError", {
      get: function() {
        return this._onError;
      },
      set: function(f) {
        this._onError = f;
      }
    });
    ImageWorkerServerItem.prototype.start = function() {
      this._xhr = new XMLHttpRequest();
      this._xhr.open("GET", this._src, true);
      this._xhr.responseType = "blob";
      var t = this;
      this._xhr.onerror = function(oEvent) {
        t.error({ type: "connection", message: "Connection error" });
      };
      this._xhr.onload = function(oEvent) {
        var blob = t._xhr.response;
        t._mimeType = blob.type;
        t._createImageBitmap(blob);
      };
      this._xhr.send();
    };
    ImageWorkerServerItem.prototype._createImageBitmap = function(blob) {
      var t = this;
      createImageBitmap(blob, { premultiplyAlpha: "premultiply", colorSpaceConversion: "none", imageOrientation: "none" }).then(function(imageBitmap) {
        t.finish({
          imageBitmap,
          hasAlphaChannel: t._hasAlphaChannel()
        });
      }).catch(function(e) {
        t.error({ type: "parse", message: "Error parsing image data" });
      });
    };
    ImageWorkerServerItem.prototype._hasAlphaChannel = function() {
      if (ImageWorkerServer.isWPEBrowser()) {
        return true;
      } else {
        return this._mimeType.indexOf("image/png") !== -1;
      }
    };
    ImageWorkerServerItem.prototype.cancel = function() {
      if (this._canceled) return;
      if (this._xhr) {
        this._xhr.abort();
      }
      this._canceled = true;
    };
    ImageWorkerServerItem.prototype.error = function(type, message) {
      if (!this._canceled && this._onError) {
        this._onError({ type, message });
      }
    };
    ImageWorkerServerItem.prototype.finish = function(info) {
      if (!this._canceled && this._onFinish) {
        this._onFinish(info);
      }
    };
    var worker = new ImageWorkerServer();
  };

  // node_modules/@lightningjs/core/dist/src/platforms/browser/WebPlatform.mjs
  var WebPlatform = class {
    init(stage2) {
      this.stage = stage2;
      this._looping = false;
      this._awaitingLoop = false;
      this._loopHandler = null;
      this._idleLoopCounter = 0;
      this._idleLoopDelay = 60;
      this._onIdle = false;
      if (this.stage.getOption("useImageWorker")) {
        if (!window.createImageBitmap || !window.Worker) {
          console.warn("[Lightning] Can't use image worker because browser does not have createImageBitmap and Web Worker support");
        } else {
          this._imageWorker = new ImageWorker();
        }
      }
      this._registerVisibilityChangeHandler();
    }
    destroy() {
      if (this._imageWorker) {
        this._imageWorker.destroy();
      }
      clearInterval(this._loopHandler);
      this._removeKeyHandler();
      this._removeClickHandler();
      this._removeHoverHandler();
      this._removeScrollWheelHandler();
      this._removeVisibilityChangeHandler();
      this.stage = null;
      delete this.stage;
    }
    startLoop() {
      this._looping = true;
      if (!this._awaitingLoop) {
        this.loop();
      }
    }
    stopLoop() {
      this._looping = false;
    }
    switchLoop() {
      if (this._onIdle === false) {
        this._onIdle = true;
        this.stage.onIdle();
      }
      if (this._idleLoopCounter < this._idleLoopDelay) {
        this._idleLoopCounter++;
        return;
      }
      if (!this.stage.ctx.hasRenderUpdates()) {
        this.stopLoop();
        this._loopHandler = setInterval(() => {
          this.stage.updateFrame();
          this.stage.idleFrame();
          if (this.stage.ctx.hasRenderUpdates()) {
            clearInterval(this._loopHandler);
            this.startLoop();
          }
          ;
        }, 1e3 / 60);
      } else {
        this._idleLoopCounter = 0;
      }
    }
    loop() {
      let self2 = this;
      let lp = function() {
        self2._awaitingLoop = false;
        self2._onIdle = false;
        if (self2._looping) {
          self2.stage.updateFrame();
          if (self2.stage.getOption("pauseRafLoopOnIdle")) {
            self2.switchLoop();
          }
          self2.stage.renderFrame();
          requestAnimationFrame(lp);
          self2._awaitingLoop = true;
        }
      };
      requestAnimationFrame(lp);
    }
    uploadCompressedGlTexture(gl, textureSource, source, options) {
      const view = !source.pvr ? new DataView(source.mipmaps[0]) : source.mipmaps[0];
      gl.compressedTexImage2D(
        gl.TEXTURE_2D,
        0,
        source.glInternalFormat,
        source.pixelWidth,
        source.pixelHeight,
        0,
        view
      );
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    }
    uploadGlTexture(gl, textureSource, source, options) {
      if (source instanceof ImageData || source instanceof HTMLImageElement || source instanceof HTMLVideoElement || window.ImageBitmap && source instanceof ImageBitmap) {
        gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
      } else if (source instanceof HTMLCanvasElement) {
        if (Utils.isZiggo || this.stage.getOption("forceTxCanvasSource")) {
          gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
        } else if (source.width > 0 && source.height > 0) {
          const ctx = source.getContext("2d");
          gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, ctx.getImageData(0, 0, source.width, source.height));
        }
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, textureSource.w, textureSource.h, 0, options.format, options.type, source);
      }
    }
    /**
     * KTX File format specification
     * https://www.khronos.org/registry/KTX/specs/1.0/ktxspec_v1.html
     **/
    handleKtxLoad(cb, src) {
      var self2 = this;
      return function() {
        var arraybuffer = this.response;
        var view = new DataView(arraybuffer);
        var targetIdentifier = 3632701469;
        if (targetIdentifier !== view.getUint32(0) + view.getUint32(4) + view.getUint32(8)) {
          cb("Parsing failed: identifier ktx mismatch:", src);
        }
        var littleEndian = view.getUint32(12) === 16909060 ? true : false;
        var data = {
          glType: view.getUint32(16, littleEndian),
          glTypeSize: view.getUint32(20, littleEndian),
          glFormat: view.getUint32(24, littleEndian),
          glInternalFormat: view.getUint32(28, littleEndian),
          glBaseInternalFormat: view.getUint32(32, littleEndian),
          pixelWidth: view.getUint32(36, littleEndian),
          pixelHeight: view.getUint32(40, littleEndian),
          pixelDepth: view.getUint32(44, littleEndian),
          numberOfArrayElements: view.getUint32(48, littleEndian),
          numberOfFaces: view.getUint32(52, littleEndian),
          numberOfMipmapLevels: view.getUint32(56, littleEndian),
          bytesOfKeyValueData: view.getUint32(60, littleEndian),
          kvps: [],
          mipmaps: [],
          get width() {
            return this.pixelWidth;
          },
          get height() {
            return this.pixelHeight;
          }
        };
        const props = (obj) => {
          const p = [];
          for (let v in obj) {
            p.push(obj[v]);
          }
          return p;
        };
        const formats = Object.values(self2.stage.renderer.getCompressedTextureExtensions()).filter((obj) => obj != null).map((obj) => props(obj)).reduce((prev, current) => prev.concat(current));
        if (!formats.includes(data.glInternalFormat)) {
          console.warn("[Lightning] Unrecognized texture extension format:", src, data.glInternalFormat, self2.stage.renderer.getCompressedTextureExtensions());
        }
        var offset = 64;
        offset += data.bytesOfKeyValueData;
        for (var i = 0; i < data.numberOfMipmapLevels; i++) {
          var imageSize = view.getUint32(offset);
          offset += 4;
          data.mipmaps.push(view.buffer.slice(offset, imageSize));
          offset += imageSize;
        }
        cb(null, {
          source: data,
          renderInfo: { src, compressed: true }
        });
      };
    }
    handlePvrLoad(cb, src) {
      return function() {
        const pvrHeaderLength = 13;
        const pvrFormatEtc1 = 36196;
        const pvrWidth = 7;
        const pvrHeight = 6;
        const pvrMipmapCount = 11;
        const pvrMetadata = 12;
        const arrayBuffer = this.response;
        const header = new Int32Array(arrayBuffer, 0, pvrHeaderLength);
        const dataOffset = header[pvrMetadata] + 52;
        const pvrtcData = new Uint8Array(arrayBuffer, dataOffset);
        var data = {
          glInternalFormat: pvrFormatEtc1,
          pixelWidth: header[pvrWidth],
          pixelHeight: header[pvrHeight],
          numberOfMipmapLevels: header[pvrMipmapCount],
          mipmaps: [],
          pvr: true,
          get width() {
            return this.pixelWidth;
          },
          get height() {
            return this.pixelHeight;
          }
        };
        let offset = 0;
        let width = data.pixelWidth;
        let height = data.pixelHeight;
        for (var i = 0; i < data.numberOfMipmapLevels; i++) {
          const level = (width + 3 >> 2) * (height + 3 >> 2) * 8;
          const view = new Uint8Array(arrayBuffer, pvrtcData.byteOffset + offset, level);
          data.mipmaps.push(view);
          offset += level;
          width = width >> 1;
          height = height >> 1;
        }
        cb(null, {
          source: data,
          renderInfo: { src, compressed: true }
        });
      };
    }
    loadSrcTexture({ src, hasAlpha }, cb) {
      let cancelCb = void 0;
      let isPng = src.toLowerCase().indexOf(".png") >= 0 || src.substr(0, 21) == "data:image/png;base64";
      let isKtx = src.indexOf(".ktx") >= 0;
      let isPvr = src.indexOf(".pvr") >= 0;
      if (isKtx || isPvr) {
        let request = new XMLHttpRequest();
        request.addEventListener(
          "load",
          isKtx ? this.handleKtxLoad(cb, src) : this.handlePvrLoad(cb, src)
        );
        request.open("GET", src);
        request.responseType = "arraybuffer";
        request.send();
        cancelCb = function() {
          request.abort();
        };
      } else if (this._imageWorker) {
        if (typeof src !== "string") {
          return cb("Invalid image URL");
        }
        const separatorPos = src.indexOf("//");
        if (separatorPos !== 0 && separatorPos !== 5 && separatorPos !== 6) {
          return cb("Invalid image URL");
        }
        const image = this._imageWorker.create(src);
        image.onError = function(err) {
          return cb("Image load error");
        };
        image.onLoad = function({ imageBitmap, hasAlphaChannel }) {
          cb(null, {
            source: imageBitmap,
            renderInfo: { src, compressed: false },
            hasAlpha: hasAlphaChannel,
            premultiplyAlpha: true
          });
        };
        cancelCb = function() {
          image.cancel();
        };
      } else {
        let image = new Image();
        if (!(src.substr(0, 5) == "data:") && !Utils.isPS4) {
          image.crossOrigin = "Anonymous";
        }
        image.onerror = function(err) {
          if (image.src) {
            return cb("Image load error");
          }
        };
        image.onload = function() {
          cb(null, {
            source: image,
            renderInfo: { src, compressed: false },
            hasAlpha: isPng || hasAlpha
          });
        };
        image.src = src;
        cancelCb = function() {
          image.onerror = null;
          image.onload = null;
          image.removeAttribute("src");
        };
      }
      return cancelCb;
    }
    createWebGLContext(w, h) {
      let canvas = this.stage.getOption("canvas") || document.createElement("canvas");
      if (w && h) {
        canvas.width = w;
        canvas.height = h;
      }
      let opts = {
        alpha: true,
        antialias: false,
        premultipliedAlpha: true,
        stencil: true,
        preserveDrawingBuffer: false
      };
      let gl = canvas.getContext("webgl", opts) || canvas.getContext("experimental-webgl", opts) || canvas.getContext("webgl2", opts);
      if (!gl) {
        throw new Error("This browser does not support webGL.");
      }
      return gl;
    }
    createCanvasContext(w, h) {
      let canvas = this.stage.getOption("canvas") || document.createElement("canvas");
      if (w && h) {
        canvas.width = w;
        canvas.height = h;
      }
      let c2d = canvas.getContext("2d");
      if (!c2d) {
        throw new Error("This browser does not support 2d canvas.");
      }
      return c2d;
    }
    getHrTime() {
      return window.performance ? window.performance.now() : (/* @__PURE__ */ new Date()).getTime();
    }
    getDrawingCanvas() {
      return document.createElement("canvas");
    }
    getTextureOptionsForDrawingCanvas(canvas) {
      let options = {};
      options.source = canvas;
      return options;
    }
    nextFrame(changes) {
    }
    registerKeydownHandler(keyhandler) {
      this._keydownListener = (e) => {
        keyhandler(e);
      };
      window.addEventListener("keydown", this._keydownListener);
    }
    registerKeyupHandler(keyhandler) {
      this._keyupListener = (e) => {
        keyhandler(e);
      };
      window.addEventListener("keyup", this._keyupListener);
    }
    _removeKeyHandler() {
      if (this._keydownListener) {
        window.removeEventListener("keydown", this._keydownListener);
      }
      if (this._keyupListener) {
        window.removeEventListener("keyup", this._keyupListener);
      }
    }
    registerClickHandler(clickHandler) {
      this._clickListener = (e) => {
        clickHandler(e);
      };
      window.addEventListener("mousedown", this._clickListener);
    }
    _removeClickHandler() {
      if (this._clickListener) {
        window.removeEventListener("mousedown", this._clickListener);
      }
    }
    registerHoverHandler(hoverHandler) {
      this._hoverListener = (e) => {
        hoverHandler(e);
      };
      window.addEventListener("mousemove", this._hoverListener);
    }
    _removeHoverHandler() {
      if (this._hoverListener) {
        window.removeEventListener("mousemove", this._hoverListener);
      }
    }
    registerScrollWheelHandler(registerScrollWheelHandler) {
      this._scrollWheelListener = (e) => {
        registerScrollWheelHandler(e);
      };
      window.addEventListener("wheel", this._scrollWheelListener);
    }
    _removeScrollWheelHandler() {
      if (this._scrollWheelListener) {
        window.removeEventListener("wheel", this._scrollWheelListener);
      }
    }
    /**
     * Fix for issue reported at: https://github.com/WebPlatformForEmbedded/WPEWebKit/issues/882
     */
    _registerVisibilityChangeHandler() {
      this._visibilityChangeHandler = () => {
        if (document.visibilityState === "visible") {
          this.stage.root.core.setHasRenderUpdates(2);
          this.stage.renderFrame();
        }
      };
      document.addEventListener("visibilitychange", this._visibilityChangeHandler);
    }
    _removeVisibilityChangeHandler() {
      if (this._visibilityChangeHandler) {
        document.removeEventListener("visibilitychange", this._visibilityChangeHandler);
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/platforms/PlatformLoader.mjs
  var PlatformLoader = class {
    static load(options) {
      if (options.platform) {
        return options.platform;
      } else {
        return WebPlatform;
      }
    }
  };

  // node_modules/@lightningjs/core/dist/src/tools/WebGLStateManager.mjs
  var Utils2 = class _Utils {
    static isFunction(value) {
      return typeof value === "function";
    }
    static isNumber(value) {
      return typeof value === "number";
    }
    static isInteger(value) {
      return typeof value === "number" && value % 1 === 0;
    }
    static isBoolean(value) {
      return value === true || value === false;
    }
    static isString(value) {
      return typeof value == "string";
    }
    static isObject(value) {
      let type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    static isPlainObject(value) {
      let type = typeof value;
      return !!value && type == "object";
    }
    static isObjectLiteral(value) {
      return typeof value === "object" && value && value.constructor === Object;
    }
    static getArrayIndex(index, arr) {
      return _Utils.getModuloIndex(index, arr.length);
    }
    static equalValues(v1, v2) {
      if (typeof v1 !== typeof v2) return false;
      if (_Utils.isObjectLiteral(v1)) {
        return _Utils.isObjectLiteral(v2) && _Utils.equalObjectLiterals(v1, v2);
      } else if (Array.isArray(v1)) {
        return Array.isArray(v2) && _Utils.equalArrays(v1, v2);
      } else {
        return v1 === v2;
      }
    }
    static equalObjectLiterals(obj1, obj2) {
      let keys1 = Object.keys(obj1);
      let keys2 = Object.keys(obj2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (let i = 0, n = keys1.length; i < n; i++) {
        const k1 = keys1[i];
        const k2 = keys2[i];
        if (k1 !== k2) {
          return false;
        }
        const v1 = obj1[k1];
        const v2 = obj2[k2];
        if (!_Utils.equalValues(v1, v2)) {
          return false;
        }
      }
      return true;
    }
    static equalArrays(v1, v2) {
      if (v1.length !== v2.length) {
        return false;
      }
      for (let i = 0, n = v1.length; i < n; i++) {
        if (!this.equalValues(v1[i], v2[i])) {
          return false;
        }
      }
      return true;
    }
  };
  var WebGLState = class _WebGLState {
    constructor(id, gl) {
      this._id = id;
      this._gl = gl;
      this._program = void 0;
      this._buffers = /* @__PURE__ */ new Map();
      this._framebuffers = /* @__PURE__ */ new Map();
      this._renderbuffers = /* @__PURE__ */ new Map();
      this._vertexAttribs = new Array(16);
      this._nonDefaultFlags = /* @__PURE__ */ new Set();
      this._settings = /* @__PURE__ */ new Map();
      this._textures = new Array(8);
      this._maxTexture = 0;
      this._activeTexture = gl.TEXTURE0;
      this._pixelStorei = new Array(5);
    }
    _getDefaultFlag(cap) {
      return cap === this._gl.DITHER;
    }
    setFlag(cap, v) {
      const def = this._getDefaultFlag(cap);
      if (v === def) {
        return this._nonDefaultFlags.delete(cap);
      } else {
        if (!this._nonDefaultFlags.has(cap)) {
          this._nonDefaultFlags.add(cap);
          return true;
        } else {
          return false;
        }
      }
    }
    setBuffer(target, buffer) {
      const change = this._buffers.get(target) !== buffer;
      this._buffers.set(target, buffer);
      if (change && target === this._gl.ARRAY_BUFFER) {
        this._vertexAttribs = [];
      }
      return change;
    }
    setFramebuffer(target, buffer) {
      const change = this._framebuffers.get(target) !== buffer;
      this._framebuffers.set(target, buffer);
      return change;
    }
    setRenderbuffer(target, buffer) {
      const change = this._renderbuffers.get(target) !== buffer;
      this._renderbuffers.set(target, buffer);
      return change;
    }
    setProgram(program) {
      const change = this._program !== program;
      this._program = program;
      return change;
    }
    setSetting(func, v) {
      const s = this._settings.get(func);
      const change = !s || !Utils2.equalValues(s, v);
      this._settings.set(func, v);
      return change;
    }
    disableVertexAttribArray(index) {
      const va = this._vertexAttribs[index];
      if (va && va[5]) {
        va[5] = false;
        return true;
      }
      return false;
    }
    enableVertexAttribArray(index) {
      const va = this._vertexAttribs[index];
      if (va) {
        if (!va[0]) {
          va[0] = true;
          return true;
        }
      } else {
        this._vertexAttribs[index] = [0, 0, 0, 0, 0, true];
        return true;
      }
      return false;
    }
    vertexAttribPointer(index, props) {
      let va = this._vertexAttribs[index];
      let equal = false;
      if (va) {
        equal = va[0] === props[0] && va[1] === props[1] && va[2] === props[2] && va[3] === props[3] && va[4] === props[4];
      }
      if (equal) {
        return false;
      } else {
        props[5] = va ? va[5] : false;
        return true;
      }
    }
    setActiveTexture(texture) {
      const changed = this._activeTexture !== texture;
      this._activeTexture = texture;
      return changed;
    }
    bindTexture(target, texture) {
      const activeIndex = _WebGLState._getTextureIndex(this._activeTexture);
      this._maxTexture = Math.max(this._maxTexture, activeIndex + 1);
      const current = this._textures[activeIndex];
      const targetIndex = _WebGLState._getTextureTargetIndex(target);
      if (current) {
        if (current[targetIndex] === texture) {
          return false;
        }
        current[targetIndex] = texture;
        return true;
      } else {
        if (texture) {
          this._textures[activeIndex] = [];
          this._textures[activeIndex][targetIndex] = texture;
          return true;
        } else {
          return false;
        }
      }
    }
    setPixelStorei(pname, param) {
      const i = _WebGLState._getPixelStoreiIndex(pname);
      const change = !Utils2.equalValues(this._pixelStorei[i], param);
      this._pixelStorei[i] = param;
      return change;
    }
    migrate(s) {
      const t = this;
      this._migrateFlags(t, s);
      if (s._program !== t._program) {
        this._gl._useProgram(s._program);
      }
      this._migrateFramebuffers(t, s);
      this._migrateRenderbuffers(t, s);
      const buffersChanged = this._migrateBuffers(t, s);
      this._migrateAttributes(t, s, buffersChanged);
      this._migrateFlags(t, s);
      this._migrateSettings(t, s);
      this._migratePixelStorei(t, s);
      this._migrateTextures(t, s);
    }
    _migratePixelStorei(t, s) {
      for (let i = 0, n = t._pixelStorei.length; i < n; i++) {
        if (t._pixelStorei[i] !== s._pixelStorei[i]) {
          const value = s._pixelStorei[i] !== void 0 ? s._pixelStorei[i] : _WebGLState._getDefaultPixelStoreiByIndex(i);
          this._gl._pixelStorei(_WebGLState._getPixelStoreiByIndex(i), value);
        }
      }
    }
    _migrateTextures(t, s) {
      const max = Math.max(t._maxTexture, s._maxTexture);
      let activeTexture = t._activeTexture;
      for (let i = 0; i < max; i++) {
        const sTargets = s._textures[i];
        const tTargets = t._textures[i];
        const textureNumb = _WebGLState._getTextureByIndex(i);
        const targetMax = Math.max(tTargets ? tTargets.length : 0, sTargets ? sTargets.length : 0);
        for (let j = 0, n = targetMax; j < n; j++) {
          const target = _WebGLState._getTextureTargetByIndex(j);
          if (activeTexture !== textureNumb) {
            this._gl._activeTexture(textureNumb);
            activeTexture = textureNumb;
          }
          const texture = sTargets && sTargets[j] || null;
          this._gl._bindTexture(target, texture);
        }
      }
      if (s._activeTexture !== activeTexture) {
        this._gl._activeTexture(s._activeTexture);
      }
    }
    _migrateBuffers(t, s) {
      s._buffers.forEach((framebuffer, target) => {
        if (t._buffers.get(target) !== framebuffer) {
          this._gl._bindBuffer(target, framebuffer);
        }
      });
      t._buffers.forEach((buffer, target) => {
        const b = s._buffers.get(target);
        if (b === void 0) {
          this._gl._bindBuffer(target, null);
        }
      });
      return s._buffers.get(this._gl.ARRAY_BUFFER) !== t._buffers.get(this._gl.ARRAY_BUFFER);
    }
    _migrateFramebuffers(t, s) {
      s._framebuffers.forEach((framebuffer, target) => {
        if (t._framebuffers.get(target) !== framebuffer) {
          this._gl._bindFramebuffer(target, framebuffer);
        }
      });
      t._framebuffers.forEach((framebuffer, target) => {
        const fb = s._framebuffers.get(target);
        if (fb === void 0) {
          this._gl._bindFramebuffer(target, null);
        }
      });
    }
    _migrateRenderbuffers(t, s) {
      s._renderbuffers.forEach((renderbuffer, target) => {
        if (t._renderbuffers.get(target) !== renderbuffer) {
          this._gl._bindRenderbuffer(target, renderbuffer);
        }
      });
      t._renderbuffers.forEach((renderbuffer, target) => {
        const fb = s._renderbuffers.get(target);
        if (fb === void 0) {
          this._gl._bindRenderbuffer(target, null);
        }
      });
    }
    _migrateAttributes(t, s, buffersChanged) {
      if (!buffersChanged) {
        t._vertexAttribs.forEach((attrib, index) => {
          if (!s._vertexAttribs[index]) {
            this._gl._disableVertexAttribArray(index);
          }
        });
        s._vertexAttribs.forEach((attrib, index) => {
          this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[4]);
          if (attrib[5]) {
            this._gl._enableVertexAttribArray(index);
          } else {
            this._gl._disableVertexAttribArray(index);
          }
        });
      } else {
        s._vertexAttribs.forEach((attrib, index) => {
          if (attrib[0]) {
            this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[3], attrib[4]);
          }
          if (attrib[5]) {
            this._gl._enableVertexAttribArray(index);
          }
        });
      }
    }
    _migrateSettings(t, s) {
      const defaults = this.constructor.getDefaultSettings();
      t._settings.forEach((value, func) => {
        const name = func.name || func.xname;
        if (!s._settings.has(func)) {
          let args = defaults.get(name);
          if (Utils2.isFunction(args)) {
            args = args(this._gl);
          }
          s._settings.set(func, args);
          func.apply(this._gl, args);
        }
      });
      s._settings.forEach((value, func) => {
        const tValue = t._settings.get(func);
        if (!tValue || !Utils2.equalValues(tValue, value)) {
          func.apply(this._gl, value);
        }
      });
    }
    _migrateFlags(t, s) {
      t._nonDefaultFlags.forEach((setting) => {
        if (!s._nonDefaultFlags.has(setting)) {
          if (this._getDefaultFlag(setting)) {
            this._gl._enable(setting);
          } else {
            this._gl._disable(setting);
          }
        }
      });
      s._nonDefaultFlags.forEach((setting) => {
        if (!t._nonDefaultFlags.has(setting)) {
          if (this._getDefaultFlag(setting)) {
            this._gl._disable(setting);
          } else {
            this._gl._enable(setting);
          }
        }
      });
    }
    static getDefaultSettings() {
      if (!this._defaultSettings) {
        this._defaultSettings = /* @__PURE__ */ new Map();
        const d = this._defaultSettings;
        const g2 = WebGLRenderingContext.prototype;
        d.set("viewport", function(gl) {
          return [0, 0, gl.canvas.width, gl.canvas.height];
        });
        d.set("scissor", function(gl) {
          return [0, 0, gl.canvas.width, gl.canvas.height];
        });
        d.set("blendColor", [0, 0, 0, 0]);
        d.set("blendEquation", [g2.FUNC_ADD]);
        d.set("blendEquationSeparate", [g2.FUNC_ADD, g2.FUNC_ADD]);
        d.set("blendFunc", [g2.ONE, g2.ZERO]);
        d.set("blendFuncSeparate", [g2.ONE, g2.ZERO, g2.ONE, g2.ZERO]);
        d.set("clearColor", [0, 0, 0, 0]);
        d.set("clearDepth", [1]);
        d.set("clearStencil", [0]);
        d.set("colorMask", [true, true, true, true]);
        d.set("cullFace", [g2.BACK]);
        d.set("depthFunc", [g2.LESS]);
        d.set("depthMask", [true]);
        d.set("depthRange", [0, 1]);
        d.set("frontFace", [g2.CCW]);
        d.set("lineWidth", [1]);
        d.set("polygonOffset", [0, 0]);
        d.set("sampleCoverage", [1, false]);
        d.set("stencilFunc", [g2.ALWAYS, 0, 1]);
        d.set("_stencilFuncSeparateFront", [g2.ALWAYS, 0, 1]);
        d.set("_stencilFuncSeparateBack", [g2.ALWAYS, 0, 1]);
        d.set("_stencilFuncSeparateFrontAndBack", [g2.ALWAYS, 0, 1]);
        d.set("stencilMask", [1]);
        d.set("_stencilMaskSeparateFront", [1]);
        d.set("_stencilMaskSeparateBack", [1]);
        d.set("_stencilMaskSeparateFrontAndBack", [1]);
        d.set("stencilOp", [g2.KEEP, g2.KEEP, g2.KEEP]);
        d.set("_stencilOpSeparateFront", [g2.KEEP, g2.KEEP, g2.KEEP]);
        d.set("_stencilOpSeparateBack", [g2.KEEP, g2.KEEP, g2.KEEP]);
        d.set("_stencilOpSeparateFrontAndBack", [g2.KEEP, g2.KEEP, g2.KEEP]);
        d.set("vertexAttrib1f", []);
        d.set("vertexAttrib1fv", []);
        d.set("vertexAttrib2f", []);
        d.set("vertexAttrib2fv", []);
        d.set("vertexAttrib3f", []);
        d.set("vertexAttrib3fv", []);
        d.set("vertexAttrib4f", []);
        d.set("vertexAttrib4fv", []);
      }
      return this._defaultSettings;
    }
    static _getTextureTargetIndex(target) {
      switch (target) {
        case 3553:
          return 0;
        case 34067:
          return 1;
        default:
          throw new Error("Unknown texture target: " + target);
      }
    }
    static _getTextureTargetByIndex(index) {
      if (!this._textureTargetIndices) {
        this._textureTargetIndices = [3553, 34067];
      }
      return this._textureTargetIndices[index];
    }
    static _getTextureIndex(index) {
      return index - 33984;
    }
    static _getTextureByIndex(index) {
      return index + 33984;
    }
    static _getPixelStoreiIndex(pname) {
      switch (pname) {
        case 3333:
          return 0;
        case 3317:
          return 1;
        case 37440:
          return 2;
        case 37441:
          return 3;
        case 37443:
          return 4;
        //@todo: support WebGL2 properties, see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei
        case 37445:
          return 5;
        default:
          throw new Error("Unknown pixelstorei: " + pname);
      }
    }
    static _getPixelStoreiByIndex(index) {
      if (!this._pixelStoreiIndices) {
        this._pixelStoreiIndices = [3333, 3317, 37440, 37441, 37443];
      }
      return this._pixelStoreiIndices[index];
    }
    static _getDefaultPixelStoreiByIndex(index) {
      if (!this._pixelStoreiDefaults) {
        this._pixelStoreiDefaults = [4, 4, false, false, WebGLRenderingContext.prototype.BROWSER_DEFAULT_WEBGL];
      }
      return this._pixelStoreiDefaults[index];
    }
  };
  var WebGLStateManager = class _WebGLStateManager {
    _initStateManager(id = "default") {
      this._states = {};
      this._state = this._getState(id);
    }
    _getState(id) {
      if (!this._states[id]) {
        this._states[id] = new WebGLState(id, this);
      }
      return this._states[id];
    }
    switchState(id = "default") {
      if (this._state._id !== id) {
        const newState = this._getState(id);
        this._state.migrate(newState);
        this._state = newState;
      }
    }
    $useProgram(program) {
      if (this._state.setProgram(program))
        this._useProgram(program);
    }
    $bindBuffer(target, fb) {
      if (this._state.setBuffer(target, fb))
        this._bindBuffer(target, fb);
    }
    $bindFramebuffer(target, fb) {
      if (this._state.setFramebuffer(target, fb))
        this._bindFramebuffer(target, fb);
    }
    $bindRenderbuffer(target, fb) {
      if (this._state.setRenderbuffer(target, fb))
        this._bindRenderbuffer(target, fb);
    }
    $enable(cap) {
      if (this._state.setFlag(cap, true))
        this._enable(cap);
    }
    $disable(cap) {
      if (this._state.setFlag(cap, false))
        this._disable(cap);
    }
    $viewport(x, y, w, h) {
      if (this._state.setSetting(this._viewport, [x, y, w, h]))
        this._viewport(x, y, w, h);
    }
    $scissor(x, y, w, h) {
      if (this._state.setSetting(this._scissor, [x, y, w, h]))
        this._scissor(x, y, w, h);
    }
    $disableVertexAttribArray(index) {
      if (this._state.disableVertexAttribArray(index))
        this._disableVertexAttribArray(index);
    }
    $enableVertexAttribArray(index) {
      if (this._state.enableVertexAttribArray(index))
        this._enableVertexAttribArray(index);
    }
    $vertexAttribPointer(index, size, type, normalized, stride, offset) {
      if (this._state.vertexAttribPointer(index, [size, type, normalized, stride, offset]))
        this._vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
    $activeTexture(texture) {
      if (this._state.setActiveTexture(texture))
        this._activeTexture(texture);
    }
    $bindTexture(target, texture) {
      if (this._state.bindTexture(target, texture))
        this._bindTexture(target, texture);
    }
    $pixelStorei(pname, param) {
      if (this._state.setPixelStorei(pname, param)) {
        this._pixelStorei(pname, param);
      }
    }
    $stencilFuncSeparate(face, func, ref, mask) {
      let f;
      switch (face) {
        case this.FRONT:
          f = this._stencilFuncSeparateFront;
          break;
        case this.BACK:
          f = this._stencilFuncSeparateBack;
          break;
        case this.FRONT_AND_BACK:
          f = this._stencilFuncSeparateFrontAndBack;
          break;
      }
      if (this._state.setSetting(f, [func, ref, mask]))
        f.apply(this, [func, ref, mask]);
    }
    _stencilFuncSeparateFront(func, ref, mask) {
      this._stencilFuncSeparate(this.FRONT, func, ref, mask);
    }
    _stencilFuncSeparateBack(func, ref, mask) {
      this._stencilFuncSeparate(this.BACK, func, ref, mask);
    }
    _stencilFuncSeparateFrontAndBack(func, ref, mask) {
      this._stencilFuncSeparate(this.FRONT_AND_BACK, func, ref, mask);
    }
    $stencilMaskSeparate(face, mask) {
      let f;
      switch (face) {
        case this.FRONT:
          f = this._stencilMaskSeparateFront;
          break;
        case this.BACK:
          f = this._stencilMaskSeparateBack;
          break;
        case this.FRONT_AND_BACK:
          f = this._stencilMaskSeparateFrontAndBack;
          break;
      }
      if (this._state.setSetting(f, [mask]))
        f.apply(this, [mask]);
    }
    _stencilMaskSeparateFront(mask) {
      this._stencilMaskSeparate(this.FRONT, mask);
    }
    _stencilMaskSeparateBack(mask) {
      this._stencilMaskSeparate(this.BACK, mask);
    }
    _stencilMaskSeparateFrontAndBack(mask) {
      this._stencilMaskSeparate(this.FRONT_AND_BACK, mask);
    }
    $stencilOpSeparate(face, fail, zfail, zpass) {
      let f;
      switch (face) {
        case this.FRONT:
          f = this._stencilOpSeparateFront;
          break;
        case this.BACK:
          f = this._stencilOpSeparateBack;
          break;
        case this.FRONT_AND_BACK:
          f = this._stencilOpSeparateFrontAndBack;
          break;
      }
      if (this._state.setSetting(f, [fail, zfail, zpass]))
        f.apply(this, [fail, zfail, zpass]);
    }
    _stencilOpSeparateFront(fail, zfail, zpass) {
      this._stencilOpSeparate(this.FRONT, fail, zfail, zpass);
    }
    _stencilOpSeparateBack(fail, zfail, zpass) {
      this._stencilOpSeparate(this.BACK, fail, zfail, zpass);
    }
    _stencilOpSeparateFrontAndBack(fail, zfail, zpass) {
      this._stencilOpSeparate(this.FRONT_AND_BACK, fail, zfail, zpass);
    }
    $blendColor(red, green, blue, alpha) {
      if (this._state.setSetting(this._blendColor, [red, green, blue, alpha]))
        this._blendColor(red, green, blue, alpha);
    }
    $blendEquation(mode) {
      if (this._state.setSetting(this._blendEquation, [mode]))
        this._blendEquation(mode);
    }
    $blendEquationSeparate(modeRGB, modeAlpha) {
      if (this._state.setSetting(this._blendEquationSeparate, [modeRGB, modeAlpha]))
        this._blendEquationSeparate(modeRGB, modeAlpha);
    }
    $blendFunc(sfactor, dfactor) {
      if (this._state.setSetting(this._blendFunc, [sfactor, dfactor]))
        this._blendFunc(sfactor, dfactor);
    }
    $blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
      if (this._state.setSetting(this._blendFuncSeparate, [srcRGB, dstRGB, srcAlpha, dstAlpha]))
        this._blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    }
    $clearColor(red, green, blue, alpha) {
      if (this._state.setSetting(this._clearColor, [red, green, blue, alpha]))
        this._clearColor(red, green, blue, alpha);
    }
    $clearDepth(depth) {
      if (this._state.setSetting(this._clearDepth, [depth]))
        this._clearDepth(depth);
    }
    $clearStencil(s) {
      if (this._state.setSetting(this._clearStencil, [s]))
        this._clearStencil(s);
    }
    $colorMask(red, green, blue, alpha) {
      if (this._state.setSetting(this._colorMask, [red, green, blue, alpha]))
        this._colorMask(red, green, blue, alpha);
    }
    $cullFace(mode) {
      if (this._state.setSetting(this._cullFace, [mode]))
        this._cullFace(mode);
    }
    $depthFunc(func) {
      if (this._state.setSetting(this._depthFunc, [func]))
        this._depthFunc(func);
    }
    $depthMask(flag) {
      if (this._state.setSetting(this._depthMask, [flag]))
        this._depthMask(flag);
    }
    $depthRange(zNear, zFar) {
      if (this._state.setSetting(this._depthRange, [zNear, zFar]))
        this._depthRange(zNear, zFar);
    }
    $frontFace(mode) {
      if (this._state.setSetting(this._frontFace, [mode]))
        this._frontFace(mode);
    }
    $lineWidth(width) {
      if (this._state.setSetting(this._lineWidth, [width]))
        this._lineWidth(width);
    }
    $polygonOffset(factor, units) {
      if (this._state.setSetting(this._polygonOffset, [factor, units]))
        this._polygonOffset(factor, units);
    }
    $sampleCoverage(value, invert) {
      if (this._state.setSetting(this._sampleCoverage, [value, invert]))
        this._sampleCoverage(value, invert);
    }
    $stencilFunc(func, ref, mask) {
      if (this._state.setSetting(this._stencilFunc, [func, ref, mask]))
        this._stencilFunc(func, ref, mask);
    }
    $stencilMask(mask) {
      if (this._state.setSetting(this._stencilMask, [mask]))
        this._stencilMask(mask);
    }
    $stencilOp(fail, zfail, zpass) {
      if (this._state.setSetting(this._stencilOp, [fail, zfail, zpass]))
        this._stencilOp(fail, zfail, zpass);
    }
    $vertexAttrib1f(indx, x) {
      if (this._state.setSetting(this._vertexAttrib1f, [indx, x]))
        this._vertexAttrib1f(indx, x);
    }
    $vertexAttrib1fv(indx, values) {
      if (this._state.setSetting(this._vertexAttrib1fv, [indx, values]))
        this._vertexAttrib1fv(indx, values);
    }
    $vertexAttrib2f(indx, x, y) {
      if (this._state.setSetting(this._vertexAttrib2f, [indx, x, y]))
        this._vertexAttrib2f(indx, x, y);
    }
    $vertexAttrib2fv(indx, values) {
      if (this._state.setSetting(this._vertexAttrib2fv, [indx, values]))
        this._vertexAttrib2fv(indx, values);
    }
    $vertexAttrib3f(indx, x, y, z) {
      if (this._state.setSetting(this._vertexAttrib3f, [indx, x, y, z]))
        this._vertexAttrib3f(indx, x, y, z);
    }
    $vertexAttrib3fv(indx, values) {
      if (this._state.setSetting(this._vertexAttrib3fv, [indx, values]))
        this._vertexAttrib3fv(indx, values);
    }
    $vertexAttrib4f(indx, x, y, z, w) {
      if (this._state.setSetting(this._vertexAttrib4f, [indx, x, y, z, w]))
        this._vertexAttrib4f(indx, x, y, z, w);
    }
    $vertexAttrib4fv(indx, values) {
      if (this._state.setSetting(this._vertexAttrib4fv, [indx, values]))
        this._vertexAttrib4fv(indx, values);
    }
    /**
     * Sets up the rendering context for context sharing.
     * @param {WebGLRenderingContext} gl
     * @param {string} id
     */
    static enable(gl, id = "default") {
      const names = Object.getOwnPropertyNames(_WebGLStateManager.prototype);
      const WebGLRenderingContextProto = gl.__proto__;
      names.forEach((name) => {
        if (name !== "constructor") {
          const method = _WebGLStateManager.prototype[name];
          if (name.charAt(0) === "$") {
            name = name.substr(1);
          }
          if (gl[name] !== method) {
            if (gl[name]) {
              if (!gl[name].name) {
                gl[name].xname = name;
              }
              gl["_" + name] = gl[name];
            }
            gl[name] = method;
          }
        }
      });
      _WebGLStateManager.prototype._initStateManager.call(gl, id);
      return gl;
    }
  };
  var WebGLStateManager_default = WebGLStateManager;

  // node_modules/@lightningjs/core/dist/src/tree/TextureManager.mjs
  var TextureManager = class {
    constructor(stage2) {
      this.stage = stage2;
      this._usedMemory = 0;
      this._uploadedTextureSources = [];
      this.textureSourceHashmap = /* @__PURE__ */ new Map();
    }
    get usedMemory() {
      return this._usedMemory;
    }
    destroy() {
      for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
        this._nativeFreeTextureSource(this._uploadedTextureSources[i]);
      }
      this.textureSourceHashmap.clear();
      this._usedMemory = 0;
    }
    getReusableTextureSource(id) {
      return this.textureSourceHashmap.get(id);
    }
    getTextureSource(func, id) {
      let textureSource = id ? this.textureSourceHashmap.get(id) : null;
      if (!textureSource) {
        textureSource = new TextureSource(this, func);
        if (id) {
          textureSource.lookupId = id;
          this.textureSourceHashmap.set(id, textureSource);
        }
      }
      return textureSource;
    }
    uploadTextureSource(textureSource, options) {
      if (textureSource.isLoaded()) return;
      this._addMemoryUsage(textureSource.w * textureSource.h);
      const nativeTexture = this._nativeUploadTextureSource(textureSource, options);
      textureSource._nativeTexture = nativeTexture;
      nativeTexture.w = textureSource.w;
      nativeTexture.h = textureSource.h;
      nativeTexture.update = this.stage.frameCounter;
      this._uploadedTextureSources.push(textureSource);
      this.addToLookupMap(textureSource);
      this._updateVramUsage(textureSource, 1);
    }
    _addMemoryUsage(delta) {
      this._usedMemory += delta;
      this.stage.addMemoryUsage(delta);
    }
    _updateVramUsage(textureSource, sign) {
      const nativeTexture = textureSource.nativeTexture;
      var usage;
      if (!Stage.isWebglSupported())
        return;
      if (!textureSource.isLoaded())
        return;
      if (!nativeTexture.hasOwnProperty("bytesPerPixel") || isNaN(nativeTexture.bytesPerPixel))
        return;
      usage = sign * (textureSource.w * textureSource.h * nativeTexture.bytesPerPixel);
      this.stage.addVramUsage(usage, textureSource.hasAlpha);
    }
    addToLookupMap(textureSource) {
      const lookupId = textureSource.lookupId;
      if (lookupId) {
        if (!this.textureSourceHashmap.has(lookupId)) {
          this.textureSourceHashmap.set(lookupId, textureSource);
        }
      }
    }
    gc() {
      this.freeUnusedTextureSources();
    }
    freeUnusedTextureSources() {
      let remainingTextureSources = [];
      for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
        let ts = this._uploadedTextureSources[i];
        if (ts.allowCleanup()) {
          this._freeManagedTextureSource(ts);
        } else {
          remainingTextureSources.push(ts);
        }
      }
      this._uploadedTextureSources = remainingTextureSources;
      this._cleanupLookupMap();
    }
    _freeManagedTextureSource(textureSource) {
      if (textureSource.isLoaded()) {
        this._nativeFreeTextureSource(textureSource);
        this._addMemoryUsage(-textureSource.w * textureSource.h);
        this._updateVramUsage(textureSource, -1);
      }
      textureSource.loadingSince = null;
    }
    _cleanupLookupMap() {
      this.textureSourceHashmap.forEach((textureSource, lookupId) => {
        if (!(textureSource.isLoaded() || textureSource.isLoading()) && !textureSource.isUsed()) {
          this.textureSourceHashmap.delete(lookupId);
        }
      });
    }
    /**
     * Externally free texture source.
     * @param textureSource
     */
    freeTextureSource(textureSource) {
      const index = this._uploadedTextureSources.indexOf(textureSource);
      const managed = index !== -1;
      if (textureSource.isLoaded()) {
        if (managed) {
          this._addMemoryUsage(-textureSource.w * textureSource.h);
          this._uploadedTextureSources.splice(index, 1);
        }
        this._nativeFreeTextureSource(textureSource);
      }
      textureSource.loadingSince = null;
    }
    _nativeUploadTextureSource(textureSource, options) {
      return this.stage.renderer.uploadTextureSource(textureSource, options);
    }
    _nativeFreeTextureSource(textureSource) {
      this.stage.renderer.freeTextureSource(textureSource);
      textureSource.clearNativeTexture();
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/TextureThrottler.mjs
  var TextureThrottler = class _TextureThrottler {
    constructor(stage2) {
      this.stage = stage2;
      this.genericCancelCb = (textureSource) => {
        this._remove(textureSource);
      };
      this._sources = [];
      this._data = [];
    }
    destroy() {
      this._sources = [];
      this._data = [];
      this.stage = null;
      delete this._sources;
      delete this._data;
      delete this.stage;
    }
    processSome() {
      if (this._sources.length) {
        const start2 = Date.now();
        do {
          this._processItem();
        } while (this._sources.length && Date.now() - start2 < _TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME);
      }
    }
    _processItem() {
      const source = this._sources.pop();
      const data = this._data.pop();
      if (source.isLoading()) {
        source.processLoadedSource(data);
      }
    }
    add(textureSource, data) {
      this._sources.push(textureSource);
      this._data.push(data);
    }
    _remove(textureSource) {
      const index = this._sources.indexOf(textureSource);
      if (index >= 0) {
        this._sources.splice(index, 1);
        this._data.splice(index, 1);
      }
    }
  };
  TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME = 10;

  // node_modules/@lightningjs/core/dist/src/tree/core/CoreContext.mjs
  var CoreContext = class {
    constructor(stage2) {
      this.stage = stage2;
      this.root = null;
      this.updateTreeOrder = 0;
      this.renderState = this.stage.renderer.createCoreRenderState(this);
      this.renderExec = this.stage.renderer.createCoreRenderExecutor(this);
      this.renderExec.init();
      this._usedMemory = 0;
      this._renderTexturePool = [];
      this._renderTextureId = 1;
      this._zSorts = [];
      this.renderToTextureCount = 0;
    }
    get usedMemory() {
      return this._usedMemory;
    }
    destroy() {
      this._renderTexturePool.forEach((texture) => this._freeRenderTexture(texture));
      this._usedMemory = 0;
      this.stage = null;
      this.root = null;
      this.renderState = null;
      this.renderExec = null;
      this._renderTexturePool = null;
      this._zSorts = null;
      delete this.stage;
      delete this.root;
      delete this.renderState;
      delete this.renderExec;
      delete this._renderTexturePool;
      delete this._zSorts;
    }
    hasRenderUpdates() {
      return !!this.root._parent._hasRenderUpdates;
    }
    render() {
      this.root._parent._hasRenderUpdates = 0;
      this._render();
    }
    update() {
      this._update();
      if (this.root._hasUpdates) {
        this._update();
      }
      this._performForcedZSorts();
    }
    /**
     * Certain ElementCore items may be forced to zSort to strip out references to prevent memleaks..
     */
    _performForcedZSorts() {
      const n = this._zSorts.length;
      if (n) {
        for (let i = 0, n2 = this._zSorts.length; i < n2; i++) {
          if (this._zSorts[i].zSort) {
            this._zSorts[i].sortZIndexedChildren();
          }
        }
        this._zSorts = [];
      }
    }
    _update() {
      this.updateTreeOrder = 0;
      this.root.update();
    }
    _render() {
      const debugFrame = this.stage.getOption("debugFrame");
      this._fillRenderState();
      if (this.stage.getOption("readPixelsBeforeDraw")) {
        this._readPixels();
      }
      this._performRender();
      if (debugFrame) {
        console.log(`[Lightning] RTT Renders in frame: ${this.renderToTextureCount}`);
      }
      if (this.stage.getOption("readPixelsAfterDraw") && this.renderToTextureCount >= this.stage.getOption("readPixelsAfterDrawThreshold")) {
        if (debugFrame) {
          console.log(`[Lightning] readPixelsAfterDraw behavior triggered`);
        }
        this._readPixels();
      }
      this.renderToTextureCount = 0;
    }
    _readPixels() {
      const pixels = new Uint8Array(4);
      const gl = this.stage.gl;
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    }
    _fillRenderState() {
      this.renderState.reset();
      this.root.render();
      this.renderState.finish();
    }
    _performRender() {
      this.renderExec.execute();
    }
    _addMemoryUsage(delta) {
      this._usedMemory += delta;
      this.stage.addMemoryUsage(delta);
    }
    allocateRenderTexture(w, h) {
      let prec = this.stage.getRenderPrecision();
      let pw = Math.max(1, Math.round(w * prec));
      let ph = Math.max(1, Math.round(h * prec));
      const n = this._renderTexturePool.length;
      for (let i = n - 1; i >= 0; i--) {
        const texture2 = this._renderTexturePool[i];
        if (texture2.w === pw && texture2.h === ph && texture2.update !== this.stage.frameCounter) {
          texture2.f = this.stage.frameCounter;
          this._renderTexturePool.splice(i, 1);
          return texture2;
        }
      }
      const texture = this._createRenderTexture(w, h, pw, ph);
      texture.precision = prec;
      return texture;
    }
    releaseRenderTexture(texture) {
      this._renderTexturePool.push(texture);
    }
    freeUnusedRenderTextures(maxAge = 60) {
      let limit = this.stage.frameCounter - maxAge;
      this._renderTexturePool = this._renderTexturePool.filter((texture) => {
        if (texture.f <= limit) {
          this._freeRenderTexture(texture);
          return false;
        }
        return true;
      });
    }
    _createRenderTexture(w, h, pw, ph) {
      this._addMemoryUsage(pw * ph);
      const texture = this.stage.renderer.createRenderTexture(w, h, pw, ph);
      texture.id = this._renderTextureId++;
      texture.f = this.stage.frameCounter;
      texture.ow = w;
      texture.oh = h;
      texture.w = pw;
      texture.h = ph;
      return texture;
    }
    _freeRenderTexture(nativeTexture) {
      this.stage.renderer.freeRenderTexture(nativeTexture);
      this._addMemoryUsage(-nativeTexture.w * nativeTexture.h);
    }
    copyRenderTexture(renderTexture, nativeTexture, options) {
      this.stage.renderer.copyRenderTexture(renderTexture, nativeTexture, options);
    }
    forceZSort(elementCore) {
      this._zSorts.push(elementCore);
    }
  };

  // node_modules/@lightningjs/core/dist/src/animation/TransitionSettings.mjs
  var TransitionSettings = class {
    constructor(stage2) {
      this.stage = stage2;
      this._timingFunction = "ease";
      this._timingFunctionImpl = StageUtils.getTimingFunction(this._timingFunction);
      this.delay = 0;
      this.duration = 0.2;
      this.merger = null;
    }
    get timingFunction() {
      return this._timingFunction;
    }
    set timingFunction(v) {
      this._timingFunction = v;
      this._timingFunctionImpl = StageUtils.getTimingFunction(v);
    }
    get timingFunctionImpl() {
      return this._timingFunctionImpl;
    }
    patch(settings2) {
      Base.patchObject(this, settings2);
    }
  };
  TransitionSettings.prototype.isTransitionSettings = true;

  // node_modules/@lightningjs/core/dist/src/animation/TransitionManager.mjs
  var TransitionManager = class {
    constructor(stage2) {
      this.stage = stage2;
      this.stage.on("frameStart", () => this.progress());
      this.active = /* @__PURE__ */ new Set();
      this.defaultTransitionSettings = new TransitionSettings(this.stage);
    }
    progress() {
      if (this.active.size) {
        let dt = this.stage.dt;
        let filter = false;
        this.active.forEach(function(a) {
          a.progress(dt);
          if (!a.isRunning()) {
            filter = true;
          }
        });
        if (filter) {
          this.active = new Set([...this.active].filter((t) => t.isRunning()));
        }
      }
    }
    createSettings(settings2) {
      const transitionSettings = new TransitionSettings();
      Base.patchObject(transitionSettings, settings2);
      return transitionSettings;
    }
    addActive(transition) {
      this.active.add(transition);
    }
    removeActive(transition) {
      this.active.delete(transition);
    }
  };

  // node_modules/@lightningjs/core/dist/src/tools/MultiSpline.mjs
  var MultiSpline = class _MultiSpline {
    constructor() {
      this._clear();
    }
    _clear() {
      this._p = [];
      this._pe = [];
      this._idp = [];
      this._f = [];
      this._v = [];
      this._lv = [];
      this._sm = [];
      this._s = [];
      this._ve = [];
      this._sme = [];
      this._se = [];
      this._length = 0;
    }
    parse(rgba, def) {
      let i, n;
      if (!Utils.isObjectLiteral(def)) {
        def = { 0: def };
      }
      let defaultSmoothness = 0.5;
      let items = [];
      for (let key in def) {
        if (def.hasOwnProperty(key)) {
          let obj = def[key];
          if (!Utils.isObjectLiteral(obj)) {
            obj = { v: obj };
          }
          let p = parseFloat(key);
          if (key === "sm") {
            defaultSmoothness = obj.v;
          } else if (!isNaN(p) && p >= 0 && p <= 2) {
            obj.p = p;
            obj.f = Utils.isFunction(obj.v);
            obj.lv = obj.f ? obj.v(0, 0) : obj.v;
            items.push(obj);
          }
        }
      }
      items = items.sort(function(a, b) {
        return a.p - b.p;
      });
      n = items.length;
      for (i = 0; i < n; i++) {
        let last = i === n - 1;
        if (!items[i].hasOwnProperty("pe")) {
          items[i].pe = last ? items[i].p <= 1 ? 1 : 2 : items[i + 1].p;
        } else {
          const max = i < n - 1 ? items[i + 1].p : 1;
          if (items[i].pe > max) {
            items[i].pe = max;
          }
        }
        if (items[i].pe === items[i].p) {
          items[i].idp = 0;
        } else {
          items[i].idp = 1 / (items[i].pe - items[i].p);
        }
      }
      for (i = 0; i < n; i++) {
        if (!items[i].hasOwnProperty("sm")) {
          items[i].sm = defaultSmoothness;
        }
        if (!items[i].hasOwnProperty("s")) {
          if (i === 0 || i === n - 1 || items[i].p === 1) {
            items[i].s = rgba ? [0, 0, 0, 0] : 0;
          } else {
            const pi = items[i - 1];
            const ni = items[i + 1];
            if (pi.p === ni.p) {
              items[i].s = rgba ? [0, 0, 0, 0] : 0;
            } else {
              if (rgba) {
                const nc = _MultiSpline.getRgbaComponents(ni.lv);
                const pc = _MultiSpline.getRgbaComponents(pi.lv);
                const d = 1 / (ni.p - pi.p);
                items[i].s = [
                  d * (nc[0] - pc[0]),
                  d * (nc[1] - pc[1]),
                  d * (nc[2] - pc[2]),
                  d * (nc[3] - pc[3])
                ];
              } else {
                items[i].s = (ni.lv - pi.lv) / (ni.p - pi.p);
              }
            }
          }
        }
      }
      for (i = 0; i < n - 1; i++) {
        if (!items[i].f) {
          let last = i === n - 1;
          if (!items[i].hasOwnProperty("ve")) {
            items[i].ve = last ? items[i].lv : items[i + 1].lv;
          }
          if (Utils.isNumber(items[i].v) && Utils.isNumber(items[i].lv)) {
            if (!items[i].hasOwnProperty("sme")) {
              items[i].sme = last ? defaultSmoothness : items[i + 1].sm;
            }
            if (!items[i].hasOwnProperty("se")) {
              items[i].se = last ? rgba ? [0, 0, 0, 0] : 0 : items[i + 1].s;
            }
            if (rgba) {
              items[i].v = _MultiSpline.getSplineRgbaValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
            } else {
              items[i].v = _MultiSpline.getSplineValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
            }
            items[i].f = true;
          }
        }
      }
      if (this.length) {
        this._clear();
      }
      for (i = 0, n = items.length; i < n; i++) {
        this._add(items[i]);
      }
    }
    _add(item) {
      this._p.push(item.p || 0);
      this._pe.push(item.pe || 0);
      this._idp.push(item.idp || 0);
      this._f.push(item.f || false);
      this._v.push(
        item.hasOwnProperty("v") ? item.v : 0
        /* v might be false or null */
      );
      this._lv.push(item.lv || 0);
      this._sm.push(item.sm || 0);
      this._s.push(item.s || 0);
      this._ve.push(item.ve || 0);
      this._sme.push(item.sme || 0);
      this._se.push(item.se || 0);
      this._length++;
    }
    _getItem(p) {
      const n = this._length;
      if (!n) {
        return -1;
      }
      if (p < this._p[0]) {
        return 0;
      }
      for (let i = 0; i < n; i++) {
        if (this._p[i] <= p && p < this._pe[i]) {
          return i;
        }
      }
      return n - 1;
    }
    getValue(p) {
      const i = this._getItem(p);
      if (i === -1) {
        return void 0;
      } else {
        if (this._f[i]) {
          const o = Math.min(1, Math.max(0, (p - this._p[i]) * this._idp[i]));
          return this._v[i](o);
        } else {
          return this._v[i];
        }
      }
    }
    get length() {
      return this._length;
    }
    static getRgbaComponents(argb) {
      let r = (argb / 65536 | 0) % 256;
      let g2 = (argb / 256 | 0) % 256;
      let b = argb % 256;
      let a = argb / 16777216 | 0;
      return [r, g2, b, a];
    }
    static getSplineValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
      let dp = p2 - p1;
      s1 *= dp;
      s2 *= dp;
      let helpers = _MultiSpline.getSplineHelpers(v1, v2, o1, i2, s1, s2);
      if (!helpers) {
        return function(p) {
          if (p === 0) return v1;
          if (p === 1) return v2;
          return v2 * p + v1 * (1 - p);
        };
      } else {
        return function(p) {
          if (p === 0) return v1;
          if (p === 1) return v2;
          return _MultiSpline.calculateSpline(helpers, p);
        };
      }
    }
    static getSplineRgbaValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
      let dp = p2 - p1;
      s1[0] *= dp;
      s1[1] *= dp;
      s1[2] *= dp;
      s1[3] *= dp;
      s2[0] *= dp;
      s2[1] *= dp;
      s2[2] *= dp;
      s2[3] *= dp;
      let cv1 = _MultiSpline.getRgbaComponents(v1);
      let cv2 = _MultiSpline.getRgbaComponents(v2);
      let helpers = [
        _MultiSpline.getSplineHelpers(cv1[0], cv2[0], o1, i2, s1[0], s2[0]),
        _MultiSpline.getSplineHelpers(cv1[1], cv2[1], o1, i2, s1[1], s2[1]),
        _MultiSpline.getSplineHelpers(cv1[2], cv2[2], o1, i2, s1[2], s2[2]),
        _MultiSpline.getSplineHelpers(cv1[3], cv2[3], o1, i2, s1[3], s2[3])
      ];
      if (!helpers[0]) {
        return function(p) {
          if (p === 0) return v1;
          if (p === 1) return v2;
          return _MultiSpline.mergeColors(v2, v1, p);
        };
      } else {
        return function(p) {
          if (p === 0) return v1;
          if (p === 1) return v2;
          return _MultiSpline.getArgbNumber([
            Math.min(255, _MultiSpline.calculateSpline(helpers[0], p)),
            Math.min(255, _MultiSpline.calculateSpline(helpers[1], p)),
            Math.min(255, _MultiSpline.calculateSpline(helpers[2], p)),
            Math.min(255, _MultiSpline.calculateSpline(helpers[3], p))
          ]);
        };
      }
    }
    /**
     * Creates helpers to be used in the spline function.
     * @param {number} v1
     *   From value.
     * @param {number} v2
     *   To value.
     * @param {number} o1
     *   From smoothness (0 = linear, 1 = smooth).
     * @param {number} s1
     *   From slope (0 = horizontal, infinite = vertical).
     * @param {number} i2
     *   To smoothness.
     * @param {number} s2
     *   To slope.
     * @returns {Number[]}
     *   The helper values to be supplied to the spline function.
     *   If the configuration is actually linear, null is returned.
     */
    static getSplineHelpers(v1, v2, o1, i2, s1, s2) {
      if (!o1 && !i2) {
        return null;
      }
      let csx = o1;
      let csy = v1 + s1 * o1;
      let cex = 1 - i2;
      let cey = v2 - s2 * i2;
      let xa = 3 * csx - 3 * cex + 1;
      let xb = -6 * csx + 3 * cex;
      let xc = 3 * csx;
      let ya = 3 * csy - 3 * cey + v2 - v1;
      let yb = 3 * (cey + v1) - 6 * csy;
      let yc = 3 * (csy - v1);
      let yd = v1;
      return [xa, xb, xc, ya, yb, yc, yd];
    }
    /**
     * Calculates the intermediate spline value based on the specified helpers.
     * @param {number[]} helpers
     *   Obtained from getSplineHelpers.
     * @param {number} p
     * @return {number}
     */
    static calculateSpline(helpers, p) {
      let xa = helpers[0];
      let xb = helpers[1];
      let xc = helpers[2];
      let ya = helpers[3];
      let yb = helpers[4];
      let yc = helpers[5];
      let yd = helpers[6];
      if (xa === -2 && ya === -2 && xc === 0 && yc === 0) {
        return p;
      }
      let t = 0.5, cbx, dx;
      for (let it = 0; it < 20; it++) {
        cbx = t * (t * (t * xa + xb) + xc);
        dx = p - cbx;
        if (dx > -1e-8 && dx < 1e-8) {
          return t * (t * (t * ya + yb) + yc) + yd;
        }
        let cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
        if (cbxd > 1e-10 && cbxd < 1e-10) {
          break;
        }
        t += dx / cbxd;
      }
      let minT = 0;
      let maxT = 1;
      for (let it = 0; it < 20; it++) {
        t = 0.5 * (minT + maxT);
        cbx = t * (t * (t * xa + xb) + xc);
        dx = p - cbx;
        if (dx > -1e-8 && dx < 1e-8) {
          return t * (t * (t * ya + yb) + yc) + yd;
        }
        if (dx < 0) {
          maxT = t;
        } else {
          minT = t;
        }
      }
      return t;
    }
    static mergeColors(c1, c2, p) {
      let r1 = (c1 / 65536 | 0) % 256;
      let g1 = (c1 / 256 | 0) % 256;
      let b1 = c1 % 256;
      let a1 = c1 / 16777216 | 0;
      let r2 = (c2 / 65536 | 0) % 256;
      let g2 = (c2 / 256 | 0) % 256;
      let b2 = c2 % 256;
      let a2 = c2 / 16777216 | 0;
      let r = r1 * p + r2 * (1 - p);
      let g3 = g1 * p + g2 * (1 - p);
      let b = b1 * p + b2 * (1 - p);
      let a = a1 * p + a2 * (1 - p);
      return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g3) * 256 + Math.round(b);
    }
    static getArgbNumber(rgba) {
      rgba[0] = Math.max(0, Math.min(255, rgba[0]));
      rgba[1] = Math.max(0, Math.min(255, rgba[1]));
      rgba[2] = Math.max(0, Math.min(255, rgba[2]));
      rgba[3] = Math.max(0, Math.min(255, rgba[3]));
      let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
      if (v < 0) {
        v = 4294967295 + v + 1;
      }
      return v;
    }
  };

  // node_modules/@lightningjs/core/dist/src/animation/AnimationActionSettings.mjs
  var AnimationActionSettings = class {
    constructor(animationSettings) {
      this.animationSettings = animationSettings;
      this._selector = "";
      this._items = new MultiSpline();
      this._props = [];
      this._propSetters = [];
      this._resetValue = void 0;
      this._hasResetValue = false;
      this._hasColorProperty = void 0;
    }
    getResetValue() {
      if (this._hasResetValue) {
        return this._resetValue;
      } else {
        return this._items.getValue(0);
      }
    }
    apply(element, p, factor) {
      const elements = this.getAnimatedElements(element);
      let v = this._items.getValue(p);
      if (v === void 0 || !elements.length) {
        return;
      }
      if (factor !== 1) {
        let sv = this.getResetValue();
        if (Utils.isNumber(v) && Utils.isNumber(sv)) {
          if (this.hasColorProperty()) {
            v = StageUtils.mergeColors(v, sv, factor);
          } else {
            v = StageUtils.mergeNumbers(v, sv, factor);
          }
        }
      }
      const n = this._propSetters.length;
      const m = elements.length;
      for (let j = 0; j < m; j++) {
        for (let i = 0; i < n; i++) {
          this._propSetters[i](elements[j], v);
        }
      }
    }
    getAnimatedElements(element) {
      const selector = this._selector;
      if (typeof selector === "string") {
        return element.select(selector);
      } else {
        return [selector];
      }
    }
    reset(element) {
      const elements = this.getAnimatedElements(element);
      let v = this.getResetValue();
      if (v === void 0 || !elements.length) {
        return;
      }
      const n = this._propSetters.length;
      const m = elements.length;
      for (let j = 0; j < m; j++) {
        for (let i = 0; i < n; i++) {
          this._propSetters[i](elements[j], v);
        }
      }
    }
    set selector(v) {
      this._selector = v;
    }
    set t(v) {
      this.selector = v;
    }
    get resetValue() {
      return this._resetValue;
    }
    set resetValue(v) {
      this._resetValue = v;
      this._hasResetValue = v !== void 0;
    }
    set rv(v) {
      this.resetValue = v;
    }
    set value(v) {
      this._items.parse(this.hasColorProperty(), v);
    }
    set v(v) {
      this.value = v;
    }
    set properties(v) {
      if (!Array.isArray(v)) {
        v = [v];
      }
      this._props = [];
      v.forEach((prop) => {
        this._props.push(prop);
        this._propSetters.push(Element.getSetter(prop));
      });
    }
    set property(v) {
      this._hasColorProperty = void 0;
      this.properties = v;
    }
    set p(v) {
      this.properties = v;
    }
    patch(settings2) {
      Base.patchObject(this, settings2);
    }
    hasColorProperty() {
      if (this._hasColorProperty === void 0) {
        this._hasColorProperty = this._props.length ? Element.isColorProperty(this._props[0]) : false;
      }
      return this._hasColorProperty;
    }
  };
  AnimationActionSettings.prototype.isAnimationActionSettings = true;

  // node_modules/@lightningjs/core/dist/src/animation/AnimationSettings.mjs
  var AnimationSettings = class _AnimationSettings {
    constructor() {
      this._actions = [];
      this.delay = 0;
      this.duration = 1;
      this.repeat = 0;
      this.repeatOffset = 0;
      this.repeatDelay = 0;
      this.autostop = false;
      this.stopMethod = _AnimationSettings.STOP_METHODS.FADE;
      this._stopTimingFunction = "ease";
      this._stopTimingFunctionImpl = StageUtils.getTimingFunction(this._stopTimingFunction);
      this.stopDuration = 0;
      this.stopDelay = 0;
    }
    get actions() {
      return this._actions;
    }
    set actions(v) {
      this._actions = [];
      for (let i = 0, n = v.length; i < n; i++) {
        const e = v[i];
        if (!e.isAnimationActionSettings) {
          const aas = new AnimationActionSettings(this);
          aas.patch(e);
          this._actions.push(aas);
        } else {
          this._actions.push(e);
        }
      }
    }
    /**
     * Applies the animation to the specified element, for the specified progress between 0 and 1.
     * @param {Element} element;
     * @param {number} p;
     * @param {number} factor;
     */
    apply(element, p, factor = 1) {
      this._actions.forEach(function(action) {
        action.apply(element, p, factor);
      });
    }
    /**
     * Resets the animation to the reset values.
     * @param {Element} element;
     */
    reset(element) {
      this._actions.forEach(function(action) {
        action.reset(element);
      });
    }
    get stopTimingFunction() {
      return this._stopTimingFunction;
    }
    set stopTimingFunction(v) {
      this._stopTimingFunction = v;
      this._stopTimingFunctionImpl = StageUtils.getTimingFunction(v);
    }
    get stopTimingFunctionImpl() {
      return this._stopTimingFunctionImpl;
    }
    patch(settings2) {
      Base.patchObject(this, settings2);
    }
  };
  AnimationSettings.STOP_METHODS = {
    FADE: "fade",
    REVERSE: "reverse",
    FORWARD: "forward",
    IMMEDIATE: "immediate",
    ONETOTWO: "onetotwo"
  };

  // node_modules/@lightningjs/core/dist/src/animation/Animation.mjs
  var Animation = class _Animation extends EventEmitter {
    constructor(manager, settings2, element) {
      super();
      this.manager = manager;
      this._settings = settings2;
      this._element = element;
      this._state = _Animation.STATES.IDLE;
      this._p = 0;
      this._delayLeft = 0;
      this._repeatsLeft = 0;
      this._stopDelayLeft = 0;
      this._stopP = 0;
    }
    start() {
      if (this._element && this._element.attached) {
        this._p = 0;
        this._delayLeft = this.settings.delay;
        this._repeatsLeft = this.settings.repeat;
        this._state = _Animation.STATES.PLAYING;
        this.emit("start");
        this.checkActive();
      } else {
        console.warn("[Lightning] Element must be attached before starting animation");
      }
    }
    play() {
      if (this._state === _Animation.STATES.PAUSED) {
        this._state = _Animation.STATES.PLAYING;
        this.checkActive();
        this.emit("resume");
      } else if (this._state == _Animation.STATES.STOPPING && this.settings.stopMethod == AnimationSettings.STOP_METHODS.REVERSE) {
        this._state = _Animation.STATES.PLAYING;
        this.emit("stopContinue");
      } else if (this._state != _Animation.STATES.PLAYING && this._state != _Animation.STATES.FINISHED) {
        this.start();
      }
    }
    pause() {
      if (this._state === _Animation.STATES.PLAYING) {
        this._state = _Animation.STATES.PAUSED;
        this.emit("pause");
      }
    }
    replay() {
      if (this._state == _Animation.STATES.FINISHED) {
        this.start();
      } else {
        this.play();
      }
    }
    skipDelay() {
      this._delayLeft = 0;
      this._stopDelayLeft = 0;
    }
    finish() {
      if (this._state === _Animation.STATES.PLAYING) {
        this._delayLeft = 0;
        this._p = 1;
      } else if (this._state === _Animation.STATES.STOPPING) {
        this._stopDelayLeft = 0;
        this._p = 0;
      }
    }
    stop() {
      if (this._state === _Animation.STATES.STOPPED || this._state === _Animation.STATES.IDLE) return;
      this._stopDelayLeft = this.settings.stopDelay || 0;
      if (this.settings.stopMethod === AnimationSettings.STOP_METHODS.IMMEDIATE && !this._stopDelayLeft || this._delayLeft > 0) {
        this._state = _Animation.STATES.STOPPING;
        this.emit("stop");
      } else {
        if (this.settings.stopMethod === AnimationSettings.STOP_METHODS.FADE) {
          this._stopP = 0;
        }
        this._state = _Animation.STATES.STOPPING;
        this.emit("stop");
      }
      this.checkActive();
    }
    stopNow() {
      if (this._state !== _Animation.STATES.STOPPED || this._state !== _Animation.STATES.IDLE) {
        this._state = _Animation.STATES.STOPPING;
        this._p = 0;
        this.emit("stop");
        this.reset();
        this._state = _Animation.STATES.STOPPED;
        this.emit("stopFinish");
      }
    }
    isPaused() {
      return this._state === _Animation.STATES.PAUSED;
    }
    isPlaying() {
      return this._state === _Animation.STATES.PLAYING;
    }
    isStopping() {
      return this._state === _Animation.STATES.STOPPING;
    }
    isFinished() {
      return this._state === _Animation.STATES.FINISHED;
    }
    checkActive() {
      if (this.isActive()) {
        this.manager.addActive(this);
      }
    }
    isActive() {
      return (this._state == _Animation.STATES.PLAYING || this._state == _Animation.STATES.STOPPING) && this._element && this._element.attached;
    }
    progress(dt) {
      if (!this._element) return;
      this._progress(dt);
      this.apply();
    }
    _progress(dt) {
      if (this._state == _Animation.STATES.STOPPING) {
        this._stopProgress(dt);
        return;
      }
      if (this._state != _Animation.STATES.PLAYING) {
        return;
      }
      if (this._delayLeft > 0) {
        this._delayLeft -= dt;
        if (this._delayLeft < 0) {
          dt = -this._delayLeft;
          this._delayLeft = 0;
          this.emit("delayEnd");
        } else {
          return;
        }
      }
      if (this.settings.duration === 0) {
        this._p = 1;
      } else if (this.settings.duration > 0) {
        this._p += dt / this.settings.duration;
      }
      if (this._p >= 1) {
        if (this.settings.repeat == -1 || this._repeatsLeft > 0) {
          if (this._repeatsLeft > 0) {
            this._repeatsLeft--;
          }
          this._p = this.settings.repeatOffset;
          this.emit("progress", this._p);
          if (this.settings.repeatDelay) {
            this._delayLeft = this.settings.repeatDelay;
          }
          this.emit("repeat", this._repeatsLeft);
        } else {
          this._p = 1;
          this.emit("progress", this._p);
          this._state = _Animation.STATES.FINISHED;
          this.emit("finish");
          if (this.settings.autostop) {
            this.stop();
          }
        }
      } else {
        this.emit("progress", this._p);
      }
    }
    _stopProgress(dt) {
      let duration = this._getStopDuration();
      if (this._stopDelayLeft > 0) {
        this._stopDelayLeft -= dt;
        if (this._stopDelayLeft < 0) {
          dt = -this._stopDelayLeft;
          this._stopDelayLeft = 0;
          this.emit("stopDelayEnd");
        } else {
          return;
        }
      }
      if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.IMMEDIATE) {
        this._state = _Animation.STATES.STOPPED;
        this.emit("stopFinish");
      } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.REVERSE) {
        if (duration === 0) {
          this._p = 0;
        } else if (duration > 0) {
          this._p -= dt / duration;
        }
        if (this._p <= 0) {
          this._p = 0;
          this._state = _Animation.STATES.STOPPED;
          this.emit("stopFinish");
        }
      } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FADE) {
        this._progressStopTransition(dt);
        if (this._stopP >= 1) {
          this._p = 0;
          this._state = _Animation.STATES.STOPPED;
          this.emit("stopFinish");
        }
      } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.ONETOTWO) {
        if (this._p < 2) {
          if (duration === 0) {
            this._p = 2;
          } else if (duration > 0) {
            if (this._p < 1) {
              this._p += dt / this.settings.duration;
            } else {
              this._p += dt / duration;
            }
          }
          if (this._p >= 2) {
            this._p = 2;
            this._state = _Animation.STATES.STOPPED;
            this.emit("stopFinish");
          } else {
            this.emit("progress", this._p);
          }
        }
      } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FORWARD) {
        if (this._p < 1) {
          if (this.settings.duration == 0) {
            this._p = 1;
          } else {
            this._p += dt / this.settings.duration;
          }
          if (this._p >= 1) {
            if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FORWARD) {
              this._p = 1;
              this._state = _Animation.STATES.STOPPED;
              this.emit("stopFinish");
            } else {
              if (this._repeatsLeft > 0) {
                this._repeatsLeft--;
                this._p = 0;
                this.emit("repeat", this._repeatsLeft);
              } else {
                this._p = 1;
                this._state = _Animation.STATES.STOPPED;
                this.emit("stopFinish");
              }
            }
          } else {
            this.emit("progress", this._p);
          }
        }
      }
    }
    _progressStopTransition(dt) {
      if (this._stopP < 1) {
        if (this._stopDelayLeft > 0) {
          this._stopDelayLeft -= dt;
          if (this._stopDelayLeft < 0) {
            dt = -this._stopDelayLeft;
            this._stopDelayLeft = 0;
            this.emit("delayEnd");
          } else {
            return;
          }
        }
        const duration = this._getStopDuration();
        if (duration == 0) {
          this._stopP = 1;
        } else {
          this._stopP += dt / duration;
        }
        if (this._stopP >= 1) {
          this._stopP = 1;
        }
      }
    }
    _getStopDuration() {
      return this.settings.stopDuration || this.settings.duration;
    }
    apply() {
      if (this._state === _Animation.STATES.STOPPED) {
        this.reset();
      } else {
        let factor = 1;
        if (this._state === _Animation.STATES.STOPPING && this.settings.stopMethod === AnimationSettings.STOP_METHODS.FADE) {
          factor = 1 - this.settings.stopTimingFunctionImpl(this._stopP);
        }
        this._settings.apply(this._element, this._p, factor);
      }
    }
    reset() {
      this._settings.reset(this._element);
    }
    get state() {
      return this._state;
    }
    get p() {
      return this._p;
    }
    get delayLeft() {
      return this._delayLeft;
    }
    get element() {
      return this._element;
    }
    get frame() {
      return Math.round(this._p * this._settings.duration * 60);
    }
    get settings() {
      return this._settings;
    }
  };
  Animation.STATES = {
    IDLE: 0,
    PLAYING: 1,
    STOPPING: 2,
    STOPPED: 3,
    FINISHED: 4,
    PAUSED: 5
  };

  // node_modules/@lightningjs/core/dist/src/animation/AnimationManager.mjs
  var AnimationManager = class {
    constructor(stage2) {
      this.stage = stage2;
      this.stage.on("frameStart", () => this.progress());
      this.active = /* @__PURE__ */ new Set();
    }
    progress() {
      if (this.active.size) {
        let dt = this.stage.dt;
        let filter = false;
        this.active.forEach(function(a) {
          if (a.isActive()) {
            a.progress(dt);
          } else {
            filter = true;
          }
        });
        if (filter) {
          this.active = new Set([...this.active].filter((t) => t.isActive()));
        }
      }
    }
    createAnimation(element, settings2) {
      if (Utils.isObjectLiteral(settings2)) {
        settings2 = this.createSettings(settings2);
      }
      return new Animation(
        this,
        settings2,
        element
      );
    }
    createSettings(settings2) {
      const animationSettings = new AnimationSettings();
      Base.patchObject(animationSettings, settings2);
      return animationSettings;
    }
    addActive(transition) {
      this.active.add(transition);
    }
  };

  // node_modules/@lightningjs/core/dist/src/textures/RectangleTexture.mjs
  var RectangleTexture = class extends Texture {
    _getLookupId() {
      return "__whitepix";
    }
    _getSourceLoader() {
      return function(cb) {
        var whitePixel = new Uint8Array([255, 255, 255, 255]);
        cb(null, { source: whitePixel, w: 1, h: 1, permanent: true });
      };
    }
    isAutosizeTexture() {
      return false;
    }
  };

  // node_modules/@lightningjs/core/dist/src/tree/Stage.mjs
  var Stage = class _Stage extends EventEmitter {
    constructor(options = {}) {
      super();
      this._setOptions(options);
      this._usedMemory = 0;
      this._lastGcFrame = 0;
      this._usedVramAlpha = 0;
      this._usedVramNonAlpha = 0;
      const platformType = _Stage.platform ? _Stage.platform : PlatformLoader.load(options);
      this.platform = new platformType();
      if (this.platform.init) {
        this.platform.init(this);
      }
      this.gl = null;
      this.c2d = null;
      const context2 = this.getOption("context");
      if (context2) {
        if (context2.useProgram) {
          this.gl = context2;
        } else {
          this.c2d = context2;
        }
      } else {
        if (Utils.isWeb && (!_Stage.isWebglSupported() || this.getOption("canvas2d"))) {
          this.c2d = this.platform.createCanvasContext(this.getOption("w"), this.getOption("h"));
        } else {
          this.gl = this.platform.createWebGLContext(this.getOption("w"), this.getOption("h"));
        }
      }
      if (this.gl) {
        WebGLStateManager_default.enable(this.gl, "lightning");
      }
      this._mode = this.gl ? 0 : 1;
      if (this.getCanvas()) {
        if (this.getOption("devicePixelRatio") !== 1) {
          const ratio = this.getOption("devicePixelRatio");
          this.getCanvas().style.width = this._options["w"] / ratio + "px";
          this.getCanvas().style.height = this._options["h"] / ratio + "px";
        }
        this._options.w = this.getCanvas().width;
        this._options.h = this.getCanvas().height;
      }
      if (this._mode === 0) {
        if (Utils.isSpark) {
          this._renderer = new SparkRenderer(this);
        } else {
          this._renderer = new WebGLRenderer(this);
        }
      } else {
        this._renderer = new C2dRenderer(this);
      }
      this.setClearColor(this.getOption("clearColor"));
      this.frameCounter = 0;
      this.transitions = new TransitionManager(this);
      this.animations = new AnimationManager(this);
      this.textureManager = new TextureManager(this);
      this.textureThrottler = new TextureThrottler(this);
      this.startTime = 0;
      this.currentTime = 0;
      this.dt = 0;
      this.rectangleTexture = new RectangleTexture(this);
      this.rectangleTexture.load();
      this.rectangleTexture.source.permanent = true;
      this.ctx = new CoreContext(this);
      this._updateSourceTextures = /* @__PURE__ */ new Set();
    }
    get renderer() {
      return this._renderer;
    }
    static isWebglSupported() {
      if (Utils.isNode) {
        return true;
      }
      try {
        return !!window.WebGLRenderingContext;
      } catch (e) {
        return false;
      }
    }
    /**
     * Returns the rendering mode.
     * @returns {number}
     *  0: WebGL
     *  1: Canvas2d
     */
    get mode() {
      return this._mode;
    }
    isWebgl() {
      return this.mode === 0;
    }
    isC2d() {
      return this.mode === 1;
    }
    getOption(name) {
      return this._options[name];
    }
    _setOptions(o) {
      this._options = {};
      let opt = (name, def) => {
        let value = o[name];
        if (value === void 0) {
          this._options[name] = def;
        } else {
          this._options[name] = value;
        }
      };
      opt("canvas", null);
      opt("context", null);
      opt("w", 1920);
      opt("h", 1080);
      opt("srcBasePath", null);
      opt("memoryPressure", 24e6);
      opt("bufferMemory", 2e6);
      opt("textRenderIssueMargin", 0);
      opt("fontSharp", { precision: 0.6666666667, fontSize: 24 });
      opt("clearColor", [0, 0, 0, 0]);
      opt("defaultFontFace", "sans-serif");
      opt("fixedDt", 0);
      opt("useImageWorker", true);
      opt("autostart", true);
      opt("precision", 1);
      opt("canvas2d", false);
      opt("platform", null);
      opt("readPixelsBeforeDraw", false);
      opt("devicePixelRatio", 1);
      opt("readPixelsAfterDraw", false);
      opt("readPixelsAfterDrawThreshold", 0);
      opt("debugFrame", false);
      opt("forceTxCanvasSource", false);
      opt("pauseRafLoopOnIdle", false);
      if (o["devicePixelRatio"] != null && o["devicePixelRatio"] !== 1) {
        this._options["precision"] *= o["devicePixelRatio"];
        this._options["w"] *= o["devicePixelRatio"];
        this._options["h"] *= o["devicePixelRatio"];
      }
    }
    setApplication(app2) {
      this.application = app2;
    }
    init() {
      if (this.application.getOption("debug") && this.platform._imageWorker) {
        console.log("[Lightning] Using image worker!");
      }
      if (this.application.getOption("debug") && this.c2d) {
        console.log("[Lightning] Using canvas2d renderer");
      }
      this.application.setAsRoot();
      if (this.getOption("autostart")) {
        this.platform.startLoop();
      }
    }
    destroy() {
      this.platform.stopLoop();
      this.platform.destroy();
      this.ctx.destroy();
      this.textureManager.destroy();
      this._renderer.destroy();
      if (this.gl) {
        this.gl.clearColor(0, 0, 0, 0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      } else if (this.c2d) {
        this.c2d.clearRect(
          0,
          0,
          this.c2d.canvas.width,
          this.c2d.canvas.height
        );
      }
      this.gl = null;
      this.c2d = null;
      this.ctx = null;
      this._options = null;
      this.platform = null;
      this.textureManager = null;
      this._renderer = null;
      delete this.gl;
      delete this.c2d;
      delete this.ctx;
      delete this._options;
      delete this.platform;
      delete this.textureManager;
      delete this._renderer;
    }
    stop() {
      this.platform.stopLoop();
    }
    resume() {
      this.platform.startLoop();
    }
    get root() {
      return this.application;
    }
    getCanvas() {
      return this._mode ? this.c2d.canvas : this.gl.canvas;
    }
    getRenderPrecision() {
      return this._options.precision;
    }
    /**
     * Marks a texture for updating it's source upon the next drawFrame.
     * @param texture
     */
    addUpdateSourceTexture(texture) {
      if (this._updatingFrame) {
        texture._performUpdateSource();
      } else {
        this._updateSourceTextures.add(texture);
      }
    }
    removeUpdateSourceTexture(texture) {
      if (this._updateSourceTextures) {
        this._updateSourceTextures.delete(texture);
      }
    }
    hasUpdateSourceTexture(texture) {
      return this._updateSourceTextures && this._updateSourceTextures.has(texture);
    }
    _performUpdateSource() {
      if (this._updateSourceTextures.size) {
        this._updateSourceTextures.forEach((texture) => {
          texture._performUpdateSource();
        });
        this._updateSourceTextures = /* @__PURE__ */ new Set();
      }
    }
    _calculateDt() {
      this.startTime = this.currentTime;
      this.currentTime = this.platform.getHrTime();
      if (this._options.fixedDt) {
        this.dt = this._options.fixedDt;
      } else {
        this.dt = !this.startTime ? 0.02 : 1e-3 * (this.currentTime - this.startTime);
      }
    }
    updateFrame() {
      this._calculateDt();
      this.emit("frameStart");
      this._performUpdateSource();
      this.emit("update");
    }
    idleFrame() {
      this.textureThrottler.processSome();
      this.emit("frameEnd");
      this.frameCounter++;
    }
    onIdle() {
      this.emit("idle");
    }
    renderFrame() {
      const changes = this.ctx.hasRenderUpdates();
      this.textureThrottler.processSome();
      if (changes) {
        this._updatingFrame = true;
        this.ctx.update();
        this.ctx.render();
        this._updatingFrame = false;
      }
      this.platform.nextFrame(changes);
      this.emit("frameEnd");
      this.frameCounter++;
    }
    isUpdatingFrame() {
      return this._updatingFrame;
    }
    drawFrame() {
      this.updateFrame();
      this.renderFrame();
    }
    forceRenderUpdate() {
      if (this.root) {
        this.root.core._parent.setHasRenderUpdates(1);
      }
    }
    setClearColor(clearColor) {
      this.forceRenderUpdate();
      if (clearColor === null) {
        this._clearColor = null;
      } else if (Array.isArray(clearColor)) {
        this._clearColor = clearColor;
      } else {
        this._clearColor = StageUtils.getRgbaComponentsNormalized(clearColor);
      }
    }
    getClearColor() {
      return this._clearColor;
    }
    createElement(settings2) {
      if (settings2) {
        return this.element(settings2);
      } else {
        return new Element(this);
      }
    }
    createShader(settings2) {
      return Shader.create(this, settings2);
    }
    element(settings2) {
      if (settings2.isElement) return settings2;
      let element;
      if (settings2.type) {
        element = new settings2.type(this);
      } else {
        element = new Element(this);
      }
      element.patch(settings2);
      return element;
    }
    c(settings2) {
      return this.element(settings2);
    }
    get w() {
      return this._options.w;
    }
    get h() {
      return this._options.h;
    }
    get coordsWidth() {
      return this.w / this._options.precision;
    }
    get coordsHeight() {
      return this.h / this._options.precision;
    }
    addMemoryUsage(delta) {
      this._usedMemory += delta;
      if (delta > 0 && this._lastGcFrame !== this.frameCounter) {
        if (this._usedMemory > this.getOption("memoryPressure")) {
          this.gc(false);
          if (this._usedMemory > this.getOption("memoryPressure") - 2e6) {
            this.gc(true);
          }
        }
      }
    }
    get usedMemory() {
      return this._usedMemory;
    }
    addVramUsage(delta, alpha) {
      if (alpha) {
        this._usedVramAlpha += delta;
      } else {
        this._usedVramNonAlpha += delta;
      }
    }
    get usedVramAlpha() {
      return this._usedVramAlpha;
    }
    get usedVramNonAlpha() {
      return this._usedVramNonAlpha;
    }
    get usedVram() {
      return this._usedVramAlpha + this._usedVramNonAlpha;
    }
    gc(aggressive) {
      if (this._lastGcFrame !== this.frameCounter) {
        this._lastGcFrame = this.frameCounter;
        const memoryUsageBefore = this._usedMemory;
        this.gcTextureMemory(aggressive);
        this.gcRenderTextureMemory(aggressive);
        this.renderer.gc(aggressive);
        if (this.application.getOption("debug")) {
          console.log(`[Lightning] GC${aggressive ? "[aggressive]" : ""}! Frame ${this._lastGcFrame} Freed ${((memoryUsageBefore - this._usedMemory) / 1e6).toFixed(2)}MP from GPU memory. Remaining: ${(this._usedMemory / 1e6).toFixed(2)}MP`);
          const other = this._usedMemory - this.textureManager.usedMemory - this.ctx.usedMemory;
          console.log(`[Lightning] Textures: ${(this.textureManager.usedMemory / 1e6).toFixed(2)}MP, Render Textures: ${(this.ctx.usedMemory / 1e6).toFixed(2)}MP, Renderer caches: ${(other / 1e6).toFixed(2)}MP`);
        }
      }
    }
    gcTextureMemory(aggressive = false) {
      if (aggressive && this.ctx.root.visible) {
        this.ctx.root.visible = false;
        this.textureManager.gc();
        this.ctx.root.visible = true;
      } else {
        this.textureManager.gc();
      }
    }
    gcRenderTextureMemory(aggressive = false) {
      if (aggressive && this.root.visible) {
        this.root.visible = false;
        this.ctx.freeUnusedRenderTextures(0);
        this.root.visible = true;
      } else {
        this.ctx.freeUnusedRenderTextures(0);
      }
    }
    getDrawingCanvas() {
      return this.platform.getDrawingCanvas();
    }
    update() {
      this.ctx.update();
    }
    addServiceProvider(serviceprovider) {
      if (Utils.isSpark) {
        this.platform.addServiceProvider(serviceprovider);
      }
    }
    getChildrenByPosition(x, y) {
      const children = [];
      this.root.core.update();
      this.root.core.collectAtCoord(x, y, children);
      return children;
    }
  };

  // node_modules/@lightningjs/core/dist/src/application/Application.mjs
  var Application = class _Application extends Component {
    constructor(options = {}, properties) {
      _Application._temp_options = options;
      _Application.booting = true;
      const stage2 = new Stage(options.stage);
      super(stage2, properties);
      _Application.booting = false;
      this.__updateFocusCounter = 0;
      this.__keypressTimers = /* @__PURE__ */ new Map();
      this.__hoveredChild = null;
      this.stage.init();
      this.updateFocusSettings();
      this.__keymap = this.getOption("keys");
      if (this.__keymap) {
        this.stage.platform.registerKeydownHandler((e) => {
          this._receiveKeydown(e);
        });
        this.stage.platform.registerKeyupHandler((e) => {
          this._receiveKeyup(e);
        });
      }
      if (this.getOption("enablePointer")) {
        this.stage.platform.registerClickHandler((e) => {
          this._receiveClick(e);
        });
        this.stage.platform.registerHoverHandler((e) => {
          this._receiveHover(e);
        });
        this.stage.platform.registerScrollWheelHandler((e) => {
          this._recieveScrollWheel(e);
        });
        this.cursor = "default";
      }
    }
    getOption(name) {
      return this.__options[name];
    }
    _setOptions(o) {
      this.__options = {};
      let opt = (name, def) => {
        let value = o[name];
        if (value === void 0) {
          this.__options[name] = def;
        } else {
          this.__options[name] = value;
        }
      };
      opt("debug", false);
      opt("keys", {
        38: "Up",
        40: "Down",
        37: "Left",
        39: "Right",
        13: "Enter",
        8: "Back",
        27: "Exit"
      });
      opt("enablePointer", false);
    }
    __construct() {
      this.stage.setApplication(this);
      this._setOptions(_Application._temp_options);
      delete _Application._temp_options;
      super.__construct();
    }
    __init() {
      super.__init();
      this.__updateFocus();
    }
    updateFocusPath() {
      this.__updateFocus();
    }
    __updateFocus() {
      const notOverridden = this.__updateFocusRec();
      if (!_Application.booting && notOverridden) {
        this.updateFocusSettings();
      }
    }
    __updateFocusRec() {
      const updateFocusId = ++this.__updateFocusCounter;
      this.__updateFocusId = updateFocusId;
      const newFocusPath = this.__getFocusPath();
      const newFocusedComponent = newFocusPath[newFocusPath.length - 1];
      const prevFocusedComponent = this._focusPath ? this._focusPath[this._focusPath.length - 1] : void 0;
      if (!prevFocusedComponent) {
        this._focusPath = [];
        for (let i = 0, n = newFocusPath.length; i < n; i++) {
          this._focusPath.push(newFocusPath[i]);
          this._focusPath[i]._focus(newFocusedComponent, void 0);
          const focusOverridden = this.__updateFocusId !== updateFocusId;
          if (focusOverridden) {
            return false;
          }
        }
        return true;
      } else {
        let m = Math.min(this._focusPath.length, newFocusPath.length);
        let index;
        for (index = 0; index < m; index++) {
          if (this._focusPath[index] !== newFocusPath[index]) {
            break;
          }
        }
        if (this._focusPath.length !== newFocusPath.length || index !== newFocusPath.length) {
          if (this.getOption("debug")) {
            console.log("[Lightning] Focus changed: " + newFocusedComponent.getLocationString());
          }
          for (let i = this._focusPath.length - 1; i >= index; i--) {
            const unfocusedElement = this._focusPath.pop();
            unfocusedElement._unfocus(newFocusedComponent, prevFocusedComponent);
            const focusOverridden = this.__updateFocusId !== updateFocusId;
            if (focusOverridden) {
              return false;
            }
          }
          for (let i = index, n = newFocusPath.length; i < n; i++) {
            this._focusPath.push(newFocusPath[i]);
            this._focusPath[i]._focus(newFocusedComponent, prevFocusedComponent);
            const focusOverridden = this.__updateFocusId !== updateFocusId;
            if (focusOverridden) {
              return false;
            }
          }
          for (let i = 0; i < index; i++) {
            this._focusPath[i]._focusChange(newFocusedComponent, prevFocusedComponent);
          }
        }
      }
      return true;
    }
    updateFocusSettings() {
      const focusedComponent = this._focusPath[this._focusPath.length - 1];
      const focusSettings = {};
      const defaultSetFocusSettings = Component.prototype._setFocusSettings;
      for (let i = 0, n = this._focusPath.length; i < n; i++) {
        if (this._focusPath[i]._setFocusSettings !== defaultSetFocusSettings) {
          this._focusPath[i]._setFocusSettings(focusSettings);
        }
      }
      const defaultHandleFocusSettings = Component.prototype._handleFocusSettings;
      for (let i = 0, n = this._focusPath.length; i < n; i++) {
        if (this._focusPath[i]._handleFocusSettings !== defaultHandleFocusSettings) {
          this._focusPath[i]._handleFocusSettings(focusSettings, this.__prevFocusSettings, focusedComponent);
        }
      }
      this.__prevFocusSettings = focusSettings;
    }
    _handleFocusSettings(settings2, prevSettings, focused, prevFocused) {
    }
    __getFocusPath() {
      const path = [this];
      let current = this;
      do {
        const nextFocus = current._getFocused();
        if (!nextFocus || nextFocus === current) {
          break;
        }
        let ptr = nextFocus.cparent;
        if (ptr === current) {
          path.push(nextFocus);
        } else {
          const newParts = [nextFocus];
          do {
            if (!ptr) {
              current._throwError("Return value for _getFocused must be an attached descendant component but its '" + nextFocus.getLocationString() + "'");
            }
            newParts.push(ptr);
            ptr = ptr.cparent;
          } while (ptr !== current);
          for (let i = 0, n = newParts.length; i < n; i++) {
            path.push(newParts[n - i - 1]);
          }
        }
        current = nextFocus;
      } while (true);
      return path;
    }
    get focusPath() {
      return this._focusPath;
    }
    /**
     * Injects an event in the state machines, top-down from application to focused component.
     */
    focusTopDownEvent(events2, ...args) {
      const path = this.focusPath;
      const n = path.length;
      for (let i = 0; i < n; i++) {
        const event = path[i]._getMostSpecificHandledMember(events2);
        if (event !== void 0) {
          const returnValue = path[i][event](...args);
          if (returnValue !== false) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Injects an event in the state machines, bottom-up from focused component to application.
     */
    focusBottomUpEvent(events2, ...args) {
      const path = this.focusPath;
      const n = path.length;
      for (let i = n - 1; i >= 0; i--) {
        const event = path[i]._getMostSpecificHandledMember(events2);
        if (event !== void 0) {
          const returnValue = path[i][event](...args);
          if (returnValue !== false) {
            return true;
          }
        }
      }
      return false;
    }
    _receiveKeydown(e) {
      const obj = e;
      const key = this.__keymap[e.keyCode];
      const path = this.focusPath;
      let keys;
      if (key) {
        keys = Array.isArray(key) ? key : [key];
      }
      if (keys) {
        for (let i = 0, n = keys.length; i < n; i++) {
          const hasTimer = this.__keypressTimers.has(keys[i]);
          if (path[path.length - 1].longpress && hasTimer) {
            return;
          }
          if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}`, "_captureKey"], obj)) {
            this.stage.application.focusBottomUpEvent([`_handle${keys[i]}`, "_handleKey"], obj);
          }
        }
      } else {
        if (!this.stage.application.focusTopDownEvent(["_captureKey"], obj)) {
          this.stage.application.focusBottomUpEvent(["_handleKey"], obj);
        }
      }
      this.updateFocusPath();
      const consumer3 = path[path.length - 1];
      if (keys && consumer3.longpress) {
        for (let i = 0, n = keys.length; i < n; i++) {
          this._startLongpressTimer(keys[i], consumer3);
        }
      }
    }
    /**
     * Keyup listener
     * To take away some confusion we add `Release` to the event to prevent ending up with method names like:
     *  _handleLeftUp / _handleUpUp / _handleEnterUp etc
     *
     * @param e
     * @private
     */
    _receiveKeyup(e) {
      const obj = e;
      const key = this.__keymap[e.keyCode];
      let keys;
      if (key) {
        keys = Array.isArray(key) ? key : [key];
      }
      if (keys) {
        for (let i = 0, n = keys.length; i < n; i++) {
          if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}Release`, "_captureKeyRelease"], obj)) {
            this.stage.application.focusBottomUpEvent([`_handle${keys[i]}Release`, "_handleKeyRelease"], obj);
          }
        }
      } else {
        if (!this.stage.application.focusTopDownEvent(["_captureKeyRelease"], obj)) {
          this.stage.application.focusBottomUpEvent(["_handleKeyRelease"], obj);
        }
      }
      this.updateFocusPath();
      if (keys) {
        for (let i = 0, n = keys.length; i < n; i++) {
          if (this.__keypressTimers.has(keys[i])) {
            clearTimeout(this.__keypressTimers.get(keys[i]));
            this.__keypressTimers.delete(keys[i]);
          }
        }
      }
    }
    /**
     * Registers and starts a timer for the pressed key. Timer will be cleared when the key is released
     * before the timer goes off.
     *
     * If key is not release (keyup) the longpress handler will be fired.
     * Configuration can be via the Components template:
     *
     * static _template() {
     *     return {
     *         w:100, h:100,
     *         longpress:{up:700, down:500}
     *     }
     * }     *
     * // this will get called when up has been pressed for 700ms
     * _handleUpLong() {
     *
     * }
     *
     * @param key
     * @param element
     * @private
     */
    _startLongpressTimer(key, element) {
      const config2 = element.longpress;
      const lookup = key.toLowerCase();
      if (config2[lookup]) {
        const timeout2 = config2[lookup];
        if (!Utils.isNumber(timeout2)) {
          element._throwError("config value for longpress must be a number");
        } else {
          this.__keypressTimers.set(key, setTimeout(
            () => {
              if (!this.stage.application.focusTopDownEvent([`_capture${key}Long`, "_captureKey"], {})) {
                this.stage.application.focusBottomUpEvent([`_handle${key}Long`, "_handleKey"], {});
              }
              this.__keypressTimers.delete(key);
            },
            timeout2 || 500
            /* prevent 0ms */
          ));
        }
      }
      return;
    }
    _recieveScrollWheel(e) {
      const obj = e;
      const { clientX, clientY } = obj;
      if (clientX <= this.stage.w && clientY <= this.stage.h) {
        if (!this.fireTopDownScrollWheelHandler("_captureScroll", obj)) {
          this.fireBottomUpScrollWheelHandler("_handleScroll", obj);
        }
      }
    }
    fireTopDownScrollWheelHandler(event, obj) {
      let children = this.stage.application.children;
      let affected = this._findChildren([], children).reverse();
      let n = affected.length;
      while (n--) {
        const child = affected[n];
        if (child && child[event]) {
          child._captureScroll(obj);
          return true;
        }
      }
      return false;
    }
    fireBottomUpScrollWheelHandler(event, obj) {
      const { clientX, clientY } = obj;
      const target = this._getTargetChild(clientX, clientY);
      let child = target;
      while (child !== null) {
        if (child && child[event]) {
          child._handleScroll(obj);
          return true;
        }
        child = child.parent;
      }
      return false;
    }
    _receiveClick(e) {
      const obj = e;
      const { clientX, clientY } = obj;
      if (clientX <= this.stage.w && clientY <= this.stage.h) {
        this.stage.application.fireBottomUpClickHandler(obj);
      }
    }
    fireBottomUpClickHandler(obj) {
      const { clientX, clientY } = obj;
      const target = this._getTargetChild(clientX, clientY);
      const precision2 = this.stage.getRenderPrecision() / this.stage.getOption("devicePixelRatio");
      let child = target;
      while (child !== null) {
        if (child && child["_handleClick"]) {
          const { px, py } = child.core._worldContext;
          const cx = px * precision2;
          const cy = py * precision2;
          const localCoords = {
            x: clientX - cx,
            y: clientY - cy
          };
          const returnValue = child._handleClick(target, localCoords);
          if (returnValue !== false) {
            break;
          }
        }
        child = child.parent;
      }
    }
    _receiveHover(e) {
      const obj = e;
      const { clientX, clientY } = obj;
      if (clientX <= this.stage.w && clientY <= this.stage.h) {
        this.stage.application.fireBottomUpHoverHandler(obj);
      }
    }
    fireBottomUpHoverHandler(obj) {
      const { clientX, clientY } = obj;
      const target = this._getTargetChild(clientX, clientY);
      if (target !== this.__hoveredChild) {
        let hoveredBranch = /* @__PURE__ */ new Set();
        let newHoveredBranch = /* @__PURE__ */ new Set();
        if (target) {
          newHoveredBranch = new Set(target.getAncestors());
        }
        if (this.__hoveredChild) {
          hoveredBranch = new Set(this.__hoveredChild.getAncestors());
          for (const elem of [...hoveredBranch].filter((e) => !newHoveredBranch.has(e))) {
            const c = Component.getComponent(elem);
            if (c["_handleUnhover"]) {
              c._handleUnhover(elem);
            }
            if (elem.parent && elem.parent.cursor) {
              this.stage.getCanvas().style.cursor = elem.parent.cursor;
            }
          }
        }
        this.__hoveredChild = target;
        const diffBranch = [...newHoveredBranch].filter((e) => !hoveredBranch.has(e));
        for (const elem of diffBranch) {
          const c = Component.getComponent(elem);
          if (c["_handleHover"]) {
            c._handleHover(elem);
          }
        }
        const lastElement = diffBranch[0];
        if (lastElement && lastElement.cursor) {
          this.stage.getCanvas().style.cursor = lastElement.cursor;
        }
        if (diffBranch.length === 0 && target) {
          const c = Component.getComponent(target);
          if (c["_handleHover"]) {
            c._handleHover(target);
          }
        }
      }
    }
    _getTargetChild(clientX, clientY) {
      let children = this.stage.application.children;
      let affected = this._findChildren([], children);
      let hoverableChildren = this._withinClickableRange(affected, clientX, clientY);
      hoverableChildren.sort((a, b) => {
        if (a.zIndex > b.zIndex) {
          return 1;
        } else if (a.zIndex < b.zIndex) {
          return -1;
        } else {
          return a.id > b.id ? 1 : -1;
        }
      });
      if (hoverableChildren.length) {
        return hoverableChildren.slice(-1)[0];
      } else {
        return null;
      }
    }
    _findChildren(bucket, children) {
      let n = children.length;
      while (n--) {
        const child = children[n];
        if (child.__active && child.collision) {
          if (child.collision === true) {
            bucket.push(child);
          }
          if (child.hasChildren()) {
            this._findChildren(bucket, child.children);
          }
        }
      }
      return bucket;
    }
    _withinClickableRange(affectedChildren, cursorX, cursorY) {
      let n = affectedChildren.length;
      const candidates = [];
      while (n--) {
        const child = affectedChildren[n];
        const precision2 = this.stage.getRenderPrecision() / this.stage.getOption("devicePixelRatio");
        const ctx = child.core._worldContext;
        const cx = ctx.px * precision2;
        const cy = ctx.py * precision2;
        const cw = child.finalW * ctx.ta * precision2;
        const ch = child.finalH * ctx.td * precision2;
        if (cx > this.stage.w || cy > this.stage.h) {
          continue;
        }
        if (child.parent.core._scissor) {
          const scissor = child.parent.core._scissor.map((v) => v * precision2);
          if (!this._testCollision(cursorX, cursorY, ...scissor))
            continue;
        }
        if (this._testCollision(cursorX, cursorY, cx, cy, cw, ch)) {
          candidates.push(child);
        }
      }
      return candidates;
    }
    _testCollision(px, py, cx, cy, cw, ch) {
      if (px >= cx && px <= cx + cw && py >= cy && py <= cy + ch) {
        return true;
      }
      return false;
    }
    destroy() {
      if (!this._destroyed) {
        this._destroy();
        this.stage.destroy();
        this._destroyed = true;
      }
    }
    _destroy() {
      this.stage.setApplication(void 0);
      this._updateAttachedFlag();
      this._updateEnabledFlag();
      if (this.__keypressTimers.size) {
        for (const timer of this.__keypressTimers.values()) {
          clearTimeout(timer);
        }
        this.__keypressTimers.clear();
      }
    }
    getCanvas() {
      return this.stage.getCanvas();
    }
  };

  // node_modules/@lightningjs/core/dist/src/textures/StaticCanvasTexture.mjs
  var StaticCanvasTexture = class extends Texture {
    constructor(stage2) {
      super(stage2);
      this._factory = void 0;
      this._lookupId = void 0;
    }
    set content({ factory, lookupId = void 0 }) {
      this._factory = factory;
      this._lookupId = lookupId;
      this._changed();
    }
    _getIsValid() {
      return !!this._factory;
    }
    _getLookupId() {
      return this._lookupId;
    }
    _getSourceLoader() {
      const f = this._factory;
      return (cb) => {
        return f((err, canvas) => {
          if (err) {
            return cb(err);
          }
          cb(null, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas));
        }, this.stage);
      };
    }
  };

  // node_modules/@lightningjs/core/dist/src/tools/Tools.mjs
  var Tools = class _Tools {
    static getCanvasTexture(canvasFactory, lookupId) {
      return { type: StaticCanvasTexture, content: { factory: canvasFactory, lookupId } };
    }
    static getRoundRect(w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
      if (!Array.isArray(radius)) {
        radius = [radius, radius, radius, radius];
      }
      let factory = (cb, stage2) => {
        if (Utils.isSpark) {
          stage2.platform.createRoundRect(cb, stage2, w, h, radius, strokeWidth, strokeColor, fill, fillColor);
        } else {
          cb(null, this.createRoundRect(stage2, w, h, radius, strokeWidth, strokeColor, fill, fillColor));
        }
      };
      let id = "rect" + [w, h, strokeWidth, strokeColor, fill ? 1 : 0, fillColor].concat(radius).join(",");
      return _Tools.getCanvasTexture(factory, id);
    }
    static createRoundRect(stage2, w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
      if (fill === void 0) fill = true;
      if (strokeWidth === void 0) strokeWidth = 0;
      let canvas = stage2.platform.getDrawingCanvas();
      let ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      canvas.width = w + strokeWidth + 2;
      canvas.height = h + strokeWidth + 2;
      ctx.beginPath();
      let x = 0.5 * strokeWidth + 1, y = 0.5 * strokeWidth + 1;
      ctx.moveTo(x + radius[0], y);
      ctx.lineTo(x + w - radius[1], y);
      ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
      ctx.lineTo(x + w, y + h - radius[2]);
      ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
      ctx.lineTo(x + radius[3], y + h);
      ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
      ctx.lineTo(x, y + radius[0]);
      ctx.arcTo(x, y, x + radius[0], y, radius[0]);
      ctx.closePath();
      if (fill) {
        if (Utils.isNumber(fillColor)) {
          ctx.fillStyle = StageUtils.getRgbaString(fillColor);
        } else {
          ctx.fillStyle = "white";
        }
        ctx.fill();
      }
      if (strokeWidth) {
        if (Utils.isNumber(strokeColor)) {
          ctx.strokeStyle = StageUtils.getRgbaString(strokeColor);
        } else {
          ctx.strokeStyle = "white";
        }
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
      }
      return canvas;
    }
    static getShadowRect(w, h, radius = 0, blur = 5, margin = blur * 2) {
      if (!Array.isArray(radius)) {
        radius = [radius, radius, radius, radius];
      }
      let factory = (cb, stage2) => {
        if (Utils.isSpark) {
          stage2.platform.createShadowRect(cb, stage2, w, h, radius, blur, margin);
        } else {
          cb(null, this.createShadowRect(stage2, w, h, radius, blur, margin));
        }
      };
      let id = "shadow" + [w, h, blur, margin].concat(radius).join(",");
      return _Tools.getCanvasTexture(factory, id);
    }
    static createShadowRect(stage2, w, h, radius, blur, margin) {
      let canvas = stage2.platform.getDrawingCanvas();
      let ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      canvas.width = w + margin * 2;
      canvas.height = h + margin * 2;
      ctx.globalAlpha = 0.01;
      ctx.fillRect(0, 0, 0.01, 0.01);
      ctx.globalAlpha = 1;
      ctx.shadowColor = StageUtils.getRgbaString(4294967295);
      ctx.fillStyle = StageUtils.getRgbaString(4294967295);
      ctx.shadowBlur = blur;
      ctx.shadowOffsetX = w + 10 + margin;
      ctx.shadowOffsetY = margin;
      ctx.beginPath();
      const x = -(w + 10);
      const y = 0;
      ctx.moveTo(x + radius[0], y);
      ctx.lineTo(x + w - radius[1], y);
      ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
      ctx.lineTo(x + w, y + h - radius[2]);
      ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
      ctx.lineTo(x + radius[3], y + h);
      ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
      ctx.lineTo(x, y + radius[0]);
      ctx.arcTo(x, y, x + radius[0], y, radius[0]);
      ctx.closePath();
      ctx.fill();
      return canvas;
    }
    static getSvgTexture(url, w, h) {
      let factory = (cb, stage2) => {
        if (Utils.isSpark) {
          stage2.platform.createSvg(cb, stage2, url, w, h);
        } else {
          this.createSvg(cb, stage2, url, w, h);
        }
      };
      let id = "svg" + [w, h, url].join(",");
      return _Tools.getCanvasTexture(factory, id);
    }
    static createSvg(cb, stage2, url, w, h) {
      let canvas = stage2.platform.getDrawingCanvas();
      let ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      let img = new Image();
      img.onload = () => {
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        cb(null, canvas);
      };
      img.onerror = (err) => {
        cb(err);
      };
      if (!Utils.isPS4) {
        img.crossOrigin = "Anonymous";
      }
      img.src = url;
    }
  };

  // node_modules/@lightningjs/core/dist/src/tools/ObjMerger.mjs
  var ObjMerger = class _ObjMerger {
    static isMf(f) {
      return Utils.isFunction(f) && f.__mf;
    }
    static mf(f) {
      f.__mf = true;
      return f;
    }
    static merge(a, b) {
      const aks = Object.keys(a);
      const bks = Object.keys(b);
      if (!bks.length) {
        return a;
      }
      const ai = {};
      const bi = {};
      for (let i = 0, n = bks.length; i < n; i++) {
        const key = bks[i];
        ai[key] = -1;
        bi[key] = i;
      }
      for (let i = 0, n = aks.length; i < n; i++) {
        const key = aks[i];
        ai[key] = i;
        if (bi[key] === void 0) {
          bi[key] = -1;
        }
      }
      const aksl = aks.length;
      const result = {};
      for (let i = 0, n = bks.length; i < n; i++) {
        const key = bks[i];
        const aIndex = ai[key];
        let curIndex2 = aIndex;
        while (--curIndex2 >= 0) {
          const akey = aks[curIndex2];
          if (bi[akey] !== -1) {
            break;
          }
        }
        while (++curIndex2 < aIndex) {
          const akey = aks[curIndex2];
          result[akey] = a[akey];
        }
        const bv = b[key];
        const av = a[key];
        let r;
        if (this.isMf(bv)) {
          r = bv(av);
        } else {
          if (!Utils.isObjectLiteral(av) || !Utils.isObjectLiteral(bv)) {
            r = bv;
          } else {
            r = _ObjMerger.merge(av, bv);
          }
        }
        if (r !== void 0) {
          result[key] = r;
        }
      }
      let curIndex = aksl;
      while (--curIndex >= 0) {
        const akey = aks[curIndex];
        if (bi[akey] !== -1) {
          break;
        }
      }
      while (++curIndex < aksl) {
        const akey = aks[curIndex];
        result[akey] = a[akey];
      }
      return result;
    }
  };

  // node_modules/@lightningjs/core/dist/src/tools/ObjectListProxy.mjs
  var ObjectListProxy = class extends ObjectList {
    constructor(target) {
      super();
      this._target = target;
    }
    onAdd(item, index) {
      this._target.addAt(item, index);
    }
    onRemove(item, index) {
      this._target.removeAt(index);
    }
    onSync(removed, added, order) {
      this._target._setByArray(order);
    }
    onSet(item, index) {
      this._target.setAt(item, index);
    }
    onMove(item, fromIndex, toIndex) {
      this._target.setAt(item, toIndex);
    }
    createItem(object) {
      return this._target.createItem(object);
    }
    isItem(object) {
      return this._target.isItem(object);
    }
  };

  // node_modules/@lightningjs/core/dist/src/tools/ObjectListWrapper.mjs
  var ObjectListWrapper = class extends ObjectListProxy {
    constructor(target, wrap) {
      super(target);
      this._wrap = wrap;
    }
    wrap(item) {
      let wrapper = this._wrap(item);
      item._wrapper = wrapper;
      return wrapper;
    }
    onAdd(item, index) {
      item = this.wrap(item);
      super.onAdd(item, index);
    }
    onRemove(item, index) {
      super.onRemove(item, index);
    }
    onSync(removed, added, order) {
      added.forEach((a) => this.wrap(a));
      order = order.map((a) => a._wrapper);
      super.onSync(removed, added, order);
    }
    onSet(item, index) {
      item = this.wrap(item);
      super.onSet(item, index);
    }
    onMove(item, fromIndex, toIndex) {
      super.onMove(item, fromIndex, toIndex);
    }
  };

  // node_modules/@lightningjs/core/dist/src/textures/NoiseTexture.mjs
  var NoiseTexture = class extends Texture {
    _getLookupId() {
      return "__noise";
    }
    _getSourceLoader() {
      const gl = this.stage.gl;
      return function(cb) {
        const noise = new Uint8Array(128 * 128 * 4);
        for (let i = 0; i < 128 * 128 * 4; i += 4) {
          const v = Math.floor(Math.random() * 256);
          noise[i] = v;
          noise[i + 1] = v;
          noise[i + 2] = v;
          noise[i + 3] = 255;
        }
        const texParams = {};
        if (gl) {
          texParams[gl.TEXTURE_WRAP_S] = gl.REPEAT;
          texParams[gl.TEXTURE_WRAP_T] = gl.REPEAT;
          texParams[gl.TEXTURE_MIN_FILTER] = gl.NEAREST;
          texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
        }
        cb(null, { source: noise, w: 128, h: 128, texParams });
      };
    }
  };

  // node_modules/@lightningjs/core/dist/src/textures/HtmlTexture.mjs
  var HtmlTexture = class _HtmlTexture extends Texture {
    constructor(stage2) {
      super(stage2);
      this._htmlElement = void 0;
      this._scale = 1;
    }
    set htmlElement(v) {
      this._htmlElement = v;
      this._changed();
    }
    get htmlElement() {
      return this._htmlElement;
    }
    set scale(v) {
      this._scale = v;
      this._changed();
    }
    get scale() {
      return this._scale;
    }
    set html(v) {
      if (!v) {
        this.htmlElement = void 0;
      } else {
        const d = document.createElement("div");
        d.innerHTML = "<div>" + v + "</div>";
        this.htmlElement = d.firstElementChild;
      }
    }
    get html() {
      return this._htmlElement.innerHTML;
    }
    _getIsValid() {
      return this.htmlElement;
    }
    _getLookupId() {
      return this._scale + ":" + this._htmlElement.innerHTML;
    }
    _getSourceLoader() {
      const htmlElement = this._htmlElement;
      const scale = this._scale;
      return function(cb) {
        if (!window.html2canvas) {
          return cb(new Error("Please include html2canvas (https://html2canvas.hertzen.com/)"));
        }
        const area = _HtmlTexture.getPreloadArea();
        area.appendChild(htmlElement);
        html2canvas(htmlElement, { backgroundColor: null, scale }).then(function(canvas) {
          area.removeChild(htmlElement);
          if (canvas.height === 0) {
            return cb(new Error("Canvas height is 0"));
          }
          cb(null, { source: canvas, width: canvas.width, height: canvas.height });
        }).catch((e) => {
          console.error("[Lightning]", e);
        });
      };
    }
    static getPreloadArea() {
      if (!this._preloadArea) {
        this._preloadArea = document.createElement("div");
        if (this._preloadArea.attachShadow) {
          this._preloadArea.attachShadow({ mode: "closed" });
        }
        this._preloadArea.style.opacity = 0;
        this._preloadArea.style.pointerEvents = "none";
        this._preloadArea.style.position = "fixed";
        this._preloadArea.style.display = "block";
        this._preloadArea.style.top = "100vh";
        this._preloadArea.style.overflow = "hidden";
        document.body.appendChild(this._preloadArea);
      }
      return this._preloadArea;
    }
  };

  // node_modules/@lightningjs/core/dist/src/textures/StaticTexture.mjs
  var StaticTexture = class extends Texture {
    constructor(stage2, options) {
      super(stage2);
      this._options = options;
    }
    set options(v) {
      if (this._options !== v) {
        this._options = v;
        this._changed();
      }
    }
    get options() {
      return this._options;
    }
    _getIsValid() {
      return !!this._options;
    }
    _getSourceLoader() {
      return (cb) => {
        cb(null, this._options);
      };
    }
  };

  // node_modules/@lightningjs/core/dist/src/components/ListComponent.mjs
  var ListComponent = class extends Component {
    constructor(stage2) {
      super(stage2);
      this._wrapper = super._children.a({});
      this._reloadVisibleElements = false;
      this._visibleItems = /* @__PURE__ */ new Set();
      this._index = 0;
      this._started = false;
      this._scrollTransitionSettings = this.stage.transitions.createSettings({});
      this._itemSize = 100;
      this._viewportScrollOffset = 0;
      this._itemScrollOffset = 0;
      this._roll = false;
      this._rollMin = 0;
      this._rollMax = 0;
      this._progressAnimation = null;
      this._invertDirection = false;
      this._horizontal = true;
      this.itemList = new ListItems(this);
    }
    _allowChildrenAccess() {
      return false;
    }
    get items() {
      return this.itemList.get();
    }
    set items(children) {
      this.itemList.patch(children);
    }
    start() {
      this._wrapper.transition(this.property, this._scrollTransitionSettings);
      this._scrollTransition = this._wrapper.transition(this.property);
      this._scrollTransition.on("progress", (p) => this.update());
      this.setIndex(0, true, true);
      this._started = true;
      this.update();
    }
    setIndex(index, immediate = false, closest = false) {
      let nElements = this.length;
      if (!nElements) return;
      this.emit("unfocus", this.getElement(this.realIndex), this._index, this.realIndex);
      if (closest) {
        let offset = Utils.getModuloIndex(index, nElements);
        let o = Utils.getModuloIndex(this.index, nElements);
        let diff = offset - o;
        if (diff > 0.5 * nElements) {
          diff -= nElements;
        } else if (diff < -0.5 * nElements) {
          diff += nElements;
        }
        this._index += diff;
      } else {
        this._index = index;
      }
      if (this._roll || this.viewportSize > this._itemSize * nElements) {
        this._index = Utils.getModuloIndex(this._index, nElements);
      }
      let direction = this._horizontal ^ this._invertDirection ? -1 : 1;
      let value = direction * this._index * this._itemSize;
      if (this._roll) {
        let min, max, scrollDelta;
        if (direction == 1) {
          max = (nElements - 1) * this._itemSize;
          scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;
          max -= scrollDelta;
          min = this.viewportSize - (this._itemSize + scrollDelta);
          if (this._rollMin) min -= this._rollMin;
          if (this._rollMax) max += this._rollMax;
          value = Math.max(Math.min(value, max), min);
        } else {
          max = nElements * this._itemSize - this.viewportSize;
          scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;
          max += scrollDelta;
          let min2 = scrollDelta;
          if (this._rollMin) min2 -= this._rollMin;
          if (this._rollMax) max += this._rollMax;
          value = Math.min(Math.max(-max, value), -min2);
        }
      }
      this._scrollTransition.start(value);
      if (immediate) {
        this._scrollTransition.finish();
      }
      this.emit("focus", this.getElement(this.realIndex), this._index, this.realIndex);
    }
    getAxisPosition() {
      let target = -this._scrollTransition._targetValue;
      let direction = this._horizontal ^ this._invertDirection ? -1 : 1;
      let value = -direction * this._index * this._itemSize;
      return this._viewportScrollOffset * this.viewportSize + (value - target);
    }
    update() {
      if (!this._started) return;
      let nElements = this.length;
      if (!nElements) return;
      let direction = this._horizontal ^ this._invertDirection ? -1 : 1;
      let v = this._horizontal ? this._wrapper.x : this._wrapper.y;
      let viewportSize = this.viewportSize;
      let scrollDelta = this._viewportScrollOffset * viewportSize - this._itemScrollOffset * this._itemSize;
      v += scrollDelta;
      let s, e, ps, pe;
      if (direction == -1) {
        s = Math.floor(-v / this._itemSize);
        ps = 1 - (-v / this._itemSize - s);
        e = Math.floor((viewportSize - v) / this._itemSize);
        pe = (viewportSize - v) / this._itemSize - e;
      } else {
        s = Math.ceil(v / this._itemSize);
        ps = 1 + v / this._itemSize - s;
        e = Math.ceil((v - viewportSize) / this._itemSize);
        pe = e - (v - viewportSize) / this._itemSize;
      }
      if (this._roll || viewportSize > this._itemSize * nElements) {
        if (e >= nElements) {
          e = nElements - 1;
          pe = 1;
        }
        if (s >= nElements) {
          s = nElements - 1;
          ps = 1;
        }
        if (e <= -1) {
          e = 0;
          pe = 1;
        }
        if (s <= -1) {
          s = 0;
          ps = 1;
        }
      }
      let offset = -direction * s * this._itemSize;
      let item;
      for (let index = s; direction == -1 ? index <= e : index >= e; direction == -1 ? index++ : index--) {
        let realIndex = Utils.getModuloIndex(index, nElements);
        let element = this.getElement(realIndex);
        item = element.parent;
        this._visibleItems.delete(item);
        if (this._horizontal) {
          item.x = offset + scrollDelta;
        } else {
          item.y = offset + scrollDelta;
        }
        let wasVisible = item.visible;
        item.visible = true;
        if (!wasVisible || this._reloadVisibleElements) {
          this.emit("visible", index, realIndex);
        }
        if (this._progressAnimation) {
          let p = 1;
          if (index == s) {
            p = ps;
          } else if (index == e) {
            p = pe;
          }
          this._progressAnimation.apply(element, p);
        }
        offset += this._itemSize;
      }
      let self2 = this;
      this._visibleItems.forEach(function(invisibleItem) {
        invisibleItem.visible = false;
        self2._visibleItems.delete(invisibleItem);
      });
      for (let index = s; direction == -1 ? index <= e : index >= e; direction == -1 ? index++ : index--) {
        let realIndex = Utils.getModuloIndex(index, nElements);
        this._visibleItems.add(this.getWrapper(realIndex));
      }
      this._reloadVisibleElements = false;
    }
    setPrevious() {
      this.setIndex(this._index - 1);
    }
    setNext() {
      this.setIndex(this._index + 1);
    }
    getWrapper(index) {
      return this._wrapper.children[index];
    }
    getElement(index) {
      let e = this._wrapper.children[index];
      return e ? e.children[0] : null;
    }
    reload() {
      this._reloadVisibleElements = true;
      this.update();
    }
    get element() {
      let e = this._wrapper.children[this.realIndex];
      return e ? e.children[0] : null;
    }
    get length() {
      return this._wrapper.children.length;
    }
    get property() {
      return this._horizontal ? "x" : "y";
    }
    get viewportSize() {
      return this._horizontal ? this.w : this.h;
    }
    get index() {
      return this._index;
    }
    get realIndex() {
      return Utils.getModuloIndex(this._index, this.length);
    }
    get itemSize() {
      return this._itemSize;
    }
    set itemSize(v) {
      this._itemSize = v;
      this.update();
    }
    get viewportScrollOffset() {
      return this._viewportScrollOffset;
    }
    set viewportScrollOffset(v) {
      this._viewportScrollOffset = v;
      this.update();
    }
    get itemScrollOffset() {
      return this._itemScrollOffset;
    }
    set itemScrollOffset(v) {
      this._itemScrollOffset = v;
      this.update();
    }
    get scrollTransitionSettings() {
      return this._scrollTransitionSettings;
    }
    set scrollTransitionSettings(v) {
      this._scrollTransitionSettings.patch(v);
    }
    set scrollTransition(v) {
      this._scrollTransitionSettings.patch(v);
    }
    get scrollTransition() {
      return this._scrollTransition;
    }
    get progressAnimation() {
      return this._progressAnimation;
    }
    set progressAnimation(v) {
      if (Utils.isObjectLiteral(v)) {
        this._progressAnimation = this.stage.animations.createSettings(v);
      } else {
        this._progressAnimation = v;
      }
      this.update();
    }
    get roll() {
      return this._roll;
    }
    set roll(v) {
      this._roll = v;
      this.update();
    }
    get rollMin() {
      return this._rollMin;
    }
    set rollMin(v) {
      this._rollMin = v;
      this.update();
    }
    get rollMax() {
      return this._rollMax;
    }
    set rollMax(v) {
      this._rollMax = v;
      this.update();
    }
    get invertDirection() {
      return this._invertDirection;
    }
    set invertDirection(v) {
      if (!this._started) {
        this._invertDirection = v;
      }
    }
    get horizontal() {
      return this._horizontal;
    }
    set horizontal(v) {
      if (v !== this._horizontal) {
        if (!this._started) {
          this._horizontal = v;
        }
      }
    }
  };
  var ListItems = class extends ObjectListWrapper {
    constructor(list) {
      let wrap = ((item) => {
        let parent = item.stage.createElement();
        parent.add(item);
        parent.visible = false;
        return parent;
      });
      super(list._wrapper._children, wrap);
      this.list = list;
    }
    onAdd(item, index) {
      super.onAdd(item, index);
      this.checkStarted(index);
    }
    checkStarted(index) {
      this.list._reloadVisibleElements = true;
      if (!this.list._started) {
        this.list.start();
      } else {
        if (this.list.length === 1) {
          this.list.setIndex(0, true, true);
        } else {
          if (this.list._index >= this.list.length) {
            this.list.setIndex(0);
          }
        }
        this.list.update();
      }
    }
    onRemove(item, index) {
      super.onRemove(item, index);
      let ri = this.list.realIndex;
      if (ri === index) {
        if (ri === this.list.length) {
          ri--;
        }
        if (ri >= 0) {
          this.list.setIndex(ri);
        }
      } else if (ri > index) {
        this.list.setIndex(ri - 1);
      }
      this.list._reloadVisibleElements = true;
    }
    onSet(item, index) {
      super.onSet(item, index);
      this.checkStarted(index);
    }
    onSync(removed, added, order) {
      super.onSync(removed, added, order);
      this.checkStarted(0);
    }
    get _signalProxy() {
      return true;
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/LinearBlurShader.mjs
  var LinearBlurShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._direction = new Float32Array([1, 0]);
      this._kernelRadius = 1;
    }
    get x() {
      return this._direction[0];
    }
    set x(v) {
      this._direction[0] = v;
      this.redraw();
    }
    get y() {
      return this._direction[1];
    }
    set y(v) {
      this._direction[1] = v;
      this.redraw();
    }
    get kernelRadius() {
      return this._kernelRadius;
    }
    set kernelRadius(v) {
      this._kernelRadius = v;
      this.redraw();
    }
    useDefault() {
      return this._kernelRadius === 0;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      this._setUniform("direction", this._direction, this.gl.uniform2fv);
      this._setUniform("kernelRadius", this._kernelRadius, this.gl.uniform1i);
      const w = operation.getRenderWidth();
      const h = operation.getRenderHeight();
      this._setUniform("resolution", new Float32Array([w, h]), this.gl.uniform2fv);
    }
  };
  LinearBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 resolution;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 direction;
    uniform int kernelRadius;
    
    vec4 blur1(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color; 
    }
    
    vec4 blur2(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
    }
    
    vec4 blur3(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
    }    

    void main(void){
        if (kernelRadius == 1) {
            gl_FragColor = blur1(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else if (kernelRadius == 2) {
            gl_FragColor = blur2(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else {
            gl_FragColor = blur3(uSampler, vTextureCoord, resolution, direction) * vColor;
        }
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/BoxBlurShader.mjs
  var BoxBlurShader = class extends DefaultShader {
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const dx = 1 / operation.getTextureWidth(0);
      const dy = 1 / operation.getTextureHeight(0);
      this._setUniform("stepTextureCoord", new Float32Array([dx, dy]), this.gl.uniform2fv);
    }
  };
  BoxBlurShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 stepTextureCoord;
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec4 vColor;
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoordUl = aTextureCoord - stepTextureCoord;
        vTextureCoordBr = aTextureCoord + stepTextureCoord;
        vTextureCoordUr = vec2(vTextureCoordBr.x, vTextureCoordUl.y);
        vTextureCoordBl = vec2(vTextureCoordUl.x, vTextureCoordBr.y);
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  BoxBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = 0.25 * (texture2D(uSampler, vTextureCoordUl) + texture2D(uSampler, vTextureCoordUr) + texture2D(uSampler, vTextureCoordBl) + texture2D(uSampler, vTextureCoordBr));
        gl_FragColor = color * vColor;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/c2d/shaders/BlurShader.mjs
  var BlurShader = class extends DefaultShader2 {
    constructor(context2) {
      super(context2);
      this._kernelRadius = 1;
    }
    get kernelRadius() {
      return this._kernelRadius;
    }
    set kernelRadius(v) {
      this._kernelRadius = v;
      this.redraw();
    }
    useDefault() {
      return this._amount === 0;
    }
    _beforeDrawEl({ target }) {
      target.ctx.filter = "blur(" + this._kernelRadius + "px)";
    }
    _afterDrawEl({ target }) {
      target.ctx.filter = "none";
    }
  };

  // node_modules/@lightningjs/core/dist/src/components/FastBlurComponent.mjs
  var FastBlurComponent = class extends Component {
    static _template() {
      return {};
    }
    get wrap() {
      return this.tag("Wrap");
    }
    set content(v) {
      return this.wrap.content = v;
    }
    get content() {
      return this.wrap.content;
    }
    set padding(v) {
      this.wrap._paddingX = v;
      this.wrap._paddingY = v;
      this.wrap._updateBlurSize();
    }
    set paddingX(v) {
      this.wrap._paddingX = v;
      this.wrap._updateBlurSize();
    }
    set paddingY(v) {
      this.wrap._paddingY = v;
      this.wrap._updateBlurSize();
    }
    set amount(v) {
      return this.wrap.amount = v;
    }
    get amount() {
      return this.wrap.amount;
    }
    _onResize() {
      this.wrap.w = this.renderWidth;
      this.wrap.h = this.renderHeight;
    }
    get _signalProxy() {
      return true;
    }
    _build() {
      this.patch({
        Wrap: { type: this.stage.gl ? WebGLFastBlurComponent : C2dFastBlurComponent }
      });
    }
  };
  var C2dFastBlurComponent = class _C2dFastBlurComponent extends Component {
    static _template() {
      return {
        forceZIndexContext: true,
        rtt: true,
        Textwrap: { shader: { type: BlurShader }, Content: {} }
      };
    }
    constructor(stage2) {
      super(stage2);
      this._textwrap = this.sel("Textwrap");
      this._wrapper = this.sel("Textwrap>Content");
      this._amount = 0;
      this._paddingX = 0;
      this._paddingY = 0;
    }
    static getSpline() {
      if (!this._multiSpline) {
        this._multiSpline = new MultiSpline();
        this._multiSpline.parse(false, { 0: 0, 0.25: 1.5, 0.5: 5.5, 0.75: 18, 1: 39 });
      }
      return this._multiSpline;
    }
    get content() {
      return this.sel("Textwrap>Content");
    }
    set content(v) {
      this.sel("Textwrap>Content").patch(v, true);
    }
    set padding(v) {
      this._paddingX = v;
      this._paddingY = v;
      this._updateBlurSize();
    }
    set paddingX(v) {
      this._paddingX = v;
      this._updateBlurSize();
    }
    set paddingY(v) {
      this._paddingY = v;
      this._updateBlurSize();
    }
    _updateBlurSize() {
      let w = this.renderWidth;
      let h = this.renderHeight;
      let paddingX = this._paddingX;
      let paddingY = this._paddingY;
      this._wrapper.x = paddingX;
      this._textwrap.x = -paddingX;
      this._wrapper.y = paddingY;
      this._textwrap.y = -paddingY;
      this._textwrap.w = w + paddingX * 2;
      this._textwrap.h = h + paddingY * 2;
    }
    get amount() {
      return this._amount;
    }
    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
      this._amount = v;
      this._textwrap.shader.kernelRadius = _C2dFastBlurComponent._amountToKernelRadius(v);
    }
    static _amountToKernelRadius(v) {
      return _C2dFastBlurComponent.getSpline().getValue(Math.min(1, v * 0.25));
    }
    get _signalProxy() {
      return true;
    }
  };
  var WebGLFastBlurComponent = class extends Component {
    static _template() {
      const onUpdate = function(element, elementCore) {
        if (elementCore._recalc & 2 + 128) {
          const w = elementCore.w;
          const h = elementCore.h;
          let cur = elementCore;
          do {
            cur = cur._children[0];
            cur._element.w = w;
            cur._element.h = h;
          } while (cur._children);
        }
      };
      return {
        Textwrap: { rtt: true, forceZIndexContext: true, renderOffscreen: true, Content: {} },
        Layers: {
          L0: { rtt: true, onUpdate, renderOffscreen: true, visible: false, Content: { shader: { type: BoxBlurShader } } },
          L1: { rtt: true, onUpdate, renderOffscreen: true, visible: false, Content: { shader: { type: BoxBlurShader } } },
          L2: { rtt: true, onUpdate, renderOffscreen: true, visible: false, Content: { shader: { type: BoxBlurShader } } },
          L3: { rtt: true, onUpdate, renderOffscreen: true, visible: false, Content: { shader: { type: BoxBlurShader } } }
        },
        Result: { shader: { type: FastBlurOutputShader }, visible: false }
      };
    }
    get _signalProxy() {
      return true;
    }
    constructor(stage2) {
      super(stage2);
      this._textwrap = this.sel("Textwrap");
      this._wrapper = this.sel("Textwrap>Content");
      this._layers = this.sel("Layers");
      this._output = this.sel("Result");
      this._amount = 0;
      this._paddingX = 0;
      this._paddingY = 0;
    }
    _buildLayers() {
      const filterShaderSettings = [{ x: 1, y: 0, kernelRadius: 1 }, { x: 0, y: 1, kernelRadius: 1 }, { x: 1.5, y: 0, kernelRadius: 1 }, { x: 0, y: 1.5, kernelRadius: 1 }];
      const filterShaders = filterShaderSettings.map((s) => {
        const shader = Shader.create(this.stage, Object.assign({ type: LinearBlurShader }, s));
        return shader;
      });
      this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
      this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);
      this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
      this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    }
    _setLayerTexture(element, texture, steps) {
      if (!steps.length) {
        element.texture = texture;
      } else {
        const step2 = steps.pop();
        const child = element.stage.c({ rtt: true, shader: step2 });
        this._setLayerTexture(child, texture, steps);
        element.childList.add(child);
      }
      return element;
    }
    get content() {
      return this.sel("Textwrap>Content");
    }
    set content(v) {
      this.sel("Textwrap>Content").patch(v, true);
    }
    set padding(v) {
      this._paddingX = v;
      this._paddingY = v;
      this._updateBlurSize();
    }
    set paddingX(v) {
      this._paddingX = v;
      this._updateBlurSize();
    }
    set paddingY(v) {
      this._paddingY = v;
      this._updateBlurSize();
    }
    getLayer(i) {
      return this._layers.sel("L" + i);
    }
    getLayerContents(i) {
      return this.getLayer(i).sel("Content");
    }
    _onResize() {
      this._updateBlurSize();
    }
    _updateBlurSize() {
      let w = this.renderWidth;
      let h = this.renderHeight;
      let paddingX = this._paddingX;
      let paddingY = this._paddingY;
      let fw = w + paddingX * 2;
      let fh = h + paddingY * 2;
      this._textwrap.w = fw;
      this._wrapper.x = paddingX;
      this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
      this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
      this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
      this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
      this._output.x = -paddingX;
      this._textwrap.x = -paddingX;
      this._output.w = fw;
      this._textwrap.h = fh;
      this._wrapper.y = paddingY;
      this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
      this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
      this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
      this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
      this._output.y = -paddingY;
      this._textwrap.y = -paddingY;
      this._output.h = fh;
      this.w = w;
      this.h = h;
    }
    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
      this._amount = v;
      this._update();
    }
    get amount() {
      return this._amount;
    }
    _update() {
      let v = Math.min(4, Math.max(0, this._amount));
      if (v === 0) {
        this._textwrap.renderToTexture = false;
        this._output.shader.otherTextureSource = null;
        this._output.visible = false;
      } else {
        this._textwrap.renderToTexture = true;
        this._output.visible = true;
        this.getLayer(0).visible = v > 0;
        this.getLayer(1).visible = v > 1;
        this.getLayer(2).visible = v > 2;
        this.getLayer(3).visible = v > 3;
        if (v <= 1) {
          this._output.texture = this._textwrap.getTexture();
          this._output.shader.otherTextureSource = this.getLayer(0).getTexture();
          this._output.shader.a = v;
        } else if (v <= 2) {
          this._output.texture = this.getLayer(0).getTexture();
          this._output.shader.otherTextureSource = this.getLayer(1).getTexture();
          this._output.shader.a = v - 1;
        } else if (v <= 3) {
          this._output.texture = this.getLayer(1).getTexture();
          this._output.shader.otherTextureSource = this.getLayer(2).getTexture();
          this._output.shader.a = v - 2;
        } else if (v <= 4) {
          this._output.texture = this.getLayer(2).getTexture();
          this._output.shader.otherTextureSource = this.getLayer(3).getTexture();
          this._output.shader.a = v - 3;
        }
      }
    }
    set shader(s) {
      super.shader = s;
      if (!this.renderToTexture) {
        console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
      }
    }
    _firstActive() {
      this._buildLayers();
    }
  };
  var FastBlurOutputShader = class extends DefaultShader {
    constructor(ctx) {
      super(ctx);
      this._a = 0;
      this._otherTextureSource = null;
    }
    get a() {
      return this._a;
    }
    set a(v) {
      this._a = v;
      this.redraw();
    }
    set otherTextureSource(v) {
      this._otherTextureSource = v;
      this.redraw();
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      this._setUniform("a", this._a, this.gl.uniform1f);
      this._setUniform("uSampler2", 1, this.gl.uniform1i);
    }
    beforeDraw(operation) {
      let glTexture = this._otherTextureSource ? this._otherTextureSource.nativeTexture : null;
      let gl = this.gl;
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.activeTexture(gl.TEXTURE0);
    }
  };
  FastBlurOutputShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uSampler2;
    uniform float a;
    void main(void){
        if (a == 1.0) {
            gl_FragColor = texture2D(uSampler2, vTextureCoord) * vColor;
        } else {
            gl_FragColor = ((1.0 - a) * texture2D(uSampler, vTextureCoord) + (a * texture2D(uSampler2, vTextureCoord))) * vColor;
        }
    }
`;

  // node_modules/@lightningjs/core/dist/src/components/BloomComponent.mjs
  var BloomComponent = class extends Component {
    static _template() {
      const onUpdate = function(element, elementCore) {
        if (elementCore._recalc & 2 + 128) {
          const w = elementCore.w;
          const h = elementCore.h;
          let cur = elementCore;
          do {
            cur = cur._children[0];
            cur._element.w = w;
            cur._element.h = h;
          } while (cur._children);
        }
      };
      return {
        Textwrap: {
          rtt: true,
          forceZIndexContext: true,
          renderOffscreen: true,
          BloomBase: {
            shader: { type: BloomBaseShader },
            Content: {}
          }
        },
        Layers: {
          L0: { rtt: true, onUpdate, scale: 2, pivot: 0, visible: false, Content: { shader: { type: BoxBlurShader } } },
          L1: { rtt: true, onUpdate, scale: 4, pivot: 0, visible: false, Content: { shader: { type: BoxBlurShader } } },
          L2: { rtt: true, onUpdate, scale: 8, pivot: 0, visible: false, Content: { shader: { type: BoxBlurShader } } },
          L3: { rtt: true, onUpdate, scale: 16, pivot: 0, visible: false, Content: { shader: { type: BoxBlurShader } } }
        }
      };
    }
    get _signalProxy() {
      return true;
    }
    constructor(stage2) {
      super(stage2);
      this._textwrap = this.sel("Textwrap");
      this._wrapper = this.sel("Textwrap.Content");
      this._layers = this.sel("Layers");
      this._amount = 0;
      this._paddingX = 0;
      this._paddingY = 0;
    }
    _build() {
      const filterShaderSettings = [{ x: 1, y: 0, kernelRadius: 3 }, { x: 0, y: 1, kernelRadius: 3 }, { x: 1.5, y: 0, kernelRadius: 3 }, { x: 0, y: 1.5, kernelRadius: 3 }];
      const filterShaders = filterShaderSettings.map((s) => {
        const shader = this.stage.createShader(Object.assign({ type: LinearBlurShader }, s));
        return shader;
      });
      this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
      this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);
      this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
      this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    }
    _setLayerTexture(element, texture, steps) {
      if (!steps.length) {
        element.texture = texture;
      } else {
        const step2 = steps.pop();
        const child = element.stage.c({ rtt: true, shader: step2 });
        this._setLayerTexture(child, texture, steps);
        element.childList.add(child);
      }
      return element;
    }
    get content() {
      return this.sel("Textwrap.Content");
    }
    set content(v) {
      this.sel("Textwrap.Content").patch(v);
    }
    set padding(v) {
      this._paddingX = v;
      this._paddingY = v;
      this._updateBlurSize();
    }
    set paddingX(v) {
      this._paddingX = v;
      this._updateBlurSize();
    }
    set paddingY(v) {
      this._paddingY = v;
      this._updateBlurSize();
    }
    getLayer(i) {
      return this._layers.sel("L" + i);
    }
    getLayerContents(i) {
      return this.getLayer(i).sel("Content");
    }
    _onResize() {
      this._updateBlurSize();
    }
    _updateBlurSize() {
      let w = this.renderWidth;
      let h = this.renderHeight;
      let paddingX = this._paddingX;
      let paddingY = this._paddingY;
      let fw = w + paddingX * 2;
      let fh = h + paddingY * 2;
      this._textwrap.w = fw;
      this._wrapper.x = paddingX;
      this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
      this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
      this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
      this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
      this._textwrap.x = -paddingX;
      this._textwrap.h = fh;
      this._wrapper.y = paddingY;
      this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
      this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
      this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
      this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
      this._textwrap.y = -paddingY;
      this.w = w;
      this.h = h;
    }
    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
      this._amount = v;
      this._update();
    }
    get amount() {
      return this._amount;
    }
    _update() {
      let v = Math.min(4, Math.max(0, this._amount));
      if (v > 0) {
        this.getLayer(0).visible = v > 0;
        this.getLayer(1).visible = v > 1;
        this.getLayer(2).visible = v > 2;
        this.getLayer(3).visible = v > 3;
      }
    }
    set shader(s) {
      super.shader = s;
      if (!this.renderToTexture) {
        console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
      }
    }
    _firstActive() {
      this._build();
    }
  };
  var BloomBaseShader = class extends DefaultShader {
  };
  BloomBaseShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float m = max(max(color.r, color.g), color.b);
        float c = max(0.0, (m - 0.80)) * 5.0;
        color = color * c;
        gl_FragColor = color;
    }
`;

  // node_modules/@lightningjs/core/dist/src/components/SmoothScaleComponent.mjs
  var SmoothScaleComponent = class _SmoothScaleComponent extends Component {
    static _template() {
      return {
        ContentWrap: {
          renderOffscreen: true,
          forceZIndexContext: true,
          onAfterUpdate: _SmoothScaleComponent._updateDimensions,
          Content: {}
        },
        Scale: { visible: false }
      };
    }
    constructor(stage2) {
      super(stage2);
      this._smoothScale = 1;
      this._iterations = 0;
    }
    get content() {
      return this.tag("Content");
    }
    set content(v) {
      this.tag("Content").patch(v, true);
    }
    get smoothScale() {
      return this._smoothScale;
    }
    set smoothScale(v) {
      if (this._smoothScale !== v) {
        let its = 0;
        while (v < 0.5 && its < 12) {
          its++;
          v = v * 2;
        }
        this.scale = v;
        this._setIterations(its);
        this._smoothScale = v;
      }
    }
    _setIterations(its) {
      if (this._iterations !== its) {
        const scalers = this.sel("Scale").childList;
        const content = this.sel("ContentWrap");
        while (scalers.length < its) {
          const first = scalers.length === 0;
          const texture = first ? content.getTexture() : scalers.last.getTexture();
          scalers.a({ rtt: true, renderOffscreen: true, texture });
        }
        _SmoothScaleComponent._updateDimensions(this.tag("ContentWrap"), true);
        const useScalers = its > 0;
        this.patch({
          ContentWrap: { renderToTexture: useScalers },
          Scale: { visible: useScalers }
        });
        for (let i = 0, n = scalers.length; i < n; i++) {
          scalers.getAt(i).patch({
            visible: i < its,
            renderOffscreen: i !== its - 1
          });
        }
        this._iterations = its;
      }
    }
    static _updateDimensions(contentWrap, force) {
      const content = contentWrap.children[0];
      let w = content.renderWidth;
      let h = content.renderHeight;
      if (w !== contentWrap.w || h !== contentWrap.h || force) {
        contentWrap.w = w;
        contentWrap.h = h;
        const scalers = contentWrap.parent.tag("Scale").children;
        for (let i = 0, n = scalers.length; i < n; i++) {
          w = w * 0.5;
          h = h * 0.5;
          scalers[i].w = w;
          scalers[i].h = h;
        }
      }
    }
    get _signalProxy() {
      return true;
    }
  };

  // node_modules/@lightningjs/core/dist/src/components/BorderComponent.mjs
  var BorderComponent = class extends Component {
    static _template() {
      return {
        Content: {},
        Borders: {
          Top: { rect: true, visible: false, mountY: 1 },
          Right: { rect: true, visible: false },
          Bottom: { rect: true, visible: false },
          Left: { rect: true, visible: false, mountX: 1 }
        }
      };
    }
    get _signalProxy() {
      return true;
    }
    constructor(stage2) {
      super(stage2);
      this._borderTop = this.tag("Top");
      this._borderRight = this.tag("Right");
      this._borderBottom = this.tag("Bottom");
      this._borderLeft = this.tag("Left");
      this.onAfterUpdate = function(element) {
        const content = element.childList.first;
        let w = element.core.w || content.renderWidth;
        let h = element.core.h || content.renderHeight;
        element._borderTop.w = w;
        element._borderBottom.y = h;
        element._borderBottom.w = w;
        element._borderLeft.h = h + element._borderTop.h + element._borderBottom.h;
        element._borderLeft.y = -element._borderTop.h;
        element._borderRight.x = w;
        element._borderRight.h = h + element._borderTop.h + element._borderBottom.h;
        element._borderRight.y = -element._borderTop.h;
      };
      this.borderWidth = 1;
    }
    get content() {
      return this.sel("Content");
    }
    set content(v) {
      this.sel("Content").patch(v, true);
    }
    get borderWidth() {
      return this.borderWidthTop;
    }
    get borderWidthTop() {
      return this._borderTop.h;
    }
    get borderWidthRight() {
      return this._borderRight.w;
    }
    get borderWidthBottom() {
      return this._borderBottom.h;
    }
    get borderWidthLeft() {
      return this._borderLeft.w;
    }
    set borderWidth(v) {
      this.borderWidthTop = v;
      this.borderWidthRight = v;
      this.borderWidthBottom = v;
      this.borderWidthLeft = v;
    }
    set borderWidthTop(v) {
      this._borderTop.h = v;
      this._borderTop.visible = v > 0;
    }
    set borderWidthRight(v) {
      this._borderRight.w = v;
      this._borderRight.visible = v > 0;
    }
    set borderWidthBottom(v) {
      this._borderBottom.h = v;
      this._borderBottom.visible = v > 0;
    }
    set borderWidthLeft(v) {
      this._borderLeft.w = v;
      this._borderLeft.visible = v > 0;
    }
    get colorBorder() {
      return this.colorBorderTop;
    }
    get colorBorderTop() {
      return this._borderTop.color;
    }
    get colorBorderRight() {
      return this._borderRight.color;
    }
    get colorBorderBottom() {
      return this._borderBottom.color;
    }
    get colorBorderLeft() {
      return this._borderLeft.color;
    }
    set colorBorder(v) {
      this.colorBorderTop = v;
      this.colorBorderRight = v;
      this.colorBorderBottom = v;
      this.colorBorderLeft = v;
    }
    set colorBorderTop(v) {
      this._borderTop.color = v;
    }
    set colorBorderRight(v) {
      this._borderRight.color = v;
    }
    set colorBorderBottom(v) {
      this._borderBottom.color = v;
    }
    set colorBorderLeft(v) {
      this._borderLeft.color = v;
    }
    get borderTop() {
      return this._borderTop;
    }
    set borderTop(settings2) {
      this.borderTop.patch(settings2);
    }
    get borderRight() {
      return this._borderRight;
    }
    set borderRight(settings2) {
      this.borderRight.patch(settings2);
    }
    get borderBottom() {
      return this._borderBottom;
    }
    set borderBottom(settings2) {
      this.borderBottom.patch(settings2);
    }
    get borderLeft() {
      return this._borderLeft;
    }
    set borderLeft(settings2) {
      this.borderLeft.patch(settings2);
    }
    set borders(settings2) {
      this.borderTop = settings2;
      this.borderLeft = settings2;
      this.borderBottom = settings2;
      this.borderRight = settings2;
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/common/shaders/GrayscaleShader.mjs
  var WebGLGrayscaleShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._amount = 1;
    }
    static getC2d() {
      return C2dGrayscaleShader;
    }
    set amount(v) {
      this._amount = v;
      this.redraw();
    }
    get amount() {
      return this._amount;
    }
    useDefault() {
      return this._amount === 0;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      this._setUniform("amount", this._amount, this.gl.uniform1f);
    }
  };
  WebGLGrayscaleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float grayness = 0.2 * color.r + 0.6 * color.g + 0.2 * color.b;
        gl_FragColor = vec4(amount * vec3(grayness, grayness, grayness) + (1.0 - amount) * color.rgb, color.a);
    }
`;
  var C2dGrayscaleShader = class extends DefaultShader2 {
    constructor(context2) {
      super(context2);
      this._amount = 1;
    }
    static getWebGL() {
      return WebGLGrayscaleShader;
    }
    set amount(v) {
      this._amount = v;
      this.redraw();
    }
    get amount() {
      return this._amount;
    }
    useDefault() {
      return this._amount === 0;
    }
    _beforeDrawEl({ target }) {
      target.ctx.filter = "grayscale(" + this._amount + ")";
    }
    _afterDrawEl({ target }) {
      target.ctx.filter = "none";
    }
  };

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/DitheringShader.mjs
  var DitheringShader = class extends DefaultShader {
    constructor(ctx) {
      super(ctx);
      this._noiseTexture = new NoiseTexture(ctx.stage);
      this._graining = 1 / 256;
      this._random = false;
    }
    set graining(v) {
      this._graining = v;
      this.redraw();
    }
    set random(v) {
      this._random = v;
      this.redraw();
    }
    setExtraAttribsInBuffer(operation) {
      this._noiseTexture.load();
      let offset = operation.extraAttribsDataByteOffset / 4;
      let floats = operation.quads.floats;
      let length = operation.length;
      for (let i = 0; i < length; i++) {
        let brx = operation.getElementWidth(i) / this._noiseTexture.getRenderWidth();
        let bry = operation.getElementHeight(i) / this._noiseTexture.getRenderHeight();
        let ulx = 0;
        let uly = 0;
        if (this._random) {
          ulx = Math.random();
          uly = Math.random();
          brx += ulx;
          bry += uly;
          if (Math.random() < 0.5) {
            const t = ulx;
            ulx = brx;
            brx = t;
          }
          if (Math.random() < 0.5) {
            const t = uly;
            uly = bry;
            bry = t;
          }
        }
        floats[offset] = ulx;
        floats[offset + 1] = uly;
        floats[offset + 2] = brx;
        floats[offset + 3] = uly;
        floats[offset + 4] = brx;
        floats[offset + 5] = bry;
        floats[offset + 6] = ulx;
        floats[offset + 7] = bry;
        offset += 8;
      }
    }
    beforeDraw(operation) {
      let gl = this.gl;
      gl.vertexAttribPointer(this._attrib("aNoiseTextureCoord"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
      let glTexture = this._noiseTexture.source.nativeTexture;
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.activeTexture(gl.TEXTURE0);
    }
    getExtraAttribBytesPerVertex() {
      return 8;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      this._setUniform("uNoiseSampler", 1, this.gl.uniform1i);
      this._setUniform("graining", 2 * this._graining, this.gl.uniform1f);
    }
    enableAttribs() {
      super.enableAttribs();
      let gl = this.gl;
      gl.enableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }
    disableAttribs() {
      super.disableAttribs();
      let gl = this.gl;
      gl.disableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }
    useDefault() {
      return this._graining === 0;
    }
    afterDraw(operation) {
      if (this._random) {
        this.redraw();
      }
    }
  };
  DitheringShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNoiseTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vNoiseTextureCoord = aNoiseTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  DitheringShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uNoiseSampler;
    uniform float graining;
    void main(void){
        vec4 noise = texture2D(uNoiseSampler, vNoiseTextureCoord);
        vec4 color = texture2D(uSampler, vTextureCoord);
        gl_FragColor = (color * vColor) + graining * (noise.r - 0.5);
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/CircularPushShader.mjs
  var CircularPushShader = class extends DefaultShader {
    constructor(ctx) {
      super(ctx);
      this._inputValue = 0;
      this._maxDerivative = 0.01;
      this._normalizedValue = 0;
      this._offset = 0;
      this._amount = 0.1;
      this._aspectRatio = 1;
      this._offsetX = 0;
      this._offsetY = 0;
      this.buckets = 100;
    }
    get aspectRatio() {
      return this._aspectRatio;
    }
    set aspectRatio(v) {
      this._aspectRatio = v;
      this.redraw();
    }
    get offsetX() {
      return this._offsetX;
    }
    set offsetX(v) {
      this._offsetX = v;
      this.redraw();
    }
    get offsetY() {
      return this._offsetY;
    }
    set offsetY(v) {
      this._offsetY = v;
      this.redraw();
    }
    set amount(v) {
      this._amount = v;
      this.redraw();
    }
    get amount() {
      return this._amount;
    }
    set inputValue(v) {
      this._inputValue = v;
    }
    get inputValue() {
      return this._inputValue;
    }
    set maxDerivative(v) {
      this._maxDerivative = v;
    }
    get maxDerivative() {
      return this._maxDerivative;
    }
    set buckets(v) {
      if (v > 100) {
        console.warn("[Lightning] CircularPushShader: supports max 100 buckets");
        v = 100;
      }
      this._buckets = v;
      this._values = new Uint8Array(this._getValues(v));
      this.redraw();
    }
    get buckets() {
      return this._buckets;
    }
    _getValues(n) {
      const v = [];
      for (let i = 0; i < n; i++) {
        v.push(this._inputValue);
      }
      return v;
    }
    /**
     * Progresses the shader with the specified (fractional) number of buckets.
     * @param {number} o;
     *   A number from 0 to 1 (1 = all buckets).
     */
    progress(o) {
      this._offset += o * this._buckets;
      const full = Math.floor(this._offset);
      this._offset -= full;
      this._shiftBuckets(full);
      this.redraw();
    }
    _shiftBuckets(n) {
      for (let i = this._buckets - 1; i >= 0; i--) {
        const targetIndex = i - n;
        if (targetIndex < 0) {
          this._normalizedValue = Math.min(this._normalizedValue + this._maxDerivative, Math.max(this._normalizedValue - this._maxDerivative, this._inputValue));
          this._values[i] = 255 * this._normalizedValue;
        } else {
          this._values[i] = this._values[targetIndex];
        }
      }
    }
    set offset(v) {
      this._offset = v;
      this.redraw();
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      this._setUniform("aspectRatio", this._aspectRatio, this.gl.uniform1f);
      this._setUniform("offsetX", this._offsetX, this.gl.uniform1f);
      this._setUniform("offsetY", this._offsetY, this.gl.uniform1f);
      this._setUniform("amount", this._amount, this.gl.uniform1f);
      this._setUniform("offset", this._offset, this.gl.uniform1f);
      this._setUniform("buckets", this._buckets, this.gl.uniform1f);
      this._setUniform("uValueSampler", 1, this.gl.uniform1i);
    }
    useDefault() {
      return this._amount === 0;
    }
    beforeDraw(operation) {
      const gl = this.gl;
      gl.activeTexture(gl.TEXTURE1);
      if (!this._valuesTexture) {
        this._valuesTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (Utils.isNode) {
          gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, false);
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      } else {
        gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
      }
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this._buckets, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this._values);
      gl.activeTexture(gl.TEXTURE0);
    }
    cleanup() {
      if (this._valuesTexture) {
        this.gl.deleteTexture(this._valuesTexture);
      }
    }
  };
  CircularPushShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform float offsetX;
    uniform float offsetY;
    uniform float aspectRatio;
    varying vec2 vTextureCoord;
    varying vec2 vPos;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vPos = vTextureCoord * 2.0 - 1.0;
        vPos.y = vPos.y * aspectRatio;
        vPos.y = vPos.y + offsetY;
        vPos.x = vPos.x + offsetX;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  CircularPushShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vPos;
    uniform float amount;
    uniform float offset;
    uniform float values[100];
    uniform float buckets;
    uniform sampler2D uSampler;
    uniform sampler2D uValueSampler;
    void main(void){
        float l = length(vPos);
        float m = (l * buckets * 0.678 - offset) / buckets;
        float f = texture2D(uValueSampler, vec2(m, 0.0)).a * amount;
        vec2 unit = vPos / l;
        gl_FragColor = texture2D(uSampler, vTextureCoord - f * unit) * vColor;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/InversionShader.mjs
  var InversionShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._amount = 1;
    }
    set amount(v) {
      this._amount = v;
      this.redraw();
    }
    get amount() {
      return this._amount;
    }
    useDefault() {
      return this._amount === 0;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      this._setUniform("amount", this._amount, this.gl.uniform1f);
    }
  };
  InversionShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        color.rgb = color.rgb * (1.0 - amount) + amount * (1.0 * color.a - color.rgb); 
        gl_FragColor = color * vColor;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/OutlineShader.mjs
  var OutlineShader = class extends DefaultShader {
    constructor(ctx) {
      super(ctx);
      this._width = 5;
      this._col = 4294967295;
      this._color = [1, 1, 1, 1];
    }
    set width(v) {
      this._width = v;
      this.redraw();
    }
    get color() {
      return this._col;
    }
    set color(v) {
      if (this._col !== v) {
        const col = StageUtils.getRgbaComponentsNormalized(v);
        col[0] = col[0] * col[3];
        col[1] = col[1] * col[3];
        col[2] = col[2] * col[3];
        this._color = col;
        this.redraw();
        this._col = v;
      }
    }
    useDefault() {
      return this._width === 0 || this._col[3] === 0;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      let gl = this.gl;
      this._setUniform("color", new Float32Array(this._color), gl.uniform4fv);
    }
    enableAttribs() {
      super.enableAttribs();
      this.gl.enableVertexAttribArray(this._attrib("aCorner"));
    }
    disableAttribs() {
      super.disableAttribs();
      this.gl.disableVertexAttribArray(this._attrib("aCorner"));
    }
    setExtraAttribsInBuffer(operation) {
      let offset = operation.extraAttribsDataByteOffset / 4;
      let floats = operation.quads.floats;
      let length = operation.length;
      for (let i = 0; i < length; i++) {
        const elementCore = operation.getElementCore(i);
        const ddw = this._width / elementCore.w;
        const dw = ddw / (1 - 2 * ddw);
        const ddh = this._width / elementCore.h;
        const dh = ddh / (1 - 2 * ddh);
        floats[offset] = -dw;
        floats[offset + 1] = -dh;
        floats[offset + 2] = 1 + dw;
        floats[offset + 3] = -dh;
        floats[offset + 4] = 1 + dw;
        floats[offset + 5] = 1 + dh;
        floats[offset + 6] = -dw;
        floats[offset + 7] = 1 + dh;
        offset += 8;
      }
    }
    beforeDraw(operation) {
      let gl = this.gl;
      gl.vertexAttribPointer(this._attrib("aCorner"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
    }
    getExtraAttribBytesPerVertex() {
      return 8;
    }
  };
  OutlineShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aCorner;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vCorner;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vCorner = aCorner;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  OutlineShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vCorner;
    uniform vec4 color;
    uniform sampler2D uSampler;
    void main(void){
        vec2 m = min(vCorner, 1.0 - vCorner);
        float value = step(0.0, min(m.x, m.y));
        gl_FragColor = mix(color, texture2D(uSampler, vTextureCoord) * vColor, value);
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/PixelateShader.mjs
  var PixelateShader = class extends DefaultShader {
    constructor(ctx) {
      super(ctx);
      this._size = new Float32Array([4, 4]);
    }
    get x() {
      return this._size[0];
    }
    set x(v) {
      this._size[0] = v;
      this.redraw();
    }
    get y() {
      return this._size[1];
    }
    set y(v) {
      this._size[1] = v;
      this.redraw();
    }
    get size() {
      return this._size[0];
    }
    set size(v) {
      this._size[0] = v;
      this._size[1] = v;
      this.redraw();
    }
    useDefault() {
      return this._size[0] === 0 && this._size[1] === 0;
    }
    static getWebGLImpl() {
      return WebGLPixelateShaderImpl;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      let gl = this.gl;
      this._setUniform("size", new Float32Array(this._size), gl.uniform2fv);
    }
    getExtraAttribBytesPerVertex() {
      return 8;
    }
    enableAttribs() {
      super.enableAttribs();
      this.gl.enableVertexAttribArray(this._attrib("aTextureRes"));
    }
    disableAttribs() {
      super.disableAttribs();
      this.gl.disableVertexAttribArray(this._attrib("aTextureRes"));
    }
    setExtraAttribsInBuffer(operation) {
      let offset = operation.extraAttribsDataByteOffset / 4;
      let floats = operation.quads.floats;
      let length = operation.length;
      for (let i = 0; i < length; i++) {
        let w = operation.quads.getTextureWidth(operation.index + i);
        let h = operation.quads.getTextureHeight(operation.index + i);
        floats[offset] = w;
        floats[offset + 1] = h;
        floats[offset + 2] = w;
        floats[offset + 3] = h;
        floats[offset + 4] = w;
        floats[offset + 5] = h;
        floats[offset + 6] = w;
        floats[offset + 7] = h;
        offset += 8;
      }
    }
    beforeDraw(operation) {
      let gl = this.gl;
      gl.vertexAttribPointer(this._attrib("aTextureRes"), 2, gl.FLOAT, false, this.getExtraAttribBytesPerVertex(), this.getVertexAttribPointerOffset(operation));
    }
  };
  PixelateShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aTextureRes;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        vTextureRes = aTextureRes;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  PixelateShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;

    uniform vec2 size;
    uniform sampler2D uSampler;
    
    vec2 mapCoord( vec2 coord )
    {
        coord *= vTextureRes.xy;
        return coord;
    }
    
    vec2 unmapCoord( vec2 coord )
    {
        coord /= vTextureRes.xy;
        return coord;
    }
    
    vec2 pixelate(vec2 coord, vec2 size)
    {
        return floor( coord / size ) * size;
    }
    
    void main(void)
    {
        vec2 coord = mapCoord(vTextureCoord);
        coord = pixelate(coord, size);
        coord = unmapCoord(coord);
        gl_FragColor = texture2D(uSampler, coord) * vColor;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/RadialFilterShader.mjs
  var RadialFilterShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._radius = 0;
      this._cutoff = 1;
    }
    set radius(v) {
      this._radius = v;
      this.redraw();
    }
    get radius() {
      return this._radius;
    }
    set cutoff(v) {
      this._cutoff = v;
      this.redraw();
    }
    get cutoff() {
      return this._cutoff;
    }
    useDefault() {
      return this._radius === 0;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      this._setUniform("radius", 2 * (this._radius - 0.5) / operation.getRenderWidth(), this.gl.uniform1f);
      this._setUniform("cutoff", 0.5 * operation.getRenderWidth() / this._cutoff, this.gl.uniform1f);
    }
  };
  RadialFilterShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy;
    }
`;
  RadialFilterShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 pos;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform float cutoff;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        float f = max(0.0, min(1.0, 1.0 - (length(pos) - radius) * cutoff));
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * f;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/RoundedRectangleShader.mjs
  var RoundedRectangleShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._blend = 0;
      this._radius = [1, 1, 1, 1];
      this._stroke = 0;
      this._fc = 16777215;
      this._fillColor = this._getNormalizedColor(4294967295);
      this._strokeColor = this._getNormalizedColor(16777215);
    }
    set blend(p) {
      this._blend = Math.min(Math.max(p, 0), 1);
    }
    get blend() {
      return this._blend;
    }
    set radius(v) {
      if (Array.isArray(v)) {
        if (v.length === 2) {
          this._radius = [v[0], v[1], v[0], v[1]];
        } else if (v.length === 3) {
          this._radius = [v[0], v[1], v[2], this._radius[3]];
        } else if (v.length === 4) {
          this._radius = v;
        } else {
          this._radius = [v[0], v[0], v[0], v[0]];
        }
      } else {
        this._radius = [v, v, v, v];
      }
      this.redraw();
    }
    get radius() {
      return this._radius;
    }
    set topLeft(num) {
      this._radius[0] = num;
      this.redraw();
    }
    get topLeft() {
      return this._radius[0];
    }
    set topRight(num) {
      this._radius[1] = num;
      this.redraw();
    }
    get topRight() {
      return this._radius[1];
    }
    set bottomRight(num) {
      this._radius[2] = num;
      this.redraw();
    }
    get bottomRight() {
      return this._radius[2];
    }
    set bottomLeft(num) {
      this._radius[3] = num;
      this.redraw();
    }
    get bottomLeft() {
      return this._radius[3];
    }
    set strokeColor(argb) {
      this._sc = argb;
      this._strokeColor = this._getNormalizedColor(argb);
      this.redraw();
    }
    get strokeColor() {
      return this._sc;
    }
    set fillColor(argb) {
      this._fc = argb;
      this._fillColor = this._getNormalizedColor(argb);
      this.redraw();
    }
    get fillColor() {
      return this._fc;
    }
    set stroke(num) {
      this._stroke = num;
      this.redraw();
    }
    get stroke() {
      return this._stroke;
    }
    _getNormalizedColor(color) {
      const col = StageUtils.getRgbaComponentsNormalized(color);
      col[0] *= col[3];
      col[1] *= col[3];
      col[2] *= col[3];
      return new Float32Array(col);
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      const renderPrecision = this.ctx.stage.getRenderPrecision();
      const _radius = this._radius.map((r) => (r + 0.5) * renderPrecision);
      this._setUniform("radius", new Float32Array(_radius), this.gl.uniform4fv);
      this._setUniform("alpha", operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
      this._setUniform("blend", this._blend, this.gl.uniform1f);
      this._setUniform("strokeColor", this._strokeColor, this.gl.uniform4fv);
      this._setUniform("fillColor", this._fillColor, this.gl.uniform4fv);
      this._setUniform("stroke", this._stroke * renderPrecision, this.gl.uniform1f);
      this._setUniform("resolution", new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
  };
  RoundedRectangleShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  RoundedRectangleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif

    #define PI 3.14159265359

    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 radius;
    uniform float stroke;
    uniform vec4 strokeColor;
    uniform vec4 fillColor;
    uniform float alpha;
    uniform float fill;
    uniform float blend;
    
    float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    float innerBorderMask(float dist, float width){
        float alpha1 = clamp(dist + width, 0.0, 1.0);
        float alpha2 = clamp(dist, 0.0, 1.0);
        return alpha1 - alpha2;
    }

    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        float r = 0.0;
        if (vTextureCoord.x < 0.5 && vTextureCoord.y < 0.5) {
            r = radius[0];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y < 0.5) {
            r = radius[1];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y >= 0.5) {
            r = radius[2];
        } else {
            r = radius[3];
        }
        
        float b = boxDist(vTextureCoord.xy * resolution - halfRes, halfRes - 0.005, r);
        vec4 tex = texture2D(uSampler, vTextureCoord) * vColor;
        vec4 blend = mix(vec4(1.0) * alpha, tex, blend);     
        vec4 layer1 = mix(vec4(0.0), tex * fillColor, fillMask(b));
        gl_FragColor = mix(layer1, blend * strokeColor, innerBorderMask(b + 1.0, stroke));
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/FadeOutShader.mjs
  var FadeOutShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._fade = [0, 0, 0, 0];
    }
    set top(num) {
      this._fade[0] = num;
      this.redraw();
    }
    get top() {
      return this._fade[0];
    }
    set right(num) {
      this._fade[1] = num;
      this.redraw();
    }
    get right() {
      return this._fade[1];
    }
    set bottom(num) {
      this._fade[2] = num;
      this.redraw();
    }
    get bottom() {
      return this._fade[2];
    }
    set left(num) {
      this._fade[3] = num;
      this.redraw();
    }
    get left() {
      return this._fade[3];
    }
    set fade(v) {
      if (Array.isArray(v)) {
        if (v.length === 2) {
          this._fade = [v[0], v[1], v[0], v[1]];
        } else if (v.length === 3) {
          this._fade = [v[0], v[1], v[2], this._fade[3]];
        } else if (v.length === 4) {
          this._fade = v;
        } else {
          this._fade = [v[0], v[0], v[0], v[0]];
        }
      } else {
        this._fade = [v, v, v, v];
      }
      this.redraw();
    }
    get fade() {
      return this._fade;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      const renderPrecision = this.ctx.stage.getRenderPrecision();
      const fade2 = this._fade.map((f) => f * renderPrecision);
      this._setUniform("fade", new Float32Array(fade2), this.gl.uniform4fv);
      this._setUniform("resolution", new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
  };
  FadeOutShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 fade;
    
    void main() {
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 point = vTextureCoord.xy * resolution.xy;
        
        vec2 pos1;
        vec2 pos2;
        vec2 d;
        float c;
        float t = 0.0;
             
        if(fade[0] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x, point.y + fade[0]);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[1] > 0.0) {
            vec2 pos1 = vec2(point.x - resolution.x - fade[1], vTextureCoord.y);
            vec2 pos2 = vec2(point.x - resolution.x, vTextureCoord.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[2] > 0.0) {
            vec2 pos1 = vec2(vTextureCoord.x, point.y - resolution.y - fade[2]);
            vec2 pos2 = vec2(vTextureCoord.x, point.y - resolution.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[3] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x + fade[3], point.y);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        gl_FragColor = color;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/VignetteShader.mjs
  var VignetteShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._magnitude = 1.3;
      this._intensity = 0.7;
      this._pivot = [0.5, 0.5];
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      this._setUniform("magnitude", this._magnitude, this.gl.uniform1f);
      this._setUniform("intensity", this._intensity, this.gl.uniform1f);
      this._setUniform("pivot", new Float32Array(this._pivot), this.gl.uniform2fv);
      this.redraw();
    }
    set pivot(v) {
      if (Array.isArray(v)) {
        this._pivot = v;
      } else {
        this._pivot = [v, v];
      }
      this.redraw();
    }
    get pivotX() {
      return this._pivot[0];
    }
    set pivotX(v) {
      this._pivot[0] = v;
      this.redraw();
    }
    get pivotY() {
      return this._pivot[1];
    }
    set pivotY(v) {
      this._pivot[1] = v;
      this.redraw();
    }
    get intensity() {
      return this._intensity;
    }
    set intensity(v) {
      this._intensity = v;
      this.redraw();
    }
    get magnitude() {
      return this._magnitude;
    }
    set magnitude(v) {
      this._magnitude = v;
      this.redraw();
    }
  };
  VignetteShader.vertexShaderSource = DefaultShader.vertexShaderSource;
  VignetteShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float magnitude;
    uniform float intensity;
    uniform vec2 pivot;

    void main() {
        vec2 uv = vTextureCoord.xy - pivot + vec2(0.5);
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);
   
        uv *=  1.00 - uv.yx;
        float vig = uv.x * uv.y * 25.0 * intensity;
        vig = pow(vig, 0.45 * magnitude);
        vec4 fragColor = vec4(vig) * vColor;
        gl_FragColor = texture2D(uSampler, vTextureCoord) * fragColor;

    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/SpinnerShader.mjs
  var SpinnerShader = class extends DefaultShader {
    constructor(ctx) {
      super(ctx);
      this._radius = 100;
      this._width = 50;
      this._period = 1;
      this._angle = 0.5;
      this._smooth = 5e-3;
      this._color = 4294967295;
      this._backgroundColor = 4278190080;
      this._time = Date.now();
    }
    set radius(v) {
      this._radius = v;
      this.redraw();
    }
    set width(v) {
      this._width = v;
      this.redraw();
    }
    set period(v) {
      this._period = v;
      this.redraw();
    }
    set angle(v) {
      this._angle = v;
      this.redraw();
    }
    set smooth(v) {
      this._smooth = v;
      this.redraw();
    }
    set color(v) {
      this._color = v;
      this.redraw();
    }
    set backgroundColor(v) {
      this._backgroundColor = v;
      this.redraw();
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      this._setUniform("iTime", Date.now() - this._time, this.gl.uniform1f);
      const renderPrecision = this.ctx.stage.getRenderPrecision();
      this._setUniform("radius", this._radius * renderPrecision, this.gl.uniform1f);
      this._setUniform("width", this._width * renderPrecision, this.gl.uniform1f);
      this._setUniform("period", this._period, this.gl.uniform1f);
      this._setUniform("angle", this._angle, this.gl.uniform1f);
      this._setUniform("smooth", this._smooth, this.gl.uniform1f);
      this._setUniform("color", new Float32Array(StageUtils.getRgbaComponentsNormalized(this._color)), this.gl.uniform4fv);
      this._setUniform("backgroundColor", new Float32Array(StageUtils.getRgbaComponentsNormalized(this._backgroundColor)), this.gl.uniform4fv);
      this._setUniform("resolution", new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
      this.redraw();
    }
  };
  SpinnerShader.vertexShaderSource = DefaultShader.vertexShaderSource;
  SpinnerShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float iTime;
    uniform float radius;
    uniform float width;
    uniform float period;
    uniform float angle;
    uniform float smooth;
    uniform vec2 resolution;

    uniform vec4 color;
    uniform vec4 backgroundColor;

    float ratio = resolution.y / resolution.x;

    vec2 transpose_pos(vec2 pos) {
        if (ratio < 1.) {
            float diff = 0.5 - pos.x;
            pos.x = 0.5 - diff / ratio;
        } else {
            float diff = 0.5 - pos.y;
            pos.y = 0.5 - diff * ratio;
        }
        return pos;
    }

    float get_angle(vec2 pos) {
        pos = transpose_pos(pos);
        float a = atan(pos.y - 0.5, pos.x - 0.5);
        a = (1.0+a/3.14159)/2.0;
        
        return a;
    }

    float dist(vec2 pos1, vec2 pos2) {
        pos1 = transpose_pos(pos1);
        return distance(pos1, pos2);
    }

    void main()
    {
        vec2 fragCoord = vTextureCoord;
        vec4 fragColor = vColor;
        
        vec2 st = vTextureCoord;
        float pct = dist(st, vec2(0.5));

        float a = get_angle(st);
        float t = iTime / 1000.0 / period;

        float inner = max((radius - width) / resolution.x, (radius - width) / resolution.y);
        float outer = max(radius / resolution.x, radius / resolution.y);

        float x1 = mod(t, 1.0);
        float x2 = mod(t + angle, 1.0);

        if (x1 < x2) {
            if (a > x1 && a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        } else {
            if (a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else if (a > x1) {
                float val = (1.0 - (1.0 + x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (1.0 + x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        }

        float s = smoothstep(inner, inner + smooth + 0.00001, pct) * (1.0 - smoothstep(outer, outer + smooth + 0.00001, pct));
        gl_FragColor = texture2D(uSampler, fragCoord) * vColor * (1. - s * fragColor.a) + fragColor * s;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/HoleShader.mjs
  var HoleShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._x = 0;
      this._y = 0;
      this._w = 0;
      this._h = 0;
      this._radius = 0;
    }
    get x() {
      return this._x;
    }
    set x(v) {
      this._x = v;
      this.redraw();
    }
    get y() {
      return this._y;
    }
    set y(v) {
      this._y = v;
      this.redraw();
    }
    get w() {
      return this._w;
    }
    set w(v) {
      this._w = v;
      this.redraw();
    }
    get h() {
      return this._h;
    }
    set h(v) {
      this._h = v;
      this.redraw();
    }
    get radius() {
      return this._radius;
    }
    set radius(v) {
      this._radius = v;
      this.redraw();
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      const renderPrecision = this.ctx.stage.getRenderPrecision();
      this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
      this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
      this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
      this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
      this._setUniform("radius", (this._radius + 0.5) * renderPrecision, this.gl.uniform1f);
      this._setUniform("resolution", new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
    useDefault() {
      return this._x === 0 && this._y === 0 && this._w === 0 && this._h === 0;
    }
  };
  HoleShader.vertexShaderSource = DefaultShader.vertexShaderSource;
  HoleShader.fragmentShaderSource = `
   #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float x;
    uniform float y;
    uniform float w;
    uniform float h;
    uniform vec2 resolution;
    uniform float radius;

    float roundBox(vec2 p, vec2 b, float r) {
        float d = length(max(abs(p)-b+r, 0.1))-r;
        return smoothstep(1.0, 0.0, d);
    }

    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
        vec2 size = vec2(w, h) / 2.0;
        float b = roundBox(pos, size, radius);
        gl_FragColor = mix(color, vec4(0.0), b) * vColor;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/RadialGradientShader.mjs
  var RadialGradientShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._pivot = [0, 0];
      this._ic = 4294967295;
      this._normalizedIC = this._getNormalizedColor(this._ic);
      this._oc = 16777215;
      this._normalizedOC = this._getNormalizedColor(this._oc);
      this._radius = 0;
    }
    set radiusX(v) {
      this.radius = v;
    }
    get radiusX() {
      return this._radius;
    }
    set radiusY(v) {
      this._radiusY = v;
      this.redraw();
    }
    get radiusY() {
      return this._radiusY;
    }
    set radius(v) {
      this._radius = v;
      this.redraw();
    }
    set innerColor(argb) {
      this._ic = argb;
      this._normalizedIC = this._getNormalizedColor(argb);
      this.redraw();
    }
    get innerColor() {
      return this._ic;
    }
    set outerColor(argb) {
      this._oc = argb;
      this._normalizedOC = this._getNormalizedColor(argb);
      this.redraw();
    }
    set color(argb) {
      this.innerColor = argb;
    }
    get color() {
      return this.innerColor;
    }
    get outerColor() {
      return this._ic;
    }
    set x(f) {
      this._x = f;
      this.redraw();
    }
    set y(f) {
      this._y = f;
      this.redraw();
    }
    set pivot(v) {
      if (Array.isArray(v) && v.length === 2) {
        this._pivot = v;
      } else if (Array.isArray(v)) {
        this._pivot = [v[0], v[1] || v[0]];
      } else {
        this._pivot = [v, v];
      }
      this.redraw();
    }
    get pivot() {
      return this._pivot[0];
    }
    set pivotY(f) {
      this._pivot[1] = f;
      this.redraw();
    }
    get pivotY() {
      return this._pivot[1];
    }
    set pivotX(f) {
      this._pivot[0] = f;
      this.redraw();
    }
    get pivotX() {
      return this._pivot[0];
    }
    _getNormalizedColor(color) {
      const col = StageUtils.getRgbaComponentsNormalized(color);
      col[0] *= col[3];
      col[1] *= col[3];
      col[2] *= col[3];
      return new Float32Array(col);
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      if (this._x) {
        this._pivot[0] = this._x / owner.w;
      }
      if (this._y) {
        this._pivot[1] = this._y / owner.h;
      }
      if (this._radius === 0) {
        this._radius = owner.w * 0.5;
      }
      this._setUniform("innerColor", this._normalizedIC, this.gl.uniform4fv);
      this._setUniform("fill", StageUtils.getRgbaComponentsNormalized(this._oc)[3], this.gl.uniform1f);
      this._setUniform("outerColor", this._normalizedOC, this.gl.uniform4fv);
      this._setUniform("pivot", new Float32Array(this._pivot), this.gl.uniform2fv);
      this._setUniform("resolution", new Float32Array([owner._w, owner._h]), this.gl.uniform2fv);
      this._setUniform("alpha", operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
      this._setUniform("radius", this._radius, this.gl.uniform1f);
      this._setUniform("radiusY", this._radiusY || this._radius, this.gl.uniform1f);
    }
  };
  RadialGradientShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec2 pivot;
    uniform vec4 innerColor;
    uniform vec4 outerColor;
    uniform float radius;
    uniform float radiusY;
    uniform float alpha;
    uniform float fill;
    uniform float aspectRatio;
    
    void main() {
        vec2 point = vTextureCoord.xy * resolution;
        vec2 projection = vec2(pivot.x * resolution.x, pivot.y * resolution.y);
        float d = length((point - projection) / vec2(radius * 2.0, radiusY * 2.0));
        vec4 color = mix(texture2D(uSampler, vTextureCoord) * vColor, outerColor * alpha, fill);
        gl_FragColor = mix(innerColor * alpha, color, smoothstep(0.0, 1.0, d));
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/Light3dShader.mjs
  var Light3dShader = class extends DefaultShader {
    constructor(ctx) {
      super(ctx);
      this._strength = 0.5;
      this._ambient = 0.5;
      this._fudge = 0.4;
      this._rx = 0;
      this._ry = 0;
      this._z = 0;
      this._pivotX = NaN;
      this._pivotY = NaN;
      this._pivotZ = 0;
      this._lightY = 0;
      this._lightZ = 0;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      let vr = operation.shaderOwner;
      let element = vr.element;
      let pivotX = isNaN(this._pivotX) ? element.pivotX * vr.w : this._pivotX;
      let pivotY = isNaN(this._pivotY) ? element.pivotY * vr.h : this._pivotY;
      let coords = vr.getRenderTextureCoords(pivotX, pivotY);
      let rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);
      let gl = this.gl;
      this._setUniform("pivot", new Float32Array([coords[0], coords[1], this._pivotZ]), gl.uniform3fv);
      this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
      this._setUniform("z", this._z, gl.uniform1f);
      this._setUniform("lightY", this.lightY, gl.uniform1f);
      this._setUniform("lightZ", this.lightZ, gl.uniform1f);
      this._setUniform("strength", this._strength, gl.uniform1f);
      this._setUniform("ambient", this._ambient, gl.uniform1f);
      this._setUniform("fudge", this._fudge, gl.uniform1f);
    }
    set strength(v) {
      this._strength = v;
      this.redraw();
    }
    get strength() {
      return this._strength;
    }
    set ambient(v) {
      this._ambient = v;
      this.redraw();
    }
    get ambient() {
      return this._ambient;
    }
    set fudge(v) {
      this._fudge = v;
      this.redraw();
    }
    get fudge() {
      return this._fudge;
    }
    get rx() {
      return this._rx;
    }
    set rx(v) {
      this._rx = v;
      this.redraw();
    }
    get ry() {
      return this._ry;
    }
    set ry(v) {
      this._ry = v;
      this.redraw();
    }
    get z() {
      return this._z;
    }
    set z(v) {
      this._z = v;
      this.redraw();
    }
    get pivotX() {
      return this._pivotX;
    }
    set pivotX(v) {
      this._pivotX = v + 1;
      this.redraw();
    }
    get pivotY() {
      return this._pivotY;
    }
    set pivotY(v) {
      this._pivotY = v + 1;
      this.redraw();
    }
    get lightY() {
      return this._lightY;
    }
    set lightY(v) {
      this._lightY = v;
      this.redraw();
    }
    get pivotZ() {
      return this._pivotZ;
    }
    set pivotZ(v) {
      this._pivotZ = v;
      this.redraw();
    }
    get lightZ() {
      return this._lightZ;
    }
    set lightZ(v) {
      this._lightZ = v;
      this.redraw();
    }
    useDefault() {
      return this._rx === 0 && this._ry === 0 && this._z === 0 && this._strength === 0 && this._ambient === 1;
    }
  };
  Light3dShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float fudge;
    uniform float strength;
    uniform float ambient;
    uniform float z;
    uniform float lightY;
    uniform float lightZ;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Set depth perspective
        float perspective = 1.0 + fudge * pos.z;

        pos.z += lightZ * projection.x;

        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, perspective);

        // Correct light source position.
        pos.y += lightY * abs(projection.y);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  Light3dShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec3 pos;
    uniform sampler2D uSampler;
    uniform float ambient;
    uniform float strength;
    void main(void){
        vec4 rgba = texture2D(uSampler, vTextureCoord);
        float d = length(pos);
        float n = 1.0 / max(0.1, d);
        rgba.rgb = rgba.rgb * (strength * n + ambient);
        gl_FragColor = rgba * vColor;
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/PerspectiveShader.mjs
  var PerspectiveShader = class extends DefaultShader {
    constructor(ctx) {
      super(ctx);
      this._fudge = 0.2;
      this._rx = 0;
      this._ry = 0;
      this._z = 1;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const vr = operation.shaderOwner;
      const element = vr.element;
      const pivotX = element.pivotX * vr.w;
      const pivotY = element.pivotY * vr.h;
      const coords = vr.getRenderTextureCoords(pivotX, pivotY);
      const rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);
      const gl = this.gl;
      this._setUniform("pivot", new Float32Array([coords[0], coords[1], 0]), gl.uniform3fv);
      this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
      this._setUniform("z", this._z, gl.uniform1f);
      this._setUniform("fudge", this._fudge, gl.uniform1f);
    }
    set fudge(v) {
      this._fudge = v;
      this.redraw();
    }
    get fudge() {
      return this._fudge;
    }
    get rx() {
      return this._rx;
    }
    set rx(v) {
      this._rx = v;
      this.redraw();
    }
    get ry() {
      return this._ry;
    }
    set ry(v) {
      this._ry = v;
      this.redraw();
    }
    get z() {
      return this._z;
    }
    set z(v) {
      this._z = v;
      this.redraw();
    }
    useDefault() {
      return this._rx === 0 && this._ry === 0 && this._z === 0;
    }
  };
  PerspectiveShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float z;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, z);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
  PerspectiveShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform vec3 rot;
    uniform float fudge;

    void main(void) {
        vec2 coords = vTextureCoord;

        coords.xy -= vec2(0.5);
        coords.y = coords.y + (sign(rot[0]) * 0.5 - coords.x) * sin(rot[0]) * fudge * coords.y;
        coords.x = coords.x + (sign(rot[1]) * 0.5 - coords.y) * sin(rot[1]) * fudge * coords.x;
        coords.xy += vec2(0.5);

        if (coords.x < 0.0 || coords.x > 1.0 || coords.y < 0.0 || coords.y > 1.0) {
            gl_FragColor = vec4(0.0);
        } else {
            gl_FragColor = texture2D(uSampler, coords) * vColor;
        }
    }
`;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/MagnifierShader.mjs
  var MagnifierShader = class extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._x = 0;
      this._y = 0;
      this._w = 0;
      this._h = 0;
      this._radius = 0;
      this._magnification = 0.6;
    }
    get x() {
      return this._x;
    }
    set x(v) {
      this._x = v;
      this.redraw();
    }
    get y() {
      return this._y;
    }
    set y(v) {
      this._y = v;
      this.redraw();
    }
    get w() {
      return this._w;
    }
    set w(v) {
      this._w = v;
      this.redraw();
    }
    get h() {
      return this._h;
    }
    set h(v) {
      this._h = v;
      this.redraw();
    }
    get magnification() {
      return this._magnification;
    }
    set magnification(v) {
      this._magnification = v;
      this.redraw();
    }
    get radius() {
      return this._radius;
    }
    set radius(v) {
      this._radius = v;
      this.redraw();
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      const renderPrecision = this.ctx.stage.getRenderPrecision();
      this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
      this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
      this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
      this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
      this._setUniform("magnification", this._magnification, this.gl.uniform1f);
      this._setUniform(
        "radius",
        (this._radius + 0.5) * renderPrecision,
        this.gl.uniform1f
      );
      this._setUniform(
        "resolution",
        new Float32Array([
          owner._w * renderPrecision,
          owner._h * renderPrecision
        ]),
        this.gl.uniform2fv
      );
    }
    useDefault() {
      return this._w === 0 && this._h === 0;
    }
  };
  MagnifierShader.vertexShaderSource = DefaultShader.vertexShaderSource;
  MagnifierShader.fragmentShaderSource = `
	  #ifdef GL_ES
		# ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
		# else
		precision lowp float;
		# endif
	  #endif

	  varying vec2 vTextureCoord;
	  varying vec4 vColor;
	  uniform sampler2D uSampler;
	  uniform float x;
	  uniform float y;
	  uniform float w;
	  uniform float h;
	  uniform vec2 resolution;
	  uniform float radius;
	  uniform float magnification;
  
	  float roundBox(vec2 p, vec2 b, float r) {
		  float d = length(max(abs(p)-b+r, 0.1))-r;
		  return smoothstep(1.0, 0.0, d);
	  }

	  float inside(vec2 v) {
		vec2 s = step(vec2(0.0, 0.0), v) - step(vec2(1.0, 1.0), v);
		return s.x * s.y;   
      }
  
	  void main(void) {
		vec4 color = texture2D(uSampler, vTextureCoord);
		vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
		vec2 size = vec2(w, h) / 2.0;
		float b = roundBox(pos, size, radius);
		vec2 pos2 = (vTextureCoord.xy * magnification * resolution + vec2(x, y) * magnification) / resolution;
		gl_FragColor = mix(color, texture2D(uSampler, pos2) * inside(pos2), b) * vColor;
	  }
  `;

  // node_modules/@lightningjs/core/dist/src/renderer/webgl/shaders/SpinnerShader2.mjs
  var SpinnerShader2 = class _SpinnerShader2 extends DefaultShader {
    constructor(context2) {
      super(context2);
      this._period = 1;
      this._stroke = 0;
      this._showDot = true;
      this._clockwise = true;
      this._bc = 4278190080;
      this._normalizedBC = this._getNormalizedColor(this._bc);
      this._c = 4294967295;
      this._normalizedC = this._getNormalizedColor(this._c);
    }
    set radius(v) {
      if (v === 0) {
        v = 1;
      }
      this._radius = v;
    }
    set stroke(value) {
      this._stroke = Math.abs(value);
    }
    get stroke() {
      return this._stroke;
    }
    set color(argb) {
      this._c = argb;
      this._normalizedC = this._getNormalizedColor(argb);
    }
    get color() {
      return this._c;
    }
    set backgroundColor(argb) {
      this._bc = argb;
      this._normalizedBC = this._getNormalizedColor(argb);
    }
    get backgroundColor() {
      return this._sc;
    }
    set showDot(bool) {
      this._showDot = bool;
    }
    get showDot() {
      return this._showDot;
    }
    set clockwise(bool) {
      this._clockwise = bool;
    }
    get clockwise() {
      return this._clockwise;
    }
    set period(v) {
      this._period = v;
    }
    get period() {
      return this._period;
    }
    _getNormalizedColor(color) {
      const col = StageUtils.getRgbaComponentsNormalized(color);
      col[0] *= col[3];
      col[1] *= col[3];
      col[2] *= col[3];
      return new Float32Array(col);
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      const radius = this._radius || owner._w / 2;
      if (this._stroke === 0) {
        this._stroke = radius * 0.33;
      }
      this._setUniform("resolution", new Float32Array([owner._w, owner._h]), this.gl.uniform2fv);
      this._setUniform("color", this._normalizedC, this.gl.uniform4fv);
      this._setUniform("backgroundColor", this._normalizedBC, this.gl.uniform4fv);
      this._setUniform("stroke", this._stroke, this.gl.uniform1f);
      this._setUniform("radius", radius, this.gl.uniform1f);
      this._setUniform("direction", this._clockwise ? -1 : 1, this.gl.uniform1f);
      this._setUniform("showDot", !!this._showDot, this.gl.uniform1f);
      this._setUniform("time", Date.now() - _SpinnerShader2.spinSync, this.gl.uniform1f);
      this._setUniform("period", this._period, this.gl.uniform1f);
      this._setUniform("alpha", operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
      if (this._sc !== this._bc || this._stroke !== radius * 0.5) {
        this.redraw();
      }
    }
  };
  SpinnerShader2.spinSync = Date.now();
  SpinnerShader2.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 color;
    uniform vec4 backgroundColor;
    uniform float direction;
    uniform float radius;
    uniform float time;
    uniform float stroke;
    uniform float showDot;
    uniform float period;
    uniform float alpha;
    
    float circleDist(vec2 p, float radius){
        return length(p) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 center = vTextureCoord.xy * resolution - halfRes;
        
        float c = max(-circleDist(center, radius - stroke), circleDist(center, radius));
        float rot = -(time / 1000.0 / period) * 6.0 * direction;
        center *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));
        
        float a = direction * atan(center.x, center.y) * PI * 0.05 + 0.45;
        
        float strokeRad = stroke * 0.5;
        a = mix(a, max(a, fillMask(circleDist(vec2(center.x, center.y + (radius - strokeRad)), strokeRad))), showDot);
        vec4 base = mix(vec4(0.0), backgroundColor * alpha, fillMask(c));
        gl_FragColor = mix(base, color * alpha, fillMask(c) * a);
    }
`;

  // node_modules/@lightningjs/core/dist/src/lightning.mjs
  var lightning = {
    Application,
    Component,
    Base,
    Utils,
    StageUtils,
    Element,
    Tools,
    Stage,
    ElementCore,
    ElementTexturizer,
    Texture,
    EventEmitter,
    shaders: {
      Grayscale: WebGLGrayscaleShader,
      BoxBlur: BoxBlurShader,
      Dithering: DitheringShader,
      CircularPush: CircularPushShader,
      Inversion: InversionShader,
      LinearBlur: LinearBlurShader,
      Outline: OutlineShader,
      Pixelate: PixelateShader,
      RadialFilter: RadialFilterShader,
      RoundedRectangle: RoundedRectangleShader,
      Spinner2: SpinnerShader2,
      FadeOut: FadeOutShader,
      Hole: HoleShader,
      Vignette: VignetteShader,
      Spinner: SpinnerShader,
      RadialGradient: RadialGradientShader,
      Light3d: Light3dShader,
      Perspective: PerspectiveShader,
      Magnifier: MagnifierShader,
      WebGLShader,
      WebGLDefaultShader: DefaultShader,
      C2dShader,
      C2dDefaultShader: DefaultShader2,
      c2d: {
        Grayscale: C2dGrayscaleShader,
        Blur: BlurShader
      }
    },
    textures: {
      RectangleTexture,
      NoiseTexture,
      TextTexture,
      ImageTexture,
      HtmlTexture,
      StaticTexture,
      StaticCanvasTexture,
      SourceTexture
    },
    components: {
      FastBlurComponent,
      BloomComponent,
      SmoothScaleComponent,
      BorderComponent,
      ListComponent
    },
    tools: {
      ObjMerger,
      ObjectListProxy,
      ObjectListWrapper
    }
  };
  if (Utils.isWeb) {
    window.lng = lightning;
  }
  var lightning_default = lightning;

  // node_modules/@lightningjs/core/dist/src/index.js
  var src_default = lightning_default;

  // node_modules/@lightningjs/sdk/src/Lightning/index.js
  var Lightning_default = src_default;

  // node_modules/@lightningjs/sdk/src/Accessibility/shaders/ColorShift.js
  var ColorShift = class extends Lightning_default.shaders.WebGLDefaultShader {
    set brightness(v) {
      this._brightness = (v - 50) / 100;
      this.redraw();
    }
    set contrast(v) {
      this._contrast = (v + 50) / 100;
      this.redraw();
    }
    set gamma(v) {
      this._gamma = (v + 50) / 100;
      this.redraw();
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const gl = this.gl;
      this._setUniform(
        "colorAdjust",
        [this._brightness || 0, this._contrast || 1, this._gamma || 1],
        gl.uniform3fv
      );
    }
  };
  ColorShift.before = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
        
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec3 colorAdjust;
    
    const mat3 RGBtoOpponentMat = mat3(0.2814, -0.0971, -0.0930, 0.6938, 0.1458,-0.2529, 0.0638, -0.0250, 0.4665);
    const mat3 OpponentToRGBMat = mat3(1.1677, 0.9014, 0.7214, -6.4315, 2.5970, 0.1257, -0.5044, 0.0159, 2.0517);    
`;
  ColorShift.after = `    
    vec3 brightnessContrast(vec3 value, float brightness, float contrast)
    {
        return (value - 0.5) * contrast + 0.5 + brightness;
    }   
    
    vec3 updateGamma(vec3 value, float param)
    {
        return vec3(pow(abs(value.r), param),pow(abs(value.g), param),pow(abs(value.b), param));
    } 
       
    void main(void){
        vec4 fragColor = texture2D(uSampler, vTextureCoord);        
        vec4 color = filter(fragColor) * vColor;       
        
        vec3 bc = brightnessContrast(color.rgb,colorAdjust[0],colorAdjust[1]);        
        vec3 ga = updateGamma(bc.rgb, colorAdjust[2]);  
              
        gl_FragColor = vec4(ga.rgb, color.a);          
    }    
`;

  // node_modules/@lightningjs/sdk/src/Accessibility/shaders/ProtanopiaShader.js
  var ProtanopiaShader = class extends ColorShift {
  };
  ProtanopiaShader.fragmentShaderSource = `
    ${ColorShift.before}    
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.20,  0.99, -0.19, 0.0);
        vec4 g = vec4( 0.16,  0.79,  0.04, 0.0);
        vec4 b = vec4( 0.01, -0.01,  1.00, 0.0);
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }
    
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= opponentColor.y * 1.5; 
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));      
    }    
    ${ColorShift.after} 
`;

  // node_modules/@lightningjs/sdk/src/Accessibility/shaders/DeuteranopiaShader.js
  var DeuteranopiaShader = class extends ColorShift {
  };
  DeuteranopiaShader.fragmentShaderSource = `
    ${ColorShift.before}
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.43,  0.72, -0.15, 0.0 );
        vec4 g = vec4( 0.34,  0.57,  0.09, 0.0 );
        vec4 b = vec4(-0.02,  0.03,  1.00, 0.0 );
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }
       
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= opponentColor.y * 1.5; 
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));    
    }
    ${ColorShift.after}    
`;

  // node_modules/@lightningjs/sdk/src/Accessibility/shaders/TritanopiaShader.js
  var TritanopiaShader = class extends ColorShift {
  };
  TritanopiaShader.fragmentShaderSource = `
    ${ColorShift.before}    
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.97,  0.11, -0.08, 0.0 );
        vec4 g = vec4( 0.02,  0.82,  0.16, 0.0 );
        vec4 b = vec4(-0.06,  0.88,  0.18, 0.0 );
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }   
    
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= ((3.0 * opponentColor.z) - opponentColor.y) * 0.25;
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));
    }   
    ${ColorShift.after} 
`;

  // node_modules/@lightningjs/sdk/src/Accessibility/shaders/NormalShader.js
  var NeutralShader = class extends ColorShift {
  };
  NeutralShader.fragmentShaderSource = `
    ${ColorShift.before}
    vec4 filter( vec4 color )
    {
        return color;
    }
    ${ColorShift.after}
`;

  // node_modules/@lightningjs/sdk/src/Accessibility/shaders/MonochromacyShader.js
  var MonochromacyShader = class extends ColorShift {
  };
  MonochromacyShader.fragmentShaderSource = `
    ${ColorShift.before}
    vec4 filter( vec4 color )
    {   
        float grey = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        return vec4(vec3(grey, grey, grey), 1.0 ); 
    }
    ${ColorShift.after}
`;

  // node_modules/@lightningjs/sdk/src/Accessibility/shaders/index.js
  var colorshiftShader = (type) => {
    const shadersMap = {
      normal: NeutralShader,
      monochromacy: MonochromacyShader,
      deuteranopia: DeuteranopiaShader,
      tritanopia: TritanopiaShader,
      protanopia: ProtanopiaShader
    };
    type = typeof type === "string" && type.toLowerCase() || null;
    return Object.keys(shadersMap).indexOf(type) > -1 ? shadersMap[type] : false;
  };

  // node_modules/@lightningjs/sdk/src/Accessibility/Announcer/Speech.js
  function flattenStrings(series = []) {
    const flattenedSeries = [];
    for (var i = 0; i < series.length; i++) {
      if (typeof series[i] === "string" && !series[i].includes("PAUSE-")) {
        flattenedSeries.push(series[i]);
      } else {
        break;
      }
    }
    return [flattenedSeries.join(",\b ")].concat(series.slice(i));
  }
  function delay(pause) {
    return new Promise((resolve) => {
      setTimeout(resolve, pause);
    });
  }
  function speak(phrase, utterances, lang = "en-US") {
    const synth = window.speechSynthesis;
    return new Promise((resolve, reject) => {
      const utterance = new SpeechSynthesisUtterance(phrase);
      utterance.lang = lang;
      utterance.onend = () => {
        resolve();
      };
      utterance.onerror = (e) => {
        reject(e);
      };
      utterances.push(utterance);
      synth.speak(utterance);
    });
  }
  function speakSeries(series, lang, root2 = true) {
    const synth = window.speechSynthesis;
    const remainingPhrases = flattenStrings(Array.isArray(series) ? series : [series]);
    const nestedSeriesResults = [];
    const utterances = [];
    let active = true;
    const seriesChain = (() => __async(null, null, function* () {
      try {
        while (active && remainingPhrases.length) {
          const phrase = yield Promise.resolve(remainingPhrases.shift());
          if (!active) {
            break;
          } else if (typeof phrase === "string" && phrase.includes("PAUSE-")) {
            let pause = phrase.split("PAUSE-")[1] * 1e3;
            if (isNaN(pause)) {
              pause = 0;
            }
            yield delay(pause);
          } else if (typeof phrase === "string" && phrase.length) {
            const totalRetries = 3;
            let retriesLeft = totalRetries;
            while (active && retriesLeft > 0) {
              try {
                yield speak(phrase, utterances, lang);
                retriesLeft = 0;
              } catch (e) {
                if (e instanceof SpeechSynthesisErrorEvent) {
                  if (e.error === "network") {
                    retriesLeft--;
                    console.warn(`Speech synthesis network error. Retries left: ${retriesLeft}`);
                    yield delay(500 * (totalRetries - retriesLeft));
                  } else if (e.error === "canceled" || e.error === "interrupted") {
                    retriesLeft = 0;
                  } else {
                    throw new Error(`SpeechSynthesisErrorEvent: ${e.error}`);
                  }
                } else {
                  throw e;
                }
              }
            }
          } else if (typeof phrase === "function") {
            const seriesResult = speakSeries(phrase(), lang, false);
            nestedSeriesResults.push(seriesResult);
            yield seriesResult.series;
          } else if (Array.isArray(phrase)) {
            const seriesResult = speakSeries(phrase, lang, false);
            nestedSeriesResults.push(seriesResult);
            yield seriesResult.series;
          }
        }
      } finally {
        active = false;
      }
    }))();
    return {
      series: seriesChain,
      get active() {
        return active;
      },
      append: (toSpeak) => {
        remainingPhrases.push(toSpeak);
      },
      cancel: () => {
        if (!active) {
          return;
        }
        if (root2) {
          synth.cancel();
        }
        nestedSeriesResults.forEach((nestedSeriesResults2) => {
          nestedSeriesResults2.cancel();
        });
        active = false;
      }
    };
  }
  var currentSeries;
  function Speech_default(toSpeak, lang) {
    currentSeries && currentSeries.cancel();
    currentSeries = speakSeries(toSpeak, lang);
    return currentSeries;
  }

  // node_modules/@lightningjs/sdk/src/Accessibility/Announcer/utils.js
  function getElmName(elm) {
    return elm.ref || elm.constructor.name;
  }
  function debounce(func, wait, immediate) {
    var timeout2, args, context2, timestamp, result;
    if (null == wait) wait = 100;
    function later() {
      var last = Date.now() - timestamp;
      if (last < wait && last >= 0) {
        timeout2 = setTimeout(later, wait - last);
      } else {
        timeout2 = null;
        if (!immediate) {
          result = func.apply(context2, args);
          context2 = args = null;
        }
      }
    }
    var debounced = function() {
      context2 = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout2;
      if (!timeout2) timeout2 = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context2, args);
        context2 = args = null;
      }
      return result;
    };
    debounced.clear = function() {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
    };
    debounced.flush = function() {
      if (timeout2) {
        result = func.apply(context2, args);
        context2 = args = null;
        clearTimeout(timeout2);
        timeout2 = null;
      }
    };
    return debounced;
  }

  // node_modules/@lightningjs/sdk/src/Accessibility/Announcer/index.js
  var resetFocusPathTimer;
  var prevFocusPath = [];
  var currentlySpeaking;
  var voiceOutDisabled = false;
  var fiveMinutes = 3e5;
  function onFocusChangeCore(focusPath = []) {
    if (!Announcer.enabled) {
      return;
    }
    const loaded = focusPath.every((elm) => !elm.loading);
    const focusDiff = focusPath.filter((elm) => !prevFocusPath.includes(elm));
    resetFocusPathTimer();
    if (!loaded) {
      Announcer.onFocusChange();
      return;
    }
    prevFocusPath = focusPath.slice(0);
    let toAnnounceText = [];
    let toAnnounce = focusDiff.reduce((acc, elm) => {
      if (elm.announce) {
        acc.push([getElmName(elm), "Announce", elm.announce]);
        toAnnounceText.push(elm.announce);
      } else if (elm.title) {
        acc.push([getElmName(elm), "Title", elm.title]);
        toAnnounceText.push(elm.title);
      }
      return acc;
    }, []);
    focusDiff.reverse().reduce((acc, elm) => {
      if (elm.announceContext) {
        acc.push([getElmName(elm), "Context", elm.announceContext]);
        toAnnounceText.push(elm.announceContext);
      } else {
        acc.push([getElmName(elm), "No Context", ""]);
      }
      return acc;
    }, toAnnounce);
    if (Announcer.debug) {
      console.table(toAnnounce);
    }
    if (toAnnounceText.length) {
      return Announcer.speak(toAnnounceText.reduce((acc, val) => acc.concat(val), []));
    }
  }
  function textToSpeech(toSpeak) {
    if (voiceOutDisabled) {
      return;
    }
    return currentlySpeaking = Speech_default(toSpeak);
  }
  var Announcer = {
    enabled: true,
    debug: false,
    cancel: function() {
      currentlySpeaking && currentlySpeaking.cancel();
    },
    clearPrevFocus: function(depth = 0) {
      prevFocusPath = prevFocusPath.slice(0, depth);
      resetFocusPathTimer();
    },
    speak: function(text, { append = false, notification = false } = {}) {
      if (Announcer.enabled) {
        Announcer.onFocusChange.flush();
        if (append && currentlySpeaking && currentlySpeaking.active) {
          currentlySpeaking.append(text);
        } else {
          Announcer.cancel();
          textToSpeech(text);
        }
        if (notification) {
          voiceOutDisabled = true;
          currentlySpeaking.series.finally(() => {
            voiceOutDisabled = false;
            Announcer.refresh();
          });
        }
      }
      return currentlySpeaking;
    },
    setupTimers: function({ focusDebounce = 400, focusChangeTimeout = fiveMinutes } = {}) {
      Announcer.onFocusChange = debounce(onFocusChangeCore, focusDebounce);
      resetFocusPathTimer = debounce(() => {
        prevFocusPath = [];
      }, focusChangeTimeout);
    }
  };
  Announcer.setupTimers();
  var Announcer_default = Announcer;

  // node_modules/@lightningjs/sdk/src/Accessibility/index.js
  var Accessibility_default = {
    Announcer: Announcer_default,
    colorshift(component, type = false, config2 = { brightness: 50, contrast: 50, gamma: 50 }) {
      config2 = __spreadValues(__spreadValues({}, { brightness: 50, contrast: 50, gamma: 50 }), config2);
      const shader = type && colorshiftShader(type);
      if (shader) {
        Log_default.info("Accessibility Colorshift", type, config2);
        component.rtt = true;
        component.shader = __spreadValues({
          type: shader
        }, config2);
      } else {
        Log_default.info("Accessibility Colorshift", "Disabled");
        component.rtt = false;
        component.shader = null;
      }
    }
  };

  // node_modules/@metrological/sdk/src/Metadata/index.js
  var metadata = {};
  var initMetadata = (metadataObj) => {
    metadata = metadataObj;
  };

  // node_modules/@metrological/sdk/src/LightningSdkPlugins/index.js
  var Log;
  var Settings;
  var ApplicationInstance;
  var Ads;
  var Lightning;
  var initLightningSdkPlugin = {
    set log(v) {
      Log = v;
    },
    set settings(v) {
      Settings = v;
    },
    set ads(v) {
      Ads = v;
    },
    set lightning(v) {
      Lightning = v;
    },
    set appInstance(v) {
      ApplicationInstance = v;
    }
  };

  // node_modules/@metrological/sdk/src/Metrics/index.js
  var initMetrics = (config2) => {
    sendMetric = config2.sendMetric;
  };
  var sendMetric = (type, event, params) => {
    Log.info("Sending metric", type, event, params);
  };
  var metrics = {
    app: ["launch", "loaded", "ready", "close"],
    page: ["view", "leave"],
    user: ["click", "input"],
    media: [
      "abort",
      "canplay",
      "ended",
      "pause",
      "play",
      // with some videos there occur almost constant suspend events ... should investigate
      // 'suspend',
      "volumechange",
      "waiting",
      "seeking",
      "seeked"
    ]
  };
  var errorMetric = (type, message, code, visible, params = {}) => {
    params = __spreadValues({ params }, { message, code, visible });
    sendMetric(type, "error", params);
  };
  var Metric = (type, events2, options = {}) => {
    return events2.reduce(
      (obj, event) => {
        obj[event] = (name, params = {}) => {
          params = __spreadValues(__spreadValues(__spreadValues({}, options), name ? { name } : {}), params);
          sendMetric(type, event, params);
        };
        return obj;
      },
      {
        error(message, code, params) {
          errorMetric(type, message, code, params);
        },
        event(name, params) {
          sendMetric(type, name, params);
        }
      }
    );
  };
  var Metrics = (types) => {
    return Object.keys(types).reduce(
      (obj, type) => {
        type === "media" ? obj[type] = (url) => Metric(type, types[type], { url }) : obj[type] = Metric(type, types[type]);
        return obj;
      },
      { error: errorMetric, event: sendMetric }
    );
  };
  var Metrics_default = Metrics(metrics);

  // node_modules/@metrological/sdk/src/Profile/helpers.js
  var formatLocale = (locale) => {
    if (locale && locale.length === 2) {
      return `${locale.toLowerCase()}-${locale.toUpperCase()}`;
    } else {
      return locale;
    }
  };
  var getLocale = (defaultValue) => {
    if ("language" in navigator) {
      const locale = formatLocale(navigator.language);
      return Promise.resolve(locale);
    } else {
      return Promise.resolve(defaultValue);
    }
  };
  var getLanguage = (defaultValue) => {
    if ("language" in navigator) {
      const language2 = formatLocale(navigator.language).slice(0, 2);
      return Promise.resolve(language2);
    } else {
      return Promise.resolve(defaultValue);
    }
  };
  var getCountryCode = (defaultValue) => {
    if ("language" in navigator) {
      const countryCode = formatLocale(navigator.language).slice(3, 5);
      return Promise.resolve(countryCode);
    } else {
      return Promise.resolve(defaultValue);
    }
  };
  var hasOrAskForGeoLocationPermission = () => {
    return new Promise((resolve) => {
      if (Settings.get("platform", "forceBrowserGeolocation") === true) resolve(true);
      if ("permissions" in navigator && typeof navigator.permissions.query === "function") {
        navigator.permissions.query({ name: "geolocation" }).then((status) => {
          resolve(status.state === "granted" || status.status === "granted");
        });
      } else {
        resolve(false);
      }
    });
  };
  var getLatLon = (defaultValue) => {
    return new Promise((resolve) => {
      hasOrAskForGeoLocationPermission().then((granted) => {
        if (granted === true) {
          if ("geolocation" in navigator) {
            navigator.geolocation.getCurrentPosition(
              // success
              (result) => result && result.coords && resolve([result.coords.latitude, result.coords.longitude]),
              // error
              () => resolve(defaultValue),
              // options
              {
                enableHighAccuracy: true,
                timeout: 5e3,
                maximumAge: 0
              }
            );
          } else {
            return queryForLatLon().then((result) => resolve(result || defaultValue));
          }
        } else {
          return queryForLatLon().then((result) => resolve(result || defaultValue));
        }
      });
    });
  };
  var queryForLatLon = () => {
    return new Promise((resolve) => {
      fetch("https://geolocation-db.com/json/").then((response) => response.json()).then(
        ({ latitude, longitude }) => latitude && longitude ? resolve([latitude, longitude]) : resolve(false)
      ).catch(() => resolve(false));
    });
  };

  // node_modules/@metrological/sdk/src/Profile/defaults.js
  var defaultProfile = {
    ageRating: "adult",
    city: "New York",
    zipCode: "27505",
    countryCode: () => getCountryCode("US"),
    ip: "127.0.0.1",
    household: "b2244e9d4c04826ccd5a7b2c2a50e7d4",
    language: () => getLanguage("en"),
    latlon: () => getLatLon([40.7128, 74.006]),
    locale: () => getLocale("en-US"),
    mac: "00:00:00:00:00:00",
    operator: "metrological",
    platform: "metrological",
    packages: [],
    uid: "ee6723b8-7ab3-462c-8d93-dbf61227998e",
    stbType: "metrological"
  };

  // node_modules/@metrological/sdk/src/Profile/index.js
  var getInfo = (key) => {
    const profile = __spreadValues(__spreadValues({}, defaultProfile), Settings.get("platform", "profile"));
    return Promise.resolve(typeof profile[key] === "function" ? profile[key]() : profile[key]);
  };
  var setInfo = (key, params) => {
    if (key in defaultProfile) return defaultProfile[key] = params;
  };
  var initProfile = (config2) => {
    getInfo = config2.getInfo ? config2.getInfo : getInfo;
    setInfo = config2.setInfo ? config2.setInfo : setInfo;
  };

  // node_modules/@metrological/sdk/src/Purchase/index.js
  var billingUrl = "https://payment-sdk.metrological.com/";
  var initPurchase = (config2) => {
    if (config2.billingUrl) billingUrl = config2.billingUrl;
  };

  // node_modules/@metrological/sdk/src/TV/defaults.js
  var defaultChannels = [
    {
      number: 1,
      name: "Metro News 1",
      description: "New York Cable News Channel",
      entitled: true,
      program: {
        title: "The Morning Show",
        description: "New York's best morning show",
        startTime: new Date(/* @__PURE__ */ new Date() - 60 * 5 * 1e3).toUTCString(),
        // started 5 minutes ago
        duration: 60 * 30,
        // 30 minutes
        ageRating: 0
      }
    },
    {
      number: 2,
      name: "MTV",
      description: "Music Television",
      entitled: true,
      program: {
        title: "Beavis and Butthead",
        description: "American adult animated sitcom created by Mike Judge",
        startTime: new Date(/* @__PURE__ */ new Date() - 60 * 20 * 1e3).toUTCString(),
        // started 20 minutes ago
        duration: 60 * 45,
        // 45 minutes
        ageRating: 18
      }
    },
    {
      number: 3,
      name: "NBC",
      description: "NBC TV Network",
      entitled: false,
      program: {
        title: "The Tonight Show Starring Jimmy Fallon",
        description: "Late-night talk show hosted by Jimmy Fallon on NBC",
        startTime: new Date(/* @__PURE__ */ new Date() - 60 * 10 * 1e3).toUTCString(),
        // started 10 minutes ago
        duration: 60 * 60,
        // 1 hour
        ageRating: 10
      }
    }
  ];
  var channels = () => Settings.get("platform", "tv", defaultChannels);
  var randomChannel = () => channels()[~~(channels.length * Math.random())];

  // node_modules/@metrological/sdk/src/TV/index.js
  var currentChannel;
  var callbacks = {};
  var emit = (event, ...args) => {
    callbacks[event] && callbacks[event].forEach((cb) => {
      cb.apply(null, args);
    });
  };
  var methods2 = {
    getChannel() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        if (currentChannel) {
          const channel = __spreadValues({}, currentChannel);
          delete channel.program;
          resolve(channel);
        } else {
          reject("No channel found");
        }
      });
    },
    getProgram() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        currentChannel.program ? resolve(currentChannel.program) : reject("No program found");
      });
    },
    setChannel(number) {
      return new Promise((resolve, reject) => {
        if (number) {
          const newChannel = channels().find((c) => c.number === number);
          if (newChannel) {
            currentChannel = newChannel;
            const channel = __spreadValues({}, currentChannel);
            delete channel.program;
            emit("channelChange", channel);
            resolve(channel);
          } else {
            reject("Channel not found");
          }
        } else {
          reject("No channel number supplied");
        }
      });
    }
  };
  var initTV = (config2) => {
    methods2 = {};
    if (config2.getChannel && typeof config2.getChannel === "function") {
      methods2.getChannel = config2.getChannel;
    }
    if (config2.getProgram && typeof config2.getProgram === "function") {
      methods2.getProgram = config2.getProgram;
    }
    if (config2.setChannel && typeof config2.setChannel === "function") {
      methods2.setChannel = config2.setChannel;
    }
    if (config2.emit && typeof config2.emit === "function") {
      config2.emit(emit);
    }
  };

  // node_modules/@metrological/sdk/src/Pin/index.js
  var unlocked = false;
  var submit = (pin, context2) => {
    return new Promise((resolve, reject) => {
      if (pin.toString() === Settings.get("platform", "pin", "0000").toString()) {
        unlocked = true;
        resolve(unlocked);
      } else {
        reject("Incorrect pin");
      }
    });
  };
  var check = (context2) => {
    return new Promise((resolve) => {
      resolve(unlocked);
    });
  };
  var initPin = (config2) => {
    if (config2.submit && typeof config2.submit === "function") {
      submit = config2.submit;
    }
    if (config2.check && typeof config2.check === "function") {
      check = config2.check;
    }
  };

  // node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js
  var execute_as_promise_default = (method, args = null, context2 = null) => {
    let result;
    if (method && typeof method === "function") {
      try {
        result = method.apply(context2, args);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }
    if (result !== null && typeof result === "object" && result.then && typeof result.then === "function") {
      return result;
    } else {
      return new Promise((resolve, reject) => {
        if (result instanceof Error) {
          reject(result);
        } else {
          resolve(result);
        }
      });
    }
  };

  // node_modules/@metrological/sdk/src/VideoPlayer/events.js
  var events_default = {
    abort: "Abort",
    canplay: "CanPlay",
    canplaythrough: "CanPlayThrough",
    durationchange: "DurationChange",
    emptied: "Emptied",
    encrypted: "Encrypted",
    ended: "Ended",
    error: "Error",
    interruptbegin: "InterruptBegin",
    interruptend: "InterruptEnd",
    loadeddata: "LoadedData",
    loadedmetadata: "LoadedMetadata",
    loadstart: "LoadStart",
    pause: "Pause",
    play: "Play",
    playing: "Playing",
    progress: "Progress",
    ratechange: "Ratechange",
    seeked: "Seeked",
    seeking: "Seeking",
    stalled: "Stalled",
    // suspend: 'Suspend', // this one is called a looooot for some videos
    timeupdate: "TimeUpdate",
    volumechange: "VolumeChange",
    waiting: "Waiting"
  };

  // node_modules/@metrological/sdk/src/helpers/autoSetupMixin.js
  var autoSetupMixin_default = (sourceObject, setup2 = () => {
  }) => {
    let ready = false;
    const doSetup = () => {
      if (ready === false) {
        setup2();
        ready = true;
      }
    };
    return Object.keys(sourceObject).reduce((obj, key) => {
      if (typeof sourceObject[key] === "function") {
        obj[key] = function() {
          doSetup();
          return sourceObject[key].apply(sourceObject, arguments);
        };
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === "function") {
        obj.__defineGetter__(key, function() {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject);
        });
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === "function") {
        obj.__defineSetter__(key, function() {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(
            sourceObject,
            arguments
          );
        });
      } else {
        obj[key] = sourceObject[key];
      }
      return obj;
    }, {});
  };

  // node_modules/@metrological/sdk/src/helpers/easeExecution.js
  var timeout = null;
  var easeExecution_default = (cb, delay2) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      cb();
    }, delay2);
  };

  // node_modules/@metrological/sdk/src/VideoPlayer/VideoTexture.js
  var VideoTexture_default = () => {
    return class VideoTexture extends Lightning.Component {
      static _template() {
        return {
          Video: {
            alpha: 1,
            visible: false,
            pivot: 0.5,
            texture: { type: Lightning.textures.StaticTexture, options: {} }
          }
        };
      }
      set videoEl(v) {
        this._videoEl = v;
      }
      get videoEl() {
        return this._videoEl;
      }
      get videoView() {
        return this.tag("Video");
      }
      get videoTexture() {
        return this.videoView.texture;
      }
      get isVisible() {
        return this.videoView.alpha === 1 && this.videoView.visible === true;
      }
      _init() {
        this._createVideoTexture();
      }
      _createVideoTexture() {
        const stage2 = this.stage;
        const gl = stage2.gl;
        const glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        this.videoTexture.options = {
          source: glTexture,
          w: this.videoEl.width,
          h: this.videoEl.height
        };
        this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision();
        this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision();
      }
      start() {
        const stage2 = this.stage;
        this._lastTime = 0;
        if (!this._updateVideoTexture) {
          this._updateVideoTexture = () => {
            if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
              const gl = stage2.gl;
              const currentTime = (/* @__PURE__ */ new Date()).getTime();
              const getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality();
              const frameCount = getVideoPlaybackQuality ? getVideoPlaybackQuality.totalVideoFrames : this.videoEl.webkitDecodedFrameCount;
              const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
              if (mustUpdate) {
                this._lastTime = currentTime;
                this._lastFrame = frameCount;
                try {
                  gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                  this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                  this.videoView.visible = true;
                  this.videoTexture.options.w = this.videoEl.width;
                  this.videoTexture.options.h = this.videoEl.height;
                  const expectedAspectRatio = this.videoView.w / this.videoView.h;
                  const realAspectRatio = this.videoEl.width / this.videoEl.height;
                  if (expectedAspectRatio > realAspectRatio) {
                    this.videoView.scaleX = realAspectRatio / expectedAspectRatio;
                    this.videoView.scaleY = 1;
                  } else {
                    this.videoView.scaleY = expectedAspectRatio / realAspectRatio;
                    this.videoView.scaleX = 1;
                  }
                } catch (e) {
                  Log.error("texImage2d video", e);
                  this.stop();
                }
                this.videoTexture.source.forceRenderUpdate();
              }
            }
          };
        }
        if (!this._updatingVideoTexture) {
          stage2.on("frameStart", this._updateVideoTexture);
          this._updatingVideoTexture = true;
        }
      }
      stop() {
        const stage2 = this.stage;
        stage2.removeListener("frameStart", this._updateVideoTexture);
        this._updatingVideoTexture = false;
        this.videoView.visible = false;
        if (this.videoTexture.options.source) {
          const gl = stage2.gl;
          gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
      }
      position(top, left2) {
        this.videoView.patch({
          x: left2,
          y: top
        });
      }
      size(width, height) {
        this.videoView.patch({
          w: width,
          h: height
        });
      }
      show() {
        this.videoView.alpha = 1;
      }
      hide() {
        this.videoView.alpha = 0;
      }
    };
  };

  // node_modules/@metrological/sdk/src/VideoPlayer/index.js
  var mediaUrl = (url) => url;
  var videoEl;
  var videoTexture;
  var metrics2;
  var consumer;
  var precision = 1;
  var textureMode = false;
  var initVideoPlayer = (config2) => {
    if (config2.mediaUrl) {
      mediaUrl = config2.mediaUrl;
    }
  };
  var eventHandlers = {};
  var state = {
    adsEnabled: false,
    playing: false,
    _playingAds: false,
    get playingAds() {
      return this._playingAds;
    },
    set playingAds(val) {
      if (this._playingAds !== val) {
        this._playingAds = val;
        fireOnConsumer(val === true ? "AdStart" : "AdEnd");
      }
    },
    skipTime: false,
    playAfterSeek: null
  };
  var hooks = {
    play() {
      state.playing = true;
    },
    pause() {
      state.playing = false;
    },
    seeked() {
      state.playAfterSeek === true && videoPlayerPlugin.play();
      state.playAfterSeek = null;
    },
    abort() {
      deregisterEventListeners();
    }
  };
  var withPrecision = (val) => Math.round(precision * val) + "px";
  var fireOnConsumer = (event, args) => {
    if (consumer) {
      consumer.fire("$videoPlayer" + event, args, videoEl.currentTime);
      consumer.fire("$videoPlayerEvent", event, args, videoEl.currentTime);
    }
  };
  var fireHook = (event, args) => {
    hooks[event] && typeof hooks[event] === "function" && hooks[event].call(null, event, args);
  };
  var customLoader = null;
  var customUnloader = null;
  var loader = (url, videoEl2, config2) => {
    return customLoader && typeof customLoader === "function" ? customLoader(url, videoEl2, config2) : new Promise((resolve) => {
      url = mediaUrl(url);
      videoEl2.setAttribute("src", url);
      videoEl2.load();
      resolve();
    });
  };
  var unloader = (videoEl2) => {
    return customUnloader && typeof customUnloader === "function" ? customUnloader(videoEl2) : new Promise((resolve) => {
      videoEl2.removeAttribute("src");
      videoEl2.load();
      resolve();
    });
  };
  var setupVideoTag = () => {
    const videoEls = document.getElementsByTagName("video");
    if (videoEls && videoEls.length) {
      return videoEls[0];
    } else {
      const videoEl2 = document.createElement("video");
      const platformSettingsWidth = Settings.get("platform", "width") ? Settings.get("platform", "width") : 1920;
      const platformSettingsHeight = Settings.get("platform", "height") ? Settings.get("platform", "height") : 1080;
      videoEl2.setAttribute("id", "video-player");
      videoEl2.setAttribute("width", withPrecision(platformSettingsWidth));
      videoEl2.setAttribute("height", withPrecision(platformSettingsHeight));
      videoEl2.style.position = "absolute";
      videoEl2.style.zIndex = "1";
      videoEl2.style.display = "none";
      videoEl2.style.visibility = "hidden";
      videoEl2.style.top = withPrecision(0);
      videoEl2.style.left = withPrecision(0);
      videoEl2.style.width = withPrecision(platformSettingsWidth);
      videoEl2.style.height = withPrecision(platformSettingsHeight);
      document.body.appendChild(videoEl2);
      return videoEl2;
    }
  };
  var setUpVideoTexture = () => {
    if (!ApplicationInstance.tag("VideoTexture")) {
      const el = ApplicationInstance.stage.c({
        type: VideoTexture_default(),
        ref: "VideoTexture",
        zIndex: 0,
        videoEl
      });
      ApplicationInstance.childList.addAt(el, 0);
    }
    return ApplicationInstance.tag("VideoTexture");
  };
  var registerEventListeners = () => {
    Log.info("VideoPlayer", "Registering event listeners");
    Object.keys(events_default).forEach((event) => {
      const handler = (e) => {
        if (metrics2 && metrics2[event] && typeof metrics2[event] === "function") {
          metrics2[event]({ currentTime: videoEl.currentTime });
        }
        fireHook(event, { videoElement: videoEl, event: e });
        fireOnConsumer(events_default[event], { videoElement: videoEl, event: e });
      };
      eventHandlers[event] = handler;
      videoEl.addEventListener(event, handler);
    });
  };
  var deregisterEventListeners = () => {
    Log.info("VideoPlayer", "Deregistering event listeners");
    Object.keys(eventHandlers).forEach((event) => {
      videoEl.removeEventListener(event, eventHandlers[event]);
    });
    eventHandlers = {};
  };
  var videoPlayerPlugin = {
    consumer(component) {
      consumer = component;
    },
    loader(loaderFn) {
      customLoader = loaderFn;
    },
    unloader(unloaderFn) {
      customUnloader = unloaderFn;
    },
    position(top = 0, left2 = 0) {
      videoEl.style.left = withPrecision(left2);
      videoEl.style.top = withPrecision(top);
      if (textureMode === true) {
        videoTexture.position(top, left2);
      }
    },
    size(width = 1920, height = 1080) {
      videoEl.style.width = withPrecision(width);
      videoEl.style.height = withPrecision(height);
      videoEl.width = parseFloat(videoEl.style.width);
      videoEl.height = parseFloat(videoEl.style.height);
      if (textureMode === true) {
        videoTexture.size(width, height);
      }
    },
    area(top = 0, right2 = 1920, bottom = 1080, left2 = 0) {
      this.position(top, left2);
      this.size(right2 - left2, bottom - top);
    },
    open(url, config2 = {}) {
      if (!this.canInteract) return;
      metrics2 = Metrics_default.media(url);
      this.hide();
      deregisterEventListeners();
      if (this.src == url) {
        this.clear().then(this.open(url, config2));
      } else {
        const adConfig = { enabled: state.adsEnabled, duration: 300 };
        if (config2.videoId) {
          adConfig.caid = config2.videoId;
        }
        Ads.get(adConfig, consumer).then((ads) => {
          state.playingAds = true;
          ads.prerolls().then(() => {
            state.playingAds = false;
            loader(url, videoEl, config2).then(() => {
              registerEventListeners();
              this.show();
              this.play();
            }).catch((e) => {
              fireOnConsumer("Error", { videoElement: videoEl, event: e });
              fireOnConsumer("error", { videoElement: videoEl, event: e });
            });
          });
        });
      }
    },
    reload() {
      if (!this.canInteract) return;
      const url = videoEl.getAttribute("src");
      this.close();
      this.open(url);
    },
    close() {
      Ads.cancel();
      if (state.playingAds) {
        state.playingAds = false;
        Ads.stop();
        setTimeout(() => {
          this.close();
        });
      }
      if (!this.canInteract) return;
      this.clear();
      this.hide();
      deregisterEventListeners();
    },
    clear() {
      if (!this.canInteract) return;
      this.pause();
      if (textureMode === true) videoTexture.stop();
      return unloader(videoEl).then(() => {
        fireOnConsumer("Clear", { videoElement: videoEl });
      });
    },
    play() {
      if (!this.canInteract) return;
      if (textureMode === true) videoTexture.start();
      execute_as_promise_default(videoEl.play, null, videoEl).catch((e) => {
        fireOnConsumer("Error", { videoElement: videoEl, event: e });
        fireOnConsumer("error", { videoElement: videoEl, event: e });
      });
    },
    pause() {
      if (!this.canInteract) return;
      videoEl.pause();
    },
    playPause() {
      if (!this.canInteract) return;
      this.playing === true ? this.pause() : this.play();
    },
    mute(muted = true) {
      if (!this.canInteract) return;
      videoEl.muted = muted;
    },
    loop(looped = true) {
      videoEl.loop = looped;
    },
    seek(time) {
      if (!this.canInteract) return;
      if (!this.src) return;
      if (state.playAfterSeek === null) {
        state.playAfterSeek = !!state.playing;
      }
      this.pause();
      videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1));
    },
    skip(seconds) {
      if (!this.canInteract) return;
      if (!this.src) return;
      state.skipTime = (state.skipTime || videoEl.currentTime) + seconds;
      easeExecution_default(() => {
        this.seek(state.skipTime);
        state.skipTime = false;
      }, 300);
    },
    show() {
      if (!this.canInteract) return;
      if (textureMode === true) {
        videoTexture.show();
      } else {
        videoEl.style.display = "block";
        videoEl.style.visibility = "visible";
      }
    },
    hide() {
      if (!this.canInteract) return;
      if (textureMode === true) {
        videoTexture.hide();
      } else {
        videoEl.style.display = "none";
        videoEl.style.visibility = "hidden";
      }
    },
    enableAds(enabled = true) {
      state.adsEnabled = enabled;
    },
    /* Public getters */
    get duration() {
      return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration);
    },
    get currentTime() {
      return videoEl && videoEl.currentTime;
    },
    get muted() {
      return videoEl && videoEl.muted;
    },
    get looped() {
      return videoEl && videoEl.loop;
    },
    get src() {
      return videoEl && videoEl.getAttribute("src");
    },
    get playing() {
      return state.playing;
    },
    get playingAds() {
      return state.playingAds;
    },
    get canInteract() {
      return state.playingAds === false;
    },
    get top() {
      return videoEl && parseFloat(videoEl.style.top);
    },
    get left() {
      return videoEl && parseFloat(videoEl.style.left);
    },
    get bottom() {
      return videoEl && parseFloat(videoEl.style.top - videoEl.style.height);
    },
    get right() {
      return videoEl && parseFloat(videoEl.style.left - videoEl.style.width);
    },
    get width() {
      return videoEl && parseFloat(videoEl.style.width);
    },
    get height() {
      return videoEl && parseFloat(videoEl.style.height);
    },
    get visible() {
      if (textureMode === true) {
        return videoTexture.isVisible;
      } else {
        return videoEl && videoEl.style.display === "block";
      }
    },
    get adsEnabled() {
      return state.adsEnabled;
    },
    // prefixed with underscore to indicate 'semi-private'
    // because it's not recommended to interact directly with the video element
    get _videoEl() {
      return videoEl;
    },
    get _consumer() {
      return consumer;
    }
  };
  var VideoPlayer_default = autoSetupMixin_default(videoPlayerPlugin, () => {
    precision = ApplicationInstance && ApplicationInstance.stage && ApplicationInstance.stage.getRenderPrecision() || precision;
    videoEl = setupVideoTag();
    textureMode = Settings.get("platform", "textureMode", false);
    if (textureMode === true) {
      videoEl.setAttribute("crossorigin", "anonymous");
      videoTexture = setUpVideoTexture();
    }
  });

  // node_modules/@lightningjs/sdk/src/Ads/index.js
  var consumer2;
  var getAds = () => {
    return Promise.resolve({
      prerolls: [],
      midrolls: [],
      postrolls: []
    });
  };
  var initAds = (config2) => {
    if (config2.getAds) {
      getAds = config2.getAds;
    }
  };
  var state2 = {
    active: false
  };
  var playSlot = (slot = []) => {
    return slot.reduce((promise, ad) => {
      return promise.then(() => {
        return playAd(ad);
      });
    }, Promise.resolve(null));
  };
  var playAd = (ad) => {
    return new Promise((resolve) => {
      if (state2.active === false) {
        Log_default.info("Ad", "Skipping add due to inactive state");
        return resolve();
      }
      const videoEl2 = document.getElementsByTagName("video")[0];
      videoEl2.style.display = "block";
      videoEl2.style.visibility = "visible";
      videoEl2.src = mediaUrl(ad.url);
      videoEl2.load();
      let timeEvents = null;
      let timeout2;
      const cleanup = () => {
        Object.keys(handlers).forEach(
          (handler) => videoEl2.removeEventListener(handler, handlers[handler])
        );
        resolve();
      };
      const handlers = {
        play() {
          Log_default.info("Ad", "Play ad", ad.url);
          fireOnConsumer2("Play", ad);
          sendBeacon(ad.callbacks, "defaultImpression");
        },
        ended() {
          fireOnConsumer2("Ended", ad);
          sendBeacon(ad.callbacks, "complete");
          cleanup();
        },
        timeupdate() {
          if (!timeEvents && videoEl2.duration) {
            timeEvents = {
              firstQuartile: videoEl2.duration / 4,
              midPoint: videoEl2.duration / 2,
              thirdQuartile: videoEl2.duration / 4 * 3
            };
            Log_default.info("Ad", "Calculated quartiles times", { timeEvents });
          }
          if (timeEvents && timeEvents.firstQuartile && videoEl2.currentTime >= timeEvents.firstQuartile) {
            fireOnConsumer2("FirstQuartile", ad);
            delete timeEvents.firstQuartile;
            sendBeacon(ad.callbacks, "firstQuartile");
          }
          if (timeEvents && timeEvents.midPoint && videoEl2.currentTime >= timeEvents.midPoint) {
            fireOnConsumer2("MidPoint", ad);
            delete timeEvents.midPoint;
            sendBeacon(ad.callbacks, "midPoint");
          }
          if (timeEvents && timeEvents.thirdQuartile && videoEl2.currentTime >= timeEvents.thirdQuartile) {
            fireOnConsumer2("ThirdQuartile", ad);
            delete timeEvents.thirdQuartile;
            sendBeacon(ad.callbacks, "thirdQuartile");
          }
        },
        stalled() {
          fireOnConsumer2("Stalled", ad);
          timeout2 = setTimeout(() => {
            cleanup();
          }, 5e3);
        },
        canplay() {
          timeout2 && clearTimeout(timeout2);
        },
        error() {
          fireOnConsumer2("Error", ad);
          cleanup();
        },
        // this doesn't work reliably on sky box, moved logic to timeUpdate event
        // loadedmetadata() {
        //   // calculate when to fire the time based events (now that duration is known)
        //   timeEvents = {
        //     firstQuartile: videoEl.duration / 4,
        //     midPoint: videoEl.duration / 2,
        //     thirdQuartile: (videoEl.duration / 4) * 3,
        //   }
        // },
        abort() {
          cleanup();
        }
        // todo: pause, resume, mute, unmute beacons
      };
      Object.keys(handlers).forEach((handler) => videoEl2.addEventListener(handler, handlers[handler]));
      videoEl2.play();
    });
  };
  var sendBeacon = (callbacks2, event) => {
    if (callbacks2 && callbacks2[event]) {
      Log_default.info("Ad", "Sending beacon", event, callbacks2[event]);
      return callbacks2[event].reduce((promise, url) => {
        return promise.then(
          () => fetch(url).then((response) => {
            if (response.status === 200) {
              fireOnConsumer2("Beacon" + event + "Sent");
            } else {
              fireOnConsumer2("Beacon" + event + "Failed" + response.status);
            }
            Promise.resolve(null);
          }).catch(() => {
            Promise.resolve(null);
          })
        );
      }, Promise.resolve(null));
    } else {
      Log_default.info("Ad", "No callback found for " + event);
    }
  };
  var fireOnConsumer2 = (event, args) => {
    if (consumer2) {
      consumer2.fire("$ad" + event, args);
      consumer2.fire("$adEvent", event, args);
    }
  };
  var Ads_default = {
    get(config2, videoPlayerConsumer) {
      if (config2.enabled === false) {
        return Promise.resolve({
          prerolls() {
            return Promise.resolve();
          }
        });
      }
      consumer2 = videoPlayerConsumer;
      return new Promise((resolve) => {
        Log_default.info("Ad", "Starting session");
        getAds(config2).then((ads) => {
          Log_default.info("Ad", "API result", ads);
          resolve({
            prerolls() {
              if (ads.preroll) {
                state2.active = true;
                fireOnConsumer2("PrerollSlotImpression", ads);
                sendBeacon(ads.preroll.callbacks, "slotImpression");
                return playSlot(ads.preroll.ads).then(() => {
                  fireOnConsumer2("PrerollSlotEnd", ads);
                  sendBeacon(ads.preroll.callbacks, "slotEnd");
                  state2.active = false;
                });
              }
              return Promise.resolve();
            },
            midrolls() {
              return Promise.resolve();
            },
            postrolls() {
              return Promise.resolve();
            }
          });
        });
      });
    },
    cancel() {
      Log_default.info("Ad", "Cancel Ad");
      state2.active = false;
    },
    stop() {
      Log_default.info("Ad", "Stop Ad");
      state2.active = false;
      const videoEl2 = document.getElementsByTagName("video")[0];
      videoEl2.pause();
      videoEl2.removeAttribute("src");
    }
  };

  // node_modules/@lightningjs/sdk/src/Application/index.js
  var import_deepmerge = __toESM(require_cjs());

  // node_modules/is-plain-object/dist/is-plain-object.mjs
  function isObject(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false) return false;
    ctor = o.constructor;
    if (ctor === void 0) return true;
    prot = ctor.prototype;
    if (isObject(prot) === false) return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  }

  // node_modules/@lightningjs/sdk/src/Locale/index.js
  var warned = false;
  var deprecated = (force = false) => {
    if (force === true || warned === false) {
      console.warn(
        [
          "The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
          "Please consider using the new 'Language'-plugin instead.",
          "https://rdkcentral.github.io/Lightning-SDK/#/plugins/language"
        ].join("\n\n")
      );
    }
    warned = true;
  };
  var Locale = class {
    constructor() {
      this.__enabled = false;
    }
    /**
     * Loads translation object from external json file.
     *
     * @param {String} path Path to resource.
     * @return {Promise}
     */
    load(path) {
      return __async(this, null, function* () {
        if (!this.__enabled) {
          return;
        }
        yield fetch(path).then((resp) => resp.json()).then((resp) => {
          this.loadFromObject(resp);
        });
      });
    }
    /**
     * Sets language used by module.
     *
     * @param {String} lang
     */
    setLanguage(lang) {
      deprecated();
      this.__enabled = true;
      this.language = lang;
    }
    /**
     * Returns reference to translation object for current language.
     *
     * @return {Object}
     */
    get tr() {
      deprecated(true);
      return this.__trObj[this.language];
    }
    /**
     * Loads translation object from existing object (binds existing object).
     *
     * @param {Object} trObj
     */
    loadFromObject(trObj) {
      deprecated();
      const fallbackLanguage = "en";
      if (Object.keys(trObj).indexOf(this.language) === -1) {
        Log_default.warn("No translations found for: " + this.language);
        if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
          Log_default.warn("Using fallback language: " + fallbackLanguage);
          this.language = fallbackLanguage;
        } else {
          const error = "No translations found for fallback language: " + fallbackLanguage;
          Log_default.error(error);
          throw Error(error);
        }
      }
      this.__trObj = trObj;
      for (const lang of Object.values(this.__trObj)) {
        for (const str of Object.keys(lang)) {
          lang[str] = new LocalizedString(lang[str]);
        }
      }
    }
  };
  var LocalizedString = class _LocalizedString extends String {
    /**
     * Returns formatted LocalizedString.
     * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
     *
     * E.g.:
     * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
     * A and B and A
     *
     * @param  {...any} args List of arguments for placeholders.
     */
    format(...args) {
      const sub = args.reduce((string, arg, index) => string.split(`{${index}}`).join(arg), this);
      return new _LocalizedString(sub);
    }
  };
  var Locale_default = new Locale();

  // node_modules/@lightningjs/sdk/src/Metrics/index.js
  var Metrics_default2 = Metrics_default;

  // node_modules/@lightningjs/sdk/src/VersionLabel/index.js
  var VersionLabel = class extends Lightning_default.Component {
    static _template() {
      return {
        rect: true,
        color: 3137370284,
        h: 40,
        w: 100,
        x: (w) => w - 50,
        y: (h) => h - 50,
        mount: 1,
        Text: {
          w: (w) => w,
          h: (h) => h,
          y: 5,
          x: 20,
          text: {
            fontSize: 22,
            lineHeight: 26
          }
        }
      };
    }
    _firstActive() {
      this.tag("Text").text = `APP - v${this.version}
SDK - v${this.sdkVersion}`;
      this.tag("Text").loadTexture();
      this.w = this.tag("Text").renderWidth + 40;
      this.h = this.tag("Text").renderHeight + 5;
    }
  };

  // node_modules/@lightningjs/sdk/src/FpsCounter/index.js
  var FpsIndicator = class extends Lightning_default.Component {
    static _template() {
      return {
        rect: true,
        color: 4294967295,
        texture: Lightning_default.Tools.getRoundRect(80, 80, 40),
        h: 80,
        w: 80,
        x: 100,
        y: 100,
        mount: 1,
        Background: {
          x: 3,
          y: 3,
          texture: Lightning_default.Tools.getRoundRect(72, 72, 36),
          color: 4278222848
        },
        Counter: {
          w: (w) => w,
          h: (h) => h,
          y: 10,
          text: {
            fontSize: 32,
            textAlign: "center"
          }
        },
        Text: {
          w: (w) => w,
          h: (h) => h,
          y: 48,
          text: {
            fontSize: 15,
            textAlign: "center",
            text: "FPS"
          }
        }
      };
    }
    _setup() {
      this.config = __spreadValues(__spreadValues({}, {
        log: false,
        interval: 500,
        threshold: 1
      }), Settings_default.get("platform", "showFps"));
      this.fps = 0;
      this.lastFps = this.fps - this.config.threshold;
      const fpsCalculator = () => {
        this.fps = ~~(1 / this.stage.dt);
      };
      this.stage.on("frameStart", fpsCalculator);
      this.stage.off("framestart", fpsCalculator);
      this.interval = setInterval(this.showFps.bind(this), this.config.interval);
    }
    _firstActive() {
      this.showFps();
    }
    _detach() {
      clearInterval(this.interval);
    }
    showFps() {
      if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return;
      this.lastFps = this.fps;
      let bgColor = 4278222848;
      if (this.fps <= 40 && this.fps > 20) bgColor = 4294944e3;
      else if (this.fps <= 20) bgColor = 4294901760;
      this.tag("Background").setSmooth("color", bgColor);
      this.tag("Counter").text = `${this.fps}`;
      this.config.log && Log_default.info("FPS", this.fps);
    }
  };

  // node_modules/@lightningjs/sdk/src/helpers/fetchJson.js
  var fetchJson_default = (file) => {
    return new Promise((resolve, reject) => {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState == XMLHttpRequest.DONE) {
          if (xhr.status === 0 || xhr.status === 200) resolve(JSON.parse(xhr.responseText));
          else reject(xhr.statusText);
        }
      };
      xhr.open("GET", file);
      xhr.send(null);
    });
  };

  // node_modules/@lightningjs/sdk/src/Utils/index.js
  var basePath;
  var proxyUrl;
  var initUtils = (config2) => {
    basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config2.path || "/"));
    if (config2.proxyUrl) {
      proxyUrl = ensureUrlWithProtocol(config2.proxyUrl);
    }
  };
  var Utils_default = {
    asset(relPath) {
      return basePath + relPath;
    },
    proxyUrl(url, options = {}) {
      return proxyUrl ? proxyUrl + "?" + makeQueryString(url, options) : url;
    },
    makeQueryString() {
      return makeQueryString(...arguments);
    },
    // since imageworkers don't work without protocol
    ensureUrlWithProtocol() {
      return ensureUrlWithProtocol(...arguments);
    }
  };
  var ensureUrlWithProtocol = (url) => {
    if (/^\/[^/]/i.test(url) && /^(?:file:)/i.test(window.location.protocol)) {
      return window.location.protocol + "//" + url;
    }
    if (/^\/\//.test(url)) {
      return window.location.protocol + url;
    }
    if (!/^(?:https?:)/i.test(url)) {
      return window.location.origin + url;
    }
    return url;
  };
  var makeFullStaticPath = (pathname = "/", path) => {
    path = path.charAt(path.length - 1) !== "/" ? path + "/" : path;
    if (/^(?:https?:)?(?:\/\/)/.test(path)) {
      return path;
    }
    if (path.charAt(0) === "/") {
      return path;
    } else {
      pathname = cleanUpPathName(pathname);
      path = path.charAt(0) === "." ? path.substr(1) : path;
      path = path.charAt(0) !== "/" ? "/" + path : path;
      return pathname + path;
    }
  };
  var cleanUpPathName = (pathname) => {
    if (pathname.slice(-1) === "/") return pathname.slice(0, -1);
    const parts = pathname.split("/");
    if (parts[parts.length - 1].indexOf(".") > -1) parts.pop();
    return parts.join("/");
  };
  var makeQueryString = (url, options = {}, type = "url") => {
    options.operator = "metrological";
    options[type] = url;
    return Object.keys(options).map((key) => {
      return encodeURIComponent(key) + "=" + encodeURIComponent("" + options[key]);
    }).join("&");
  };

  // node_modules/@lightningjs/sdk/src/Language/index.js
  var meta = {};
  var translations = {};
  var language = null;
  var dictionary = null;
  var initLanguage = (file, language2 = null) => {
    return new Promise((resolve, reject) => {
      fetchJson_default(file).then((json) => {
        setTranslations(json);
        typeof language2 === "object" && "then" in language2 && typeof language2.then === "function" ? language2.then(
          (lang) => setLanguage(lang).then(resolve).catch(reject)
        ).catch((e) => {
          Log_default.error(e);
          reject(e);
        }) : setLanguage(language2).then(resolve).catch(reject);
      }).catch(() => {
        const error = "Language file " + file + " not found";
        Log_default.error(error);
        reject(error);
      });
    });
  };
  var setTranslations = (obj) => {
    if ("meta" in obj) {
      meta = __spreadValues({}, obj.meta);
      delete obj.meta;
    }
    translations = obj;
  };
  var setLanguage = (lng) => {
    language = null;
    dictionary = null;
    return new Promise((resolve, reject) => {
      if (lng in translations) {
        language = lng;
      } else {
        if ("map" in meta && lng in meta.map && meta.map[lng] in translations) {
          language = meta.map[lng];
        } else if ("default" in meta && meta.default in translations) {
          const error = "Translations for Language " + language + " not found. Using default language " + meta.default;
          Log_default.warn(error);
          language = meta.default;
        } else {
          const error = "Translations for Language " + language + " not found.";
          Log_default.error(error);
          reject(error);
        }
      }
      if (language) {
        Log_default.info("Setting language to", language);
        const translationsObj = translations[language];
        if (typeof translationsObj === "object") {
          dictionary = translationsObj;
          resolve();
        } else if (typeof translationsObj === "string") {
          const url = Utils_default.asset(translationsObj);
          fetchJson_default(url).then((json) => {
            translations[language] = json;
            dictionary = json;
            resolve();
          }).catch((e) => {
            const error = "Error while fetching " + url;
            Log_default.error(error, e);
            reject(error);
          });
        }
      }
    });
  };

  // node_modules/@lightningjs/sdk/src/Registry/index.js
  var registry = {
    eventListeners: [],
    timeouts: [],
    intervals: [],
    targets: []
  };
  var Registry_default = {
    // Timeouts
    setTimeout(cb, timeout2, ...params) {
      const timeoutId = setTimeout(
        () => {
          registry.timeouts = registry.timeouts.filter((id) => id !== timeoutId);
          cb.apply(null, params);
        },
        timeout2,
        params
      );
      Log_default.info("Set Timeout", "ID: " + timeoutId);
      registry.timeouts.push(timeoutId);
      return timeoutId;
    },
    clearTimeout(timeoutId) {
      if (registry.timeouts.indexOf(timeoutId) > -1) {
        registry.timeouts = registry.timeouts.filter((id) => id !== timeoutId);
        Log_default.info("Clear Timeout", "ID: " + timeoutId);
        clearTimeout(timeoutId);
      } else {
        Log_default.error("Clear Timeout", "ID " + timeoutId + " not found");
      }
    },
    clearTimeouts() {
      registry.timeouts.forEach((timeoutId) => {
        this.clearTimeout(timeoutId);
      });
    },
    // Intervals
    setInterval(cb, interval, ...params) {
      const intervalId = setInterval(
        () => {
          registry.intervals.filter((id) => id !== intervalId);
          cb.apply(null, params);
        },
        interval,
        params
      );
      Log_default.info("Set Interval", "ID: " + intervalId);
      registry.intervals.push(intervalId);
      return intervalId;
    },
    clearInterval(intervalId) {
      if (registry.intervals.indexOf(intervalId) > -1) {
        registry.intervals = registry.intervals.filter((id) => id !== intervalId);
        Log_default.info("Clear Interval", "ID: " + intervalId);
        clearInterval(intervalId);
      } else {
        Log_default.error("Clear Interval", "ID " + intervalId + " not found");
      }
    },
    clearIntervals() {
      registry.intervals.forEach((intervalId) => {
        this.clearInterval(intervalId);
      });
    },
    // Event listeners
    addEventListener(target, event, handler) {
      target.addEventListener(event, handler);
      const targetIndex = registry.targets.indexOf(target) > -1 ? registry.targets.indexOf(target) : registry.targets.push(target) - 1;
      registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {};
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || [];
      registry.eventListeners[targetIndex][event].push(handler);
      Log_default.info(
        "Add eventListener",
        "Target:",
        target,
        "Event: " + event,
        "Handler:",
        handler.toString()
      );
    },
    removeEventListener(target, event, handler) {
      const targetIndex = registry.targets.indexOf(target);
      if (targetIndex > -1 && registry.eventListeners[targetIndex] && registry.eventListeners[targetIndex][event] && registry.eventListeners[targetIndex][event].indexOf(handler) > -1) {
        registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event].filter((fn) => fn !== handler);
        Log_default.info(
          "Remove eventListener",
          "Target:",
          target,
          "Event: " + event,
          "Handler:",
          handler.toString()
        );
        target.removeEventListener(event, handler);
        Object.keys(registry.eventListeners[targetIndex]).forEach((event2) => {
          if (registry.eventListeners[targetIndex][event2].length === 0) {
            delete registry.eventListeners[targetIndex][event2];
          }
        });
        if (Object.keys(registry.eventListeners[targetIndex]).length === 0) {
          registry.targets.splice(targetIndex, 1);
          registry.eventListeners.splice(targetIndex, 1);
        }
      } else {
        Log_default.error(
          "Remove eventListener",
          "Not found",
          "Target",
          target,
          "Event: " + event,
          "Handler",
          handler.toString()
        );
      }
    },
    // if `event` is omitted, removes all registered event listeners for target
    // if `target` is also omitted, removes all registered event listeners
    removeEventListeners(target, event) {
      if (target && event) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          registry.eventListeners[targetIndex][event].forEach((handler) => {
            this.removeEventListener(target, event, handler);
          });
        }
      } else if (target) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          Object.keys(registry.eventListeners[targetIndex]).forEach((_event) => {
            this.removeEventListeners(target, _event);
          });
        }
      } else {
        Object.keys(registry.eventListeners).forEach((targetIndex) => {
          this.removeEventListeners(registry.targets[targetIndex]);
        });
      }
    },
    // Clear everything (to be called upon app close for proper cleanup)
    clear() {
      this.clearTimeouts();
      this.clearIntervals();
      this.removeEventListeners();
      registry.eventListeners = [];
      registry.timeouts = [];
      registry.intervals = [];
      registry.targets = [];
    }
  };

  // node_modules/@lightningjs/sdk/src/Colors/utils.js
  var isObject2 = (v) => {
    return typeof v === "object" && v !== null;
  };
  var isString = (v) => {
    return typeof v === "string";
  };

  // node_modules/@lightningjs/sdk/src/Colors/index.js
  var colors = {
    white: "#ffffff",
    black: "#000000",
    red: "#ff0000",
    green: "#00ff00",
    blue: "#0000ff",
    yellow: "#feff00",
    cyan: "#00feff",
    magenta: "#ff00ff"
  };
  var normalizedColors = {
    //store for normalized colors
  };
  var addColors = (colorsToAdd, value) => {
    if (isObject2(colorsToAdd)) {
      Object.keys(colorsToAdd).forEach((color) => cleanUpNormalizedColors(color));
      colors = Object.assign({}, colors, colorsToAdd);
    } else if (isString(colorsToAdd) && value) {
      cleanUpNormalizedColors(colorsToAdd);
      colors[colorsToAdd] = value;
    }
  };
  var cleanUpNormalizedColors = (color) => {
    for (let c in normalizedColors) {
      if (c.indexOf(color) > -1) {
        delete normalizedColors[c];
      }
    }
  };
  var initColors = (file) => {
    return new Promise((resolve, reject) => {
      if (typeof file === "object") {
        addColors(file);
        return resolve();
      }
      fetchJson_default(file).then((json) => {
        addColors(json);
        return resolve();
      }).catch(() => {
        const error = "Colors file " + file + " not found";
        Log_default.error(error);
        return reject(error);
      });
    });
  };

  // node_modules/@lightningjs/sdk/package.json
  var package_default = {
    name: "@lightningjs/sdk",
    version: "5.5.5",
    license: "Apache-2.0",
    types: "index.d.ts",
    scripts: {
      postinstall: "node ./scripts/postinstall.js",
      lint: "eslint '**/*.js'",
      release: "npm publish --access public",
      typedoc: "typedoc --tsconfig tsconfig.typedoc.json",
      tsd: "tsd"
    },
    "lint-staged": {
      "*.js": [
        "eslint --fix"
      ],
      "src/startApp.js": [
        "rollup -c ./rollup.config.js"
      ]
    },
    husky: {
      hooks: {
        "pre-commit": "lint-staged"
      }
    },
    dependencies: {
      "@babel/polyfill": "^7.11.5",
      "@lightningjs/core": "^2.15.0",
      "@metrological/sdk": "^1.0.2",
      "@michieljs/execute-as-promise": "^1.0.0",
      deepmerge: "^4.2.2",
      "is-plain-object": "^5.0.0",
      localcookies: "^2.0.0",
      shelljs: "^0.8.5",
      "url-polyfill": "^1.1.10",
      "whatwg-fetch": "^3.0.0"
    },
    devDependencies: {
      "@babel/core": "^7.11.6",
      "@babel/plugin-transform-parameters": "^7.10.5 ",
      "@babel/plugin-transform-spread": "^7.11.0",
      "@babel/preset-env": "^7.11.5",
      "babel-eslint": "^10.1.0",
      eslint: "^7.10.0",
      "eslint-config-prettier": "^6.12.0",
      "eslint-plugin-prettier": "^3.1.4",
      husky: "^4.3.0",
      "lint-staged": "^10.4.0",
      prettier: "^1.19.1",
      rollup: "^1.32.1",
      "rollup-plugin-babel": "^4.4.0",
      tsd: "^0.22.0",
      typedoc: "^0.23.9"
    },
    repository: {
      type: "git",
      url: "git@github.com:rdkcentral/Lightning-SDK.git"
    },
    bugs: {
      url: "https://github.com/rdkcentral/Lightning-SDK/issues"
    }
  };

  // node_modules/@lightningjs/sdk/src/Application/index.js
  var AppInstance;
  var AppData;
  var defaultOptions = {
    stage: { w: 1920, h: 1080, precision: 1, clearColor: 0, canvas2d: false },
    debug: false,
    defaultFontFace: "RobotoRegular",
    keys: {
      8: "Back",
      13: "Enter",
      27: "Menu",
      37: "Left",
      38: "Up",
      39: "Right",
      40: "Down",
      174: "ChannelDown",
      175: "ChannelUp",
      178: "Stop",
      250: "PlayPause",
      191: "Search",
      // Use "/" for keyboard
      409: "Search"
    }
  };
  var customFontFaces = [];
  var fontLoader = (fonts, store) => new Promise((resolve, reject) => {
    fonts.map(({ family, url, urls, descriptors }) => () => {
      const src = urls ? urls.map((url2) => {
        return "url(" + url2 + ")";
      }) : "url(" + url + ")";
      const fontFace = new FontFace(family, src, descriptors || {});
      store.push(fontFace);
      Log_default.info("Loading font", family);
      document.fonts.add(fontFace);
      return fontFace.load();
    }).reduce((promise, method) => {
      return promise.then(() => method());
    }, Promise.resolve(null)).then(resolve).catch(reject);
  });
  function Application_default(App3, appData, platformSettings) {
    const { width, height } = platformSettings;
    if (width && height) {
      defaultOptions.stage["w"] = width;
      defaultOptions.stage["h"] = height;
      defaultOptions.stage["precision"] = width / 1920;
    }
    if (!width && !height && window.innerHeight === 720) {
      defaultOptions.stage["w"] = 1280;
      defaultOptions.stage["h"] = 720;
      defaultOptions.stage["precision"] = 1280 / 1920;
    }
    return class Application extends Lightning_default.Application {
      constructor(options) {
        const config2 = (0, import_deepmerge.default)(defaultOptions, options, {
          isMergeableObject: isPlainObject
        });
        super(config2);
        this.config = config2;
      }
      static _template() {
        return {
          w: 1920,
          h: 1080
        };
      }
      colorshift(type = false, config2 = {}) {
        Accessibility_default.colorshift(this, type, config2);
      }
      get keymapping() {
        return this.stage.application.config.keys;
      }
      /**
       * This function overrides the default keymap with the latest keymap.
       * @param customKeyMap
       * @param keepDuplicates
       */
      overrideKeyMap(customKeyMap, keepDuplicates = false) {
        const baseKeyMap = this.stage.application.config.keys;
        Object.keys(customKeyMap).reduce((keymapping, key) => {
          if (!keepDuplicates) {
            Object.keys(baseKeyMap).forEach((baseKey) => {
              if (baseKey != key && baseKeyMap[baseKey] == customKeyMap[key]) {
                delete keymapping[baseKey];
              }
            });
          }
          keymapping[key] = customKeyMap[key];
          return keymapping;
        }, baseKeyMap);
        return baseKeyMap;
      }
      _setup() {
        Promise.all([
          this.loadFonts(App3.config && App3.config.fonts || App3.getFonts && App3.getFonts() || []),
          // to be deprecated
          Locale_default.load(App3.config && App3.config.locale || App3.getLocale && App3.getLocale()),
          App3.language && this.loadLanguage(App3.language()),
          App3.colors && this.loadColors(App3.colors())
        ]).then(() => {
          Metrics_default2.app.loaded();
          this.w = this.config.stage.w / this.config.stage.precision;
          this.h = this.config.stage.h / this.config.stage.precision;
          AppData = appData;
          AppInstance = this.stage.c({
            ref: "App",
            type: App3,
            zIndex: 1,
            forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps
          });
          this.childList.a(AppInstance);
          this._refocus();
          Log_default.info("App version", this.config.version);
          Log_default.info("SDK version", package_default.version);
          if (platformSettings.showVersion) {
            this.childList.a({
              ref: "VersionLabel",
              type: VersionLabel,
              version: this.config.version,
              sdkVersion: package_default.version,
              zIndex: 1
            });
          }
          if (platformSettings.showFps) {
            this.childList.a({
              ref: "FpsCounter",
              type: FpsIndicator,
              zIndex: 1
            });
          }
          super._setup();
        }).catch(console.error);
      }
      _handleBack() {
        this.closeApp();
      }
      _handleExit() {
        this.closeApp();
      }
      closeApp() {
        Log_default.info("Signaling App Close");
        if (platformSettings.onClose && typeof platformSettings.onClose === "function") {
          platformSettings.onClose(...arguments);
        } else {
          this.close();
        }
      }
      close() {
        Log_default.info("Closing App");
        Settings_default.clearSubscribers();
        Registry_default.clear();
        this.childList.remove(this.tag("App"));
        this.cleanupFonts();
        this.stage.gc();
        this.destroy();
      }
      loadFonts(fonts) {
        return platformSettings.fontLoader && typeof platformSettings.fontLoader === "function" ? platformSettings.fontLoader(fonts, customFontFaces) : fontLoader(fonts, customFontFaces);
      }
      cleanupFonts() {
        if ("delete" in document.fonts) {
          customFontFaces.forEach((fontFace) => {
            Log_default.info("Removing font", fontFace.family);
            document.fonts.delete(fontFace);
          });
        } else {
          Log_default.info("No support for removing manually-added fonts");
        }
      }
      loadLanguage(config2) {
        let file = Utils_default.asset("translations.json");
        let language2 = config2;
        if (typeof language2 === "object") {
          language2 = config2.language || null;
          file = config2.file || file;
        }
        return initLanguage(file, language2);
      }
      loadColors(config2) {
        let file = Utils_default.asset("colors.json");
        if (config2 && (typeof config2 === "string" || typeof config2 === "object")) {
          file = config2;
        }
        return initColors(file);
      }
      set focus(v) {
        this._focussed = v;
        this._refocus();
      }
      _getFocused() {
        return this._focussed || this.tag("App");
      }
    };
  }

  // node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js
  var ScaledImageTexture = class extends Lightning_default.textures.ImageTexture {
    constructor(stage2) {
      super(stage2);
      this._scalingOptions = void 0;
    }
    set options(options) {
      this.resizeMode = this._scalingOptions = options;
    }
    _getLookupId() {
      return `${this._src}-${this._scalingOptions.type}-${this._scalingOptions.w}-${this._scalingOptions.h}`;
    }
    getNonDefaults() {
      const obj = super.getNonDefaults();
      if (this._src) {
        obj.src = this._src;
      }
      return obj;
    }
  };

  // node_modules/@lightningjs/sdk/src/Img/index.js
  var Img_default = (imageUrl, options) => {
    const imageServerUrl = Settings_default.get("platform", "imageServerUrl");
    const make = (options2) => {
      if (!/^(?:https?:)?\/\//i.test(imageUrl) && !imageUrl.includes("data:image/png;base64")) {
        imageUrl = Utils_default.asset(imageUrl);
      }
      if (imageServerUrl && imageUrl.indexOf(window.location.origin) === -1) {
        imageUrl = Utils_default.ensureUrlWithProtocol(
          imageServerUrl + "?" + Utils_default.makeQueryString(imageUrl, options2)
        );
      } else {
        if (options2.type !== "cover") {
          if (options2.type === "crop") options2.type = "cover";
          else options2.type = "contain";
        }
      }
      return {
        type: ScaledImageTexture,
        src: imageUrl,
        options: options2
      };
    };
    const setOptions = (options2) => {
      options2 = __spreadValues(__spreadValues({}, {
        type: "contain",
        w: 0,
        h: 0
      }), options2);
      const imageQuality = Math.max(
        0.1,
        Math.min(1, (parseFloat(Settings_default.get("platform", "image.quality")) || 100) / 100)
      );
      options2.w = options2.w * imageQuality;
      options2.h = options2.h * imageQuality;
      return options2;
    };
    if (options) {
      return make(setOptions(options));
    }
    return {
      // official api
      exact: (w, h) => make(setOptions({ type: "exact", w, h })),
      landscape: (w) => make(setOptions({ type: "landscape", w })),
      portrait: (h) => make(setOptions({ type: "portrait", h })),
      cover: (w, h) => make(setOptions({ type: "cover", w, h })),
      contain: (w, h) => make(setOptions({ type: "contain", w, h })),
      original: () => make(setOptions({ type: "contain" }))
      // todo: add positioning - i.e. top, bottom, center, left etc.
    };
  };

  // node_modules/@lightningjs/sdk/src/MediaPlayer/index.js
  var events = [
    "timeupdate",
    "error",
    "ended",
    "loadeddata",
    "canplay",
    "play",
    "playing",
    "pause",
    "loadstart",
    "seeking",
    "seeked",
    "encrypted"
  ];
  var mediaUrl2 = (url) => url;
  var initMediaPlayer = (config2) => {
    if (config2.mediaUrl) {
      mediaUrl2 = config2.mediaUrl;
    }
  };
  var Mediaplayer = class extends Lightning_default.Component {
    _construct() {
      this._skipRenderToTexture = false;
      this._metrics = null;
      this._textureMode = Settings_default.get("platform", "textureMode") || false;
      Log_default.info("Texture mode: " + this._textureMode);
      console.warn(
        [
          "The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
          "Please consider using the new 'VideoPlayer'-plugin instead.",
          "https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer"
        ].join("\n\n")
      );
    }
    static _template() {
      return {
        Video: {
          VideoWrap: {
            VideoTexture: {
              visible: false,
              pivot: 0.5,
              texture: { type: Lightning_default.textures.StaticTexture, options: {} }
            }
          }
        }
      };
    }
    set skipRenderToTexture(v) {
      this._skipRenderToTexture = v;
    }
    get textureMode() {
      return this._textureMode;
    }
    get videoView() {
      return this.tag("Video");
    }
    _init() {
      const videoEls = document.getElementsByTagName("video");
      if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0];
      else {
        this.videoEl = document.createElement("video");
        this.videoEl.setAttribute("id", "video-player");
        this.videoEl.style.position = "absolute";
        this.videoEl.style.zIndex = "1";
        this.videoEl.style.display = "none";
        this.videoEl.setAttribute("width", "100%");
        this.videoEl.setAttribute("height", "100%");
        this.videoEl.style.visibility = this.textureMode ? "hidden" : "visible";
        document.body.appendChild(this.videoEl);
      }
      if (this.textureMode && !this._skipRenderToTexture) {
        this._createVideoTexture();
      }
      this.eventHandlers = [];
    }
    _registerListeners() {
      events.forEach((event) => {
        const handler = (e) => {
          if (this._metrics && this._metrics[event] && typeof this._metrics[event] === "function") {
            this._metrics[event]({ currentTime: this.videoEl.currentTime });
          }
          this.fire(event, { videoElement: this.videoEl, event: e });
        };
        this.eventHandlers.push(handler);
        this.videoEl.addEventListener(event, handler);
      });
    }
    _deregisterListeners() {
      Log_default.info("Deregistering event listeners MediaPlayer");
      events.forEach((event, index) => {
        this.videoEl.removeEventListener(event, this.eventHandlers[index]);
      });
      this.eventHandlers = [];
    }
    _attach() {
      this._registerListeners();
    }
    _detach() {
      this._deregisterListeners();
      this.close();
    }
    _createVideoTexture() {
      const stage2 = this.stage;
      const gl = stage2.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height };
    }
    _startUpdatingVideoTexture() {
      if (this.textureMode && !this._skipRenderToTexture) {
        const stage2 = this.stage;
        if (!this._updateVideoTexture) {
          this._updateVideoTexture = () => {
            if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
              const gl = stage2.gl;
              const currentTime = (/* @__PURE__ */ new Date()).getTime();
              const frameCount = this.videoEl.webkitDecodedFrameCount;
              const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
              if (mustUpdate) {
                this._lastTime = currentTime;
                this._lastFrame = frameCount;
                try {
                  gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                  this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                  this.videoTextureView.visible = true;
                  this.videoTexture.options.w = this.videoEl.videoWidth;
                  this.videoTexture.options.h = this.videoEl.videoHeight;
                  const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h;
                  const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight;
                  if (expectedAspectRatio > realAspectRatio) {
                    this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio;
                    this.videoTextureView.scaleY = 1;
                  } else {
                    this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio;
                    this.videoTextureView.scaleX = 1;
                  }
                } catch (e) {
                  Log_default.error("texImage2d video", e);
                  this._stopUpdatingVideoTexture();
                  this.videoTextureView.visible = false;
                }
                this.videoTexture.source.forceRenderUpdate();
              }
            }
          };
        }
        if (!this._updatingVideoTexture) {
          stage2.on("frameStart", this._updateVideoTexture);
          this._updatingVideoTexture = true;
        }
      }
    }
    _stopUpdatingVideoTexture() {
      if (this.textureMode) {
        const stage2 = this.stage;
        stage2.removeListener("frameStart", this._updateVideoTexture);
        this._updatingVideoTexture = false;
        this.videoTextureView.visible = false;
        if (this.videoTexture.options.source) {
          const gl = stage2.gl;
          gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
      }
    }
    updateSettings(settings2 = {}) {
      this._consumer = settings2.consumer;
      if (this._consumer && this._consumer.getMediaplayerSettings) {
        settings2 = Object.assign(settings2, this._consumer.getMediaplayerSettings());
      }
      if (!Lightning_default.Utils.equalValues(this._stream, settings2.stream)) {
        if (settings2.stream && settings2.stream.keySystem) {
          navigator.requestMediaKeySystemAccess(
            settings2.stream.keySystem.id,
            settings2.stream.keySystem.config
          ).then((keySystemAccess) => {
            return keySystemAccess.createMediaKeys();
          }).then((createdMediaKeys) => {
            return this.videoEl.setMediaKeys(createdMediaKeys);
          }).then(() => {
            if (settings2.stream && settings2.stream.src) this.open(settings2.stream.src);
          }).catch(() => {
            console.error("Failed to set up MediaKeys");
          });
        } else if (settings2.stream && settings2.stream.src) {
          if (Settings_default.get("app", "hls")) {
            if (!window.Hls) {
              window.Hls = class Hls {
                static isSupported() {
                  console.warn("hls-light not included");
                  return false;
                }
              };
            }
            if (window.Hls.isSupported()) {
              if (!this._hls) this._hls = new window.Hls({ liveDurationInfinity: true });
              this._hls.loadSource(settings2.stream.src);
              this._hls.attachMedia(this.videoEl);
              this.videoEl.style.display = "block";
            }
          } else {
            this.open(settings2.stream.src);
          }
        } else {
          this.close();
        }
        this._stream = settings2.stream;
      }
      this._setHide(settings2.hide);
      this._setVideoArea(settings2.videoPos);
    }
    _setHide(hide) {
      if (this.textureMode) {
        this.tag("Video").setSmooth("alpha", hide ? 0 : 1);
      } else {
        this.videoEl.style.visibility = hide ? "hidden" : "visible";
      }
    }
    open(url, settings2 = { hide: false, videoPosition: null }) {
      url = mediaUrl2(url);
      this._metrics = Metrics_default2.media(url);
      Log_default.info("Playing stream", url);
      if (this.application.noVideo) {
        Log_default.info("noVideo option set, so ignoring: " + url);
        return;
      }
      if (this.videoEl.getAttribute("src") === url) {
        this.close();
      }
      this.videoEl.setAttribute("src", url);
      this.videoEl.style.visibility = "hidden";
      this.videoEl.style.display = "none";
      setTimeout(() => {
        this.videoEl.style.display = "block";
        this.videoEl.style.visibility = "visible";
      });
      this._setHide(settings2.hide);
      this._setVideoArea(settings2.videoPosition || [0, 0, 1920, 1080]);
    }
    close() {
      this.videoEl.pause();
      this.videoEl.removeAttribute("src");
      this.videoEl.load();
      this._clearSrc();
      this.videoEl.style.display = "none";
    }
    playPause() {
      if (this.isPlaying()) {
        this.doPause();
      } else {
        this.doPlay();
      }
    }
    get muted() {
      return this.videoEl.muted;
    }
    set muted(v) {
      this.videoEl.muted = v;
    }
    get loop() {
      return this.videoEl.loop;
    }
    set loop(v) {
      this.videoEl.loop = v;
    }
    isPlaying() {
      return this._getState() === "Playing";
    }
    doPlay() {
      this.videoEl.play();
    }
    doPause() {
      this.videoEl.pause();
    }
    reload() {
      var url = this.videoEl.getAttribute("src");
      this.close();
      this.videoEl.src = url;
    }
    getPosition() {
      return Promise.resolve(this.videoEl.currentTime);
    }
    setPosition(pos) {
      this.videoEl.currentTime = pos;
    }
    getDuration() {
      return Promise.resolve(this.videoEl.duration);
    }
    seek(time, absolute = false) {
      if (absolute) {
        this.videoEl.currentTime = time;
      } else {
        this.videoEl.currentTime += time;
      }
    }
    get videoTextureView() {
      return this.tag("Video").tag("VideoTexture");
    }
    get videoTexture() {
      return this.videoTextureView.texture;
    }
    _setVideoArea(videoPos) {
      if (Lightning_default.Utils.equalValues(this._videoPos, videoPos)) {
        return;
      }
      this._videoPos = videoPos;
      if (this.textureMode) {
        this.videoTextureView.patch({
          smooth: {
            x: videoPos[0],
            y: videoPos[1],
            w: videoPos[2] - videoPos[0],
            h: videoPos[3] - videoPos[1]
          }
        });
      } else {
        const precision2 = this.stage.getRenderPrecision();
        this.videoEl.style.left = Math.round(videoPos[0] * precision2) + "px";
        this.videoEl.style.top = Math.round(videoPos[1] * precision2) + "px";
        this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision2) + "px";
        this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision2) + "px";
      }
    }
    _fireConsumer(event, args) {
      if (this._consumer) {
        this._consumer.fire(event, args);
      }
    }
    _equalInitData(buf1, buf2) {
      if (!buf1 || !buf2) return false;
      if (buf1.byteLength != buf2.byteLength) return false;
      const dv1 = new Int8Array(buf1);
      const dv2 = new Int8Array(buf2);
      for (let i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false;
      return true;
    }
    error(args) {
      this._fireConsumer("$mediaplayerError", args);
      this._setState("");
      return "";
    }
    loadeddata(args) {
      this._fireConsumer("$mediaplayerLoadedData", args);
    }
    play(args) {
      this._fireConsumer("$mediaplayerPlay", args);
    }
    playing(args) {
      this._fireConsumer("$mediaplayerPlaying", args);
      this._setState("Playing");
    }
    canplay(args) {
      this.videoEl.play();
      this._fireConsumer("$mediaplayerStart", args);
    }
    loadstart(args) {
      this._fireConsumer("$mediaplayerLoad", args);
    }
    seeked() {
      this._fireConsumer("$mediaplayerSeeked", {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1
      });
    }
    seeking() {
      this._fireConsumer("$mediaplayerSeeking", {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1
      });
    }
    durationchange(args) {
      this._fireConsumer("$mediaplayerDurationChange", args);
    }
    encrypted(args) {
      const video = args.videoElement;
      const event = args.event;
      if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
        this._previousInitData = event.initData;
        this._fireConsumer("$mediaplayerEncrypted", args);
      }
    }
    static _states() {
      return [
        class Playing extends this {
          $enter() {
            this._startUpdatingVideoTexture();
          }
          $exit() {
            this._stopUpdatingVideoTexture();
          }
          timeupdate() {
            this._fireConsumer("$mediaplayerProgress", {
              currentTime: this.videoEl.currentTime,
              duration: this.videoEl.duration || 1
            });
          }
          ended(args) {
            this._fireConsumer("$mediaplayerEnded", args);
            this._setState("");
          }
          pause(args) {
            this._fireConsumer("$mediaplayerPause", args);
            this._setState("Playing.Paused");
          }
          _clearSrc() {
            this._fireConsumer("$mediaplayerStop", {});
            this._setState("");
          }
          static _states() {
            return [class Paused extends this {
            }];
          }
        }
      ];
    }
  };

  // node_modules/localcookies/module/localCookie.js
  var localCookie = class {
    constructor(e) {
      return e = e || {}, this.forceCookies = e.forceCookies || false, true === this._checkIfLocalStorageWorks() && true !== e.forceCookies ? { getItem: this._getItemLocalStorage, setItem: this._setItemLocalStorage, removeItem: this._removeItemLocalStorage, clear: this._clearLocalStorage, keys: this._getLocalStorageKeys } : { getItem: this._getItemCookie, setItem: this._setItemCookie, removeItem: this._removeItemCookie, clear: this._clearCookies, keys: this._getCookieKeys };
    }
    _checkIfLocalStorageWorks() {
      if ("undefined" == typeof localStorage) return false;
      try {
        return localStorage.setItem("feature_test", "yes"), "yes" === localStorage.getItem("feature_test") && (localStorage.removeItem("feature_test"), true);
      } catch (e) {
        return false;
      }
    }
    _getItemLocalStorage(e) {
      return window.localStorage.getItem(e);
    }
    _setItemLocalStorage(e, t) {
      return window.localStorage.setItem(e, t);
    }
    _removeItemLocalStorage(e) {
      return window.localStorage.removeItem(e);
    }
    _clearLocalStorage() {
      return window.localStorage.clear();
    }
    _getLocalStorageKeys() {
      return Object.keys(window.localStorage);
    }
    _getItemCookie(e) {
      var t = document.cookie.match(RegExp("(?:^|;\\s*)" + (function(e2) {
        return e2.replace(/([.*+?\^${}()|\[\]\/\\])/g, "\\$1");
      })(e) + "=([^;]*)"));
      return t && "" === t[1] && (t[1] = null), t ? t[1] : null;
    }
    _setItemCookie(e, t) {
      var o = /* @__PURE__ */ new Date(), r = new Date(o.getTime() + 15768e7);
      document.cookie = `${e}=${t}; expires=${r.toUTCString()};`;
    }
    _removeItemCookie(e) {
      document.cookie = `${e}=;Max-Age=-99999999;`;
    }
    _clearCookies() {
      document.cookie.split(";").forEach((e) => {
        document.cookie = e.replace(/^ +/, "").replace(/=.*/, "=;expires=Max-Age=-99999999");
      });
    }
    _getCookieKeys() {
      return document.cookie.split(";").map((e) => e.split("=")[0]);
    }
  };
  var localCookie_default = localCookie;

  // node_modules/@lightningjs/sdk/src/Storage/index.js
  var namespace;
  var lc;
  var initStorage = () => {
    namespace = Settings_default.get("platform", "id");
    lc = new localCookie_default();
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/regex.js
  var hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g;
  var isWildcard = /^[!*$]$/;
  var hasLookupId = /\/:\w+?@@([0-9]+?)@@/;
  var isNamedGroup = /^\/:/;
  var stripRegex = (route, char = "R") => {
    if (hasRegex.test(route)) {
      route = route.replace(hasRegex, char);
    }
    return route;
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/register.js
  var createRegister = (flags) => {
    const reg = /* @__PURE__ */ new Map();
    [...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach((key) => {
      reg.set(key, flags[key]);
    });
    return reg;
  };

  // node_modules/@lightningjs/sdk/src/Router/model/Request.js
  var Request2 = class {
    constructor(hash = "", navArgs, storeCaller) {
      this._hash = hash;
      this._storeCaller = storeCaller;
      this._register = /* @__PURE__ */ new Map();
      this._isCreated = false;
      this._isSharedInstance = false;
      this._cancelled = false;
      this._copiedHistoryState = null;
      if (isObject3(navArgs)) {
        this._register = createRegister(navArgs);
      } else if (isBoolean(navArgs)) {
        this._storeCaller = navArgs;
      }
      this._register.set(symbols.store, this._storeCaller);
    }
    cancel() {
      Log_default.debug("[router]:", `cancelled ${this._hash}`);
      this._cancelled = true;
    }
    get url() {
      return this._hash;
    }
    get register() {
      return this._register;
    }
    get hash() {
      return this._hash;
    }
    set hash(args) {
      this._hash = args;
    }
    get route() {
      return this._route;
    }
    set route(args) {
      this._route = args;
    }
    get provider() {
      return this._provider;
    }
    set provider(args) {
      this._provider = args;
    }
    get providerType() {
      return this._providerType;
    }
    set providerType(args) {
      this._providerType = args;
    }
    set page(args) {
      this._page = args;
    }
    get page() {
      return this._page;
    }
    set isCreated(args) {
      this._isCreated = args;
    }
    get isCreated() {
      return this._isCreated;
    }
    get isSharedInstance() {
      return this._isSharedInstance;
    }
    set isSharedInstance(args) {
      this._isSharedInstance = args;
    }
    get isCancelled() {
      return this._cancelled;
    }
    set copiedHistoryState(v) {
      this._copiedHistoryState = v;
    }
    get copiedHistoryState() {
      return this._copiedHistoryState;
    }
  };

  // node_modules/@lightningjs/sdk/src/Router/model/Route.js
  var Route = class {
    constructor(config2 = {}) {
      let type = ["on", "before", "after"].reduce((acc, type2) => {
        return isFunction(config2[type2]) ? type2 : acc;
      }, void 0);
      this._cfg = config2;
      if (type) {
        this._provider = {
          type,
          request: config2[type]
        };
      }
    }
    get path() {
      return this._cfg.path;
    }
    get name() {
      return this._cfg.name;
    }
    get component() {
      return this._cfg.component;
    }
    get options() {
      return this._cfg.options;
    }
    get widgets() {
      return this._cfg.widgets;
    }
    get cache() {
      return this._cfg.cache;
    }
    get hook() {
      return this._cfg.hook;
    }
    get beforeNavigate() {
      return this._cfg.beforeNavigate;
    }
    get provider() {
      return this._provider;
    }
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/route.js
  var getFloor = (route) => {
    return stripRegex(route).split("/").length;
  };
  var getRoutesByFloor = (floor) => {
    const matches = [];
    for (let [route] of routes.entries()) {
      if (getFloor(route) === floor) {
        matches.push(route);
      }
    }
    return matches;
  };
  var getRouteByHash = (hash) => {
    hash = hash.replace(/^#/, "");
    const getUrlParts = /(\/?:?[^/]+)/g;
    const candidates = getRoutesByFloor(getFloor(hash));
    const hashParts = hash.match(getUrlParts) || [];
    let regexStore = [];
    let matches = candidates.filter((route) => {
      let isMatching = true;
      if (hasRegex.test(route)) {
        const regMatches = route.match(hasRegex);
        if (regMatches && regMatches.length) {
          route = regMatches.reduce((fullRoute, regex) => {
            const lookupId = regexStore.length;
            fullRoute = fullRoute.replace(regex, `@@${lookupId}@@`);
            regexStore.push(regex.substring(1, regex.length - 1));
            return fullRoute;
          }, route);
        }
      }
      const routeParts = route.match(getUrlParts) || [];
      for (let i = 0, j = routeParts.length; i < j; i++) {
        const routePart = routeParts[i];
        const hashPart = hashParts[i];
        if (hasLookupId.test(routePart)) {
          const routeMatches = hasLookupId.exec(routePart);
          const storeId = routeMatches[1];
          const routeRegex = regexStore[storeId];
          const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex);
          if (regMatches && regMatches.length) {
            const expression = regMatches[1];
            const modifiers = regMatches[2];
            const regex = new RegExp(`^/${expression}$`, modifiers);
            if (!regex.test(hashPart)) {
              isMatching = false;
            }
          }
        } else if (isNamedGroup.test(routePart)) {
          continue;
        } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
          isMatching = false;
        }
      }
      return isMatching;
    });
    if (matches.length) {
      if (matches.indexOf(hash) !== -1) {
        const match = matches[matches.indexOf(hash)];
        return routes.get(match);
      } else {
        matches = matches.sort((a) => {
          return isNamedGroup.test(a) ? -1 : 1;
        });
        if (routeExists(matches[0])) {
          return routes.get(matches[0]);
        }
      }
    }
    return false;
  };
  var getValuesFromHash = (hash = "", path) => {
    path = stripRegex(path, "");
    const getUrlParts = /(\/?:?[\w%\s:.-]+)/g;
    const hashParts = hash.match(getUrlParts) || [];
    const routeParts = path.match(getUrlParts) || [];
    const getNamedGroup = /^\/:([\w-]+)\/?/;
    return routeParts.reduce((storage, value, index) => {
      const match = getNamedGroup.exec(value);
      if (match && match.length) {
        storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, "")));
      }
      return storage;
    }, /* @__PURE__ */ new Map());
  };
  var getOption = (stack, prop) => {
    if (stack && stack.hasOwnProperty(prop)) {
      return stack[prop];
    }
  };
  var createRoute = (config2) => {
    if (config2.path === "$") {
      let options = {
        preventStorage: true
      };
      if (isObject3(config2.options)) {
        options = __spreadValues(__spreadValues({}, config2.options), options);
      }
      config2.options = options;
      if (bootRequest) {
        config2.after = bootRequest;
      }
    }
    return new Route(config2);
  };
  var createRequest = (url, args, store) => {
    return new Request2(url, args, store);
  };
  var getHashByName = (obj) => {
    if (!obj.to && !obj.name) {
      return false;
    }
    const route = getRouteByName(obj.to || obj.name);
    const hasDynamicGroup = /\/:([\w-]+)\/?/;
    let hash = route;
    if (hasDynamicGroup.test(route)) {
      if (obj.params) {
        const keys = Object.keys(obj.params);
        hash = keys.reduce((acc, key) => {
          return acc.replace(`:${key}`, obj.params[key]);
        }, route);
      }
      if (obj.query) {
        return `${hash}${objectToQueryString(obj.query)}`;
      }
    }
    return hash;
  };
  var getRouteByName = (name) => {
    for (let [path, route] of routes.entries()) {
      if (route.name === name) {
        return path;
      }
    }
    return false;
  };
  var keepActivePageAlive = (route, request) => {
    if (isString2(route)) {
      const routes2 = getRoutes();
      if (routes2.has(route)) {
        route = routes2.get(route);
      } else {
        return false;
      }
    }
    const register = request.register;
    const routeOptions = route.options;
    if (register.has("keepAlive")) {
      return register.get("keepAlive");
    } else if (routeOptions && routeOptions.keepAlive) {
      return routeOptions.keepAlive;
    }
    return false;
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/emit.js
  var emit_default = (page, events2 = [], params = {}) => {
    if (!isArray(events2)) {
      events2 = [events2];
    }
    events2.forEach((e) => {
      const event = `_on${ucfirst(e)}`;
      if (isFunction(page[event])) {
        page[event](params);
      }
    });
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/widgets.js
  var activeWidget = null;
  var getReferences = () => {
    if (!widgetsHost) {
      return;
    }
    return widgetsHost.get().reduce((storage, widget) => {
      const key = widget.ref.toLowerCase();
      storage[key] = widget;
      return storage;
    }, {});
  };
  var updateWidgets = (widgets, page) => {
    const configured = (widgets || []).map((ref) => ref.toLowerCase());
    widgetsHost.forEach((widget) => {
      widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1;
      if (widget.visible) {
        emit_default(widget, ["activated"], page);
      }
    });
    if (app.state === "Widgets" && activeWidget && !activeWidget.visible) {
      app._setState("");
    }
  };
  var getWidgetByName = (name) => {
    name = ucfirst(name);
    return widgetsHost.getByRef(name) || false;
  };
  var focusWidget = (name) => {
    const widget = getWidgetByName(name);
    if (widget) {
      setActiveWidget(widget);
      if (app.state === "Widgets") {
        app.reload(activeWidget);
      } else {
        app._setState("Widgets", [activeWidget]);
      }
    }
  };
  var restoreFocus = () => {
    activeWidget = null;
    app._setState("");
  };
  var getActiveWidget = () => {
    return activeWidget;
  };
  var setActiveWidget = (instance) => {
    activeWidget = instance;
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/components.js
  var createComponent = (stage2, type) => {
    return stage2.c({
      type,
      visible: false,
      widgets: getReferences()
    });
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/history.js
  var history = [];
  var updateHistory = (request) => {
    const hash = getActiveHash();
    if (!hash) {
      return;
    }
    const register = request.register;
    const forceNavigateStore = register.get(symbols.store);
    const activeRoute2 = getRouteByHash(hash);
    const preventStorage = getOption(activeRoute2.options, "preventStorage");
    let store = isBoolean(forceNavigateStore) ? forceNavigateStore : !preventStorage;
    if (store) {
      const toStore = hash.replace(/^\//, "");
      const location = locationInHistory(toStore);
      const stateObject = getStateObject(getActivePage(), request);
      const routerConfig2 = getRouterConfig();
      if (location === -1 || routerConfig2.get("storeSameHash")) {
        history.push({ hash: toStore, state: stateObject });
      } else {
        const prev = history.splice(location, 1)[0];
        history.push({ hash: prev.hash, state: stateObject });
      }
    }
  };
  var locationInHistory = (hash) => {
    for (let i = 0; i < history.length; i++) {
      if (history[i].hash === hash) {
        return i;
      }
    }
    return -1;
  };
  var getHistoryState = (hash) => {
    let state3 = null;
    if (history.length) {
      if (!hash) {
        const record = history[history.length - 1];
        state3 = record.state;
      } else {
        if (locationInHistory(hash) !== -1) {
          const record = history[locationInHistory(hash)];
          state3 = record.state;
        }
      }
    }
    return state3;
  };
  var replaceHistoryState = (state3 = null, hash) => {
    if (!history.length) {
      return;
    }
    const location = hash ? locationInHistory(hash) : history.length - 1;
    if (location !== -1 && isObject3(state3)) {
      history[location].state = state3;
    }
  };
  var getStateObject = (page, request) => {
    if (request.isSharedInstance) {
      if (request.copiedHistoryState) {
        return request.copiedHistoryState;
      }
    } else if (page && isFunction(page.historyState)) {
      return page.historyState();
    }
    return null;
  };
  var getHistory = () => {
    return history.slice(0);
  };
  var setHistory = (arr = []) => {
    if (isArray(arr)) {
      history = arr;
    }
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/router.js
  var application;
  var app;
  var pagesHost;
  var stage;
  var routerConfig;
  var widgetsHost;
  var rootHash;
  var bootRequest;
  var updateHash = true;
  var beforeEachRoute = (from, to) => __async(null, null, function* () {
    return true;
  });
  var afterEachRoute = () => {
  };
  var routes = /* @__PURE__ */ new Map();
  var components = /* @__PURE__ */ new Map();
  var initialised = false;
  var activePage = null;
  var activeHash;
  var activeRoute;
  var lastAcceptedHash;
  var previousState;
  var mixin = (app2) => {
    if (app2.pages) {
      pagesHost = app2.pages.childList;
    }
    if (app2.widgets && app2.widgets.children) {
      widgetsHost = app2.widgets.childList;
      widgetsHost.forEach((w) => w.visible = false);
    }
    app2._handleBack = (e) => {
      step(-1);
      e.preventDefault();
    };
  };
  var bootRouter = (config2, instance) => {
    let { appInstance, routes: routes2 } = config2;
    if (instance && isPage(instance)) {
      app = instance;
    }
    if (!app) {
      app = appInstance || AppInstance;
    }
    application = app.application;
    pagesHost = application.childList;
    stage = app.stage;
    routerConfig = getConfigMap();
    mixin(app);
    if (isArray(routes2)) {
      setup(config2);
    } else if (isFunction(routes2)) {
      console.warn("[Router]: Calling Router.route() directly is deprecated.");
      console.warn(
        "Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration"
      );
    }
  };
  var setup = (config2) => {
    if (!initialised) {
      init(config2);
    }
    config2.routes.forEach((r) => {
      const path = cleanHash(r.path);
      if (!routeExists(path)) {
        const route = createRoute(r);
        routes.set(path, route);
        if (route.component) {
          let type = route.component;
          if (isComponentConstructor(type)) {
            if (!routerConfig.get("lazyCreate")) {
              type = createComponent(stage, type);
              pagesHost.a(type);
            }
          }
          components.set(path, type);
        }
      } else {
        console.error(`${path} already exists in routes configuration`);
      }
    });
  };
  var init = (config2) => {
    rootHash = config2.root;
    if (isFunction(config2.boot)) {
      bootRequest = config2.boot;
    }
    if (isBoolean(config2.updateHash)) {
      updateHash = config2.updateHash;
    }
    if (isFunction(config2.beforeEachRoute)) {
      beforeEachRoute = config2.beforeEachRoute;
    }
    if (isFunction(config2.afterEachRoute)) {
      afterEachRoute = config2.afterEachRoute;
    }
    if (config2.bootComponent) {
      console.warn(
        "[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes"
      );
      console.warn(
        "[Router]: setting { bootComponent } property will be deprecated in a future release"
      );
      if (isPage(config2.bootComponent)) {
        config2.routes.push({
          path: "$",
          component: config2.bootComponent,
          // we try to assign the bootRequest as after data-provider
          // so it will behave as any other component
          after: bootRequest || null,
          options: {
            preventStorage: true
          }
        });
      } else {
        console.error(`[Router]: ${config2.bootComponent} is not a valid boot component`);
      }
    }
    config2.routes.forEach((item) => {
      const strippedPath = stripRegex(item.path);
      const pattern = /.*\/:.*?\?$/u;
      if (pattern.test(strippedPath)) {
        const optionalPath = item.path.substring(0, item.path.lastIndexOf("/"));
        const originalPath = item.path.substring(0, item.path.lastIndexOf("?"));
        item.path = originalPath;
        let optionalItem = __spreadValues({}, item);
        optionalItem.path = optionalPath;
        config2.routes.push(optionalItem);
      }
    });
    initialised = true;
  };
  var storeComponent = (route, type) => {
    if (components.has(route)) {
      components.set(route, type);
    }
  };
  var getComponent = (route) => {
    if (components.has(route)) {
      return components.get(route);
    }
    return null;
  };
  var deleteCurrentInstance = (route) => {
    if (components.has(route) && pagesHost.getIndex(components.get(route)) !== -1) {
      pagesHost.remove(components.get(route));
      storeComponent(route, components.get(route)._routedType || components.get(route).constructor);
    }
  };
  var mustUpdateLocationHash = () => {
    if (!routerConfig || !routerConfig.size) {
      return false;
    }
    const updateConfig = routerConfig.get("updateHash");
    return !(isBoolean(updateConfig) && !updateConfig || isBoolean(updateHash) && !updateHash);
  };
  var onRequestResolved = (request) => {
    const hash = request.hash;
    const route = request.route;
    const register = request.register;
    const page = request.page;
    if (getOption(route.options, "clearHistory")) {
      setHistory([]);
    } else if (hash && !isWildcard.test(route.path)) {
      updateHistory(request);
    }
    storeComponent(route.path, page);
    if (request.isSharedInstance || !request.isCreated) {
      emit_default(page, "changed");
    } else if (request.isCreated) {
      emit_default(page, "mounted");
    }
    if (widgetsHost) {
      updateWidgets(route.widgets, page);
    }
    if (getActivePage() && !request.isSharedInstance) {
      cleanUp(activePage, request);
    }
    if (register.get(symbols.historyState) && isFunction(page.historyState)) {
      page.historyState(register.get(symbols.historyState));
    }
    setActivePage(page);
    activeHash = request.hash;
    activeRoute = route.path;
    for (let request2 of navigateQueue.values()) {
      if (request2.isCancelled && request2.hash) {
        navigateQueue.delete(request2.hash);
      }
    }
    afterEachRoute(request);
    Log_default.info("[route]:", route.path);
    Log_default.info("[hash]:", hash);
  };
  var cleanUp = (page, request) => {
    const route = activeRoute;
    const register = request.register;
    const lazyDestroy = routerConfig.get("lazyDestroy");
    const destroyOnBack = routerConfig.get("destroyOnHistoryBack");
    const keepAlive = register.get("keepAlive");
    const isFromHistory = register.get(symbols.backtrack);
    let doCleanup = false;
    if (isFromHistory && (destroyOnBack || lazyDestroy)) {
      doCleanup = true;
    }
    if (lazyDestroy && !keepAlive) {
      doCleanup = true;
    }
    if (activeRoute === request.route.path) {
      doCleanup = true;
    }
    if (doCleanup) {
      storeComponent(route, page._routedType || page.constructor);
      pagesHost.remove(page);
      if (routerConfig.get("gcOnUnload")) {
        stage.gc();
      }
    } else {
      page.patch({
        x: 0,
        y: 0,
        scale: 1,
        visible: false,
        alpha: 1
      });
    }
  };
  var getActiveHash = () => {
    return activeHash;
  };
  var setActivePage = (page) => {
    activePage = page;
  };
  var getActivePage = () => {
    return activePage;
  };
  var getActiveRoute = () => {
    return activeRoute;
  };
  var getLastHash = () => {
    return lastAcceptedHash;
  };
  var setLastHash = (hash) => {
    lastAcceptedHash = hash;
  };
  var setPreviousState = (state3) => {
    previousState = state3;
  };
  var getPreviousState = () => {
    return previousState;
  };
  var routeExists = (key) => {
    return routes.has(key);
  };
  var getRootHash = () => {
    return rootHash;
  };
  var getBootRequest = () => {
    return bootRequest;
  };
  var getRouterConfig = () => {
    return routerConfig;
  };
  var getRoutes = () => {
    return routes;
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/helpers.js
  var isFunction = (v) => {
    return typeof v === "function";
  };
  var isObject3 = (v) => {
    return typeof v === "object" && v !== null;
  };
  var isBoolean = (v) => {
    return typeof v === "boolean";
  };
  var isPage = (v) => {
    if (v instanceof Lightning_default.Element || isComponentConstructor(v)) {
      return true;
    }
    return false;
  };
  var isComponentConstructor = (type) => {
    return type.prototype && "isComponent" in type.prototype;
  };
  var isArray = (v) => {
    return Array.isArray(v);
  };
  var ucfirst = (v) => {
    return `${v.charAt(0).toUpperCase()}${v.slice(1)}`;
  };
  var isString2 = (v) => {
    return typeof v === "string";
  };
  var isPromise = (method) => {
    let result;
    if (isFunction(method)) {
      try {
        result = method.apply(null);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }
    return isObject3(result) && isFunction(result.then);
  };
  var cleanHash = (hash = "") => {
    return hash.replace(/^#/, "").replace(/\/+$/, "");
  };
  var getConfigMap = () => {
    const routerSettings = Settings_default.get("platform", "router");
    const isObj = isObject3(routerSettings);
    return [
      "backtrack",
      "gcOnUnload",
      "destroyOnHistoryBack",
      "lazyCreate",
      "lazyDestroy",
      "reuseInstance",
      "autoRestoreRemote",
      "numberNavigation",
      "updateHash",
      "storeSameHash"
    ].reduce((config2, key) => {
      config2.set(key, isObj ? routerSettings[key] : Settings_default.get("platform", key));
      return config2;
    }, /* @__PURE__ */ new Map());
  };
  var getQueryStringParams = (hash = getActiveHash()) => {
    const resumeHash2 = getResumeHash();
    if ((hash === "$" || !hash) && resumeHash2) {
      if (isString2(resumeHash2)) {
        hash = resumeHash2;
      }
    }
    let parse = "";
    const getQuery = /([?&].*)/;
    const matches = getQuery.exec(hash);
    const params = {};
    if (document.location && document.location.search) {
      parse = document.location.search;
    }
    if (matches && matches.length) {
      let hashParams = matches[1];
      if (parse) {
        hashParams = hashParams.replace(/^\?/, "");
        parse = `${parse}&${hashParams}`;
      } else {
        parse = hashParams;
      }
    }
    if (parse) {
      const urlParams = new URLSearchParams(parse);
      for (const [key, value] of urlParams.entries()) {
        params[key] = value;
      }
      return params;
    } else {
      return false;
    }
  };
  var objectToQueryString = (obj) => {
    if (!isObject3(obj)) {
      return "";
    }
    return "?" + Object.keys(obj).map((key) => {
      return `${key}=${obj[key]}`;
    }).join("&");
  };
  var symbols = {
    route: Symbol("route"),
    hash: Symbol("hash"),
    store: Symbol("store"),
    fromHistory: Symbol("fromHistory"),
    expires: Symbol("expires"),
    resume: Symbol("resume"),
    backtrack: Symbol("backtrack"),
    historyState: Symbol("historyState"),
    queryParams: Symbol("queryParams")
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/provider.js
  var dataHooks = {
    on: (request) => {
      setPreviousState(app.state || "");
      app._setState("Loading");
      return execProvider(request);
    },
    before: (request) => {
      return execProvider(request);
    },
    after: (request) => {
      try {
        execProvider(request, true);
      } catch (e) {
      }
      return Promise.resolve();
    }
  };
  var execProvider = (request, emitProvided) => {
    const route = request.route;
    const provider = route.provider;
    const expires = route.cache ? route.cache * 1e3 : 0;
    const params = addPersistData(request);
    return provider.request(request.page, __spreadValues({}, params)).then(() => {
      request.page[symbols.expires] = Date.now() + expires;
      if (emitProvided) {
        emit_default(request.page, "dataProvided");
      }
    }).catch((e) => {
      request.page[symbols.expires] = Date.now();
      throw e;
    });
  };
  var addPersistData = ({ page, route, hash, register = /* @__PURE__ */ new Map() }) => {
    const urlValues = getValuesFromHash(hash, route.path);
    const queryParams = getQueryStringParams(hash);
    const pageData = new Map([...urlValues, ...register]);
    const params = {};
    for (let [name, value] of pageData) {
      params[name] = value;
    }
    if (queryParams) {
      params[symbols.queryParams] = queryParams;
    }
    if (register.size) {
      const obj = {};
      for (let [k, v] of register) {
        obj[k] = v;
      }
      page.persist = obj;
    }
    page.params = params;
    emit_default(page, ["urlParams"], params);
    return params;
  };
  var isPageExpired = (page) => {
    if (!page[symbols.expires]) {
      return false;
    }
    const expires = page[symbols.expires];
    const now = Date.now();
    return now >= expires;
  };
  var hasProvider = (path) => {
    if (routeExists(path)) {
      const record = routes.get(path);
      return !!record.provider;
    }
    return false;
  };
  var getProvider = (route) => {
    if (routeExists(route.path)) {
      const { provider } = routes.get(route.path);
      return {
        type: provider.type,
        provider: provider.request
      };
    }
  };

  // node_modules/@lightningjs/sdk/src/Router/transitions.js
  var fade = (i, o) => {
    return new Promise((resolve) => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, { duration: 0.5, delay: 0.1 }]
        }
      });
      i.transition("alpha").on("finish", () => {
        if (o) {
          o.visible = false;
        }
        resolve();
      });
    });
  };
  var crossFade = (i, o) => {
    return new Promise((resolve) => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, { duration: 0.5, delay: 0.1 }]
        }
      });
      if (o) {
        o.patch({
          smooth: {
            alpha: [0, { duration: 0.5, delay: 0.3 }]
          }
        });
      }
      i.transition("alpha").on("finish", () => {
        resolve();
      });
    });
  };
  var moveOnAxes = (axis, direction, i, o) => {
    const bounds = axis === "x" ? 1920 : 1080;
    return new Promise((resolve) => {
      i.patch({
        [`${axis}`]: direction ? bounds * -1 : bounds,
        visible: true,
        smooth: {
          [`${axis}`]: [0, { duration: 0.4, delay: 0.2 }]
        }
      });
      if (o) {
        o.patch({
          [`${axis}`]: 0,
          smooth: {
            [`${axis}`]: [direction ? bounds : bounds * -1, { duration: 0.4, delay: 0.2 }]
          }
        });
      }
      i.transition(axis).on("finish", () => {
        resolve();
      });
    });
  };
  var up = (i, o) => {
    return moveOnAxes("y", 0, i, o);
  };
  var down = (i, o) => {
    return moveOnAxes("y", 1, i, o);
  };
  var left = (i, o) => {
    return moveOnAxes("x", 0, i, o);
  };
  var right = (i, o) => {
    return moveOnAxes("x", 1, i, o);
  };
  var transitions_default = {
    fade,
    crossFade,
    up,
    down,
    left,
    right
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/transition.js
  var executeTransition = (pageIn, pageOut = null) => {
    const transition = pageIn.pageTransition || pageIn.easing;
    const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition);
    const transitionsDisabled = getRouterConfig().get("disableTransitions");
    if (pageIn.easing) {
      console.warn("easing() method is deprecated and will be removed. Use pageTransition()");
    }
    if (!hasCustomTransitions || transitionsDisabled) {
      pageIn.visible = true;
      if (pageOut) {
        pageOut.visible = false;
      }
      return Promise.resolve();
    }
    if (transition) {
      let type;
      try {
        type = transition.call(pageIn, pageIn, pageOut);
      } catch (e) {
        type = "crossFade";
      }
      if (isPromise(type)) {
        return type;
      }
      if (isString2(type)) {
        const fn = transitions_default[type];
        if (fn) {
          return fn(pageIn, pageOut);
        }
      }
      if (pageIn.smoothIn) {
        const smooth = (p, v, args = {}) => {
          return new Promise((resolve) => {
            pageIn.visible = true;
            pageIn.setSmooth(p, v, args);
            pageIn.transition(p).on("finish", () => {
              resolve();
            });
          });
        };
        return pageIn.smoothIn({ pageIn, smooth });
      }
    }
    return transitions_default.crossFade(pageIn, pageOut);
  };

  // node_modules/@lightningjs/sdk/src/Router/utils/loader.js
  var load = (request) => __async(null, null, function* () {
    let expired = false;
    try {
      request = yield loader2(request);
      if (request && !request.isCancelled) {
        if (app.state === "Loading") {
          if (getPreviousState() === "Widgets") {
            app._setState("Widgets", [getActiveWidget()]);
          } else {
            app._setState("");
          }
        }
        if (!request.isSharedInstance && !request.isCancelled) {
          yield executeTransition(request.page, getActivePage());
        }
      } else {
        expired = true;
      }
      if (expired || request.isCancelled) {
        Log_default.debug("[router]:", `Rejected ${request.hash} because route to ${getLastHash()} started`);
        if (request.isCreated && !request.isSharedInstance) {
          pagesHost.remove(request.page);
        }
      } else {
        onRequestResolved(request);
        return request.page;
      }
    } catch (request2) {
      if (!request2.route) {
        console.error(request2);
      } else if (!expired) {
        const { route } = request2;
        if (getOption(route.options, "clearHistory")) {
          setHistory([]);
        } else if (!isWildcard.test(route.path)) {
          updateHistory(request2);
        }
        if (request2.isCreated && !request2.isSharedInstance) {
          pagesHost.remove(request2.page);
        }
        handleError(request2);
      }
    }
  });
  var loader2 = (request) => __async(null, null, function* () {
    const route = request.route;
    const hash = request.hash;
    const register = request.register;
    let type = getComponent(route.path);
    let isConstruct = isComponentConstructor(type);
    let provide = false;
    if (!isConstruct && !register.get(symbols.backtrack)) {
      if (!mustReuse(route)) {
        type = type.constructor;
        isConstruct = true;
      }
    }
    if (!isConstruct) {
      request.page = type;
      if (hasProvider(route.path)) {
        if (isPageExpired(type) || type[symbols.hash] !== hash) {
          provide = true;
        }
      }
      let currentRoute = getActivePage() && getActivePage()[symbols.route];
      if (route.path === currentRoute) {
        request.isSharedInstance = true;
        if (isFunction(request.page.historyState)) {
          request.copiedHistoryState = request.page.historyState();
        }
      }
    } else {
      request.page = createComponent(stage, type);
      pagesHost.a(request.page);
      if (hasProvider(route.path)) {
        provide = true;
      }
      request.isCreated = true;
    }
    request.page[symbols.hash] = hash;
    request.page[symbols.route] = route.path;
    try {
      if (provide) {
        const { type: loadType, provider } = getProvider(route);
        request.provider = provider;
        request.providerType = loadType;
        yield dataHooks[loadType](request);
        if (hash !== getLastHash()) {
          return false;
        } else {
          if (request.providerType !== "after") {
            emit_default(request.page, "dataProvided");
          }
          return request;
        }
      } else {
        addPersistData(request);
        return request;
      }
    } catch (e) {
      request.error = e;
      return Promise.reject(request);
    }
  });
  var handleError = (request) => {
    if (request && request.error) {
      console.error(request.error);
    } else if (request) {
      Log_default.error(request);
    }
    if (request.page && routeExists("!")) {
      navigate("!", { request }, false);
    }
  };
  var mustReuse = (route) => {
    const opt = getOption(route.options, "reuseInstance");
    const config2 = routerConfig.get("reuseInstance");
    if (isBoolean(opt)) {
      return opt;
    }
    return !(isBoolean(config2) && config2 === false);
  };

  // node_modules/@lightningjs/sdk/src/Router/base.js
  var RoutedApp = class extends Lightning_default.Component {
    static _template() {
      return {
        Pages: {
          forceZIndexContext: true
        },
        /**
         * This is a default Loading page that will be made visible
         * during data-provider on() you CAN override in child-class
         */
        Loading: {
          rect: true,
          w: 1920,
          h: 1080,
          color: 4278190080,
          visible: false,
          zIndex: 99,
          Label: {
            mount: 0.5,
            x: 960,
            y: 540,
            text: {
              text: "Loading.."
            }
          }
        }
      };
    }
    static _states() {
      return [
        class Loading extends this {
          $enter() {
            this.tag("Loading").visible = true;
          }
          $exit() {
            this.tag("Loading").visible = false;
          }
        },
        class Widgets extends this {
          $enter(args, widget) {
            this._widget = widget;
            this._refocus();
          }
          _getFocused() {
            return this._widget;
          }
          // if we want to widget to widget focus delegation
          reload(widget) {
            this._widget = widget;
            this._refocus();
          }
          _handleKey() {
            const restoreFocus2 = routerConfig.get("autoRestoreRemote");
            if (!isBoolean(restoreFocus2) || restoreFocus2 === true) {
              Router_default.focusPage();
            }
          }
        }
      ];
    }
    /**
     * Return location where pages need to be stored
     */
    get pages() {
      return this.tag("Pages");
    }
    /**
     * Tell router where widgets are stored
     */
    get widgets() {
      return this.tag("Widgets");
    }
    /**
     * we MUST register _handleBack method so the Router
     * can override it
     * @private
     */
    _handleBack() {
    }
    /**
     * We MUST return Router.activePage() so the new Page
     * can listen to the remote-control.
     */
    _getFocused() {
      return Router_default.getActivePage();
    }
  };

  // node_modules/@lightningjs/sdk/src/Router/index.js
  var navigateQueue = /* @__PURE__ */ new Map();
  var forcedHash = "";
  var resumeHash = "";
  var startRouter = (config2, instance) => {
    bootRouter(config2, instance);
    registerListener();
    start();
  };
  var start = () => {
    let hash = (getHash() || "").replace(/^#/, "");
    const bootKey = "$";
    const params = getQueryStringParams(hash);
    const bootRequest2 = getBootRequest();
    const rootHash2 = getRootHash();
    const isDirectLoad = hash.indexOf(bootKey) !== -1;
    if (isWildcard.test(hash) && hash !== bootKey) {
      hash = "";
    }
    resumeHash = isDirectLoad ? rootHash2 : hash || rootHash2;
    const ready = () => {
      if (!hash && rootHash2) {
        if (isString2(rootHash2)) {
          navigate(rootHash2);
        } else if (isFunction(rootHash2)) {
          rootHash2().then((res) => {
            if (isObject3(res)) {
              navigate(res.path, res.params);
            } else {
              navigate(res);
            }
          });
        }
      } else {
        queue(hash);
        handleHashChange().then(() => {
          app._refocus();
        }).catch((e) => {
          console.error(e);
        });
      }
    };
    if (routeExists(bootKey)) {
      if (hash && !isDirectLoad) {
        if (!getRouteByHash(hash)) {
          navigate("*", { failedHash: hash });
          return;
        }
      }
      navigate(
        bootKey,
        {
          resume: resumeHash,
          reload: bootKey === hash
        },
        false
      );
    } else if (isFunction(bootRequest2)) {
      bootRequest2(params).then(() => {
        ready();
      }).catch((e) => {
        handleBootError(e);
      });
    } else {
      ready();
    }
  };
  var handleBootError = (e) => {
    if (routeExists("!")) {
      navigate("!", { request: { error: e } });
    } else {
      console.error(e);
    }
  };
  var navigate = (url, args = {}, store) => {
    if (isObject3(url)) {
      url = getHashByName(url);
      if (!url) {
        return;
      }
    }
    let hash = getHash();
    if (!mustUpdateLocationHash() && forcedHash) {
      hash = forcedHash;
    }
    if (hash.replace(/^#/, "") !== url) {
      queue(url, args, store);
      if (mustUpdateLocationHash()) {
        setHash(url);
      } else {
        forcedHash = url;
        handleHashChange(url).then(() => {
          app._refocus();
        }).catch((e) => {
          console.error(e);
        });
      }
    } else if (args.reload) {
      queue(url, args, store);
      handleHashChange(url).then(() => {
        app._refocus();
      }).catch((e) => {
        console.error(e);
      });
    }
  };
  var queue = (hash, args = {}, store) => {
    hash = cleanHash(hash);
    if (!navigateQueue.has(hash)) {
      for (let request2 of navigateQueue.values()) {
        request2.cancel();
      }
      const request = createRequest(hash, args, store);
      navigateQueue.set(decodeURIComponent(hash), request);
      return request;
    }
    return false;
  };
  var handleHashChange = (override) => __async(null, null, function* () {
    const hash = cleanHash(override || getHash());
    const queueId = decodeURIComponent(hash);
    let request = navigateQueue.get(queueId);
    if (!request && !navigateQueue.size) {
      request = queue(hash);
    }
    const route = getRouteByHash(hash);
    if (!route) {
      if (routeExists("*")) {
        navigate("*", { failedHash: hash });
      } else {
        console.error(`Unable to navigate to: ${hash}`);
      }
      return;
    }
    request.hash = hash;
    request.route = route;
    let result = yield beforeEachRoute(getActiveHash(), request);
    if (result && route.beforeNavigate) {
      result = yield route.beforeNavigate(getActiveHash(), request);
    }
    if (isBoolean(result)) {
      if (result) {
        return resolveHashChange(request);
      }
    } else {
      request.cancel();
      navigateQueue.delete(queueId);
      if (isString2(result)) {
        navigate(result);
      } else if (isObject3(result)) {
        let store = true;
        if (isBoolean(result.store)) {
          store = result.store;
        }
        navigate(result.path, result.params, store);
      }
    }
  });
  var resolveHashChange = (request) => {
    const hash = request.hash;
    const route = request.route;
    const queueId = decodeURIComponent(hash);
    setLastHash(hash);
    if (route.path) {
      const component = getComponent(route.path);
      if (isFunction(route.hook)) {
        const urlParams = getValuesFromHash(hash, route.path);
        const params = {};
        for (const key of urlParams.keys()) {
          params[key] = urlParams.get(key);
        }
        route.hook(app, __spreadValues({}, params));
      }
      if (component) {
        const activePage2 = getActivePage();
        if (activePage2) {
          const keepAlive = keepActivePageAlive(getActiveRoute(), request);
          if (activePage2 && route.path === getActiveRoute() && !keepAlive) {
            activePage2._setState("");
          }
        }
        if (isPage(component, stage)) {
          load(request).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        } else {
          component().then((contents) => {
            return contents.default;
          }).then((module) => {
            storeComponent(route.path, module);
            return load(request);
          }).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        }
      } else {
        navigateQueue.delete(queueId);
      }
    }
  };
  var step = (level = 0) => {
    if (!level || isNaN(level)) {
      return false;
    }
    const history2 = getHistory();
    level = Math.abs(level);
    if (history2.length) {
      const route = history2.splice(history2.length - level, level)[0];
      setHistory(history2);
      return navigate(
        route.hash,
        {
          [symbols.backtrack]: true,
          [symbols.historyState]: route.state
        },
        false
      );
    } else if (routerConfig.get("backtrack")) {
      const hashLastPart = /(\/:?[\w%\s-]+)$/;
      let hash = stripRegex(getHash());
      let floor = getFloor(hash);
      if (floor > 1) {
        while (floor--) {
          hash = hash.replace(hashLastPart, "");
          if (getRouteByHash(hash)) {
            return navigate(hash, { [symbols.backtrack]: true }, false);
          }
        }
      }
    }
    if (level > history2.length) {
      if (isFunction(app._handleAppClose)) {
        return app._handleAppClose();
      }
      return app.application.closeApp();
    }
    return false;
  };
  var resume = () => {
    if (isString2(resumeHash)) {
      navigate(resumeHash, false);
      resumeHash = "";
    } else if (isFunction(resumeHash)) {
      resumeHash().then((res) => {
        resumeHash = "";
        if (isObject3(res)) {
          navigate(res.path, res.params);
        } else {
          navigate(res);
        }
      });
    } else {
      console.warn("[Router]: resume() called but no hash found");
    }
  };
  var reload = () => {
    if (!isNavigating()) {
      const hash = getActiveHash();
      navigate(hash, { reload: true }, false);
    }
  };
  var isNavigating = () => {
    if (navigateQueue.size) {
      let isProcessing = false;
      for (let request of navigateQueue.values()) {
        if (!request.isCancelled) {
          isProcessing = true;
        }
      }
      return isProcessing;
    }
    return false;
  };
  var getResumeHash = () => {
    return resumeHash;
  };
  var getHash = () => {
    return document.location.hash;
  };
  var setHash = (url) => {
    document.location.hash = url;
  };
  var initRouter = (config2) => {
    if (config2.getHash) {
      getHash = config2.getHash;
    }
    if (config2.setHash) {
      setHash = config2.setHash;
    }
  };
  var registerListener = () => {
    Registry_default.addEventListener(window, "hashchange", () => __async(null, null, function* () {
      if (mustUpdateLocationHash()) {
        try {
          yield handleHashChange();
        } catch (e) {
          console.error(e);
        }
      }
    }));
  };
  var root = () => {
    const rootHash2 = getRootHash();
    if (isString2(rootHash2)) {
      navigate(rootHash2);
    } else if (isFunction(rootHash2)) {
      rootHash2().then((res) => {
        if (isObject3(res)) {
          navigate(res.path, res.params);
        } else {
          navigate(res);
        }
      });
    }
  };
  var deletePage = (param) => {
    deleteCurrentInstance(param);
  };
  var Router_default = {
    startRouter,
    navigate,
    resume,
    step,
    go: step,
    back: step.bind(null, -1),
    activePage: getActivePage,
    getActivePage() {
      return getActivePage();
    },
    deletePage,
    getActiveRoute,
    getActiveHash,
    focusWidget,
    getActiveWidget,
    restoreFocus,
    isNavigating,
    getHistory,
    setHistory,
    getHistoryState,
    replaceHistoryState,
    getQueryStringParams,
    reload,
    symbols,
    App: RoutedApp,
    // keep backwards compatible
    focusPage: restoreFocus,
    root,
    /**
     * Deprecated api methods
     */
    setupRoutes() {
      console.warn("Router: setupRoutes is deprecated, consolidate your configuration");
      console.warn("https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration");
    },
    on() {
      console.warn("Router.on() is deprecated, consolidate your configuration");
      console.warn("https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration");
    },
    before() {
      console.warn("Router.before() is deprecated, consolidate your configuration");
      console.warn("https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration");
    },
    after() {
      console.warn("Router.after() is deprecated, consolidate your configuration");
      console.warn("https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration");
    }
  };

  // node_modules/@lightningjs/sdk/src/Launch/index.js
  var ApplicationInstance2;
  var Launch_default = (App3, appSettings, platformSettings, appData) => {
    initSettings(appSettings, platformSettings);
    initUtils(platformSettings);
    initMetadata(appSettings);
    initStorage();
    if (platformSettings.plugins) {
      platformSettings.plugins.profile && initProfile(platformSettings.plugins.profile);
      platformSettings.plugins.metrics && initMetrics(platformSettings.plugins.metrics);
      platformSettings.plugins.mediaPlayer && initMediaPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.mediaPlayer && initVideoPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.ads && initAds(platformSettings.plugins.ads);
      platformSettings.plugins.router && initRouter(platformSettings.plugins.router);
      platformSettings.plugins.tv && initTV(platformSettings.plugins.tv);
      platformSettings.plugins.purchase && initPurchase(platformSettings.plugins.purchase);
      platformSettings.plugins.pin && initPin(platformSettings.plugins.pin);
    }
    const app2 = Application_default(App3, appData, platformSettings);
    initLightningSdkPlugin.log = Log_default;
    initLightningSdkPlugin.settings = Settings_default;
    initLightningSdkPlugin.ads = Ads_default;
    initLightningSdkPlugin.lightning = Lightning_default;
    ApplicationInstance2 = new app2(appSettings);
    initLightningSdkPlugin.appInstance = ApplicationInstance2;
    return ApplicationInstance2;
  };

  // node_modules/@lightningjs/sdk/src/VideoPlayer/index.js
  var VideoPlayer_default2 = VideoPlayer_default;

  // node_modules/@lightningjs/sdk/src/Subtitles/SubtitleComponent.js
  var SubtitleComponent = class extends Lightning_default.Component {
    static _template() {
      return {
        visible: false,
        rect: true,
        color: 2415919104,
        shader: { type: Lightning_default.shaders.RoundedRectangle, radius: 5 },
        Text: {
          y: 5,
          x: 20,
          text: {
            textColor: 4294967295,
            fontSize: 38,
            lineHeight: 38 * 1.4,
            textAlign: "center",
            wordWrap: true,
            maxLines: 3,
            shadow: true,
            shadowColor: 4281545523
          }
        }
      };
    }
    _init() {
      this._textTextureDefaults = new Lightning_default.textures.TextTexture(this.stage).cloneArgs();
      this.tag("Text").on("txLoaded", ({ _source }) => {
        this.w = _source.w + this.tag("Text").x * 2;
        this.h = _source.h;
        this.position();
      });
    }
    get textFormat() {
      const textTag = this.tag("Text").text;
      return {
        fontFace: textTag.fontFace || "sans-serif",
        fontSize: textTag.fontSize,
        lineHeight: textTag.lineHeight,
        textAlign: textTag.textAlign,
        wordWrap: true,
        maxLines: textTag.maxLines
      };
    }
    show() {
      this.visible = true;
    }
    hide() {
      this.visible = false;
    }
    position() {
      this.x = this._calculateX(this.xPos);
      this.y = this._calculateY(this.yPos);
    }
    set viewportW(v) {
      this._viewportW = v;
      this.x = this._calculateX(this.xPos);
    }
    get viewportW() {
      return this._viewportW || this.application.finalW;
    }
    set viewportH(v) {
      this._viewportH = v;
      this.y = this._calculateY(this.yPos);
    }
    get viewportH() {
      return this._viewportH || this.application.finalH;
    }
    _calculateX(x) {
      if (x === "center") {
        x = (this.viewportW - this.finalW) / 2;
      } else if (x === "left") {
        x = 60;
      } else if (x === "right") {
        x = this.viewportW - this.finalW - 60;
      }
      return x;
    }
    set xPos(v) {
      this._x = v;
      this.x = this._calculateX(v);
    }
    get xPos() {
      return this._x || "center";
    }
    _calculateY(y) {
      if (y === "center") {
        return (this.viewportH - this.finalH) / 2;
      } else if (y === "top") {
        return 60;
      } else if (y === "bottom") {
        return this.viewportH - this.finalH - 60;
      }
      return y;
    }
    set yPos(v) {
      this._y = v;
      this.y = this._calculateY(v);
    }
    get yPos() {
      return this._y || "bottom";
    }
    set fontFamily(v) {
      this.tag("Text").text.fontFace = v;
    }
    set fontSize(v) {
      this.tag("Text").text.fontSize = v;
      this.tag("Text").text.lineHeight = v * 1.3;
    }
    set fontColor(v) {
      this.tag("Text").color = v;
    }
    set backgroundColor(v) {
      this.color = v;
    }
    _defineBreakpoint(text, breakpoint) {
      if (breakpoint >= this.maxWidth) return this.maxWidth;
      const info = Lightning_default.textures.TextTexture.renderer(
        this.stage,
        this.stage.platform.getDrawingCanvas(),
        __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, this._textTextureDefaults), this.textFormat), { wordWrapWidth: breakpoint }), {
          text
        })
      )._calculateRenderInfo();
      if (info.width <= breakpoint && info.lines.length <= 2) {
        return breakpoint;
      } else {
        return this._defineBreakpoint(text, breakpoint * 1.25);
      }
    }
    set text(v) {
      this.alpha = 0;
      if (v && v.length) {
        const breakpoint = this._defineBreakpoint(v, 640);
        this.tag("Text").text.wordWrapWidth = breakpoint;
        this.tag("Text").text = v;
        this.alpha = 1;
      }
    }
    set textAlign(v) {
      this._textAlign = v;
      this.tag("Text").text.textAlign = v;
    }
    set maxWidth(v) {
      this._maxWidth = v;
    }
    get maxWidth() {
      return (this._maxWidth || 1200) - this.tag("Text").x * 2;
    }
    set maxLines(v) {
      this.tag("Text").text.maxLines = v;
    }
  };

  // src/core/theme.ts
  var Theme = {
    w: 1920,
    h: 1080,
    colors: {
      bg: 4279243800,
      text: 4293125608,
      textDim: 4287270807,
      accent: 4278222503,
      tile: 4279442218,
      focus: 4293523199,
      tilefocus: 1722214366,
      tileunfocus: 4280956487
    },
    spacing: {
      xs: 8,
      sm: 16,
      md: 32,
      lg: 48,
      xl: 72
    },
    typography: {
      h1: 64,
      h2: 42,
      h3: 32,
      body: 26,
      tiny: 20
    }
  };
  var Typography = {
    heading: { face: "RelaxAI-SoraSemiBold", size: 48 },
    nav: { face: "RelaxAI-SoraLight", size: 36 },
    title: { face: "RelaxAI-SoraMedium", size: 60 },
    body: { face: "RelaxAI-SoraLight", size: 36 },
    small: { face: "RelaxAI-Manrope", size: 22 },
    button: { face: "RelaxAI-SoraMedium", size: 30 }
  };

  // src/pages/base/BasePage.ts
  var BasePage = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      // ======== ESTADO ========
      this._section = this.hasHeader ? -1 : 0;
      this._restoredFromHistory = false;
      this._offsets = {};
      this._minY = 0;
      this._maxY = 0;
      this._lastSync = 0;
      this._pendingRestoreY = null;
    }
    // ======== CONFIG POR PGINA (override en subclases) ========
    get hasHeader() {
      return true;
    }
    get sections() {
      return [];
    }
    get defaultHeights() {
      return {};
    }
    get extraBottom() {
      return 120;
    }
    get enableScrollSnap() {
      return true;
    }
    get enableHistory() {
      return true;
    }
    get innerPath() {
      return "Viewport.Content.ContentInner";
    }
    get persistHeaderInHistory() {
      return false;
    }
    get autoInitialFocus() {
      return true;
    }
    /** Si `false`, no restauramos ndices de foco desde history POP. */
    get enableFocusRecovery() {
      return true;
    }
    /** Hook: decidir si una seccin debe hacer scroll (por ndice). */
    get shouldScrollOnSection() {
      return () => true;
    }
    get wasRestoredFromHistory() {
      return this._restoredFromHistory;
    }
    // ======== TEMPLATE (Chrome) ========
    static chrome(children) {
      return {
        w: Theme.w,
        h: Theme.h,
        rect: true,
        color: Theme.colors.bg,
        Viewport: {
          w: Theme.w,
          h: Theme.h,
          clipping: true,
          Content: {
            y: 0,
            transitions: { y: { duration: 0.25, timingFunction: "ease-out" } },
            ContentInner: children
          }
        }
      };
    }
    // ======== HISTORYSTATE ========
    historyState(params) {
      var _a, _b;
      const content = this.tag("Viewport.Content");
      if (params) {
        console.log("%c[BasePage] LOAD", "color:#00bfa5", params);
        this._restoredFromHistory = true;
        const restored = (_a = params.section) != null ? _a : this.hasHeader ? -1 : 0;
        this._section = !this.persistHeaderInHistory && restored < 0 ? 0 : restored;
        this._pendingRestoreY = (_b = params.scrollY) != null ? _b : 0;
        if (params.focus) {
          for (const key of this.sections) {
            const idx = params.focus[key];
            if (idx !== void 0) this._setChildFocusIndex(key, idx);
          }
        }
        if (params.section) {
          this._section = params.section;
        }
        if (params.scrollY) {
          const content2 = this.tag("Viewport.Content");
          content2.setSmooth("y", -params.scrollY);
        }
        return void 0;
      } else {
        console.log("%cf[BasePage] NO LOAD", "color:#00bfa5", params);
      }
      const sectionToSave = !this.persistHeaderInHistory && this._section < 0 ? 0 : this._section;
      const snap = {
        section: sectionToSave,
        scrollY: Math.abs(content.y || 0),
        focus: {}
      };
      for (const key of this.sections) {
        const idx = this._getChildFocusIndex(key);
        if (idx !== void 0) snap.focus[key] = idx;
      }
      return snap;
    }
    // ======== LIFECYCLE ========
    _attach() {
      this._computeMetrics();
      this._maybeInitFocus();
    }
    _active() {
      var _a, _b, _c, _d, _e;
      (_a = super._active) == null ? void 0 : _a.call(this);
      const history2 = (_c = (_b = Router_default).getHistory) == null ? void 0 : _c.call(_b);
      const active = (_e = (_d = Router_default).getActiveHash) == null ? void 0 : _e.call(_d);
      console.log("[_onMounted] active:", active, "history:", history2);
      if (Router_default._resetNextPage) {
        console.warn(
          "\x1B[31m%s\x1B[0m",
          "[HomePage] Reset state due to header navigation"
        );
        this.resetRailsFocus();
        this.focusCarousel();
        Router_default._resetNextPage = false;
      }
    }
    resetRailsFocus() {
      for (const key of this.sections) {
        const node = this.tag(`${this.innerPath}.${key}`);
        if (!node) continue;
        try {
          if (node.setFocusIndex) {
            node.setFocusIndex(0);
          } else if (node._focusIndex !== void 0) {
            node._focusIndex = 0;
          }
        } catch (e) {
        }
      }
    }
    focusCarousel() {
      const carouselIndex = this.sections.indexOf("Carussel");
      if (carouselIndex < 0) return;
      this._section = carouselIndex;
      this._applyScrollForSection(carouselIndex);
      this._refocus();
    }
    /** Ejecuta despus de layout (til desde subclases post-patch). */
    computeAfterLayout() {
      setTimeout(() => {
        this._computeMetrics();
        if (this._pendingRestoreY !== null) {
          const content = this.tag("Viewport.Content");
          const wantedY = -this._pendingRestoreY;
          content.patch({ y: this._clamp(wantedY) });
          this._pendingRestoreY = null;
          this._refocus();
        } else {
          this._maybeInitFocus();
        }
      }, 0);
    }
    // ======== MTRICAS / LIMITES ========
    _computeMetrics() {
      const content = this.tag("Viewport.Content");
      const inner = this.tag(this.innerPath);
      this.stage.update();
      const zy = (n) => (n == null ? void 0 : n.y) || 0;
      const zh = (name, n) => (n == null ? void 0 : n.h) || this.defaultHeights[name] || 0;
      const get = (name) => inner == null ? void 0 : inner.tag(name);
      const innerY = zy(inner);
      this._offsets = {};
      if (this.hasHeader) {
        const header = get("Header");
        this._offsets["Header"] = innerY + zy(header);
      }
      for (const key of this.sections) {
        const node = get(key);
        this._offsets[key] = innerY + zy(node);
      }
      const bottoms = [];
      if (this.hasHeader) {
        const header = get("Header");
        bottoms.push(innerY + zy(header) + zh("Header", header));
      }
      for (const key of this.sections) {
        const node = get(key);
        bottoms.push(innerY + zy(node) + zh(key, node));
      }
      const totalH = Math.max(...bottoms, Theme.h) + this.extraBottom;
      const viewportH = Theme.h;
      this._maxY = 0;
      this._minY = Math.min(0, viewportH - totalH);
      content.y = this._clamp(content.y);
    }
    _clamp(y) {
      return Math.max(this._minY, Math.min(y, this._maxY));
    }
    // ======== FOCUS ========
    _getFocused() {
      if (this.hasHeader && this._section === -1) {
        return this.tag(`${this.innerPath}.Header`);
      }
      const name = this._nameFor(this._section);
      return this.tag(`${this.innerPath}.${name}`);
    }
    _nameFor(index) {
      const clampIndex = (i) => Math.max(0, Math.min(i, this.sections.length - 1));
      if (this.hasHeader) {
        if (index < 0) return "Header";
        return this.sections[clampIndex(index)];
      }
      return this.sections[clampIndex(index)];
    }
    focusActiveNode() {
      const f = this._getFocused();
      if (f == null ? void 0 : f.focus) f.focus();
    }
    // ======== NAVEGACIN POR SECCIONES ========
    focusNext() {
      if (!this.enableScrollSnap) return;
      const max = this.sections.length - 1;
      this._section = Math.min(this._section + 1, max);
      this._applyScrollForSection(this._section);
    }
    focusPrev() {
      if (!this.enableScrollSnap) return;
      const min = this.hasHeader ? -1 : 0;
      this._section = Math.max(this._section - 1, min);
      this._applyScrollForSection(this._section);
    }
    /** Lleva el viewport al top inmediato, preservando transiciones del resto. */
    $scrollTop() {
      var _a;
      const content = this.tag("Viewport.Content");
      const prev = (_a = content.transitions) == null ? void 0 : _a.y;
      content.patch({ transitions: { y: { duration: 0 } } });
      content.patch({ y: this._clamp(0) });
      content.patch({ transitions: { y: prev != null ? prev : void 0 } });
    }
    _applyScrollForSection(index) {
      const content = this.tag("Viewport.Content");
      if (!this.enableScrollSnap || !this.shouldScrollOnSection(index)) {
        this._refocus();
        return;
      }
      if (this.hasHeader && index < 0 || index === 0) {
        content.setSmooth("y", this._clamp(0));
        this._refocus();
        return;
      }
      const key = this._nameFor(index);
      const targetY = -(this._offsets[key] || 0);
      content.setSmooth("y", this._clamp(targetY));
      this._refocus();
    }
    _syncHistorySnapshot() {
      var _a, _b, _c, _d, _e, _f;
      if (!this.enableHistory) return;
      const content = this.tag("Viewport.Content");
      const sectionToSave = !this.persistHeaderInHistory && this._section < 0 ? 0 : this._section;
      const state3 = {
        section: sectionToSave,
        scrollY: Math.abs(content.y || 0),
        focus: {}
      };
      for (const key of this.sections) {
        const idx = this._getChildFocusIndex(key);
        if (idx !== void 0) state3.focus[key] = idx;
      }
      (_b = (_a = Router_default).replaceHistoryState) == null ? void 0 : _b.call(_a, state3);
      console.log("%c[BasePage] SAVE", "color:#00bfa5", {
        hash: (_d = (_c = Router_default).getActiveHash) == null ? void 0 : _d.call(_c),
        state: state3,
        history: (_f = (_e = Router_default).getHistory) == null ? void 0 : _f.call(_e)
      });
    }
    // ======== HELPERS FOCUS HIJOS ========
    _getChildFocusIndex(name) {
      const node = this.tag(`${this.innerPath}.${name}`);
      try {
        if (node == null ? void 0 : node.getFocusIndex) return node.getFocusIndex();
        if ((node == null ? void 0 : node._focusIndex) !== void 0) return node._focusIndex;
      } catch (e) {
      }
      return void 0;
    }
    _setChildFocusIndex(name, idx) {
      if (idx === void 0) return;
      const node = this.tag(`${this.innerPath}.${name}`);
      try {
        if (node == null ? void 0 : node.setFocusIndex) node.setFocusIndex(idx);
        else if (node) node._focusIndex = idx;
      } catch (e) {
      }
    }
    // ======== TECLAS POR DEFECTO ========
    _handleDown() {
      this.focusNext();
      return true;
    }
    _handleUp() {
      this.focusPrev();
      return true;
    }
    // ======== NAVEGAR util ========
    navigate(path, params) {
      this._syncHistorySnapshot();
      const base = path.replace(/^#?\/?/, "").toLowerCase();
      const target = (params == null ? void 0 : params.id) ? `${base}/${encodeURIComponent(params.id)}` : base;
      if ((params == null ? void 0 : params.from) == "header") {
        Router_default._resetNextPage = true;
      }
      Router_default.navigate(target, params, true);
    }
    // ======== FOCUS INICIAL INTELIGENTE ========
    _maybeInitFocus() {
      if (!this.autoInitialFocus) return;
      if (this.wasRestoredFromHistory) return;
      if (!this.sections.length) return;
      const desired = this._determineInitialSectionIndex();
      const safeIndex = Math.max(0, desired);
      if (this._section !== safeIndex) {
        this._section = safeIndex;
        this._applyScrollForSection(this._section);
      } else {
        this._refocus();
      }
    }
    /** Heurstica para seccin inicial: prevFocus > Carussel > Hero > SearchInput > primera. */
    _determineInitialSectionIndex() {
      const withPrev = this.sections.findIndex((name) => {
        const idx = this._getChildFocusIndex(name);
        return idx !== void 0 && idx !== null;
      });
      if (withPrev >= 0) return withPrev;
      const idxCar = this._hasInnerTag("Carussel") ? this.sections.indexOf("Carussel") : -1;
      if (idxCar >= 0) return idxCar;
      const idxHero = this._hasInnerTag("Hero") ? this.sections.indexOf("Hero") : -1;
      if (idxHero >= 0) return idxHero;
      const idxSearch = this._hasInnerTag("SearchInput") ? this.sections.indexOf("SearchInput") : -1;
      if (idxSearch >= 0) return idxSearch;
      return 0;
    }
    _hasInnerTag(name) {
      try {
        return !!this.tag(`${this.innerPath}.${name}`);
      } catch (e) {
        return false;
      }
    }
  };

  // src/atoms/Logo.ts
  var Logo = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._left = "Relax";
      this._right = "AI";
      this._spacing = 6;
    }
    set label(v) {
      var _a, _b;
      const parts = v.split(/\s+/);
      this._left = (_a = parts[0]) != null ? _a : "Relax";
      this._right = (_b = parts[1]) != null ? _b : "AI";
      this._updateWordmark();
    }
    get label() {
      return `${this._left} ${this._right}`;
    }
    get Wordmark() {
      return this.tag("Wordmark");
    }
    get LabelRelax() {
      return this.tag("Wordmark").tag("LabelRelax");
    }
    get LabelAI() {
      return this.tag("Wordmark").tag("LabelAI");
    }
    static _template() {
      return {
        w: 260,
        h: 72,
        rect: true,
        color: 0,
        Wordmark: {
          x: 0,
          mountY: 0.5,
          LabelRelax: {
            text: {
              text: "Relax",
              fontFace: Typography.heading.face,
              fontSize: Typography.heading.size,
              textColor: Theme.colors.text
            }
          },
          LabelAI: {
            x: 135,
            text: {
              text: "AI",
              fontFace: Typography.heading.face,
              fontSize: Typography.heading.size,
              textColor: Theme.colors.accent
            }
          }
        }
      };
    }
    _init() {
      this._updateWordmark();
    }
    _updateWordmark() {
      this.patch({
        Wordmark: {
          LabelRelax: { text: { text: this._left } },
          LabelAI: { text: { text: this._right } }
        }
      });
    }
  };

  // src/atoms/NavItem.ts
  var NavItem = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._routeActive = false;
      this._pendingIndicatorColor = null;
    }
    static _template() {
      return {
        w: 200,
        h: 60,
        rect: true,
        color: 0,
        Indicator: {
          x: 0,
          y: 58,
          w: (w) => w,
          h: 6,
          rect: true,
          color: 0
        },
        Label: {
          y: 0,
          x: 0,
          text: {
            text: "",
            fontFace: Typography.nav.face,
            fontSize: Typography.nav.size,
            textColor: Theme.colors.text
          }
        }
      };
    }
    set labelText(v) {
      this.patch({ Label: { text: { text: v } } });
    }
    get labelText() {
      var _a, _b;
      return ((_b = (_a = this.tag("Label")) == null ? void 0 : _a.text) == null ? void 0 : _b.text) || "";
    }
    _init() {
      if (this._pendingIndicatorColor !== null) {
        const ind = this.tag("Indicator");
        ind == null ? void 0 : ind.patch({ color: this._pendingIndicatorColor });
        this._pendingIndicatorColor = null;
      } else {
        this._renderIndicator();
      }
    }
    set routeActive(v) {
      this._routeActive = v;
      this._renderIndicator();
    }
    get routeActive() {
      return this._routeActive;
    }
    setSelected(v) {
      this.routeActive = v;
    }
    _focus() {
      this._renderIndicator();
      return true;
    }
    _unfocus() {
      this._renderIndicator();
      return true;
    }
    _renderIndicator() {
      var _a;
      const ind = this.tag("Indicator");
      const la = this.tag("Label");
      const focused = this.hasFocus();
      const SELECTED = (_a = Theme.colors.accent) != null ? _a : 4294901760;
      const UNSELECTED = 4294967295;
      const UNFOCUS = 0;
      const color = focused ? SELECTED : this._routeActive ? UNSELECTED : UNFOCUS;
      la == null ? void 0 : la.patch({ text: { textColor: focused ? SELECTED : UNSELECTED } });
      if (ind) {
        ind.patch({ color });
        this._pendingIndicatorColor = null;
      } else {
        this._pendingIndicatorColor = color;
      }
    }
  };

  // src/molecules/Header.ts
  var _val = 230;
  var Header = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._focusIdx = 0;
      this._currentIdx = 0;
      this._routes = [
        "home",
        "suggest",
        "breathe",
        "longform",
        "search",
        "watchlist"
      ];
      this._onHashChange = () => this._syncSelectedFromLocation();
    }
    static _template() {
      return {
        w: 1920,
        h: 100,
        Logo: { x: 40, y: 90, mountY: 1, type: Logo },
        Nav: {
          x: 40,
          y: 120,
          mountY: 1,
          Home: { type: NavItem, labelText: "Home" },
          New: { x: _val, type: NavItem, labelText: "Suggest" },
          Movies: { x: _val * 2, type: NavItem, labelText: "Breathe" },
          Series: { x: _val * 3, type: NavItem, labelText: "Longform" },
          Search: { x: _val * 4, type: NavItem, labelText: "Search" },
          Watchlist: { x: _val * 5, type: NavItem, labelText: "Watchlist" }
        }
      };
    }
    _setup() {
      this._syncSelectedFromLocation();
      if (typeof window !== "undefined")
        window.addEventListener("hashchange", this._onHashChange);
      this._refocus();
    }
    _firstActive() {
      this._applyCurrentByIndex(this._currentIdx);
      this._setFocusIndex(this._currentIdx);
    }
    _detach() {
      if (typeof window !== "undefined")
        window.removeEventListener("hashchange", this._onHashChange);
    }
    _focus() {
      this._setFocusIndex(this._currentIdx);
      return true;
    }
    _getFocused() {
      return this.tag("Nav").children[this._focusIdx];
    }
    _handleLeft() {
      if (this._focusIdx > 0) this._setFocusIndex(this._focusIdx - 1);
      return true;
    }
    _handleRight() {
      const max = this.tag("Nav").children.length - 1;
      if (this._focusIdx < max) this._setFocusIndex(this._focusIdx + 1);
      return true;
    }
    _handleEnter() {
      this._applyCurrentByIndex(this._focusIdx);
      this.signal("navigate", this._routes[this._currentIdx], { from: "header" });
      return true;
    }
    _handleDown() {
      this.signal("focusNext");
      return true;
    }
    setCurrentByRoute(route) {
      const i = this._routes.indexOf((route || "").toLowerCase());
      if (i >= 0) this._applyCurrentByIndex(i);
    }
    _syncSelectedFromLocation() {
      const route = this._detectRouteFromHash();
      const idx = this._routes.indexOf(route);
      if (idx >= 0) this._applyCurrentByIndex(idx);
    }
    _detectRouteFromHash() {
      if (typeof window === "undefined") return "home";
      const raw = window.location.hash || "";
      return (raw.replace(/^#\/?/, "").split("/")[0] || "home").toLowerCase();
    }
    _setFocusIndex(i) {
      this._focusIdx = i;
      this._refocus();
    }
    _applyCurrentByIndex(i) {
      this._currentIdx = i;
      this.tag("Nav").children.forEach(
        (c, idx) => c.routeActive = idx === i
      );
    }
  };

  // src/atoms/Tile.ts
  var Tile = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._title = "";
      this._videoSrc = "";
      this._imageSrc = "";
    }
    get titleElement() {
      return this.tag("Title");
    }
    get poster() {
      return this.tag("Poster");
    }
    get posterImg() {
      var _a;
      return (_a = this.poster) == null ? void 0 : _a.tag("PosterImg");
    }
    set title(v) {
      var _a;
      this._title = v;
      (_a = this.titleElement) == null ? void 0 : _a.patch({ text: { text: v } });
    }
    set imageSrc(v) {
      this._imageSrc = v;
      this.posterImg.patch({
        src: Utils_default.asset(v || "/assets/images/placeholder.png")
      });
    }
    get imageSrc() {
      return this._imageSrc;
    }
    set videoSrc(v) {
      this._videoSrc = v;
    }
    get videoSrc() {
      return this._videoSrc;
    }
    //  setter per injectar totes les dades dun cop
    set data(d) {
      this._data = d;
      this.title = d.title;
      this.imageSrc = d.imageSrc;
      this.videoSrc = d.videoSrc;
    }
    get data() {
      return this._data;
    }
    static _template() {
      return {
        w: 300,
        h: 170,
        rect: true,
        Poster: {
          w: (w) => w,
          h: (h) => h,
          PosterBg: {
            rect: true,
            w: (w) => w,
            h: (h) => h,
            color: Theme.colors.tileunfocus
          },
          PosterImg: { w: (w) => w, h: (h) => h }
        },
        Title: {
          y: 176,
          text: {
            text: "",
            fontSize: 22,
            fontFace: "RelaxAI-SoraRegular",
            textColor: Theme.colors.textDim
          }
        }
      };
    }
    _focus() {
      this.tag("Poster").patch({
        shader: {
          type: Lightning_default.shaders.Outline,
          thickness: 16,
          pixelSize: 16,
          color: Theme.colors.accent
        }
      });
    }
    _unfocus() {
      this.tag("Poster").patch({ shader: null });
    }
    /** Extreu la secci actual del hash: #/home/..., #/suggest/..., etc. */
    _getCurrentSection() {
      if (typeof window === "undefined") return "home";
      const seg = (window.location.hash || "").replace(/^#\/?/, "").split("/")[0] || "home";
      return seg.toLowerCase();
    }
    _handleEnter() {
      var _a;
      if (!this._data) return true;
      const section = this._getCurrentSection().toLowerCase() || "home";
      this.signal("navigate", `${section}/detail`, { id: (_a = this._data) == null ? void 0 : _a.id });
      return true;
    }
  };

  // src/molecules/Rail.ts
  var STEP = 330;
  var VIEW_W = 1840;
  var LEFT_PAD = 40;
  var Rail = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._index = 0;
      this._totalW = 0;
    }
    static _template() {
      return {
        Title: {
          x: LEFT_PAD,
          y: 0,
          text: {
            text: "",
            fontSize: 32,
            fontFace: "RelaxAI-SoraRegular",
            textColor: Theme.colors.text
          }
        },
        Viewport: {
          x: 0,
          y: 62,
          w: VIEW_W + LEFT_PAD,
          h: 270,
          clipping: true,
          Row: {
            x: LEFT_PAD,
            y: 0,
            transitions: { x: { duration: 0.25, timingFunction: "ease-out" } }
          }
        }
      };
    }
    reset() {
      this._index = 0;
      this._scrollToIndex();
    }
    getFocusIndex() {
      return this._index;
    }
    setFocusIndex(i) {
      const row = this.tag("Viewport.Row");
      const max = Math.max(0, row.children.length - 1);
      this._index = Math.max(0, Math.min(i != null ? i : 0, max));
      this._scrollToIndex();
      this._refocus();
    }
    set title(v) {
      this.tag("Title").text.text = v;
    }
    set items(v) {
      this.tag("Viewport.Row").children = v.map((it, i) => ({
        type: Tile,
        x: i * STEP,
        signals: { navigate: "onChildNavigate" },
        data: it
      }));
      this._totalW = v.length * STEP;
      const max = Math.max(0, v.length - 1);
      this._index = Math.max(0, Math.min(this._index, max));
      this._scrollToIndex();
    }
    onChildNavigate(path, params) {
      this.signal("navigate", path, params);
    }
    _getFocused() {
      return this.tag("Viewport.Row").children[this._index];
    }
    _handleLeft() {
      if (this._index > 0) {
        this._index--;
        this._scrollToIndex();
      }
      return true;
    }
    _handleRight() {
      const max = this.tag("Viewport.Row").children.length - 1;
      if (this._index < max) {
        this._index++;
        this._scrollToIndex();
      }
      return true;
    }
    _handleUp() {
      this.signal("focusPrev");
      return true;
    }
    _handleDown() {
      this.signal("focusNext");
      return true;
    }
    _scrollToIndex() {
      const row = this.tag("Viewport.Row");
      const targetItemX = this._index * STEP;
      const desiredCenter = targetItemX + STEP / 2;
      const maxScroll = Math.max(0, this._totalW - VIEW_W);
      const scroll = Math.min(Math.max(desiredCenter - VIEW_W / 2, 0), maxScroll);
      row.setSmooth("x", LEFT_PAD - scroll);
    }
  };

  // node_modules/@lightningjs/ui/src/helpers/CollectionWrapper.js
  var CollectionWrapper = class _CollectionWrapper extends src_default.Component {
    static _template() {
      return {
        Wrapper: {}
      };
    }
    _construct() {
      this._direction = _CollectionWrapper.DIRECTION.row;
      this._scrollTransitionSettings = this.stage.transitions.createSettings({});
      this._spacing = 0;
      this._autoResize = false;
      this._requestingItems = false;
      this._requestThreshold = 1;
      this._requestsEnabled = false;
      this._gcThreshold = 5;
      this._gcIncrement = 0;
      this._forceLoad = false;
      this.clear();
    }
    _setup() {
      this._updateScrollTransition();
    }
    _updateScrollTransition() {
      const axis = this._direction === 1 ? "y" : "x";
      this.wrapper.transition(axis, this._scrollTransitionSettings);
      this._scrollTransition = this.wrapper.transition(axis);
    }
    _indexChanged(obj, options = {}) {
      let { index: target, dataLength: max, mainIndex, previousMainIndex, lines } = obj;
      if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
        target = mainIndex;
        max = lines;
      }
      if (this._requestsEnabled && !this._requestingItems) {
        if (target + this._requestThreshold >= max) {
          this.requestItems(false, obj);
        }
      }
      this._refocus();
      this.scrollCollectionWrapper(obj, options);
      if (obj.previousIndex !== obj.index) {
        this.signal("onIndexChanged", obj);
      }
    }
    requestItems(reload2 = false, obj = void 0) {
      if (obj === void 0) {
        obj = {
          previousIndex: 0,
          index: this._index,
          mainIndex: this._mainIndex || 0,
          previousMainIndex: this._mainIndex || 0,
          crossIndex: this._crossIndex || 0,
          previousCrossIndex: this._crossIndex || 0,
          lines: this._lines && this._lines.length || 0,
          dataLength: this._items && this._items.length || 0
        };
      }
      this._requestingItems = true;
      this._request(obj).then((response) => {
        this._requestingItems = false;
        if (reload2) {
          this.clear();
        }
        const type = typeof response;
        if (Array.isArray(response) && response.length > 0 || type === "object" || type === "string" || type === "number") {
          this.add(response);
          obj.dataLength = this._items && this._items.length || 0;
          this.signal("onRequestItemsAdded", obj);
        }
      });
    }
    _request(obj) {
      return new Promise((resolve) => {
        this.signal("onRequestItems", obj).then((response) => {
          if (response === void 0 || response === false || Array.isArray(response) && response.length === 0) {
            this.enableRequests = false;
          }
          resolve(response);
        });
      });
    }
    _requestMore(index, data = [], options) {
      const obj = {
        previousIndex: this._index,
        index,
        mainIndex: this._mainIndex || 0,
        previousMainIndex: this._previous && this._previous.mainIndex || 0,
        crossIndex: this._crossIndex || 0,
        previousCrossIndex: this._previous && this._previous.crossIndex || 0,
        lines: this._lines && this._lines.length || 0,
        dataLength: data.length + (this._items && this._items.length || 0)
      };
      this._requestingItems = true;
      return new Promise((resolve) => {
        this._request(obj).then((response = []) => {
          if (response) {
            const newData = [...data, ...response];
            if (index > this._items.length + newData.length) {
              this._requestMore(index, newData).then(resolve);
            } else {
              this.add(newData);
              obj.dataLength = this._items && this._items.length || 0;
              this.signal("onRequestItemsAdded", obj);
              this._requestingItems = false;
              this.setIndex(index, options);
              resolve(true);
            }
          } else {
            this._requestingItems = false;
            resolve(false);
          }
        });
      });
    }
    setIndex(index, options = {}) {
      if (this._requestsEnabled && index > this._items.length - 1) {
        if (!this._requestingItems) {
          this._requestMore(index, [], options);
        }
        return true;
      }
      if (this._items.length === 0) {
        this._index = 0;
        return false;
      }
      const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
      const previousIndex = this._index;
      this._index = targetIndex;
      this._indexChanged({ previousIndex, index: targetIndex, dataLength: this._items.length }, options);
      return previousIndex !== targetIndex;
    }
    clear() {
      this._uids = [];
      this._items = [];
      this._index = 0;
      if (this._scrollTransition && this._scrollTransition.isRunning()) {
        this._scrollTransition.reset(0, 1);
      }
      if (this.wrapper) {
        const hadChildren = this.wrapper.children.length > 0;
        this.wrapper.patch({
          x: 0,
          y: 0,
          children: []
        });
        if (hadChildren) {
          this._collectGarbage(true);
        }
      }
    }
    add(item, options = {}) {
      this.addAt(item, this._items.length, options);
    }
    addAt(item, index = this._items.length, options = {}) {
      if (index >= 0 && index <= this._items.length) {
        if (!Array.isArray(item)) {
          item = [item];
        }
        const items = this._normalizeDataItems(item);
        this._items.splice(index, 0, ...items);
        this.plotItems(options);
        const targetIndex = index < this._index ? this._index + items.length : this._index;
        this.setIndex(targetIndex, options);
      } else {
        throw new Error("addAt: The index " + index + " is out of bounds " + this._items.length);
      }
    }
    remove(target, options = {}) {
      if (this.hasItems && target.assignedID) {
        for (let i = 0; i < this._items.length; i++) {
          let item = this._items[i];
          if (target.assignedID === item.assignedID) {
            if (i === this._items.length - 1 && this._index === this._items.length - 1) {
              this._index = this._index - 1;
            }
            return this.removeAt(i, 1, options);
          }
        }
      } else {
        throw new Error("remove: item not found");
      }
    }
    removeAt(index, amount = 1, options = {}) {
      if (index < 0 && index >= this._items.length) {
        throw new Error("removeAt: The index " + index + " is out of bounds " + this._items.length);
      }
      const item = this._items[index];
      this._items.splice(index, amount);
      if (this._items.length > 0) {
        this.plotItems(options);
      }
      this.setIndex(this.index);
      return item;
    }
    reload(item, options = {}) {
      this.clear();
      this.add(item, options);
    }
    plotItems(options = {}) {
    }
    reposition(time = 70) {
      if (this._repositionDebounce) {
        clearTimeout(this._repositionDebounce);
      }
      this._repositionDebounce = setTimeout(() => {
        this.repositionItems();
      }, time);
    }
    repositionItems() {
      this.signal("onItemsRepositioned");
    }
    up(options = {}) {
      return this._attemptNavigation(-1, 1, options);
    }
    down(options = {}) {
      return this._attemptNavigation(1, 1, options);
    }
    left(options = {}) {
      return this._attemptNavigation(-1, 0, options);
    }
    right(options = {}) {
      return this._attemptNavigation(1, 0, options);
    }
    first(options = {}) {
      return this.setIndex(0, options);
    }
    last(options = {}) {
      return this.setIndex(this._items.length - 1, options);
    }
    next(options = {}) {
      return this.setIndex(this._index + 1, options);
    }
    previous(options = {}) {
      return this.setIndex(this._index - 1, options);
    }
    _attemptNavigation(shift, direction, options = {}) {
      if (this.hasItems) {
        return this.navigate(shift, direction, options);
      }
      return false;
    }
    navigate(shift, direction = this._direction, options = {}) {
      if (direction !== this._direction) {
        return false;
      }
      return this.setIndex(this._index + shift, options);
    }
    scrollCollectionWrapper(obj, options = {}) {
      const { immediate = false } = options;
      let { previousIndex: previous, index: target, dataLength: max, mainIndex, previousMainIndex, lines } = obj;
      if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
        previous = previousMainIndex;
        target = mainIndex;
        max = lines;
      }
      const { directionIsRow, main, mainDim, mainMarginFrom, mainMarginTo } = this._getPlotProperties(this._direction);
      const cw = this.currentItemWrapper;
      let bound = this[mainDim];
      if (bound === 0) {
        bound = directionIsRow ? 1920 : 1080;
      }
      const offset = Math.min(this.wrapper[main], this._scrollTransition && this._scrollTransition.targetValue || 0);
      const sizes = this._getItemSizes(cw);
      const marginFrom = sizes[mainMarginFrom] || sizes.margin || 0;
      const marginTo = sizes[mainMarginTo] || sizes.margin || 0;
      let scroll = this._scroll;
      if (!isNaN(scroll)) {
        if (scroll >= 0 && scroll <= 1) {
          scroll = bound * scroll - (cw[main] + cw[mainDim] * scroll);
        } else {
          scroll = scroll - cw[main];
        }
      } else if (typeof scroll === "function") {
        scroll = scroll.apply(this, [cw, obj]);
      } else if (typeof scroll === "object") {
        const { jump = false, after = false, backward = 0, forward = 1 } = scroll;
        if (jump) {
          let mod = target % jump;
          if (mod === 0) {
            scroll = marginFrom - cw[main];
          }
          if (mod === jump - 1) {
            const actualSize = marginFrom + cw[mainDim] + marginTo;
            scroll = mod * actualSize + marginFrom - cw[main];
          }
        } else if (after) {
          scroll = 0;
          if (target >= after - 1) {
            const actualSize = marginFrom + cw[mainDim] + marginTo;
            scroll = (after - 1) * actualSize + marginFrom - cw[main];
          }
        } else {
          const backwardBound = bound * this._normalizePixelToPercentage(backward, bound);
          const forwardBound = bound * this._normalizePixelToPercentage(forward, bound);
          if (target < max - 1 && (previous < target && offset + cw[main] + cw[mainDim] > forwardBound)) {
            scroll = forwardBound - (cw[main] + cw[mainDim]);
          } else if (target > 0 && (target < previous && offset + cw[main] < backwardBound)) {
            scroll = backwardBound - cw[main];
          } else if (target === max - 1) {
            scroll = bound - (cw[main] + cw[mainDim]);
          } else if (target === 0) {
            scroll = marginFrom - cw[main];
          }
        }
      } else if (isNaN(scroll)) {
        if (previous < target && offset + cw[main] + cw[mainDim] > bound) {
          scroll = bound - (cw[main] + cw[mainDim]);
        } else if (target < previous && offset + cw[main] < 0) {
          scroll = marginFrom - cw[main];
        }
      }
      if (this.active && !isNaN(scroll) && this._scrollTransition) {
        if (immediate) {
          this._scrollTransition.reset(scroll, 1);
        } else {
          if (this._scrollTransition.isRunning()) {
            this._scrollTransition.reset(scroll, 0.05);
          } else {
            this._scrollTransition.start(scroll);
          }
        }
      } else if (!isNaN(scroll)) {
        this.wrapper[main] = scroll;
        if (this._scrollTransition) {
          this._scrollTransition.reset(scroll, 1);
        }
      }
    }
    $childInactive({ child }) {
      if (typeof child === "object") {
        const index = child.componentIndex;
        for (let key in this._items[index]) {
          if (child.component[key] !== void 0) {
            this._items[index][key] = child.component[key];
          }
        }
      }
      this._collectGarbage();
    }
    $getChildComponent({ index }) {
      return this._items[index];
    }
    _resizeWrapper(crossSize) {
      let obj = crossSize;
      if (!isNaN(crossSize)) {
        const { main, mainDim, crossDim } = this._getPlotProperties(this._direction);
        const lastItem = this.wrapper.childList.last;
        obj = {
          [mainDim]: lastItem[main] + lastItem[mainDim],
          [crossDim]: crossSize
        };
      }
      this.wrapper.patch(obj);
      if (this._autoResize) {
        this.patch(obj);
      }
    }
    _generateUniqueID() {
      let id = "";
      while (this._uids[id] || id === "") {
        id = Math.random().toString(36).substring(2, 9);
      }
      this._uids[id] = true;
      return id;
    }
    _getPlotProperties(direction) {
      const directionIsRow = direction === 0;
      return {
        directionIsRow: directionIsRow ? true : false,
        mainDirection: directionIsRow ? "rows" : "columns",
        main: directionIsRow ? "x" : "y",
        mainDim: directionIsRow ? "w" : "h",
        mainMarginTo: directionIsRow ? "marginRight" : "marginBottom",
        mainMarginFrom: directionIsRow ? "marginLeft" : "marginTop",
        crossDirection: !directionIsRow ? "columns" : "rows",
        cross: directionIsRow ? "y" : "x",
        crossDim: directionIsRow ? "h" : "w",
        crossMarginTo: directionIsRow ? "marginBottom" : "marginRight",
        crossMarginFrom: directionIsRow ? "marginTop" : "marginLeft"
      };
    }
    _getItemSizes(item) {
      const itemType = item.type;
      if (item.component && item.component.__attached) {
        item = item.component;
      }
      return {
        w: item.w || itemType && itemType["width"],
        h: item.h || itemType && itemType["height"],
        margin: item.margin || itemType && itemType["margin"] || 0,
        marginLeft: item.marginLeft || itemType && itemType["marginLeft"],
        marginRight: item.marginRight || itemType && itemType["marginRight"],
        marginTop: item.marginTop || itemType && itemType["marginTop"],
        marginBottom: item.marginBottom || itemType && itemType["marginBottom"]
      };
    }
    _collectGarbage(immediate) {
      this._gcIncrement++;
      if (immediate || this.active && this._gcThreshold !== 0 && this._gcIncrement >= this._gcThreshold) {
        this._gcIncrement = 0;
        this.stage.gc();
      }
    }
    _normalizeDataItems(array) {
      return array.map((item, index) => {
        return this._normalizeDataItem(item) || index;
      }).filter((item) => {
        if (!isNaN(item)) {
          console.warn(`Item at index: ${item}, is not a valid item. Removing it from dataset`);
          return false;
        }
        return true;
      });
    }
    _normalizeDataItem(item, index) {
      if (typeof item === "string" || typeof item === "number") {
        item = { label: item.toString() };
      }
      if (typeof item === "object") {
        let id = this._generateUniqueID();
        return __spreadValues({ assignedID: id, type: this.itemType, collectionWrapper: this, isAlive: false }, item);
      }
      return index;
    }
    _normalizePixelToPercentage(value, max) {
      if (value && value > 1) {
        return value / max;
      }
      return value || 0;
    }
    _getFocused() {
      if (this.hasItems) {
        return this.currentItemWrapper;
      }
      return this;
    }
    _handleRight() {
      return this.right();
    }
    _handleLeft() {
      return this.left();
    }
    _handleUp() {
      return this.up();
    }
    _handleDown() {
      return this.down();
    }
    _inactive() {
      if (this._repositionDebounce) {
        clearTimeout(this._repositionDebounce);
      }
      this._collectGarbage(true);
    }
    static get itemType() {
      return void 0;
    }
    set forceLoad(bool) {
      this._forceLoad = bool;
    }
    get forceLoad() {
      return this._forceLoad;
    }
    get requestingItems() {
      return this._requestingItems;
    }
    set requestThreshold(num) {
      this._requestThreshold = num;
    }
    get requestThreshold() {
      return this._requestThreshold;
    }
    set enableRequests(bool) {
      this._requestsEnabled = bool;
    }
    get enableRequests() {
      return this._requestsEnabled;
    }
    set gcThreshold(num) {
      this._gcThreshold = num;
    }
    get gcThreshold() {
      return this._gcThreshold;
    }
    get wrapper() {
      return this.tag("Wrapper");
    }
    get hasItems() {
      return this.wrapper && this.wrapper.children && this.wrapper.children.length > 0;
    }
    get currentItemWrapper() {
      return this.wrapper.children[this._index];
    }
    get currentItem() {
      return this.currentItemWrapper && this.currentItemWrapper.component || void 0;
    }
    set direction(string) {
      this._direction = _CollectionWrapper.DIRECTION[string] || _CollectionWrapper.DIRECTION.row;
    }
    get direction() {
      return Object.keys(_CollectionWrapper.DIRECTION)[this._direction];
    }
    set items(array) {
      this.clear();
      this.add(array);
    }
    get items() {
      const itemWrappers = this.itemWrappers;
      return this._items.map((item, index) => {
        if (itemWrappers[index] && itemWrappers[index].component.isAlive) {
          return itemWrappers[index].component;
        }
        return item;
      });
    }
    get length() {
      return this._items.length;
    }
    set index(index) {
      this.setIndex(index);
    }
    get itemWrappers() {
      return this.wrapper.children;
    }
    get index() {
      return this._index;
    }
    set scrollTransition(obj) {
      this._scrollTransitionSettings.patch(obj);
      if (this.active) {
        this._updateScrollTransition();
      }
    }
    get scrollTransition() {
      return this._scrollTransition;
    }
    set scroll(value) {
      this._scroll = value;
    }
    get scroll() {
      return this._scroll;
    }
    set autoResize(bool) {
      this._autoResize = bool;
    }
    get autoResize() {
      return this._autoResize;
    }
    set spacing(num) {
      this._spacing = num;
    }
    get spacing() {
      return this._spacing;
    }
  };
  CollectionWrapper.DIRECTION = {
    row: 0,
    column: 1
  };

  // node_modules/@lightningjs/ui/src/helpers/Cursor.js
  var Cursor = class extends src_default.Component {
    static _template() {
      return {
        alpha: 0
      };
    }
    _construct() {
      this._blink = true;
    }
    _init() {
      this._blinkAnimation = this.animation({ duration: 1, repeat: -1, actions: [
        { p: "alpha", v: { 0: 0, 0.5: 1, 1: 0 } }
      ] });
    }
    show() {
      if (this._blink) {
        this._blinkAnimation.start();
      } else {
        this.alpha = 1;
      }
    }
    hide() {
      if (this._blink) {
        this._blinkAnimation.stop();
      } else {
        this.alpha = 0;
      }
    }
    set blink(bool) {
      this._blink = bool;
      if (this.active) {
        if (bool) {
          this.show();
        } else {
          this.hide();
        }
      }
    }
    get blink() {
      return this._blink;
    }
  };

  // node_modules/@lightningjs/ui/src/helpers/ItemWrapper.js
  var ItemWrapper = class extends src_default.Component {
    static _template() {
      return {
        clipbox: true
      };
    }
    create() {
      if (this.children.length > 0) {
        return;
      }
      const component = this.fireAncestors("$getChildComponent", { index: this.componentIndex });
      component.isAlive = true;
      const { w, h, margin, marginTop, marginBottom, marginRight, marginLeft } = this;
      this.children = [__spreadProps(__spreadValues({}, component), { w, h, margin, marginTop, marginRight, marginLeft, marginBottom })];
      if (this.hasFocus()) {
        this._refocus();
      }
    }
    get component() {
      return this.children[0] || this.fireAncestors("$getChildComponent", { index: this.componentIndex });
    }
    _setup() {
      if (this.forceLoad) {
        this.create();
      }
    }
    _active() {
      this.create();
    }
    _inactive() {
      if (!this.forceLoad) {
        this.children[0].isAlive = false;
        this.fireAncestors("$childInactive", { child: this });
        this.childList.clear();
      }
    }
    _getFocused() {
      return this.children && this.children[0] || this;
    }
  };

  // node_modules/@lightningjs/ui/src/helpers/KeyWrapper.js
  var KeyWrapper = class extends src_default.Component {
    static _template() {
      return {
        clipbox: true
      };
    }
    _update() {
      let currentKey = this.children && this.children[0];
      if (currentKey && currentKey.action === this._key.data.action) {
        currentKey.patch(__spreadValues({}, this._key));
      } else {
        this.children = [__spreadValues({ type: this._key.keyType }, this._key)];
      }
      if (this.hasFocus()) {
        this._refocus();
      }
    }
    set key(obj) {
      this._key = obj;
      if (this.active) {
        this._update();
      }
    }
    get key() {
      return this._key;
    }
    _active() {
      this._update();
    }
    _inactive() {
      this.childList.clear();
    }
    _getFocused() {
      return this.children && this.children[0] || this;
    }
  };

  // node_modules/@lightningjs/ui/src/helpers/index.js
  var limitWithinRange = (num, min, max) => {
    return Math.min(Math.max(num, min), max);
  };
  var defineProperties = (component, props) => {
    props.forEach((prop) => {
      Object.defineProperty(component, prop, {
        set: function(value) {
          component[`_${prop}`] = value;
        },
        get: function() {
          return component[`_${prop}`];
        }
      });
    });
  };
  var findIndexOfObject = (array, search, targetProp) => {
    for (let i = 0; i < array.length; i++) {
      if (array[i][targetProp] === search) {
        return i;
      }
    }
    return -1;
  };

  // node_modules/@lightningjs/ui/src/Carousel.js
  var Carousel = class extends CollectionWrapper {
    static _template() {
      return {
        Wrapper: {}
      };
    }
    _construct() {
      super._construct();
      this._scroll = 0.5;
      this._scrollOffsetStart = 0;
      this._scrollOffsetEnd = 0;
      this._tresholdStart = 400;
      this._tresholdEnd = 400;
      this._dataIndex = -1;
    }
    clear() {
      super.clear();
      this._dataIndex = 0;
    }
    _normalizeDataIndex(index, items = this._items) {
      if (index > items.length - 1) {
        return 0;
      } else if (index < 0) {
        return items.length - 1;
      }
      return index;
    }
    plotItems() {
      const items = this._items;
      const wrapper = this.wrapper;
      const { main, mainDim, mainMarginFrom, mainMarginTo, cross, crossDim } = this._getPlotProperties(this._direction);
      const viewBound = this[mainDim];
      let crossPos = 0, crossSize = 0;
      const scroll = this._scroll;
      const scrollIsAnchored = !isNaN(scroll);
      const scrollAnchor = scrollIsAnchored ? scroll > 1 ? this._normalizePixelToPercentage(scroll) : scroll : null;
      const scrollOffsetStart = 0;
      const positiveHalf = [];
      const negativeHalf = [];
      const itemIndex = this._index;
      let isFirst = true;
      let index = itemIndex;
      let position = scrollOffsetStart;
      let currentDataIndex = null;
      if (this.currentItemWrapper) {
        currentDataIndex = this.currentItemWrapper.componentIndex;
      }
      while (viewBound - scrollOffsetStart + this._tresholdEnd > position) {
        const item = items[index];
        const sizes = this._getItemSizes(item);
        if (isFirst && scrollIsAnchored) {
          isFirst = false;
          position = (viewBound - sizes[mainDim]) * scrollAnchor;
        } else {
          position += sizes[mainMarginFrom] || sizes.margin || 0;
        }
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        positiveHalf.push(__spreadProps(__spreadValues({
          type: ItemWrapper,
          componentIndex: index,
          forceLoad: this._forceLoad
        }, sizes), {
          [`assigned${main.toUpperCase()}`]: position,
          [`assigned${cross.toUpperCase()}`]: crossPos,
          [main]: position,
          [cross]: crossPos
        }));
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
        index = this._normalizeDataIndex(index + 1, items);
      }
      position = positiveHalf[0][main] - (positiveHalf[0][mainMarginFrom] || positiveHalf[0].margin);
      index = itemIndex > 0 ? itemIndex - 1 : items.length - 1;
      let lastWidth = 0;
      while (-(scrollOffsetStart + this._tresholdStart) < position + lastWidth) {
        const item = items[index];
        const sizes = this._getItemSizes(item);
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        position -= sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
        negativeHalf.push(__spreadProps(__spreadValues({
          componentIndex: index,
          type: ItemWrapper
        }, sizes), {
          [`assigned${main.toUpperCase()}`]: position,
          [`assigned${cross.toUpperCase()}`]: crossPos,
          [main]: position,
          [cross]: crossPos
        }));
        lastWidth = sizes[mainDim];
        position -= sizes[mainMarginFrom] || sizes.margin;
        index = this._normalizeDataIndex(index - 1, items);
      }
      this._index = negativeHalf.length;
      const previousDataIndex = this._dataIndex;
      this._dataIndex = currentDataIndex || 0;
      wrapper.children = [...negativeHalf.reverse(), ...positiveHalf];
      this._indexChanged({ previousIndex: previousDataIndex, index: this._dataIndex, dataLength: this._items.length });
    }
    repositionItems() {
      const children = this.wrapper.children;
      const begin = children.slice(0, this._index);
      const end = children.slice(this._index + 1);
      const { main, mainDim, mainMarginFrom, mainMarginTo, cross, crossDim } = this._getPlotProperties(this._direction);
      let crossPos = 0, crossSize = 0;
      const scroll = this._scroll;
      const scrollIsAnchored = !isNaN(scroll);
      const scrollAnchor = scrollIsAnchored ? scroll > 1 ? this._normalizePixelToPercentage(scroll) : scroll : null;
      const focusedItem = children[this._index];
      let position = focusedItem[main] + (focusedItem[mainDim] - focusedItem.component[mainDim]) * scrollAnchor;
      const focusedItemSizes = this._getItemSizes(focusedItem);
      focusedItem.patch(__spreadProps(__spreadValues({}, focusedItemSizes), {
        [`assigned${main.toUpperCase()}`]: position,
        [`assigned${cross.toUpperCase()}`]: crossPos,
        [main]: position,
        [cross]: crossPos
      }));
      position = focusedItem[main] - (focusedItem[mainMarginFrom] || focusedItem.margin);
      begin.reverse().forEach((item) => {
        const sizes = this._getItemSizes(item);
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        position -= sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
        item.patch(__spreadProps(__spreadValues({}, sizes), {
          [`assigned${main.toUpperCase()}`]: position,
          [`assigned${cross.toUpperCase()}`]: crossPos,
          [main]: position,
          [cross]: crossPos
        }));
      });
      position = focusedItem[main] + focusedItem[mainDim] + (focusedItem[mainMarginTo] || focusedItem.margin || this._spacing);
      end.forEach((item) => {
        const sizes = this._getItemSizes(item);
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        item.patch(__spreadProps(__spreadValues({}, sizes), {
          [`assigned${main.toUpperCase()}`]: position,
          [`assigned${cross.toUpperCase()}`]: crossPos,
          [main]: position,
          [cross]: crossPos
        }));
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
      });
    }
    navigate(shift, orientation = this._direction) {
      if (orientation !== this._direction) {
        return false;
      }
      this._cleanUp();
      const targetIndex = this._index + shift;
      const childList = this.wrapper.childList;
      const { main, mainDim, mainMarginFrom, mainMarginTo } = this._getPlotProperties(this._direction);
      const currentDataIndex = this.currentItemWrapper.componentIndex;
      let referenceItem = childList.last;
      if (shift < 0) {
        referenceItem = childList.first;
      }
      const targetDataIndex = this._normalizeDataIndex(referenceItem.componentIndex + shift);
      const targetItem = this._items[targetDataIndex];
      const sizes = this._getItemSizes(targetItem);
      let position = referenceItem[main] + (referenceItem[mainMarginFrom] || sizes.margin) + referenceItem[mainDim] + (sizes[mainMarginTo] || sizes.margin || this.spacing);
      if (shift < 0) {
        position = referenceItem[main] - (referenceItem[mainMarginTo] || sizes.margin) - (sizes[mainDim] + (sizes[mainMarginFrom] || sizes.margin || this._spacing));
      }
      const child = this.stage.c(__spreadProps(__spreadValues({
        type: ItemWrapper,
        componentIndex: targetDataIndex,
        forceLoad: this._forceLoad
      }, sizes), {
        [main]: position
      }));
      childList.addAt(child, shift > 0 ? childList.length : 0);
      const newDataIndex = currentDataIndex + shift;
      if (shift > 0) {
        this._index = targetIndex;
        if (newDataIndex >= 0 && newDataIndex > this._items.length - 1) {
          this._dataIndex = 0;
        } else {
          this._dataIndex = newDataIndex;
        }
      } else {
        this._dataIndex = newDataIndex >= 0 ? newDataIndex : this._items.length - 1;
      }
      this._indexChanged({ previousIndex: currentDataIndex, index: this._dataIndex, dataLength: this._items.length });
      return true;
    }
    setIndex(index) {
      this._index = index;
      this.plotItems();
      return true;
    }
    addAt(item, index = this._items.length) {
      if (index >= 0 && index <= this._items.length) {
        if (!Array.isArray(item)) {
          item = [item];
        }
        const items = this._normalizeDataItems(item);
        this._items.splice(index, 0, ...items);
        this.plotItems();
      } else {
        throw new Error("addAt: The index " + index + " is out of bounds " + this._items.length);
      }
    }
    _cleanUp(time = 500) {
      if (this._cleanUpDebounce) {
        clearTimeout(this._cleanUpDebounce);
      }
      this._cleanUpDebounce = setTimeout(() => {
        const children = this.wrapper.children;
        const { main, mainDim, directionIsRow } = this._getPlotProperties(this._direction);
        const bound = this[mainDim];
        const viewboundMain = directionIsRow ? 1920 : 1080;
        const offset = this.wrapper[main];
        const boundStart = -viewboundMain * 0.66;
        const boundEnd = bound + viewboundMain * 0.66;
        let rem = children.reduce((acc, child, index) => {
          if (offset + child[main] + child[mainDim] < boundStart || offset + child[main] > boundEnd) {
            acc.push(index);
          }
          return acc;
        }, []);
        if (rem.length > 0) {
          if (rem[0] === 0) {
            for (let i = 0; i < rem.length; i++) {
              if (!rem[i + 1] || rem[i + 1] - rem[i] !== 1) {
                this._index = this._index - (i + 1);
                break;
              }
            }
          }
          rem.sort((a, b) => a - b).reverse().forEach((index) => {
            this.wrapper.childList.removeAt(index);
          });
        }
      }, time);
    }
    _inactive() {
      this._cleanUp(0);
      super._inactive();
    }
    set index(index) {
      this.setIndex(index);
    }
    get index() {
      return this._dataIndex;
    }
    set threshold(num) {
      this._threshold = num;
      this._thresholdStart = num;
      this._thresholdEnd = num;
    }
    get threshold() {
      return this._threshold;
    }
    set thresholdStart(num) {
      this._thresholdStart = num;
    }
    get thresholdStart() {
      return this._thresholdStart;
    }
    set thresholdEnd(num) {
      this._thresholdEnd = num;
    }
    get thresholdEnd() {
      return this._tresholdEnd;
    }
  };

  // node_modules/@lightningjs/ui/src/InputField.js
  var InputField = class extends src_default.Component {
    static _template() {
      return {
        PreLabel: { renderOffscreen: true },
        PostLabel: { renderOffscreen: true },
        Cursor: { type: Cursor, rect: true, w: 4, h: 54, x: 0, y: 0 }
      };
    }
    _construct() {
      this._input = "";
      this._previousInput = "";
      this._description = "";
      this._cursorX = 0;
      this._cursorIndex = 0;
      this._passwordMask = "*";
      this._passwordMode = false;
      this._autoHideCursor = true;
      this._labelPositionStatic = true;
      this._maxLabelWidth = 0;
    }
    _init() {
      this.tag("PreLabel").on("txLoaded", () => {
        this._labelTxLoaded();
      });
      this.tag("PostLabel").on("txLoaded", () => {
        this._labelTxLoaded;
      });
    }
    onInputChanged({ input = "" }) {
      let targetIndex = Math.max(input.length - this._input.length + this._cursorIndex, 0);
      this._input = input;
      this._update(targetIndex);
    }
    toggleCursor(bool = !this._cursorVisible) {
      this._cursorVisible = bool;
      this.cursor[bool ? "show" : "hide"]();
    }
    _labelTxLoaded() {
      const preLabel = this.tag("PreLabel");
      const cursor = this.tag("Cursor");
      const postLabel = this.tag("PostLabel");
      this.h = preLabel.renderHeight || postLabel.renderHeight;
      cursor.x = preLabel.renderWidth + this._cursorX;
      postLabel.x = cursor.x + cursor.w * (1 - cursor.mountX);
      this.setSmooth("x", this._labelOffset);
      if (!this.autoHideCursor) {
        this.toggleCursor(true);
      }
    }
    _update(index = 0) {
      const hasInput = this._input.length > 0;
      let pre = this._description + "";
      let post = "";
      if (hasInput) {
        pre = this._input.substring(0, index);
        post = this._input.substring(index, this._input.length);
        if (this._passwordMode) {
          pre = this._passwordMask.repeat(pre.length);
          post = this._passwordMask.repeat(post.length);
        }
        this.toggleCursor(true);
      } else if (this._autoHideCursor) {
        this.toggleCursor(false);
      }
      this.patch({
        PreLabel: { text: { text: pre } },
        PostLabel: { text: { text: post } }
      });
      if (this.h === 0) {
        this.tag("PreLabel").loadTexture();
        this.h = this.tag("PreLabel").renderHeight;
      }
      this._cursorIndex = index;
    }
    _handleRight() {
      this._update(Math.min(this._input.length, this._cursorIndex + 1));
    }
    _handleLeft() {
      this._update(Math.max(0, this._cursorIndex - 1));
    }
    _firstActive() {
      this._labelTxLoaded();
      this._update();
    }
    get input() {
      return this._input;
    }
    get hasInput() {
      return this._input.length > 0;
    }
    get cursorIndex() {
      return this._cursorIndex;
    }
    set inputText(obj) {
      this._inputText = obj;
      this.tag("PreLabel").patch({ text: obj });
      this.tag("PostLabel").patch({ text: obj });
    }
    get inputText() {
      return this._inputText;
    }
    set description(str) {
      this._description = str;
    }
    get description() {
      return this._description;
    }
    set cursor(obj) {
      if (obj.x) {
        this._cursorX = obj.x;
        delete obj.x;
      }
      this.tag("Cursor").patch(obj);
    }
    get cursor() {
      return this.tag("Cursor");
    }
    get cursorVisible() {
      return this._cursorVisible;
    }
    set autoHideCursor(bool) {
      this._autoHideCursor = bool;
    }
    get autoHideCursor() {
      return this._autoHideCursor;
    }
    set passwordMode(val) {
      this._passwordMode = val;
    }
    get passwordMode() {
      return this._passwordMode;
    }
    set passwordMask(str) {
      this._passwordMask = str;
    }
    get passwordmask() {
      return this._passwordMask;
    }
    // the width at which the text start scrolling
    set maxLabelWidth(val) {
      this._maxLabelWidth = val;
    }
    get maxLabelWidth() {
      return this._maxLabelWidth;
    }
    set labelPositionStatic(val) {
      this._labelPositionStatic = val;
    }
    get labelPositionStatic() {
      return this._labelPositionStatic;
    }
    get _labelOffset() {
      if (this._labelPositionStatic) return 0;
      let offset = this.maxLabelWidth - this.tag("Cursor").x;
      return offset < 0 ? offset : 0;
    }
  };

  // node_modules/@lightningjs/ui/src/Key.js
  var Key = class extends src_default.Component {
    static _template() {
      return {
        Background: {
          w: (w) => w,
          h: (h) => h,
          rect: true
        },
        Label: {
          mount: 0.5,
          x: (w) => w / 2,
          y: (h) => h / 2
        }
      };
    }
    _construct() {
      this._backgroundColors = {};
      this._labelColors = {};
    }
    set data(obj) {
      this._data = obj;
      this._update();
    }
    get data() {
      return this._data;
    }
    set labelText(obj) {
      this._labelText = obj;
      this.tag("Label").patch({ text: obj });
    }
    get labelText() {
      return this._labelText;
    }
    set label(obj) {
      this.tag("Label").patch(obj);
    }
    get label() {
      return this.tag("Label");
    }
    set labelColors(obj) {
      this._labelColors = obj;
      this._update();
    }
    get labelColors() {
      return this._labelColors;
    }
    set backgroundColors(obj) {
      this._backgroundColors = obj;
      this._update();
    }
    get backgroundColors() {
      return this._backgroundColors;
    }
    set background(obj) {
      this.tag("Background").patch(obj);
    }
    get background() {
      return this.tag("Background");
    }
    _update() {
      if (!this.active) {
        return;
      }
      const { label = "" } = this._data;
      const hasFocus = this.hasFocus();
      let { focused, unfocused = 4278190080 } = this._backgroundColors;
      let { focused: labelFocused, unfocused: labelUnfocused = 4294967295 } = this._labelColors;
      this.patch({
        Background: { color: hasFocus && focused ? focused : unfocused },
        Label: { text: { text: label }, color: hasFocus && labelFocused ? labelFocused : labelUnfocused }
      });
    }
    _firstActive() {
      this._update();
    }
    _focus() {
      let { focused, unfocused = 4278190080 } = this._backgroundColors;
      let { focused: labelFocused, unfocused: labelUnfocused = 4294967295 } = this._labelColors;
      this.patch({
        Background: { smooth: { color: focused || unfocused } },
        Label: { smooth: { color: labelFocused || labelUnfocused } }
      });
    }
    _unfocus() {
      let { unfocused = 4278190080 } = this._backgroundColors;
      let { unfocused: labelUnfocused = 4294967295 } = this._labelColors;
      this.patch({
        Background: { smooth: { color: unfocused } },
        Label: { smooth: { color: labelUnfocused } }
      });
    }
    static get width() {
      return 80;
    }
    static get height() {
      return 80;
    }
  };

  // node_modules/@lightningjs/ui/src/Keyboard.js
  var Keyboard = class extends src_default.Component {
    static _template() {
      return {
        Keys: { w: (w) => w }
      };
    }
    _construct() {
      this._input = "";
      this._inputField = void 0;
      this._maxCharacters = 56;
      this.navigationWrapAround = false;
      this._snapToRow = false;
      this.resetFocus();
    }
    resetFocus() {
      this._columnIndex = 0;
      this._rowIndex = 0;
      this._previousKey = null;
    }
    _setup() {
      this._keys = this.tag("Keys");
      this._update();
    }
    _update() {
      const { layouts, buttonTypes = {}, styling = {} } = this._config;
      if (!this._layout || this._layout && layouts[this._layout] === void 0) {
        console.error(`Configured layout "${this._layout}" does not exist. Picking first available: "${Object.keys(layouts)[0]}"`);
        this._layout = Object.keys(layouts)[0];
      }
      const { horizontalSpacing = 0, verticalSpacing = 0, align = "left" } = styling;
      let rowPosition = 0;
      const isEvent = /^[A-Z][A-Za-z0-9]{1}/;
      const hasLabel = /\:/;
      if (buttonTypes.default === void 0) {
        buttonTypes.default = Key;
      }
      this._keys.children = layouts[this._layout].map((row, rowIndex) => {
        const {
          x = 0,
          margin = 0,
          marginRight,
          marginLeft,
          marginTop,
          marginBottom,
          spacing: rowHorizontalSpacing = horizontalSpacing || 0,
          align: rowAlign = align
        } = styling[`Row${rowIndex + 1}`] || {};
        let keyPosition = 0;
        let rowHeight = 0;
        const rowKeys = row.map((key, keyIndex) => {
          const origin = key;
          let keyType = buttonTypes.default;
          let action = "Input";
          let label = key;
          if (isEvent.test(key)) {
            if (hasLabel.test(key)) {
              key = key.split(":");
              label = key[1].toString();
              key = key[0];
            }
            if (buttonTypes[key]) {
              keyType = buttonTypes[key];
              action = key.action || key;
            }
          }
          let keySpacing = keyType && keyType.margin || 0;
          let w = 0;
          let h = 0;
          let marginLeft2 = 0;
          let marginRight2 = rowHorizontalSpacing;
          if (keyType.type) {
            keySpacing = keyType.type.margin || keySpacing;
            w = keyType.type.width || w;
            h = keyType.type.height || h;
            marginLeft2 = keyType.type.marginLeft || marginLeft2;
            marginRight2 = keyType.type.marginRight || marginRight2;
          }
          w = keyType.w || w;
          h = keyType.h || h;
          rowHeight = h > rowHeight ? h : rowHeight;
          const currentPosition2 = keyPosition + marginLeft2;
          keyPosition += marginLeft2 + w + marginRight2;
          return { ref: `Key-{${keyIndex + 1}}`, type: KeyWrapper, keyboard: this, x: currentPosition2, w, h, key: __spreadValues({ data: { origin, key, label, action }, w, h }, keyType) };
        });
        let rowOffset = x + (marginLeft || margin);
        let rowMount = 0;
        if (this.w && rowAlign === "center") {
          rowOffset = this.w / 2;
          rowMount = 0.5;
        }
        if (this.w && rowAlign === "right") {
          rowOffset = this.w - (marginRight || margin);
          rowMount = 1;
        }
        const currentPosition = rowPosition + (marginTop || margin);
        rowPosition = currentPosition + rowHeight + (marginBottom || margin || verticalSpacing);
        return {
          ref: `Row-${rowIndex + 1}`,
          x: rowOffset,
          mountX: rowMount,
          w: keyPosition,
          y: currentPosition,
          children: rowKeys
        };
      });
      this._refocus();
    }
    _getFocused() {
      return this.currentKeyWrapper || this;
    }
    _handleRight() {
      return this.navigate("row", 1);
    }
    _handleLeft() {
      return this.navigate("row", -1);
    }
    _handleUp() {
      return this.navigate("column", -1);
    }
    _handleDown() {
      return this.navigate("column", 1);
    }
    _handleKey({ key, code = "CustomKey" }) {
      if (code === "Backspace" && this._input.length === 0) {
        return false;
      }
      if (key === " ") {
        key = "Space";
      }
      const targetFound = this._findKey(key);
      if (targetFound) {
        this._handleEnter();
      }
      return targetFound;
    }
    _findKey(str) {
      const rows = this._config.layouts[this._layout];
      let i = 0, j = 0;
      for (; i < rows.length; i++) {
        for (j = 0; j < rows[i].length; j++) {
          let key = rows[i][j];
          if (str.length > 1 && key.indexOf(str) > -1 || key.toUpperCase() === str.toUpperCase()) {
            this._rowIndex = i;
            this._columnIndex = j;
            return true;
          }
        }
      }
      return false;
    }
    _handleEnter() {
      const { origin, action } = this.currentKey.data;
      const event = {
        index: this._input.length,
        key: origin
      };
      if (this._inputField && this._inputField.cursorIndex) {
        event.index = this._inputField.cursorIndex;
      }
      if (action !== "Input") {
        const split = event.key.split(":");
        const call = `on${split[0]}`;
        const eventFunction = this[call];
        event.key = split[1];
        if (eventFunction && eventFunction.apply && eventFunction.call) {
          eventFunction.call(this, event);
        }
        this.signal(call, __spreadValues({ input: this._input, keyboard: this }, event));
      } else {
        this.addAt(event.key, event.index);
      }
    }
    _changeInput(input) {
      if (input.length > this._maxCharacters) {
        return;
      }
      const eventData = {
        previousInput: this._input,
        input: this._input = input
      };
      if (this._inputField && this._inputField.onInputChanged) {
        this._inputField.onInputChanged(eventData);
      }
      this.signal("onInputChanged", eventData);
    }
    focus(str) {
      this._findKey(str);
    }
    add(str) {
      this._changeInput(this._input + str);
    }
    addAt(str, index) {
      if (index > this._input.length - 1) {
        this.add(str);
      } else if (index > -1) {
        this._changeInput(this._input.substring(0, index) + str + this._input.substring(index, this._input.length));
      }
    }
    remove() {
      this._changeInput(this._input.substring(0, this._input.length - 1));
    }
    removeAt(index) {
      if (index > this._input.length - 1) {
        this.remove();
      } else if (index > -1) {
        this._changeInput(this._input.substring(0, index - 1) + this._input.substring(index, this._input.length));
      }
    }
    clear() {
      this._changeInput("");
    }
    layout(key) {
      if (key === this._layout) {
        return;
      }
      this._layout = key;
      if (this.attached) {
        this.resetFocus();
        this._update();
      }
    }
    inputField(component) {
      if (component && component.isComponent) {
        this._rowIndex = 0;
        this._columnIndex = 0;
        this._input = component.input !== void 0 ? component.input : "";
        this._inputField = component;
      } else {
        this._rowIndex = 0;
        this._columnIndex = 0;
        this._input = "";
        this._inputField = void 0;
      }
    }
    _findKeyInRow(currentKey, currentRow, targetRow) {
      const currentX = currentRow.x - currentRow.w * currentRow.mountX + currentKey.x;
      const m = targetRow.children.map((key) => {
        const keyX = targetRow.x - targetRow.w * targetRow.mountX + key.x;
        if (keyX <= currentX && (this._snapToRow || currentX < keyX + key.w)) {
          return keyX + key.w - currentX;
        }
        if (keyX >= currentX && (this._snapToRow || keyX < currentX + currentKey.w)) {
          return currentX + currentKey.w - keyX;
        }
        return -1;
      });
      if (!this._snapToRow) {
        let acc = -1;
        let t2 = -1;
        for (let i = 0; i < m.length; i++) {
          if (m[i] === -1 && acc > -1) {
            break;
          }
          if (m[i] > acc) {
            acc = m[i];
            t2 = i;
          }
        }
        return t2;
      }
      let t = m.indexOf(currentKey.w);
      if (t === -1 && m.length > 0) {
        let acc = this.w;
        for (let i = 0; i < m.length; i++) {
          if (m[i] >= 0) {
            const cutoff = currentX + currentKey.w - currentX - m[i];
            if (cutoff < acc) {
              acc = cutoff;
              t = i;
            }
          }
        }
        if (t === -1) {
          acc = this.w;
          for (let i = 0; i < m.length; i++) {
            if (Math.abs(m[i]) < acc) {
              acc = Math.abs(m[i]);
              t = i;
            }
          }
        }
      }
      return t;
    }
    navigate(direction, shift) {
      const targetIndex = (direction === "row" ? this._columnIndex : this._rowIndex) + shift;
      const currentRow = this.rows[this._rowIndex];
      if (direction === "row" && targetIndex > -1 && targetIndex < currentRow.children.length) {
        this._previous = null;
        return this._columnIndex = targetIndex;
      } else if (direction === "row" && this.navigationWrapAround) {
        this._previous = null;
        let rowLen = currentRow.children.length;
        return this._columnIndex = (targetIndex % rowLen + rowLen) % rowLen;
      }
      if (direction === "column" && targetIndex > -1 && targetIndex < this.rows.length) {
        const currentRowIndex = this._rowIndex;
        const currentColumnIndex = this._columnIndex;
        if (this._previous && this._previous.row === targetIndex) {
          const tmp = this._previous.column;
          this._previous.column = this._columnIndex;
          this._columnIndex = tmp;
          this._rowIndex = this._previous.row;
        } else {
          const targetRow = this.rows[targetIndex];
          const currentKey = this.currentKeyWrapper;
          const currentRow2 = this.rows[this._rowIndex];
          let t = this._findKeyInRow(currentKey, currentRow2, targetRow);
          if (t > -1) {
            this._rowIndex = targetIndex;
            this._columnIndex = t;
          } else if (this.navigationWrapAround) {
            t = this._findKeyInRow(currentKey, currentRow2, this.rows[0]);
            this._columnIndex = t > -1 ? t : Math.min(this.rows[0].children.length - 1, this._columnIndex);
            return this._rowIndex = 0;
          }
        }
        if (this._rowIndex !== currentRowIndex) {
          this._previous = { column: currentColumnIndex, row: currentRowIndex };
          return this._rowIndex = targetIndex;
        }
      } else if (direction === "column" && this.navigationWrapAround) {
        this._previous = { column: this._columnIndex, row: this._rowIndex };
        let nrRows = this.rows.length;
        this._rowIndex = (targetIndex % nrRows + nrRows) % nrRows;
        this._columnIndex = Math.min(this.rows[this._rowIndex].children.length - 1, this._columnIndex);
      }
      return false;
    }
    onSpace({ index }) {
      this.addAt(" ", index);
    }
    onBackspace({ index }) {
      this.removeAt(index);
    }
    onClear() {
      this.clear();
    }
    onLayout({ key }) {
      this.layout(key);
    }
    set config(obj) {
      this._config = obj;
      if (this.active) {
        this._update();
      }
    }
    get config() {
      return this._config;
    }
    set currentInputField(component) {
      this.inputField(component);
    }
    get currentInputField() {
      return this._inputField;
    }
    set currentLayout(str) {
      this.layout(str);
    }
    get currentLayout() {
      return this._layout;
    }
    set maxCharacters(num) {
      this._maxCharacters = num;
    }
    get maxCharacters() {
      return this._maxCharacters;
    }
    set snapToRow(bool) {
      this._snapToRow = bool;
    }
    get snapToRow() {
      return true;
    }
    get rows() {
      return this._keys && this._keys.children;
    }
    get currentKeyWrapper() {
      return this.rows && this.rows[this._rowIndex] && this.rows[this._rowIndex].children[this._columnIndex];
    }
    get currentKey() {
      return this.currentKeyWrapper && this.currentKeyWrapper.key;
    }
  };

  // node_modules/@lightningjs/ui/src/List.js
  var List = class extends CollectionWrapper {
    plotItems(options = {}) {
      const { immediate = false } = options;
      const items = this._items;
      const wrapper = this.wrapper;
      const { directionIsRow, main, mainDim, mainMarginTo, mainMarginFrom, cross, crossDim } = this._getPlotProperties(this._direction);
      let crossPos = 0, crossSize = 0, position = 0;
      const animateItems = [];
      const viewboundMain = directionIsRow ? 1920 : 1080;
      const viewboundCross = directionIsRow ? 1080 : 1920;
      const renderContext = this.core.renderContext;
      const newChildren = items.map((item, index) => {
        const sizes = this._getItemSizes(item);
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        const ref = `IW-${item.assignedID}`;
        let mainPos = position;
        crossPos = item[cross] || crossPos;
        let tmp = mainPos;
        let tcp = crossPos;
        const existingItemWrapper = wrapper.tag(ref);
        if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext[`p${main}`] + wrapper[main] + mainPos <= viewboundMain || renderContext[`p${cross}`] + wrapper[cross] + crossPos <= viewboundCross))) {
          tmp = existingItemWrapper[main];
          tcp = existingItemWrapper[cross];
          animateItems.push(index);
        }
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
        return __spreadProps(__spreadValues({
          ref,
          type: ItemWrapper,
          componentIndex: index,
          forceLoad: this._forceLoad
        }, sizes), {
          [`assigned${main.toUpperCase()}`]: mainPos,
          [`assigned${cross.toUpperCase()}`]: crossPos,
          [main]: tmp,
          [cross]: tcp
        });
      });
      wrapper.children = newChildren;
      animateItems.forEach((index) => {
        const item = wrapper.children[index];
        if (immediate) {
          item.patch({ x: item.assignedX, y: item.assignedY });
        } else {
          item.patch({ smooth: { x: item.assignedX, y: item.assignedY } });
        }
      });
      this._resizeWrapper(crossSize);
    }
    repositionItems() {
      const wrapper = this.wrapper;
      if (!wrapper && wrapper.children.length) {
        return true;
      }
      const { main, mainDim, mainMarginTo, mainMarginFrom, cross, crossDim } = this._getPlotProperties(this._direction);
      let crossPos = 0, crossSize = 0, position = 0;
      wrapper.children.forEach((item) => {
        const sizes = this._getItemSizes(item);
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        crossPos = item[cross] || crossPos;
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        const mainPos = position;
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this.spacing);
        item.patch(__spreadValues({
          [`assigned${main.toUpperCase()}`]: mainPos,
          [`assigned${cross.toUpperCase()}`]: 0,
          [main]: mainPos,
          [cross]: crossPos
        }, sizes));
      });
      this._resizeWrapper(crossSize);
      super.repositionItems();
    }
  };

  // node_modules/@lightningjs/ui/src/ScrollingLabel.js
  var ScrollingLabel = class _ScrollingLabel extends src_default.Component {
    static _template() {
      return {
        LabelClipper: {
          w: (w) => w,
          rtt: true,
          shader: { type: src_default.shaders.FadeOut },
          LabelWrapper: {
            Label: { renderOffscreen: true },
            LabelCopy: { renderOffscreen: true }
          }
        }
      };
    }
    _construct() {
      this._autoStart = true;
      this._scrollAnimation = false;
      this._fade = 30;
      this._spacing = 30;
      this._label = {};
      this._align = "left";
      this._animationSettings = {
        delay: 0.7,
        repeat: -1,
        stopMethod: "immediate"
      };
    }
    _init() {
      const label = this.tag("Label");
      label.on("txLoaded", () => {
        this._update(label);
        this._updateAnimation(label);
        if (this._autoStart) {
          this.start();
        }
      });
    }
    _update(label = this.tag("Label")) {
      const renderWidth = label.renderWidth;
      const noScroll = renderWidth <= this.renderWidth;
      let labelPos = 0;
      if (noScroll && this._align !== "left") {
        labelPos = (this.renderWidth - renderWidth) * _ScrollingLabel.ALIGN[this._align];
      }
      this.tag("LabelClipper").patch({
        h: label.renderHeight,
        shader: {
          right: noScroll ? 0 : this._fade
        },
        LabelWrapper: {
          x: 0,
          Label: {
            x: labelPos
          },
          LabelCopy: {
            x: renderWidth + this._spacing
          }
        }
      });
    }
    _updateAnimation(label = this.tag("Label")) {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
      }
      if (label.renderWidth > this.renderWidth) {
        if (!this._animationSettings.duration) {
          this._animationSettings.duration = label.renderWidth / 50;
        }
        this._scrollAnimation = this.animation(__spreadProps(__spreadValues({}, this._animationSettings), {
          actions: [
            { t: "LabelWrapper", p: "x", v: { sm: 0, 0: 0, 1: -(label.renderWidth + this._spacing) } },
            { t: "LabelClipper", p: "shader.left", v: { 0: 0, 0.2: this._fade, 0.8: this._fade, 1: 0 } }
          ]
        }));
      }
    }
    start() {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this.tag("LabelCopy").patch({
          text: this._label
        });
        this._scrollAnimation.start();
      }
    }
    stop() {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this.tag("LabelCopy").text = "";
      }
    }
    set label(obj) {
      if (typeof obj === "string") {
        obj = { text: obj };
      }
      this._label = __spreadValues(__spreadValues({}, this._label), obj);
      this.tag("Label").patch({
        text: obj
      });
    }
    get label() {
      return this.tag("Label");
    }
    set align(pos) {
      this._align = pos;
    }
    get align() {
      return this._align;
    }
    set autoStart(bool) {
      this._autoStart = bool;
    }
    get autoStart() {
      return this._autoStart;
    }
    set repeat(num) {
      this.animationSettings = { repeat: num };
    }
    get repeat() {
      return this._animationSettings.repeat;
    }
    set delay(num) {
      this.animationSettings = { delay: num };
    }
    get delay() {
      return this._animationSettings.delay;
    }
    set duration(num) {
      this.animationSettings = { duration: num };
    }
    get duration() {
      return this._animationSettings.duration;
    }
    set animationSettings(obj) {
      this._animationSettings = __spreadValues(__spreadValues({}, this._animationSettings), obj);
      if (this._scrollAnimation) {
        this._updateAnimation();
      }
    }
    get animationSettings() {
      return this._animationSettings;
    }
  };
  ScrollingLabel.ALIGN = {
    left: 0,
    center: 0.5,
    right: 1
  };

  // node_modules/@lightningjs/ui/src/Stepper.js
  var calcCarouselNavigation = (dir, current, min, max) => {
    let target = current + dir;
    if (target < min) {
      target = max;
    }
    if (target > max) {
      target = min;
    }
    return target;
  };
  var Stepper = class extends src_default.Component {
    static _template() {
      return {
        h: 80,
        w: 574,
        Focus: { alpha: 0, w: (w) => w, h: (h) => h, rect: true },
        Label: { x: 30, y: (h) => h * 0.5, mountY: 0.5, text: { text: "", fontSize: 22 } },
        ValueWrapper: {
          x: (w) => w - 30,
          w: 200,
          h: (h) => h,
          mountX: 1,
          Value: { x: (w) => w * 0.5, y: (h) => h * 0.5, mountX: 0.5, mountY: 0.5, text: { text: "", fontSize: 22 } }
        }
      };
    }
    _construct() {
      this._focusColor = 4278227525;
      this._labelColor = 4288519581;
      this._labelColorFocused = 4294967295;
      this._padding = 30;
      this._max = 100;
      this._min = 0;
      this._value = 50;
      this._options = void 0;
      this._label = "label";
      this._focusAnimation = null;
      defineProperties(this, ["focusColor", "labelColor", "labelColorFocused", "padding", "max", "min", "focusAnimation"]);
    }
    _update() {
      this.patch({
        Focus: { color: this._focusColor },
        Label: { x: this._padding, color: this._labelColor, text: { text: this._label } },
        ValueWrapper: {
          x: (w) => w - this._padding,
          Value: { color: this._labelColor, text: { text: this.optionValue || this.value } }
        }
      });
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({ duration: 0.2, stopMethod: "reverse", actions: [
        { t: "Focus", p: "alpha", v: { 0: 0, 1: 1 } },
        { t: "Label", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } },
        { t: "ValueWrapper.Value", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } }
      ] });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      this._update();
    }
    _navigate(dir) {
      this.value = calcCarouselNavigation(dir, this._value, this._min, this._max);
      const event = {
        value: this._value
      };
      if (this._options) {
        event.options = this._options;
      }
      this.fireAncestors("$onValueChanged", event);
      this.signal("onValueChanged", event);
    }
    _handleLeft() {
      this._navigate(-1);
    }
    _handleRight() {
      this._navigate(1);
    }
    _focus() {
      if (this._focusAnimation) {
        this._focusAnimation.start();
      }
    }
    _unfocus() {
      if (this._focusAnimation) {
        this._focusAnimation.stop();
      }
    }
    set label(str) {
      this._label = str;
      if (this.active) {
        this.tag("Label").text.text = str;
      }
    }
    get label() {
      return this._label;
    }
    set value(str) {
      this._value = str;
      if (this.active) {
        this.tag("Value").text.text = this.optionValue || this._value;
      }
    }
    get value() {
      return this._value;
    }
    get optionValue() {
      return this._options && this._options[this._value] && this._options[this._value].label || void 0;
    }
    set options(arr) {
      const refactor = arr.map((option) => {
        if (typeof option === "string") {
          return { label: option };
        }
        return option;
      });
      this._value = 0;
      this._options = refactor;
      this._max = refactor.length - 1;
      this._update();
    }
    get options() {
      return this._options;
    }
  };

  // node_modules/@lightningjs/ui/src/ArrowStepper.js
  var ArrowStepper = class extends Stepper {
    static _template() {
      return __spreadProps(__spreadValues({}, super._template()), {
        ValueWrapper: {
          x: (w) => w - 30,
          w: 200,
          h: (h) => h,
          mountX: 1,
          ArrowLeft: { y: (h) => h * 0.5, mountY: 0.5 },
          Value: { x: (w) => w * 0.5, y: (h) => h * 0.5, mountX: 0.5, mountY: 0.5, text: { text: "", fontSize: 22 } },
          ArrowRight: { y: (h) => h * 0.5, x: (w) => w, mountY: 0.5, mountX: 1 }
        }
      });
    }
    _update() {
      this.patch({
        Focus: { color: this._focusColor },
        Label: { x: this._padding, color: this._labelColor, text: { text: this._label } },
        ValueWrapper: {
          x: (w) => w - this._padding,
          ArrowLeft: { color: this._labelColor },
          Value: { color: this._labelColor, text: { text: this.optionValue || this.value } },
          ArrowRight: { color: this._labelColor }
        }
      });
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({ duration: 0.2, stopMethod: "reverse", actions: [
        { t: "Focus", p: "alpha", v: { 0: 0, 1: 1 } },
        { t: "ValueWrapper.ArrowLeft", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } },
        { t: "ValueWrapper.Value", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } },
        { t: "ValueWrapper.ArrowRight", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } }
      ] });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      const arrowLeft = this.tag("ArrowLeft");
      const arrowRight = this.tag("ArrowRight");
      if (!(arrowLeft.src !== void 0 && arrowLeft.text !== null)) {
        arrowLeft.text = { text: "\u25C0", fontSize: 18 };
      }
      if (!(arrowRight.src !== void 0 && arrowRight.text !== null)) {
        arrowRight.text = { text: "\u25B6", fontSize: 18 };
      }
      this._update();
    }
  };

  // node_modules/@lightningjs/ui/src/ColorShift.js
  var ColorShift2 = class extends src_default.Component {
    static _template() {
      return {
        w: 574,
        h: 240,
        List: { type: List, w: (w) => w, h: (h) => h, forceLoad: true, spacing: 0, direction: "column" }
      };
    }
    _construct() {
      this._autoColorShift = true;
      this._focusColor = 4278227525;
      this._labelColor = 4288519581;
      this._labelColorFocused = 4294967295;
      this._options = [
        {
          type: "neutral",
          label: "normal"
        },
        {
          type: "protanopia",
          label: "Protanopia"
        },
        {
          type: "deuteranopia",
          label: "Deuteranopia"
        },
        {
          type: "tritanopia",
          label: "Tritanopia"
        },
        {
          type: "monochromacy",
          label: "Achromatopsia"
        }
      ];
      defineProperties(this, ["focusColor", "labelColor", "labelColorFocused", "options", "autoColorShift"]);
    }
    _getFocused() {
      return this.tag("List");
    }
    _shiftColors() {
      if (this._autoColorShift && (this.application && this.application.colorshift)) {
        this.application.colorshift(this._settings.correction, this._settings);
      }
    }
    $onValueChanged() {
      const listItems = this.tag("List").items;
      const correction = listItems[0];
      this._settings = {
        correction: correction.options[correction.value].type,
        brightness: listItems[1].value,
        contrast: listItems[2].value,
        gamma: listItems[3].value
      };
      if (this._currentCorrection && this._settings.correction !== this._currentCorrection) {
        const steppers = listItems.slice(1);
        steppers.forEach((stepper) => {
          stepper.value = 50;
        });
      }
      this._currentCorrection = this._settings.correction;
      this._shiftColors();
      this.signal("onColorShift", this._settings);
    }
    _update() {
      const list = this.tag("List");
      const steppers = ["Brightness", "Contrast", "Gamma"];
      const options = this._options;
      const settings2 = this._settings;
      const colors2 = {
        focusColor: this._focusColor,
        labelColor: this._labelColor,
        labelColorFocused: this._labelColorFocused
      };
      this._shiftColors();
      const settingItems = steppers.map((stepper) => {
        const lowerC = stepper.toLocaleLowerCase();
        return __spreadValues({ type: this[`${lowerC}Component`], label: stepper, value: settings2[lowerC], w: this.finalW, h: 80 }, colors2);
      });
      settingItems.unshift(__spreadValues({ type: this.correctionComponent, options, value: findIndexOfObject(options, settings2.correction, "type"), label: "Color adjustment", w: this.finalW, h: 80 }, colors2));
      list.clear();
      list.add(settingItems);
    }
    _firstActive() {
      if (!this._settings) {
        this._settings = {
          correction: "neutral",
          brightness: 50,
          contrast: 50,
          gamma: 50
        };
      }
      this._update();
    }
    set settings(obj) {
      this._settings = obj;
      if (this.active) {
        const listItems = this.tag("List").items;
        listItems[0] = findIndexOfObject(this._options, obj.correction, "type");
        listItems[1] = obj.brightness || 50;
        listItems[2] = obj.contrast || 50;
        listItems[3] = obj.gamma || 50;
      }
    }
    get settings() {
      return this._settings;
    }
    get correctionTag() {
      return this.tag("List").items[0];
    }
    get brightnessTag() {
      return this.tag("List").items[1];
    }
    get contrastTag() {
      return this.tag("List").items[2];
    }
    get gammaTag() {
      return this.tag("List").items[3];
    }
    get adjustmentTags() {
      return this.tag("List").items;
    }
    set stepperComponent(component) {
      this._stepperComponent = component;
    }
    get stepperComponent() {
      return this._stepperComponent || ArrowStepper;
    }
    set correctionComponent(component) {
      this._correctionComponent = component;
    }
    get correctionComponent() {
      return this._correctionComponent || this.stepperComponent;
    }
    set brightnessComponent(component) {
      this._brightnessComponent = component;
    }
    get brightnessComponent() {
      return this._brightnessComponent || this.stepperComponent;
    }
    set contrastComponent(component) {
      this._contrastComponent = component;
    }
    get contrastComponent() {
      return this._contrastComponent || this.stepperComponent;
    }
    set gammaComponent(component) {
      this._gammaComponent = component;
    }
    get gammaComponent() {
      return this._gammaComponent || this.stepperComponent;
    }
  };

  // node_modules/@lightningjs/ui/src/CarouselStepper.js
  var CarouselItem = class extends src_default.Component {
    static _template() {
      return {
        Focus: { alpha: 0, x: (w) => w * 0.5, y: (h) => h * 0.5, mount: 0.5, w: 120, h: 50, rect: true, shader: { type: src_default.shaders.RoundedRectangle, radius: 25 } },
        Label: { x: (w) => w * 0.5, y: (h) => h * 0.5, mount: 0.5, renderOffscreen: true, text: { text: "", fontSize: 22 } }
      };
    }
    _construct() {
      this._focusColor = 4278227525;
      this._labelColor = 4288519581;
      this._labelColorFocused = 4294967295;
      this._padding = 40;
      defineProperties(this, ["focusColor", "labelColor", "labelColorFocused", "padding"]);
    }
    set label(str) {
      this.tag("Label").text.text = str;
      this._label = str;
    }
    get label() {
      return this._label;
    }
    _init() {
      const label = this.tag("Label");
      label.on("txLoaded", () => {
        this.patch({
          w: label.renderWidth,
          Focus: { w: label.renderWidth + this._padding * 2 }
        });
        if (this.collectionWrapper) {
          this.collectionWrapper.reposition();
        }
      });
    }
    _focus() {
      this.patch({
        Focus: { smooth: { alpha: 1 } },
        Label: { smooth: { color: this._labelColorFocused } }
      });
    }
    _unfocus(target) {
      if (target.isCarouselItem === true) {
        this.patch({
          Focus: { smooth: { alpha: 0 } },
          Label: { smooth: { color: this._labelColor } }
        });
      }
    }
    _firstActive() {
      this.patch({
        Focus: { color: this._focusColor },
        Label: { color: this._labelColor }
      });
      if (this.cparent.componentIndex === this.collectionWrapper.currentItemWrapper.componentIndex) {
        this._focus();
      }
    }
    get isCarouselItem() {
      return true;
    }
    static get width() {
      return 120;
    }
    static get height() {
      return 50;
    }
  };

  // node_modules/@lightningjs/ui/src/ProgressBar.js
  var ProgressBar = class extends src_default.Component {
    static _template() {
      return {
        w: 300,
        h: 10,
        Background: {
          w: (w) => w,
          h: (h) => h,
          rect: true,
          rtt: true,
          shader: { type: src_default.shaders.RoundedRectangle, radius: 5 },
          Progress: { h: (h) => h, w: 10, rect: true, shader: { type: src_default.shaders.RoundedRectangle, radius: 0 } }
        }
      };
    }
    _construct() {
      this._progressColor = 4278227525;
      this._progressColorFocused = void 0;
      this._backgroundColor = 4288519581;
      this._backgroundColorFocused = void 0;
      this._backgroundRadius = 5;
      this._progressRadius = 0;
      this.value = 0.5;
      defineProperties(this, ["progressColor", "backgroundColor", "progressColorFocused", "backgroundColorFocused"]);
    }
    progress(p) {
      if (p > 1) {
        p = p / 100;
      }
      this._value = p;
      this.tag("Progress").w = this.w * p;
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({ duration: 0.2, stopMethod: "reverse", actions: [
        { t: "Background", p: "color", v: { 0: this._backgroundColor, 1: this._backgroundColorFocused || this._backgroundColor } },
        { t: "Background.Progress", p: "color", v: { 0: this._progressColor, 1: this._progressColorFocused || this._progressColor } }
      ] });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      this.patch({
        Background: {
          color: this._backgroundColor,
          shader: { radius: this._backgroundRadius },
          Progress: {
            color: this._progressColor,
            shader: { radius: this._progressRadius }
          }
        }
      });
      this.progress(this._value);
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _focus() {
      if (this._focusAnimation) {
        this._focusAnimation.start();
      }
    }
    _unfocus() {
      if (this._focusAnimation) {
        this._focusAnimation.stop();
      }
    }
    set value(p) {
      this._value = p;
      if (this.active) {
        this.progress(p);
      }
    }
    get value() {
      return this._value;
    }
    set backgroundRadius(num) {
      this._backgroundRadius = num;
      if (this.active) {
        this.tag("Background").shader.radius = num;
      }
    }
    get progressRadius() {
      return this._progressRadius;
    }
    set progressRadius(num) {
      this._progressRadius = num;
      if (this.active) {
        this.tag("Progress").shader.radius = num;
      }
    }
    get progressRadius() {
      return this._progressRadius;
    }
    get backgroundTag() {
      return this.tag("Background");
    }
    get progressTag() {
      return this.tag("Progress");
    }
  };

  // src/atoms/CarouselItem.ts
  var HERO_H = 650;
  var SIDE_MARGIN = 100;
  var CarouselItem2 = class extends Lightning_default.Component {
    static _template() {
      return {
        Poster: {
          PosterImg: {
            w: (w) => w,
            h: (h) => h,
            src: null
          },
          Overlay: {
            w: (w) => w,
            h: (h) => h,
            rect: true,
            colorTop: 0,
            colorBottom: 3221225472
          }
        },
        Info: {
          x: SIDE_MARGIN,
          y: HERO_H - 450,
          Title: {
            text: {
              text: "",
              fontSize: 72,
              fontFace: "RelaxAI-SoraBold",
              textColor: Theme.colors.text
            }
          },
          Meta: {
            y: 90,
            text: { text: "", fontSize: 30, textColor: Theme.colors.textDim }
          },
          DescBox: {
            y: 140,
            x: 0,
            w: Theme.w - SIDE_MARGIN * 2,
            text: {
              text: "",
              wordWrap: true,
              maxLines: 5,
              fontSize: 36,
              lineHeight: 40,
              textColor: Theme.colors.textDim
            }
          }
        }
      };
    }
    set item(v) {
      var _a;
      this._data = v;
      this.patch({
        Poster: v.posterSrc ? { src: Utils_default.asset(v.posterSrc) } : { color: 4281545523 }
      });
      this.tag("Info.Title").patch({ text: { text: (_a = v.title) != null ? _a : "" } });
      const genres = Array.isArray(v.genres) ? v.genres.join(", ") : v.genres || "";
      const parts = [
        v.year ? `${v.year}` : null,
        v.duration ? `${v.duration} min` : null,
        v.author ? `${v.author}` : null,
        genres ? `${genres}` : null
      ].filter(Boolean);
      const textParts = parts.join("  \u2022  ");
      this.tag("Info.Meta").patch({ text: { text: textParts } });
      this.tag("DescBox").patch({ text: { text: v.description } });
    }
    _focus() {
      this.tag("Poster").patch({
        shader: {
          type: Lightning_default.shaders.Outline,
          thickness: 8,
          color: Theme.colors.accent
        }
      });
    }
    _unfocus() {
      this.tag("Poster").patch({ shader: null });
    }
    _getCurrentSection() {
      if (typeof window === "undefined") return "home";
      const seg = (window.location.hash || "").replace(/^#\/?/, "").split("/")[0] || "home";
      return seg.toLowerCase();
    }
    _handleEnter() {
      var _a;
      if (!this._data) return true;
      const section = this._getCurrentSection().toLowerCase() || "home";
      this.fireAncestors("$onChildNavigate", `${section}/detail`, {
        id: (_a = this._data) == null ? void 0 : _a.id
      });
      return true;
    }
  };
  CarouselItem2.width = 1920;
  CarouselItem2.height = 600;

  // src/molecules/Carousel.ts
  var CarouselComp = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._interval = 6e3;
      this._isFocused = false;
    }
    static _template() {
      return {
        Rail: {
          type: Carousel,
          direction: "row",
          spacing: 24,
          scroll: 0.5,
          autoResize: false
        }
      };
    }
    getFocusIndex() {
      var _a;
      const rail = this.tag("Rail");
      return Number((_a = rail == null ? void 0 : rail.index) != null ? _a : 0);
    }
    setFocusIndex(i) {
      var _a;
      const rail = this.tag("Rail");
      const max = Math.max(0, (((_a = rail == null ? void 0 : rail.children) == null ? void 0 : _a.length) || 1) - 1);
      rail.index = Math.max(0, Math.min(i != null ? i : 0, max));
      this._refocus();
    }
    set items(data) {
      var _a, _b;
      const rail = this.tag("Rail");
      rail.reload(
        data.map((d) => ({ type: CarouselItem2, w: 1920, h: 600, item: d }))
      );
      rail.items.forEach((cmp, i) => {
        if (cmp) cmp.item = data[i];
      });
      const max = Math.max(0, (((_a = rail == null ? void 0 : rail.children) == null ? void 0 : _a.length) || 1) - 1);
      rail.index = Math.max(0, Math.min(Number((_b = rail == null ? void 0 : rail.index) != null ? _b : 0), max));
      if (this._isFocused && !this._timer) this._startAutoplay();
    }
    $onChildNavigate(path, params) {
      this.signal("navigate", path, params);
    }
    _focus() {
      this._isFocused = true;
      this._clearResume();
      this._startAutoplay();
    }
    _unfocus() {
      this._isFocused = false;
      this._stopAutoplay();
      this._clearResume();
    }
    _captureLeft() {
      this._pauseAndScheduleResume();
      return false;
    }
    _captureRight() {
      this._pauseAndScheduleResume();
      return false;
    }
    _handlePageDown() {
      this.tag("Rail").index += 4;
      this._pauseAndScheduleResume();
    }
    _handlePageUp() {
      this.tag("Rail").index -= 4;
      this._pauseAndScheduleResume();
    }
    _setup() {
      this._onHidden = () => {
        this._stopAutoplay();
        this._clearResume();
      };
      this._onVisible = () => {
        if (this._isFocused) this._startAutoplay();
      };
      this._onVisChange = () => {
        var _a, _b;
        document.visibilityState === "hidden" ? (_a = this._onHidden) == null ? void 0 : _a.call(this) : (_b = this._onVisible) == null ? void 0 : _b.call(this);
      };
    }
    _active() {
      var _a;
      if (this._onVisChange && this._onHidden && this._onVisible) {
        document.addEventListener("visibilitychange", this._onVisChange);
        window.addEventListener("blur", this._onHidden);
        window.addEventListener("focus", this._onVisible);
      }
      document.visibilityState === "hidden" ? (_a = this._onHidden) == null ? void 0 : _a.call(this) : this._isFocused && this._startAutoplay();
    }
    _inactive() {
      if (this._onVisChange && this._onHidden && this._onVisible) {
        document.removeEventListener("visibilitychange", this._onVisChange);
        window.removeEventListener("blur", this._onHidden);
        window.removeEventListener("focus", this._onVisible);
      }
      this._stopAutoplay();
      this._clearResume();
    }
    _startAutoplay() {
      this._stopAutoplay();
      const rail = this.tag("Rail");
      this._timer = setInterval(() => {
        var _a;
        try {
          (_a = rail._handleRight) == null ? void 0 : _a.call(rail);
        } catch (e) {
        }
      }, this._interval);
    }
    _stopAutoplay() {
      if (this._timer) {
        clearInterval(this._timer);
        this._timer = void 0;
      }
    }
    _pauseAndScheduleResume() {
      this._stopAutoplay();
      this._clearResume();
      this._resumeTmr = setTimeout(() => {
        if (this._isFocused && document.visibilityState !== "hidden")
          this._startAutoplay();
      }, this._interval);
    }
    _clearResume() {
      if (this._resumeTmr) {
        clearTimeout(this._resumeTmr);
        this._resumeTmr = void 0;
      }
    }
    _getFocused() {
      return this.tag("Rail");
    }
    _detach() {
      this._stopAutoplay();
      this._clearResume();
    }
  };

  // src/utils/routerUtils.ts
  function getActiveRouteName(fallback = "home") {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const route = (_b = (_a = Router_default).getActiveRoute) == null ? void 0 : _b.call(_a);
    const raw = (_i = (_h = (_e = route == null ? void 0 : route.hash) != null ? _e : (_d = (_c = Router_default).getActiveHash) == null ? void 0 : _d.call(_c)) != null ? _h : (_g = (_f = Router_default).getUrl) == null ? void 0 : _g.call(_f)) != null ? _i : typeof window !== "undefined" ? window.location.hash : "";
    const name = (_j = String(raw).replace(/^#?\/?/, "").split("/")[0]) == null ? void 0 : _j.toLowerCase();
    return name || fallback;
  }
  function sanitizeSection(v) {
    const s = String(v != null ? v : "").toLowerCase();
    const allowed = [
      "home",
      "suggest",
      "breathe",
      "longform",
      "search",
      "watchlist"
    ];
    return allowed.includes(s) ? s : null;
  }
  function extractIdFromHash() {
    if (typeof window === "undefined") return null;
    const segs = window.location.hash.replace(/^#\/?/, "").split("/");
    return segs[3] ? decodeURIComponent(segs[3]) : segs[1] || null;
  }
  function resolveById(id, data, getId) {
    var _a;
    if (id == null) return null;
    const s = String(id);
    if (Array.isArray(data)) {
      return (_a = data.find((it) => String(getId(it)) === s)) != null ? _a : null;
    }
    for (const section of Object.values(data)) {
      if (!section || !Array.isArray(section)) continue;
      const found = section.find((it) => String(getId(it)) === s);
      if (found) return found;
    }
    return null;
  }

  // src/services/DataStore.ts
  var DataStore = class {
    static get data() {
      if (!this._data) throw new Error("DataStore not init");
      return this._data;
    }
    static get isReady() {
      return this._data !== null;
    }
    static init(from = "local") {
      return __async(this, null, function* () {
        if (this._data) return;
        if (from === "local") {
          const url = Utils_default.asset("data/data.json");
          const res = yield fetch(url);
          if (!res.ok) throw new Error(`Error loading JSON (${res.status})`);
          this._data = yield res.json();
        }
      });
    }
  };
  DataStore._data = null;
  var DataStore_default = DataStore;

  // src/pages/Home.ts
  var GAP2 = 30;
  var GAP = 60;
  var HEADER_H = 200;
  var CAROUSSEL_H = 600;
  var RAIL_H = 230;
  var HomeSection = class _HomeSection extends BasePage {
    get hasHeader() {
      return true;
    }
    get sections() {
      return ["Carussel", "TopSearches", "NextWatch", "Retro"];
    }
    get defaultHeights() {
      return {
        Header: HEADER_H,
        Carussel: CAROUSSEL_H,
        TopSearches: RAIL_H,
        NextWatch: RAIL_H,
        Retro: RAIL_H
      };
    }
    static _template() {
      return BasePage.chrome({
        Header: {
          type: Header,
          h: HEADER_H,
          signals: { navigate: true, focusNext: true }
        },
        Carussel: {
          x: 40,
          y: HEADER_H + GAP2,
          h: CAROUSSEL_H,
          type: CarouselComp,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        TopSearches: {
          y: HEADER_H + GAP2 + CAROUSSEL_H + GAP2,
          h: RAIL_H,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        NextWatch: {
          y: HEADER_H + GAP2 + CAROUSSEL_H + GAP2 + RAIL_H + GAP,
          h: RAIL_H,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        Retro: {
          y: HEADER_H + GAP2 + CAROUSSEL_H + GAP2 + RAIL_H + GAP + RAIL_H + GAP,
          h: RAIL_H,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        }
      });
    }
    _focus() {
      var _a, _b;
      const routeName = getActiveRouteName();
      (_b = (_a = this.tag("Viewport.Content.ContentInner.Header")) == null ? void 0 : _a.setCurrentByRoute) == null ? void 0 : _b.call(
        _a,
        routeName
      );
    }
    _active() {
      return __async(this, null, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        __superGet(_HomeSection.prototype, this, "_active").call(this);
        const inner = "Viewport.Content.ContentInner";
        const carouselData = (_b = (_a = DataStore_default.data.rail5) == null ? void 0 : _a.slice(1, 8)) != null ? _b : [];
        this.tag(`${inner}.Carussel`).items = carouselData;
        (_e = this.tag(`${inner}.TopSearches`)) == null ? void 0 : _e.patch({
          title: "Top searches",
          items: (_d = (_c = DataStore_default.data.rail1) == null ? void 0 : _c.slice(0, 15)) != null ? _d : []
        });
        (_h = this.tag(`${inner}.NextWatch`)) == null ? void 0 : _h.patch({
          title: "Your next watch",
          items: (_g = (_f = DataStore_default.data.rail3) == null ? void 0 : _f.slice(0, 15)) != null ? _g : []
        });
        (_k = this.tag(`${inner}.Retro`)) == null ? void 0 : _k.patch({
          title: "Retro TV",
          items: (_j = (_i = DataStore_default.data.rail4) == null ? void 0 : _i.slice(0, 15)) != null ? _j : []
        });
        this.computeAfterLayout();
      });
    }
  };

  // src/pages/SuggestSection.ts
  var HEADER_H2 = 200;
  var CAROUSSEL_H2 = 600;
  var RAIL_H2 = 230;
  var GAP22 = 30;
  var GAP3 = 60;
  var SuggestSection = class _SuggestSection extends BasePage {
    get hasHeader() {
      return true;
    }
    get sections() {
      return ["Carussel", "TopSearches", "NextWatch", "Retro"];
    }
    get defaultHeights() {
      return {
        Header: HEADER_H2,
        Carussel: CAROUSSEL_H2,
        TopSearches: RAIL_H2,
        NextWatch: RAIL_H2,
        Retro: RAIL_H2
      };
    }
    static _template() {
      return BasePage.chrome({
        Header: {
          type: Header,
          h: HEADER_H2,
          signals: { navigate: true, focusNext: true }
        },
        Carussel: {
          type: CarouselComp,
          x: 40,
          y: HEADER_H2 + GAP22,
          h: CAROUSSEL_H2,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        TopSearches: {
          type: Rail,
          y: HEADER_H2 + GAP22 + CAROUSSEL_H2 + GAP22,
          h: RAIL_H2,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        NextWatch: {
          type: Rail,
          y: HEADER_H2 + GAP22 + CAROUSSEL_H2 + GAP22 + RAIL_H2 + GAP3,
          h: RAIL_H2,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        Retro: {
          type: Rail,
          y: HEADER_H2 + GAP22 + CAROUSSEL_H2 + GAP22 + RAIL_H2 + GAP3 + RAIL_H2 + GAP3,
          h: RAIL_H2,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        }
      });
    }
    _focus() {
      var _a, _b;
      const name = getActiveRouteName();
      (_b = (_a = this.tag("Viewport.Content.ContentInner.Header")) == null ? void 0 : _a.setCurrentByRoute) == null ? void 0 : _b.call(_a, name);
    }
    _active() {
      return __async(this, null, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        __superGet(_SuggestSection.prototype, this, "_active").call(this);
        const inner = "Viewport.Content.ContentInner";
        const dataCarousel = (_b = (_a = DataStore_default.data.rail1) == null ? void 0 : _a.slice(0, 15)) != null ? _b : [];
        this.tag(`${inner}.Carussel`).items = dataCarousel;
        (_d = this.tag(`${inner}.TopSearches`)) == null ? void 0 : _d.patch({
          title: "Top searches",
          items: (_c = DataStore_default.data.rail2) == null ? void 0 : _c.slice(0, 15)
        });
        (_f = this.tag(`${inner}.NextWatch`)) == null ? void 0 : _f.patch({
          title: "Your next watch",
          items: (_e = DataStore_default.data.rail4) == null ? void 0 : _e.slice(0, 15)
        });
        (_h = this.tag(`${inner}.Retro`)) == null ? void 0 : _h.patch({
          title: "Retro TV",
          items: (_g = DataStore_default.data.rail5) == null ? void 0 : _g.slice(0, 15)
        });
        this.computeAfterLayout();
      });
    }
  };

  // src/atoms/Button.ts
  var PAD_X = 24;
  var RADIUS = 8;
  var Button = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._label = "";
    }
    static _template() {
      return {
        w: 300,
        h: 80,
        rect: true,
        color: Theme.colors.text,
        shader: { type: Lightning_default.shaders.RoundedRectangle, radius: RADIUS },
        Label: {
          mountY: 0.5,
          x: PAD_X,
          y: (h) => h / 2,
          text: {
            text: "",
            fontFace: Typography.button.face,
            fontSize: Typography.button.size,
            textColor: Theme.colors.bg
          }
        }
      };
    }
    get label() {
      return this._label;
    }
    set label(v) {
      var _a;
      this._label = v;
      (_a = this.tag("Label")) == null ? void 0 : _a.patch({ text: { text: v } });
    }
    _focus() {
      var _a;
      this.color = Theme.colors.accent;
      (_a = this.tag("Label")) == null ? void 0 : _a.patch({ text: { textColor: Theme.colors.bg } });
    }
    _unfocus() {
      var _a;
      this.color = Theme.colors.text;
      (_a = this.tag("Label")) == null ? void 0 : _a.patch({ text: { textColor: Theme.colors.bg } });
    }
  };

  // node_modules/tslib/tslib.es6.mjs
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }

  // node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction2(value) {
    return typeof value === "function";
  }

  // node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });

  // node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscription.js
  var Subscription = (function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction2(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = (function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    })();
    return Subscription2;
  })();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction2(value.remove) && isFunction2(value.add) && isFunction2(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction2(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }

  // node_modules/rxjs/dist/esm5/internal/config.js
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  // node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider = {
    setTimeout: function(handler, timeout2) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop() {
  }

  // node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  var COMPLETE_NOTIFICATION = (function() {
    return createNotification("C", void 0, void 0);
  })();
  function errorNotification(error) {
    return createNotification("E", void 0, error);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }

  // node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  var context = null;
  function errorContext(cb) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error = _a.error;
        context = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }
  function captureError(err) {
    if (config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
  var Subscriber = (function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  })(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = (function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  })();
  var SafeSubscriber = (function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction2(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  })(Subscriber);
  function handleUnhandledError(error) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      captureError(error);
    } else {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
  };

  // node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  var observable = (function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  })();

  // node_modules/rxjs/dist/esm5/internal/util/identity.js
  function identity(x) {
    return x;
  }

  // node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // node_modules/rxjs/dist/esm5/internal/Observable.js
  var Observable = (function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  })();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction2(value.next) && isFunction2(value.error) && isFunction2(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  // node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  // node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject = (function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  })(Observable);
  var AnonymousSubject = (function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  })(Subject);

  // node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
  var BehaviorSubject = (function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  })(Subject);

  // src/state/watchlist.store.ts
  var WatchlistStore = class {
    constructor() {
      this._watchlist$ = new BehaviorSubject(this._load());
      this.watchlist$ = this._watchlist$.asObservable();
    }
    get current() {
      return this._watchlist$.value;
    }
    add(movie) {
      const cur = this._watchlist$.value;
      if (!cur.find((m) => m.id === movie.id)) {
        const next = [...cur, movie];
        this._watchlist$.next(next);
        this._save(next);
      }
    }
    remove(id) {
      const next = this._watchlist$.value.filter((m) => m.id !== id);
      this._watchlist$.next(next);
      this._save(next);
    }
    toggle(movie) {
      console.log("toggle ->", movie);
      const exists = this._watchlist$.value.some((m) => m.id === movie.id);
      exists ? this.remove(movie.id) : this.add(movie);
    }
    has(id) {
      if (!id) return false;
      const list = this._watchlist$.value;
      if (!Array.isArray(list) || list.length === 0) return false;
      return list.some((m) => m.id === id);
    }
    clear() {
      this._watchlist$.next([]);
      this._save([]);
    }
    _save(list) {
      try {
        localStorage.setItem("watchlist", JSON.stringify(list));
      } catch (e) {
      }
    }
    _load() {
      try {
        return JSON.parse(localStorage.getItem("watchlist") || "[]");
      } catch (e) {
        return [];
      }
    }
  };
  var watchlistStore = new WatchlistStore();

  // src/molecules/Hero.ts
  var HERO_H2 = 650;
  var SIDE_MARGIN2 = 100;
  var WIDTH = Theme.w - 80;
  var Hero = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._btnIndex = 0;
      this._btnOrder = ["PlayBtn", "AddBtn"];
      this._data = null;
    }
    static _template() {
      return {
        x: 40,
        w: WIDTH,
        h: HERO_H2,
        Poster: { w: WIDTH, h: HERO_H2, texture: null },
        Overlay: {
          w: WIDTH,
          h: HERO_H2,
          rect: true,
          colorTop: 0,
          colorBottom: 3758096384
        },
        Info: {
          x: SIDE_MARGIN2,
          y: HERO_H2 - 450,
          Title: {
            text: {
              text: "",
              fontSize: 72,
              fontFace: "RelaxAI-SoraBold",
              textColor: Theme.colors.text
            }
          },
          Meta: {
            y: 90,
            text: { text: "", fontSize: 30, textColor: Theme.colors.textDim }
          },
          DescBox: {
            y: 140,
            x: 0,
            w: Theme.w - SIDE_MARGIN2 * 2,
            text: {
              text: "",
              wordWrap: true,
              maxLines: 5,
              fontSize: 36,
              lineHeight: 40,
              textColor: Theme.colors.textDim
            }
          },
          Buttons: {
            y: 250,
            PlayBtn: { type: Button, x: 0, w: 260, label: "WATCH NOW" },
            AddBtn: {
              type: Button,
              x: 275,
              w: 80,
              h: 80,
              shader: { type: Lightning_default.shaders.RoundedRectangle, radius: 40 },
              label: "",
              Icon: {
                mount: 0.5,
                x: 40,
                y: 40,
                text: { text: "+", textColor: Theme.colors.bg, fontSize: 40 }
              }
            }
          }
        },
        signals: { navigate: true, focusPrev: true, focusNext: true }
      };
    }
    set data(v) {
      this._data = v;
      this.refreshAddButton(v.id);
    }
    _active() {
      if (this._data) this.refreshAddButton(this._data.id);
    }
    refreshAddButton(id) {
      const hasStore = watchlistStore.has(id);
      this.tag("AddBtn.Icon").patch({
        text: { text: `${hasStore ? "-" : "+"}` }
      });
    }
    getFocusIndex() {
      return this._btnIndex;
    }
    setFocusIndex(i) {
      this._btnIndex = Math.max(0, Math.min(i, this._btnOrder.length - 1));
    }
    _getFocused() {
      const key = this._btnOrder[this._btnIndex];
      return this.tag(`Info.Buttons.${key}`);
    }
    setIndex(i) {
      this._btnIndex = Math.max(0, Math.min(i, this._btnOrder.length - 1));
      this._refocus();
    }
    step(dir) {
      this.setIndex(this._btnIndex + dir);
    }
    _handleRight() {
      this.setFocusIndex(this._btnIndex + 1);
      this._refocus();
      return true;
    }
    _handleLeft() {
      this.setFocusIndex(this._btnIndex - 1);
      this._refocus();
      return true;
    }
    _handleDown() {
      this.signal("focusNext");
      return true;
    }
    _handleUp() {
      this.signal("focusPrev");
      return true;
    }
    _handleEnter() {
      var _a;
      if (this._btnOrder[this._btnIndex] === "PlayBtn") {
        this.signal("navigate", "player", { id: (_a = this._data) == null ? void 0 : _a.id });
        return true;
      }
      if (this._btnOrder[this._btnIndex] === "AddBtn") {
        if (this._data) {
          watchlistStore.toggle(this._data);
          this.refreshAddButton(this._data.id);
        }
        return true;
      }
    }
  };

  // src/utils/detailHelpers.ts
  var HERO_H3 = 650;
  function scrollToSection(ctx, section) {
    var _a, _b;
    const vp = ctx.tag("Viewport.Content");
    if (section === -1) {
      (_a = vp == null ? void 0 : vp.setSmooth) == null ? void 0 : _a.call(vp, "y", 0);
    } else {
      (_b = ctx["_applyScrollForSection"]) == null ? void 0 : _b.call(ctx, section);
    }
  }
  function applyHeaderSelected(ctx, fromRoute) {
    var _a;
    if (!fromRoute) return;
    const header = ctx.tag(
      "Viewport.Content.ContentInner.Header"
    );
    (_a = header == null ? void 0 : header.setCurrentByRoute) == null ? void 0 : _a.call(header, fromRoute);
  }
  function patchDetailData(ctx, v) {
    var _a, _b;
    if (!v) return;
    const src = v.posterSrc || v.imageSrc;
    if (src) {
      ctx.tag("Hero.Poster").patch({
        texture: Img_default(Utils_default.asset(src)).cover(Theme.w, HERO_H3)
      });
    }
    ctx.tag("Hero.Info.Title").patch({ text: { text: (_a = v.title) != null ? _a : "" } });
    const genres = Array.isArray(v.genres) ? v.genres.join(", ") : v.genres || "";
    const parts = [
      v.year ? `${v.year}` : null,
      v.duration ? `${v.duration} min` : null,
      v.author ? `${v.author}` : null,
      genres ? `${genres}` : null
    ].filter(Boolean);
    const textParts = parts.join("  \u2022  ");
    ctx.tag("Hero.Info.Meta").patch({ text: { text: textParts } });
    ctx.tag("Hero.Info.DescBox").patch({ text: { text: (_b = v.description) != null ? _b : "" } });
  }

  // src/pages/Detail.ts
  var HEADER_H3 = 200;
  var HERO_H4 = 650;
  var CONTENT_Y = HEADER_H3;
  var RAIL_H3 = 230;
  var Detail = class extends BasePage {
    constructor() {
      super(...arguments);
      this._data = null;
      this._btnIndex = 0;
      this._btnOrder = [
        "PlayBtn",
        "AddBtn",
        "LikeBtn"
      ];
      this._fromRoute = null;
      this._lastId = null;
    }
    get hasHeader() {
      return true;
    }
    get enableHistory() {
      return false;
    }
    get enableScrollSnap() {
      return true;
    }
    get defaultHeights() {
      return { Header: HEADER_H3, Hero: HERO_H4, TopSearches: RAIL_H3 };
    }
    get sections() {
      return ["Hero", "TopSearches"];
    }
    get persistHeaderInHistory() {
      return false;
    }
    get enableFocusRecovery() {
      return false;
    }
    static _template() {
      return BasePage.chrome({
        Header: {
          type: Header,
          h: HEADER_H3,
          signals: { navigate: true, focusNext: true }
        },
        Hero: {
          type: Hero,
          y: CONTENT_Y,
          w: Theme.w,
          h: HERO_H4,
          signals: { navigate: "_handleEnter", focusPrev: true, focusNext: true }
        },
        TopSearches: {
          y: CONTENT_Y + HERO_H4 + 40,
          h: RAIL_H3,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        }
      });
    }
    _onUrlParams(params) {
      var _a, _b, _c, _d;
      this._fromRoute = sanitizeSection(params == null ? void 0 : params.section);
      const newId = (params == null ? void 0 : params.id) ? String(params.id) : extractIdFromHash();
      if (newId && newId !== this._lastId) {
        this._lastId = newId;
        this._restoredFromHistory = false;
      }
      applyHeaderSelected(this, this._fromRoute);
      this.data = resolveById(
        newId,
        DataStore_default.data,
        (d) => d == null ? void 0 : d.id
      );
      const active = (_b = (_a = Router_default).getActiveHash) == null ? void 0 : _b.call(_a);
      const state3 = (_d = (_c = Router_default).getHistoryState) == null ? void 0 : _d.call(_c, active);
      state3 ? this._refocus() : this.focusHeroBtn("PlayBtn");
      this.tag("Hero").data = this._data;
    }
    set data(v) {
      this._data = v;
      patchDetailData(this, v);
    }
    _active() {
      var _a, _b, _c, _d;
      super._active();
      this.focusHeroBtn("PlayBtn");
      const inner = "Viewport.Content.ContentInner";
      (_c = this.tag(`${inner}.TopSearches`)) == null ? void 0 : _c.patch({
        title: "Related",
        items: (_b = (_a = DataStore_default.data.rail4) == null ? void 0 : _a.slice(0, 10)) != null ? _b : []
      });
      (_d = this.tag(`${inner}.Hero`)) == null ? void 0 : _d.patch({ data: this._data });
    }
    focusHeroBtn(key = "PlayBtn") {
      const idx = this._btnOrder.indexOf(key);
      if (idx < 0) return;
      this._btnIndex = idx;
      this._section = 0;
      scrollToSection(this, 0);
      this._refocus();
    }
    getFocusIndex() {
      return this._btnIndex;
    }
    setFocusIndex(i) {
      this._btnIndex = Math.max(0, Math.min(i, this._btnOrder.length - 1));
    }
    _getFocused() {
      var _a;
      const section = (_a = this._section) != null ? _a : 0;
      if (this.hasHeader && section === -1)
        return this.tag("Viewport.Content.ContentInner.Header");
      if (section === 0) return this.tag("Viewport.Content.ContentInner.Hero");
      return this.tag("Viewport.Content.ContentInner.TopSearches");
    }
    _handleRight() {
      this.setFocusIndex(this._btnIndex + 1);
      this._refocus();
      return true;
    }
    _handleLeft() {
      this.setFocusIndex(this._btnIndex - 1);
      this._refocus();
      return true;
    }
    _handleDown() {
      var _a, _b;
      const section = (_a = this._section) != null ? _a : 0;
      if (section === -1) {
        this._section = 0;
        scrollToSection(this, 0);
        this._refocus();
        return true;
      }
      (_b = this["focusNext"]) == null ? void 0 : _b.call(this);
      return true;
    }
    _handleUp() {
      var _a, _b;
      const section = (_a = this._section) != null ? _a : 0;
      if (section === 0) {
        this._section = -1;
        scrollToSection(this, -1);
        this._refocus();
        return true;
      }
      (_b = this["focusPrev"]) == null ? void 0 : _b.call(this);
      return true;
    }
    focusNext() {
      var _a;
      const cur = (_a = this._section) != null ? _a : 0;
      const max = 1;
      this._section = Math.min(max, cur + 1);
      scrollToSection(this, this._section);
      this._syncHistorySnapshot();
      this._refocus();
    }
    focusPrev() {
      var _a;
      const cur = (_a = this._section) != null ? _a : 0;
      this._section = Math.max(-1, cur - 1);
      scrollToSection(this, this._section);
      this._syncHistorySnapshot();
      this._refocus();
    }
    _handleEnter() {
      var _a, _b;
      const key = this._btnOrder[this._btnIndex];
      if (key === "PlayBtn") {
        this._syncHistorySnapshot();
        this.navigate(
          "player",
          { id: (_a = this._data) == null ? void 0 : _a.id, section: (_b = this._fromRoute) != null ? _b : "home" },
          true
        );
      }
      return true;
    }
  };

  // src/atoms/ControlButton.ts
  var ControlButton = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._size = 80;
      this._radius = 8;
      this._iconScale = 0.5;
    }
    get Bg() {
      return this.tag("Bg");
    }
    get Icon() {
      return this.tag("Icon");
    }
    static _template() {
      return {
        w: 80,
        h: 80,
        Bg: {
          w: 80,
          h: 80,
          rect: true,
          color: Theme.colors.text,
          shader: { type: Lightning_default.shaders.RoundedRectangle, radius: 8 }
        },
        Icon: {
          mount: 0.5,
          x: 40,
          y: 40,
          w: 80,
          h: 80,
          color: 4278190080,
          texture: void 0
        }
      };
    }
    set iconSrc(v) {
      this._iconSrc = v;
      this._applyIcon();
    }
    set size(v) {
      if (Number.isFinite(v) && v > 0) {
        this._size = v;
        this._applySizing();
      }
    }
    set radius(v) {
      if (Number.isFinite(v) && v >= 0) {
        this._radius = v;
        this._applyRadius();
      }
    }
    set iconScale(v) {
      if (Number.isFinite(v) && v > 0 && v <= 1) {
        this._iconScale = v;
        this._applyIcon();
      }
    }
    setVariant(v) {
      const map = {
        play: "videos/controls/play.png",
        pause: "videos/controls/pause.png",
        rew: "videos/controls/rewind.png",
        fwd: "videos/controls/forward.png",
        back: "videos/controls/back.png"
      };
      this.iconSrc = map[v];
      this._applyIcon();
    }
    _init() {
      this._applySizing();
      this._applyRadius();
      this._applyIcon();
    }
    _focus() {
      var _a;
      (_a = this.Bg) == null ? void 0 : _a.patch({ color: Theme.colors.accent });
      this.setSmooth("scale", 1.04, { duration: 0.12 });
    }
    _unfocus() {
      var _a;
      (_a = this.Bg) == null ? void 0 : _a.patch({ color: Theme.colors.text });
      this.setSmooth("scale", 1, { duration: 0.12 });
    }
    _handleEnter() {
      this.signal("select", { iconSrc: this._iconSrc });
      return false;
    }
    _applySizing() {
      var _a, _b;
      this.w = this._size;
      this.h = this._size;
      (_a = this.Bg) == null ? void 0 : _a.patch({ w: this._size, h: this._size });
      (_b = this.Icon) == null ? void 0 : _b.patch({ x: this._size / 2, y: this._size / 2 });
      this._applyIcon();
    }
    _applyRadius() {
      var _a;
      (_a = this.Bg) == null ? void 0 : _a.patch({
        shader: { type: Lightning_default.shaders.RoundedRectangle, radius: this._radius }
      });
    }
    _applyIcon() {
      var _a, _b;
      const iconSide = Math.round(this._size * this._iconScale);
      if (this._iconSrc) {
        (_a = this.Icon) == null ? void 0 : _a.patch({
          texture: Img_default(Utils_default.asset(this._iconSrc)).contain(iconSide, iconSide)
        });
      } else {
        (_b = this.Icon) == null ? void 0 : _b.patch({ texture: null });
      }
    }
  };
  var ControlButton_default = ControlButton;

  // src/pages/player/Player.ts
  var FOCUS_ORDER = [
    "BackBtn",
    "PlayPause",
    "Back30",
    "Fwd30",
    "Progress"
  ];
  var SKIP_SECONDS = 30;
  var Player = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._data = null;
      this._isTexture = false;
      this._controlsVisible = false;
      this._focusIndex = 1;
      this._scrubbing = false;
      this._scrubPct = 0;
      this._wasPlayingBeforeScrub = false;
    }
    static _template() {
      const SIDE_PAD = 60;
      const BTN_W = 80;
      const BTN_H = 80;
      const BTN_GAP = 30;
      return {
        Poster: {
          x: 0,
          y: 0,
          w: 1920,
          h: 1080
        },
        Controls: {
          alpha: 0,
          OverlayBg: {
            rect: true,
            w: 1920,
            h: 1080,
            alpha: 0.45,
            color: 4278190080
          },
          BackBtn: {
            type: ControlButton_default,
            x: SIDE_PAD,
            y: 50,
            w: 140,
            h: BTN_H,
            label: "Back"
          },
          Title: {
            x: Theme.w - SIDE_PAD,
            y: 50,
            mountX: 1,
            text: {
              text: "",
              fontSize: 56,
              textAlign: "right"
            }
          },
          Metadata: {
            x: Theme.w - SIDE_PAD,
            y: 130,
            mountX: 1,
            text: {
              text: "",
              fontSize: 28,
              textColor: 4291875024,
              textAlign: "right"
            }
          },
          PlayPause: {
            type: ControlButton_default,
            x: SIDE_PAD,
            y: 920,
            w: BTN_W,
            h: BTN_H,
            label: "Play"
          },
          Back30: {
            type: ControlButton_default,
            x: SIDE_PAD + BTN_W + BTN_GAP,
            y: 920,
            w: BTN_W,
            h: BTN_H,
            label: "-30s"
          },
          Fwd30: {
            type: ControlButton_default,
            x: SIDE_PAD + (BTN_W + BTN_GAP) * 2,
            y: 920,
            w: BTN_W,
            h: BTN_H,
            label: "+30s"
          },
          Progress: {
            x: SIDE_PAD + 350,
            y: 950,
            Track: {
              rect: true,
              w: 1520 - SIDE_PAD * 2,
              h: 8,
              color: 1157627903
            },
            Fill: { rect: true, w: 0, h: 8, color: 4294967295 },
            Times: { x: 0, y: 14, text: { text: "00:00 / 00:00", fontSize: 28 } },
            Glow: {
              rect: true,
              x: -6,
              y: -6,
              w: (w) => w - 0 + 12,
              h: 20 + 12,
              alpha: 0,
              color: 587202559
            },
            Thumb: {
              rect: true,
              w: 6,
              h: 18,
              y: -5,
              x: 0,
              color: 4294967295,
              alpha: 0
            }
          }
        }
      };
    }
    _onUrlParams(params) {
      const itemId = (params == null ? void 0 : params.id) ? String(params.id) : extractIdFromHash();
      this.data = resolveById(
        itemId,
        DataStore_default.data,
        (d) => d.id
      );
    }
    set data(v) {
      this._data = v;
    }
    get Poster() {
      return this.tag("Poster");
    }
    get Controls() {
      return this.tag("Controls");
    }
    get BackBtn() {
      return this.tag("Controls.BackBtn");
    }
    get PlayPause() {
      return this.tag("Controls.PlayPause");
    }
    get Back30() {
      return this.tag("Controls.Back30");
    }
    get Fwd30() {
      return this.tag("Controls.Fwd30");
    }
    get Progress() {
      return this.tag("Controls.Progress");
    }
    get ProgressTrack() {
      return this.tag("Controls.Progress.Track");
    }
    get ProgressFill() {
      return this.tag("Controls.Progress.Fill");
    }
    get ProgressTimes() {
      return this.tag("Controls.Progress.Times");
    }
    get ProgressGlow() {
      return this.tag("Controls.Progress.Glow");
    }
    get ProgressThumb() {
      return this.tag("Controls.Progress.Thumb");
    }
    _init() {
      this._isTexture = !!Settings_default.get("platform", "textureMode", false);
      VideoPlayer_default2.consumer(this);
      if (!this._isTexture) {
        VideoPlayer_default2.position(0, 0);
        VideoPlayer_default2.size(1920, 1080);
        VideoPlayer_default2.show();
      }
    }
    _active() {
      var _a;
      this.PlayPause.setVariant("play");
      this.Back30.setVariant("rew");
      this.Fwd30.setVariant("fwd");
      this.BackBtn.setVariant("back");
      const title = ((_a = this._data) == null ? void 0 : _a.title) || "Now Playing";
      this.tag("Controls.Title").text = { text: title };
      const md = this._buildMetadata(this._data);
      this.tag("Controls.Metadata").text = { text: md };
      const poster = this.tag("Poster");
      const src = Utils_default.asset("images/poster.png");
      console.log("posterSrc ->", src);
      poster.texture = {
        type: Lightning_default.textures.ImageTexture,
        src
      };
      poster.visible = !!src;
      setTimeout(() => {
        this.play(
          "https://res.cloudinary.com/dt8savcjt/video/upload/v1761829047/clip_thcmgl.mp4"
        );
      }, 1e3);
    }
    _getFocused() {
      const key = FOCUS_ORDER[this._focusIndex];
      if (key === "BackBtn") return this.BackBtn;
      if (key === "PlayPause") return this.PlayPause;
      if (key === "Back30") return this.Back30;
      if (key === "Fwd30") return this.Fwd30;
      return this;
    }
    _focus() {
      this._applyPageFocus();
    }
    _unfocus() {
      this._applyPageFocus();
    }
    _applyPageFocus() {
      this._applyItemFocus();
    }
    play(url) {
      setTimeout(() => {
        VideoPlayer_default2.open(url);
        VideoPlayer_default2.play();
        setTimeout(() => {
          if (!VideoPlayer_default2.playing) VideoPlayer_default2.play();
        }, 1e3);
      }, 0);
      this._startTick();
      this._showControls(true);
    }
    pause() {
      VideoPlayer_default2.pause();
    }
    _exitPlayer() {
      var _a, _b, _c, _d;
      console.log("[Player] Exiting player...");
      this._clearTimers();
      try {
        (_b = (_a = VideoPlayer_default2).stop) == null ? void 0 : _b.call(_a);
      } catch (e) {
      }
      try {
        VideoPlayer_default2.close();
      } catch (e) {
      }
      const history2 = ((_d = (_c = Router_default).getHistory) == null ? void 0 : _d.call(_c)) || [];
      if (history2.length > 1) {
        Router_default.back();
      } else {
        const current = Router_default.getActiveRoute && Router_default.getActiveRoute() || "";
        if (current !== "home") Router_default.navigate("home");
      }
      this.signal("onBackFromPlayer");
    }
    stop() {
      this._exitPlayer();
    }
    _disable() {
      var _a, _b;
      this._clearTimers();
      try {
        (_b = (_a = VideoPlayer_default2).stop) == null ? void 0 : _b.call(_a);
      } catch (e) {
      }
      try {
        VideoPlayer_default2.close();
      } catch (e) {
      }
    }
    $videoPlayerPlaying() {
      this.PlayPause.setVariant("pause");
      this.Poster.visible = false;
      this._autoHideSoon();
    }
    $videoPlayerPause() {
      this.PlayPause.setVariant("play");
      this._showControls();
    }
    $videoPlayerWaiting() {
      this._showControls();
    }
    $videoPlayerStop() {
      this.PlayPause.setVariant("play");
      this.Poster.visible = true;
      this._showControls();
    }
    $videoPlayerEnded() {
      this.Poster.visible = true;
      this._showControls();
      this._exitPlayer();
    }
    $videoPlayerError() {
      this.Poster.visible = true;
      this._showControls();
    }
    _ensureControlsShown() {
      if (!this._controlsVisible) {
        this._showControls();
        return true;
      }
      return false;
    }
    _handleEnter() {
      if (this._ensureControlsShown()) return true;
      const key = FOCUS_ORDER[this._focusIndex];
      if (key === "BackBtn") {
        this._exitPlayer();
        return true;
      }
      if (key === "PlayPause") {
        const playing = !!VideoPlayer_default2.playing;
        playing ? VideoPlayer_default2.pause() : VideoPlayer_default2.play();
        this._autoHideSoon();
        return true;
      }
      if (key === "Back30") {
        this._skip(-SKIP_SECONDS);
        this._autoHideSoon();
        return true;
      }
      if (key === "Fwd30") {
        this._skip(+SKIP_SECONDS);
        this._autoHideSoon();
        return true;
      }
      if (key === "Progress") {
        if (!this._scrubbing) this._enterScrubMode();
        else this._commitScrub();
        return true;
      }
      return false;
    }
    _handleBack() {
      if (this._scrubbing) {
        this._cancelScrub();
        return true;
      }
      this._exitPlayer();
      return true;
    }
    _handleLeft() {
      if (this._ensureControlsShown()) return true;
      if (this._scrubbing && FOCUS_ORDER[this._focusIndex] === "Progress") {
        this._nudgeScrub(-1);
        return true;
      }
      if (this._focusIndex > 0) {
        this._focusIndex--;
        this._applyItemFocus();
      }
      this._autoHideSoon();
      return true;
    }
    _handleRight() {
      if (this._ensureControlsShown()) return true;
      if (this._scrubbing && FOCUS_ORDER[this._focusIndex] === "Progress") {
        this._nudgeScrub(1);
        return true;
      }
      if (this._focusIndex < FOCUS_ORDER.length - 1) {
        this._focusIndex++;
        this._applyItemFocus();
      }
      this._autoHideSoon();
      return true;
    }
    _handleUp() {
      if (this._ensureControlsShown()) {
        this._focusIndex = 0;
        this._applyItemFocus();
        return true;
      }
      if (!this._scrubbing) {
        this._focusIndex = 0;
        this._applyItemFocus();
        this._autoHideSoon();
      }
      return true;
    }
    _handleDown() {
      if (this._ensureControlsShown()) {
        this._focusIndex = 1;
        this._applyItemFocus();
        return true;
      }
      if (this._scrubbing) {
        this._cancelScrub();
        return true;
      }
      if (this._focusIndex < FOCUS_ORDER.length - 1) this._focusIndex++;
      this._applyItemFocus();
      this._autoHideSoon();
      return true;
    }
    _applyItemFocus() {
      this._styleProgress(false);
      const key = FOCUS_ORDER[this._focusIndex];
      if (key === "Progress") this._styleProgress(true);
    }
    _styleProgress(on) {
      this.ProgressTrack.setSmooth("h", on ? 10 : 10, { duration: 0.12 });
      this.ProgressFill.setSmooth("h", on ? 10 : 10, { duration: 0.12 });
      this.ProgressTrack.color = on ? 1728053247 : 1157627903;
      this.ProgressFill.color = on ? 4278222503 : 3439329279;
      this.ProgressTimes.patch({
        text: { textColor: on ? 4294967295 : 4291875024 }
      });
      this.ProgressTimes.setSmooth("alpha", on ? 1 : 0.85, { duration: 0.12 });
      this.ProgressGlow.setSmooth("alpha", on ? 0.2 : 0, { duration: 0.12 });
      if (!this._scrubbing)
        this.ProgressThumb.setSmooth("alpha", 0, { duration: 0.12 });
    }
    _skip(delta) {
      const dur = Math.max(0, this._vpGet("duration", 0));
      const cur = Math.max(0, this._vpGet("currentTime", 0));
      const target = Math.max(0, Math.min(dur, cur + delta));
      VideoPlayer_default2.seek(target);
    }
    _enterScrubMode() {
      this._scrubbing = true;
      this._wasPlayingBeforeScrub = !!VideoPlayer_default2.playing;
      if (this._wasPlayingBeforeScrub) VideoPlayer_default2.pause();
      const dur = Math.max(0, this._vpGet("duration", 0));
      const cur = Math.max(0, this._vpGet("currentTime", 0));
      this._scrubPct = dur > 0 ? cur / dur : 0;
      this._updateThumbFromPct();
      this.ProgressThumb.setSmooth("alpha", 1, { duration: 0.12 });
      this._clearAutohide();
    }
    _commitScrub() {
      const dur = Math.max(0, this._vpGet("duration", 0));
      const target = Math.max(0, Math.min(dur, Math.round(dur * this._scrubPct)));
      VideoPlayer_default2.seek(target);
      if (this._wasPlayingBeforeScrub) VideoPlayer_default2.play();
      this._scrubbing = false;
      this.ProgressThumb.setSmooth("alpha", 0, { duration: 0.12 });
      this._autoHideSoon();
      VideoPlayer_default2.play();
    }
    _cancelScrub() {
      this._scrubbing = false;
      this.ProgressThumb.setSmooth("alpha", 0, { duration: 0.12 });
      if (this._wasPlayingBeforeScrub) VideoPlayer_default2.play();
      this._autoHideSoon();
    }
    _nudgeScrub(dir) {
      const stepPct = 0.02;
      this._scrubPct = Math.max(0, Math.min(1, this._scrubPct + dir * stepPct));
      this._updateThumbFromPct();
      const dur = Math.max(0, this._vpGet("duration", 0)) || 0;
      const preview = Math.round(dur * this._scrubPct);
      const cur = Math.max(0, this._vpGet("currentTime", 0));
      this.ProgressTimes.text = {
        text: `${this._fmt(cur)}  \u27F6  ${this._fmt(preview)} / ${this._fmt(dur)}`
      };
    }
    _updateThumbFromPct() {
      const trackW = this.ProgressTrack.w;
      const x = Math.round(trackW * this._scrubPct);
      this.ProgressThumb.x = x - Math.floor(this.ProgressThumb.w / 2);
    }
    _showControls(init2 = false) {
      this._controlsVisible = true;
      this.Controls.setSmooth("alpha", 1, { duration: 0.2 });
      if (init2) this._focusIndex = 1;
      this._applyItemFocus();
      this._refocus();
      this._autoHideSoon();
    }
    _hideControls() {
      this._controlsVisible = false;
      this.Controls.setSmooth("alpha", 0, { duration: 0.2 });
      this._clearAutohide();
    }
    _autoHideSoon(delay2 = 3e3) {
      this._clearAutohide();
      if (!this._scrubbing) {
        this._hideTimer = setTimeout(
          () => this._hideControls(),
          delay2
        );
      }
    }
    _clearAutohide() {
      if (this._hideTimer) {
        clearTimeout(this._hideTimer);
        this._hideTimer = void 0;
      }
    }
    _startTick() {
      this._clearTick();
      this._tickTimer = setInterval(
        () => this._updateProgressUI(),
        250
      );
    }
    _clearTick() {
      if (this._tickTimer) {
        clearInterval(this._tickTimer);
        this._tickTimer = void 0;
      }
    }
    _clearTimers() {
      this._clearAutohide();
      this._clearTick();
    }
    _updateProgressUI() {
      var _a, _b;
      const safeNum = (v, fb = 0) => {
        const n = Number(v);
        return Number.isFinite(n) && n >= 0 ? n : fb;
      };
      const fmtSafe = (v, placeholder = "00:00") => Number.isFinite(Number(v)) && Number(v) >= 0 ? this._fmt(v) : placeholder;
      const dur = safeNum(this._vpGet("duration", 0), 0);
      const cur = safeNum(this._vpGet("currentTime", 0), 0);
      const trackW = safeNum((_a = this.ProgressTrack) == null ? void 0 : _a.w, 0);
      const thumbW = safeNum((_b = this.ProgressThumb) == null ? void 0 : _b.w, 6);
      const pct = dur > 0 ? Math.min(1, Math.max(0, cur / dur)) : 0;
      if (!this._scrubbing) {
        const fillW = Math.round(trackW * pct);
        this.ProgressFill.w = Math.max(0, Math.min(trackW, fillW));
        this.ProgressTimes.text = {
          text: `${fmtSafe(cur)} / ${fmtSafe(dur)}`
        };
        const thumbX = Math.round(trackW * pct) - Math.floor(thumbW / 2);
        this.ProgressThumb.x = Math.max(0, Math.min(trackW - thumbW, thumbX));
      } else {
        this.ProgressFill.w = Math.round(
          trackW * Math.min(1, Math.max(0, this._scrubPct))
        );
      }
      const playing = !!VideoPlayer_default2.playing;
      this.PlayPause.setVariant(playing ? "pause" : "play");
    }
    _fmt(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
    }
    _vpGet(key, fallback) {
      const v = VideoPlayer_default2[key];
      if (typeof v === "function") return v.call(VideoPlayer_default2);
      if (v === void 0 || v === null) return fallback;
      return v;
    }
    _buildMetadata(d) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!d) return "";
      const year = (_b = (_a = d.year) != null ? _a : d.releaseYear) != null ? _b : "";
      const duration = d.duration;
      const author = (_e = (_d = (_c = d.author) != null ? _c : d.director) != null ? _d : d.creator) != null ? _e : "";
      const genre = (_g = (_f = d.genre) != null ? _f : Array.isArray(d.genres) ? d.genres.join(", ") : d.genres) != null ? _g : "";
      const parts = [
        year ? `${year}` : null,
        duration ? `${duration} min` : null,
        author ? `${author}` : null,
        genre ? `${genre}` : null
      ].filter(Boolean);
      return parts.join("  \u2022  ");
    }
    onParams(params) {
      var _a;
      const title = (_a = params == null ? void 0 : params.title) != null ? _a : "Now Playing";
      this.tag("Controls.Title").text = { text: title };
    }
  };

  // src/pages/Boot.ts
  var W = 1920;
  var H = 1080;
  var Boot = class extends Lightning_default.Component {
    static _template() {
      return {
        w: W,
        h: H,
        rect: true,
        color: Theme.colors.bg,
        Wrapper: {
          mount: 0.5,
          x: W / 2,
          y: H / 2,
          Spinner: { w: 100, h: 100, mount: 0.5, x: 0, y: -20 },
          Label: {
            mount: 0.5,
            x: 0,
            y: 90,
            text: {
              text: "Loading\u2026",
              fontSize: 38,
              textColor: Theme.colors.textDim,
              fontFace: "RelaxAI-SoraMedium"
            }
          }
        }
      };
    }
    _init() {
      this._buildSpinner();
      this._startSpinner();
      this._loadData();
    }
    _inactive() {
      this._stopSpinner();
    }
    _detach() {
      this._stopSpinner();
    }
    _startSpinner() {
      const spinner = this.tag("Spinner");
      let angle = 0;
      this._spinTimer = setInterval(() => {
        angle = (angle + 6) % 360;
        spinner.rotation = angle * Math.PI / 180;
      }, 16);
    }
    _stopSpinner() {
      if (this._spinTimer) {
        clearInterval(this._spinTimer);
        this._spinTimer = void 0;
      }
    }
    _buildSpinner() {
      const spinner = this.tag("Spinner");
      const TICKS = 12;
      const R = 40;
      const BAR_W = 8;
      const BAR_H = 20;
      const cx = spinner.w / 2;
      const cy = spinner.h / 2;
      const ticks = [];
      for (let i = 0; i < TICKS; i++) {
        const ang = i / TICKS * Math.PI * 2;
        ticks.push({
          type: Lightning_default.Component,
          x: cx,
          y: cy,
          rotation: ang,
          Bar: {
            mountX: 0.5,
            mountY: 1,
            x: 0,
            y: -R,
            w: BAR_W,
            h: BAR_H,
            rect: true,
            color: Theme.colors.accent,
            alpha: 0.25 + i / TICKS * 0.75
          }
        });
      }
      spinner.children = ticks;
    }
    _loadData() {
      return __async(this, null, function* () {
        try {
          yield DataStore_default.init("local");
          yield new Promise((r) => setTimeout(r, 2e3));
          Router_default.resume();
        } catch (e) {
          console.error("[Boot] Error cargando datos:", e);
          this.tag("Label").text = { text: "Error cargando datos" };
        }
      });
    }
  };

  // src/pages/Breathe.ts
  var GAP23 = 30;
  var GAP4 = 60;
  var HEADER_H4 = 200;
  var CAROUSSEL_H3 = 600;
  var RAIL_H4 = 230;
  var BreatheSection = class _BreatheSection extends BasePage {
    get hasHeader() {
      return true;
    }
    get sections() {
      return ["Carussel", "TopSearches", "NextWatch", "Retro"];
    }
    get defaultHeights() {
      return {
        Header: HEADER_H4,
        Carussel: CAROUSSEL_H3,
        TopSearches: RAIL_H4,
        NextWatch: RAIL_H4,
        Retro: RAIL_H4
      };
    }
    static _template() {
      return BasePage.chrome({
        Header: {
          type: Header,
          h: HEADER_H4,
          signals: { navigate: true, focusNext: true }
        },
        Carussel: {
          y: HEADER_H4 + GAP23,
          h: CAROUSSEL_H3,
          x: 40,
          type: CarouselComp,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        TopSearches: {
          y: HEADER_H4 + GAP23 + CAROUSSEL_H3 + GAP23,
          h: RAIL_H4,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        NextWatch: {
          y: HEADER_H4 + GAP23 + CAROUSSEL_H3 + GAP23 + RAIL_H4 + GAP4,
          h: RAIL_H4,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        Retro: {
          y: HEADER_H4 + GAP23 + CAROUSSEL_H3 + GAP23 + RAIL_H4 + GAP4 + RAIL_H4 + GAP4,
          h: RAIL_H4,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        }
      });
    }
    _focus() {
      var _a, _b;
      const name = getActiveRouteName();
      (_b = (_a = this.tag("Viewport.Content.ContentInner.Header")) == null ? void 0 : _a.setCurrentByRoute) == null ? void 0 : _b.call(_a, name);
    }
    _active() {
      return __async(this, null, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        __superGet(_BreatheSection.prototype, this, "_active").call(this);
        const dataCarousel = (_a = DataStore_default.data.rail3) == null ? void 0 : _a.slice(0, 15);
        this.tag("Viewport.Content.ContentInner.Carussel").items = dataCarousel != null ? dataCarousel : [];
        const inner = "Viewport.Content.ContentInner";
        (_d = this.tag(`${inner}.TopSearches`)) == null ? void 0 : _d.patch({
          title: "Top searches",
          items: (_c = (_b = DataStore_default.data.rail1) == null ? void 0 : _b.slice(0, 15)) != null ? _c : []
        });
        (_g = this.tag(`${inner}.NextWatch`)) == null ? void 0 : _g.patch({
          title: "Your next watch",
          items: (_f = (_e = DataStore_default.data.rail4) == null ? void 0 : _e.slice(0, 15)) != null ? _f : []
        });
        (_j = this.tag(`${inner}.Retro`)) == null ? void 0 : _j.patch({
          title: "Retro TV",
          items: (_i = (_h = DataStore_default.data.rail2) == null ? void 0 : _h.slice(0, 15)) != null ? _i : []
        });
        this.computeAfterLayout();
      });
    }
  };

  // src/pages/Longform.ts
  var GAP24 = 30;
  var GAP5 = 60;
  var HEADER_H5 = 200;
  var CAROUSSEL_H4 = 600;
  var RAIL_H5 = 230;
  var LongformSection = class _LongformSection extends BasePage {
    get hasHeader() {
      return true;
    }
    get sections() {
      return ["Carussel", "TopSearches", "NextWatch", "Retro"];
    }
    get defaultHeights() {
      return {
        Header: HEADER_H5,
        Carussel: CAROUSSEL_H4,
        TopSearches: RAIL_H5,
        NextWatch: RAIL_H5,
        Retro: RAIL_H5
      };
    }
    static _template() {
      return BasePage.chrome({
        Header: {
          type: Header,
          h: HEADER_H5,
          signals: { navigate: true, focusNext: true }
        },
        Carussel: {
          x: 40,
          y: HEADER_H5 + GAP24,
          h: CAROUSSEL_H4,
          type: CarouselComp,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        TopSearches: {
          y: HEADER_H5 + GAP24 + CAROUSSEL_H4 + GAP24,
          h: RAIL_H5,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        NextWatch: {
          y: HEADER_H5 + GAP24 + CAROUSSEL_H4 + GAP24 + RAIL_H5 + GAP5,
          h: RAIL_H5,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        },
        Retro: {
          y: HEADER_H5 + GAP24 + CAROUSSEL_H4 + GAP24 + RAIL_H5 + GAP5 + RAIL_H5 + GAP5,
          h: RAIL_H5,
          type: Rail,
          signals: { focusPrev: true, focusNext: true, navigate: true }
        }
      });
    }
    _focus() {
      var _a, _b;
      const routeName = getActiveRouteName();
      (_b = (_a = this.tag("Viewport.Content.ContentInner.Header")) == null ? void 0 : _a.setCurrentByRoute) == null ? void 0 : _b.call(
        _a,
        routeName
      );
    }
    _active() {
      return __async(this, null, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        __superGet(_LongformSection.prototype, this, "_active").call(this);
        const inner = "Viewport.Content.ContentInner";
        const carouselData = (_b = (_a = DataStore_default.data.rail5) == null ? void 0 : _a.slice(0, 15)) != null ? _b : [];
        this.tag(`${inner}.Carussel`).items = carouselData;
        (_e = this.tag(`${inner}.TopSearches`)) == null ? void 0 : _e.patch({
          title: "Top searches",
          items: (_d = (_c = DataStore_default.data.rail4) == null ? void 0 : _c.slice(0, 15)) != null ? _d : []
        });
        (_h = this.tag(`${inner}.NextWatch`)) == null ? void 0 : _h.patch({
          title: "Your next watch",
          items: (_g = (_f = DataStore_default.data.rail3) == null ? void 0 : _f.slice(0, 15)) != null ? _g : []
        });
        (_k = this.tag(`${inner}.Retro`)) == null ? void 0 : _k.patch({
          title: "Retro TV",
          items: (_j = (_i = DataStore_default.data.rail2) == null ? void 0 : _i.slice(0, 15)) != null ? _j : []
        });
        this.computeAfterLayout();
      });
    }
  };

  // src/atoms/SearchInput.ts
  var SearchInput = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._value = "";
      this._placeholder = "Search...";
    }
    static _template() {
      return {
        Input: {
          x: 0,
          y: 0,
          w: (w) => w,
          h: (h) => h,
          Bg: {
            x: 0,
            y: 0,
            w: (w) => w,
            h: (h) => h,
            rect: true,
            color: 4279442218,
            shader: null
          },
          SearchText: {
            x: 40,
            y: 12,
            w: (w) => w,
            h: (h) => h,
            rect: true,
            text: {
              text: "Search...",
              fontSize: 38,
              textColor: 4294967295,
              fontFace: "RelaxAI-SoraMedium"
            }
          }
        }
      };
    }
    get value() {
      return this._value;
    }
    set value(v) {
      this._value = (v != null ? v : "").trimStart();
      this._renderText();
      this.signal("changed", this._value);
    }
    get placeholder() {
      return this._placeholder;
    }
    set placeholder(v) {
      this._placeholder = v != null ? v : "Search...";
      this._renderText();
    }
    clear() {
      this._value = "";
      this._renderText();
    }
    setValue(v) {
      this._value = v;
      this._renderText();
    }
    _focus() {
      this.tag("Bg").patch({
        shader: {
          type: Lightning_default.shaders.Outline,
          thickness: 16,
          pixelSize: 16,
          color: Theme.colors.accent
        }
      });
      this._renderText();
      this.signal("onFocus");
    }
    _unfocus() {
      this.tag("Bg").patch({
        shader: null
      });
      this._renderText();
    }
    _handleEnter() {
      this.signal("enter", this._value);
      return true;
    }
    _renderText() {
      const empty = this._value.length === 0;
      const text = empty ? this._placeholder : this._value;
      const color = empty ? Theme.colors.textDim : Theme.colors.text;
      this.tag("SearchText").patch({ text: { text }, color });
    }
  };
  var SearchInput_default = SearchInput;

  // src/molecules/Grid.ts
  var TILE_W = 300;
  var TILE_H = 250;
  var GAP_X = 30;
  var GAP_Y = 24;
  var STEP_X = TILE_W + GAP_X;
  var VIEW_W2 = 1840;
  var VIEW_H = 800;
  var LEFT_PAD2 = 40;
  var Grid2 = class extends Lightning_default.Component {
    constructor() {
      super(...arguments);
      this._index = 0;
      this._cols = 0;
      this._totalW = 0;
      this._totalH = 0;
      this._itemsLen = 0;
      this.config = {};
    }
    static _template() {
      return {
        Title: {
          x: LEFT_PAD2,
          y: 0,
          text: {
            text: "",
            fontSize: 36,
            fontFace: "RelaxAI-SoraRegular",
            textColor: Theme.colors.text
          }
        },
        Viewport: {
          x: 0,
          y: 100,
          w: VIEW_W2 + LEFT_PAD2,
          clipping: false,
          Grid: {
            x: LEFT_PAD2,
            y: 0,
            transitions: {
              x: { duration: 0.25, timingFunction: "ease-out" },
              y: { duration: 0.25, timingFunction: "ease-out" }
            }
          }
        }
      };
    }
    reset() {
      this._index = 0;
      this._scrollToIndex();
      this._emitFocusMoved();
    }
    getFocusIndex() {
      return this._index;
    }
    setFocusIndex(i) {
      const max = Math.max(0, this._itemsLen - 1);
      this._index = Math.max(0, Math.min(i != null ? i : 0, max));
      this._scrollToIndex();
      this._emitFocusMoved();
      this._refocus();
    }
    set title(v) {
      this.tag("Title").text.text = v;
    }
    set items(v) {
      var _a, _b, _c, _d, _e;
      const viewW = VIEW_W2;
      const gapX = (_a = this.config.gapX) != null ? _a : GAP_X;
      const gapY = (_b = this.config.gapY) != null ? _b : GAP_Y;
      const tileW = (_c = this.config.tileW) != null ? _c : TILE_W;
      const tileH = (_d = this.config.tileH) != null ? _d : TILE_H;
      const stepX = tileW + gapX;
      const stepY = tileH + gapY;
      const colsAuto = Math.max(1, Math.floor(viewW / STEP_X));
      this._cols = Math.max(1, (_e = this.config.cols) != null ? _e : colsAuto);
      this._itemsLen = v.length;
      this.tag("Viewport.Grid").children = v.map((it, i) => {
        const col = i % this._cols;
        const row = Math.floor(i / this._cols);
        return {
          type: Tile,
          x: col * stepX,
          y: row * stepY,
          data: it,
          signals: { navigate: "onChildNavigate" }
        };
      });
      const rows = Math.ceil(v.length / this._cols);
      this._totalW = Math.max(this._cols * stepX, viewW);
      this._totalH = Math.max(rows * stepY, VIEW_H);
      const max = Math.max(0, v.length - 1);
      this._index = Math.max(0, Math.min(this._index, max));
      this._scrollToIndex();
      this._emitFocusMoved();
    }
    onChildNavigate(path, params) {
      this.signal("navigate", path, params);
    }
    _getFocused() {
      return this.tag("Viewport.Grid").children[this._index];
    }
    _handleLeft() {
      if (this._itemsLen === 0) return true;
      const col = this._colOf(this._index);
      if (col > 0) {
        this._index--;
        this._scrollToIndex();
        this._emitFocusMoved();
      }
      return true;
    }
    _handleRight() {
      if (this._itemsLen === 0) return true;
      const col = this._colOf(this._index);
      const lastCol = this._cols - 1;
      if (this._index < this._itemsLen - 1 && col < lastCol) {
        this._index++;
        this._scrollToIndex();
        this._emitFocusMoved();
      }
      return true;
    }
    _handleUp() {
      if (this._itemsLen === 0) return true;
      const next = this._index - this._cols;
      if (next >= 0) {
        this._index = next;
        this._scrollToIndex();
        this._emitFocusMoved();
      } else {
        this.signal("focusPrev");
      }
      return true;
    }
    _handleDown() {
      if (this._itemsLen === 0) return true;
      const next = this._index + this._cols;
      if (next <= this._itemsLen - 1) {
        this._index = next;
        this._scrollToIndex();
        this._emitFocusMoved();
      } else {
        this.signal("focusNext");
      }
      return true;
    }
    _rowOf(i) {
      return Math.floor(i / this._cols);
    }
    _colOf(i) {
      return i % this._cols;
    }
    _emitFocusMoved() {
      var _a, _b;
      const gapY = (_a = this.config.gapY) != null ? _a : GAP_Y;
      const tileH = (_b = this.config.tileH) != null ? _b : TILE_H;
      const row = this._rowOf(this._index);
      const col = this._colOf(this._index);
      const anchorY = row * (tileH + gapY);
      const centerY = anchorY + tileH / 2;
      const rowH = tileH + gapY;
      this.signal("focusMoved", {
        index: this._index,
        row,
        col,
        anchorY,
        centerY,
        rowH,
        cols: this._cols,
        itemsLen: this._itemsLen
      });
    }
    _scrollToIndex() {
      var _a, _b;
      const grid = this.tag("Viewport.Grid");
      const gapX = (_a = this.config.gapX) != null ? _a : GAP_X;
      const tileW = (_b = this.config.tileW) != null ? _b : TILE_W;
      const viewW = VIEW_W2;
      const col = this._colOf(this._index);
      const targetCenterX = col * (tileW + gapX) + tileW / 2;
      const maxScrollX = Math.max(0, this._totalW - viewW);
      const scrollX = Math.min(
        Math.max(targetCenterX - viewW / 2, 0),
        maxScrollX
      );
      grid.setSmooth("x", LEFT_PAD2 - scrollX);
    }
  };
  var Grid_default = Grid2;

  // src/utils/searchUtils.ts
  function searchItems(data, query) {
    var _a;
    const results = [];
    if (!query.trim()) return results;
    const normalizedQuery = query.toLowerCase();
    for (const railKey of Object.keys(data)) {
      const items = (_a = data[railKey]) != null ? _a : [];
      for (const item of items) {
        const searchable = [
          item.title
          // disabled search in teh all content
          // item.text,
          // item.description,
          // item.author,
          // item.genres?.join(" "),
        ].join(" ").toLowerCase();
        if (searchable.includes(normalizedQuery)) {
          results.push(item);
        }
      }
    }
    return results;
  }

  // src/utils/Basekey/ActionKey.ts
  var ActionKey = class extends Key {
    _active() {
      this.label = { mountY: 0.45, fontSize: 36 };
      this.labelColors = {
        unfocused: Theme.colors.text,
        focused: Theme.colors.bg
      };
      this.backgroundColors = {
        unfocused: Theme.colors.bg,
        focused: Theme.colors.accent
      };
      if (this.hasFocus()) this._focus();
    }
    get width() {
      return 160;
    }
    get height() {
      return 50;
    }
  };

  // src/utils/Basekey/Key.ts
  var Key2 = class extends Key {
    _firstActive() {
      this.label = { mountY: 0.45, fontSize: 36 };
      this.labelColors = {
        unfocused: Theme.colors.text,
        focused: Theme.colors.bg
      };
      this.backgroundColors = {
        unfocused: Theme.colors.bg,
        focused: Theme.colors.accent
      };
      if (this.hasFocus()) this._focus();
    }
    get width() {
      return 50;
    }
    get height() {
      return 50;
    }
  };

  // src/utils/keyboardConfig.ts
  var keyboardConfig = {
    layout: "grid-en",
    layouts: {
      abc: [
        ["q", "w", "e", "r", "t", "y", "u", "i"],
        ["o", "p", "a", "s", "d", "f", "g", "h"],
        ["j", "k", "l", "z", "x", "c", "v", "b"],
        ["n", "m", ",", ".", "'", "-", "/", "="],
        [
          "Layout:ABC",
          "Layout:@#&",
          "Space:space",
          "Backspace:\u2190",
          "Clear:clear",
          "Submit:search"
        ]
      ],
      ABC: [
        ["Q", "W", "E", "R", "T", "Y", "U", "I"],
        ["O", "P", "A", "S", "D", "F", "G", "H"],
        ["J", "K", "L", "Z", "X", "C", "V", "B"],
        ["N", "M", "<", ">", '"', "_", "?", ":"],
        [
          "Layout:abc",
          "Layout:@#&",
          "Space:space",
          "Backspace:\u2190",
          "Clear:clear",
          "Submit:search"
        ]
      ],
      "@#&": [
        ["1", "2", "3", "4", "5", "6", "7", "8"],
        ["9", "0", "!", "@", "#", "$", "%", "^"],
        ["&", "*", "(", ")", "-", "_", "+", "="],
        ["/", "\\", ":", ";", '"', "'", ".", "?"],
        [
          "Layout:abc",
          "Layout:ABC",
          "Space:space",
          "Backspace:\u2190",
          "Clear:clear",
          "Submit:search"
        ]
      ]
    },
    styling: { align: "center", horizontalSpacing: 8, verticalSpacing: 24 },
    buttonTypes: {
      default: { type: Key2, w: 120, h: 64 },
      Layout: { type: ActionKey, w: 120, h: 64 },
      Space: { type: ActionKey, w: 130, h: 64 },
      Backspace: { type: ActionKey, w: 100, h: 64 },
      Clear: { type: ActionKey, w: 120, h: 64 },
      Submit: { type: ActionKey, w: 150, h: 64 }
    }
  };

  // src/pages/Search.ts
  var HEADER_H6 = 200;
  var GAP_H = 40;
  var GAP_W = 40;
  var SearchSection = class extends BasePage {
    constructor() {
      super(...arguments);
      this._keyboardVisible = true;
      this._value = "";
      this._onLoadResults = false;
    }
    get hasHeader() {
      return true;
    }
    get sections() {
      const s = ["SearchInput"];
      if (this._keyboardVisible) s.push("KeyboardWrap.Keyboard");
      if (this._onLoadResults) s.push("Results");
      return s;
    }
    get defaultHeights() {
      return { Header: HEADER_H6, SearchInput: 80 };
    }
    get Keyboard() {
      return this.tag("KeyboardWrap.Keyboard");
    }
    static _template() {
      return BasePage.chrome({
        Header: {
          type: Header,
          h: HEADER_H6,
          signals: { navigate: true, focusNext: true }
        },
        SearchInput: {
          x: GAP_W,
          y: HEADER_H6 + GAP_H,
          w: Theme.w - GAP_W * 2,
          h: 80,
          type: SearchInput_default,
          signals: { enter: "onSearchInputEnter", onFocus: "onFocusInput" }
        },
        KeyboardWrap: {
          y: HEADER_H6 + GAP_H + 120,
          x: GAP_W,
          Keyboard: {
            type: Keyboard,
            currentLayout: "abc",
            config: keyboardConfig,
            signals: { onInputChanged: true, onSubmit: true, onClear: true }
          }
        },
        NotFound: {
          y: HEADER_H6 + GAP_H + 140,
          x: GAP_W,
          alpha: 0,
          visible: false,
          text: {
            text: "No results found",
            fontSize: 36,
            fontFace: "RelaxAI-SoraRegular",
            textColor: Theme.colors.text
          }
        },
        Results: {
          y: HEADER_H6 + GAP_H + 140,
          type: Grid2,
          config: { cols: 5, rowsVisible: 1, gapX: 68, gapY: 0, tileH: 230 },
          signals: {
            focusPrev: true,
            focusNext: true,
            navigate: true,
            focusMoved: true
          }
        }
      });
    }
    _resetView() {
      this._onLoadResults = false;
      this.value = "";
      this._value = "";
      this._section = 1;
      this.hideResults();
      this.tag("Viewport.Content").y = this._clamp(0);
      this._showKeyboard();
      this.Keyboard.clear();
      this.Keyboard.resetFocus();
    }
    _active() {
      if (Router_default._resetNextPage) this._resetView();
      this._section = 1;
      super._active();
    }
    onFocusInput() {
      this.tag("Viewport.Content").setSmooth(
        "y",
        this._clamp(0)
      );
    }
    set value(v) {
      var _a, _b;
      this._value = v;
      (_b = (_a = this.tag("SearchInput")) == null ? void 0 : _a.setValue) == null ? void 0 : _b.call(_a, v);
    }
    get value() {
      return this._value;
    }
    _showKeyboard() {
      const wrap = this.tag("KeyboardWrap");
      wrap.visible = true;
      wrap.patch({ smooth: { alpha: 1 } });
      this._keyboardVisible = true;
      this.tag("NotFound").patch({ alpha: 0, visible: false });
      this._section = 1;
      this.Keyboard.resetFocus();
      this._refocus();
    }
    _hideKeyboard() {
      const wrap = this.tag("KeyboardWrap");
      wrap.patch({ smooth: { alpha: 0 } });
      wrap.visible = false;
      this._keyboardVisible = false;
      this._section = 0;
      this._refocus();
    }
    focusPrev() {
      if (!this.enableScrollSnap) return;
      const min = this.hasHeader ? -1 : 0;
      this._section = Math.max(this._section - 1, min);
      this._applyScrollForSection(this._section);
      this._syncHistorySnapshot();
    }
    _focus() {
      var _a, _b, _c;
      const routeName = getActiveRouteName();
      (_b = (_a = this.tag("Viewport.Content.ContentInner.Header")) == null ? void 0 : _a.setCurrentByRoute) == null ? void 0 : _b.call(
        _a,
        routeName
      );
      if (!this.wasRestoredFromHistory && this._section < 0) {
        this._section = 0;
        (_c = this._applyScrollForSection) == null ? void 0 : _c.call(this, 0);
      } else this._refocus();
    }
    get shouldScrollOnSection() {
      return (index) => index >= 2;
    }
    showResults() {
      var _a;
      (_a = this.tag("Viewport.Content.ContentInner.Results")) == null ? void 0 : _a.patch({
        visible: true,
        alpha: 1
      });
    }
    hideResults() {
      var _a;
      (_a = this.tag("Viewport.Content.ContentInner.Results")) == null ? void 0 : _a.patch({
        visible: false,
        alpha: 0
      });
    }
    onSearchInputEnter(value) {
      if (!this._keyboardVisible) {
        this._onLoadResults = false;
        this._showKeyboard();
        this.hideResults();
      } else {
        if (value) {
          this.search(value);
          this._hideKeyboard();
        }
      }
    }
    search(v) {
      this._onLoadResults = true;
      const items = searchItems(DataStore_default.data, v);
      const inner = "Viewport.Content.ContentInner";
      const grid = this.tag(`${inner}.Results`);
      if (items.length > 0) {
        this.tag("NotFound").patch({ alpha: 0, visible: false });
        grid == null ? void 0 : grid.patch({ title: `Search results for ${v}`, items });
        grid == null ? void 0 : grid.reset();
        this.showResults();
        this.computeAfterLayout();
      } else {
        this.tag("NotFound").patch({ alpha: 1, visible: true });
        this._onLoadResults = false;
      }
      this.tag("Viewport.Content").setSmooth(
        "y",
        this._clamp(0)
      );
    }
    onInputChanged(data) {
      this.value = data.input;
    }
    onSubmit(data) {
      this.value = data.input;
      this._hideKeyboard();
      this.search(data.input);
    }
    onClear() {
      var _a, _b;
      this._value = "";
      (_b = (_a = this.tag("SearchInput")) == null ? void 0 : _a.setValue) == null ? void 0 : _b.call(_a, "");
    }
    focusMoved(payload) {
      var _a, _b, _c, _d;
      if (!this._onLoadResults) return;
      const content = this.tag("Viewport.Content");
      const viewport = this.tag("Viewport");
      const grid = this.tag("ResultsGrid");
      const baseOffset = HEADER_H6 + GAP_H + 140;
      const EXTRA_BOTTOM = -100;
      const CENTER_BIAS = 0;
      const cols = Math.max(1, payload.cols | 0);
      const row = Math.max(0, payload.row | 0);
      const tileH = Math.max(1, payload.rowH | 0);
      const gapY = Number(
        (_c = (_b = (_a = grid == null ? void 0 : grid.gapY) != null ? _a : grid == null ? void 0 : grid.spacingY) != null ? _b : grid == null ? void 0 : grid.itemSpacingY) != null ? _c : 0
      );
      const rowPitch = tileH + gapY;
      const totalRows = Math.max(1, Math.ceil(payload.itemsLen / cols));
      const lastRowBottom = totalRows * rowPitch - gapY;
      const viewportH = Number((_d = viewport == null ? void 0 : viewport.h) != null ? _d : 1080);
      const availableH = Math.max(1, viewportH - baseOffset - EXTRA_BOTTOM);
      let anchorPx = row * rowPitch + tileH / 2 - availableH / 2;
      anchorPx = Math.max(0, Math.min(anchorPx, lastRowBottom - availableH));
      const targetY = -(baseOffset + anchorPx) + CENTER_BIAS;
      const neededH = baseOffset + lastRowBottom + EXTRA_BOTTOM;
      if (content.h < neededH) content.h = neededH;
      content.setSmooth("y", targetY);
    }
  };

  // node_modules/@capacitor/app/dist/esm/index.js
  init_dist();
  var App = registerPlugin("App", {
    web: () => Promise.resolve().then(() => (init_web(), web_exports)).then((m) => new m.AppWeb())
  });

  // src/pages/Watchlist.ts
  var HEADER_H7 = 200;
  var WatchListSection = class _WatchListSection extends BasePage {
    get hasHeader() {
      return true;
    }
    get sections() {
      const items = watchlistStore.current;
      const sections = [];
      if (items.length > 0) {
        sections.push("WatchList");
      }
      return sections;
    }
    get enableScrollSnap() {
      return false;
    }
    get defaultHeights() {
      return {
        Header: HEADER_H7
      };
    }
    static _template() {
      return BasePage.chrome({
        Header: {
          type: Header,
          h: HEADER_H7,
          signals: { navigate: true, focusNext: true }
        },
        WatchList: {
          y: HEADER_H7 + 40,
          type: Grid_default,
          title: "List",
          config: { cols: 5, rowsVisible: 1, gapX: 68, gapY: 0, tileH: 230 },
          signals: {
            focusPrev: true,
            focusNext: true,
            navigate: true,
            focusMoved: true
          }
        }
      });
    }
    _focus() {
      var _a, _b;
      const name = getActiveRouteName();
      (_b = (_a = this.tag("Viewport.Content.ContentInner.Header")) == null ? void 0 : _a.setCurrentByRoute) == null ? void 0 : _b.call(_a, name);
    }
    focusNext() {
      var _a;
      if (watchlistStore.current.length === 0) {
        return;
      }
      const cur = (_a = this._section) != null ? _a : 0;
      const max = 0;
      this._section = Math.min(max, cur + 1);
      this._syncHistorySnapshot();
      this._refocus();
    }
    focusPrev() {
      console.log("[focusPrev]");
      const min = this.hasHeader ? -1 : 0;
      this._section = Math.max(this._section - 1, min);
      this._applyScrollForSection(this._section);
      this._syncHistorySnapshot();
      this._refocus();
    }
    _active() {
      return __async(this, null, function* () {
        __superGet(_WatchListSection.prototype, this, "_active").call(this);
        const items = watchlistStore.current;
        const inner = "Viewport.Content.ContentInner";
        const grid = this.tag(`${inner}.WatchList`);
        const title = items.length === 0 ? "Your watchlist is empty \u{1F622}" : "Your watchlist";
        grid == null ? void 0 : grid.patch({ title, items });
        this.computeAfterLayout();
      });
    }
    focusMoved(payload) {
      var _a, _b, _c, _d;
      const content = this.tag("Viewport.Content");
      const viewport = this.tag("Viewport");
      const grid = this.tag("WatchList");
      const HEADER_OFFSET = HEADER_H7 + 40;
      const EXTRA_BOTTOM = -100;
      const row = (_a = payload.row) != null ? _a : 0;
      const tileH = (_b = payload.rowH) != null ? _b : 230;
      const gapY = (_c = grid == null ? void 0 : grid.gapY) != null ? _c : 10;
      const rowPitch = tileH + gapY;
      const totalRows = Math.ceil(payload.itemsLen / payload.cols);
      if (row < 1) {
        content.setSmooth("y", 0);
        return;
      }
      let anchorPx = row * rowPitch;
      const viewportH = (_d = viewport == null ? void 0 : viewport.h) != null ? _d : 1080;
      const maxScroll = totalRows * rowPitch - viewportH + HEADER_OFFSET + EXTRA_BOTTOM;
      if (anchorPx > maxScroll) anchorPx = maxScroll;
      const targetY = -(HEADER_OFFSET + anchorPx);
      const neededH = HEADER_OFFSET + totalRows * rowPitch + EXTRA_BOTTOM;
      if (content.h < neededH) content.h = neededH;
      console.log(
        "[focusMoved] row",
        row,
        "targetY",
        targetY,
        "totalRows",
        totalRows
      );
      content.setSmooth("y", targetY);
    }
  };

  // src/App.ts
  var App2 = class extends Router_default.App {
    static _template() {
      return {
        w: Theme.w,
        h: Theme.h,
        color: Theme.colors.bg,
        Pages: {},
        Widgets: {}
      };
    }
    static getFonts() {
      return [
        {
          family: "RelaxAI-SoraBold",
          url: Utils_default.asset("fonts/Sora-Bold.ttf")
        },
        {
          family: "RelaxAI-SoraSemiBold",
          url: Utils_default.asset("fonts/Sora-SemiBold.ttf")
        },
        {
          family: "RelaxAI-SoraRegular",
          url: Utils_default.asset("fonts/Sora-Regular.ttf")
        },
        {
          family: "RelaxAI-SoraMedium",
          url: Utils_default.asset("fonts/Sora-Medium.ttf")
        },
        {
          family: "RelaxAI-SoraLight",
          url: Utils_default.asset("fonts/Sora-Light.ttf")
        },
        {
          family: "RelaxAI-Manrope",
          url: Utils_default.asset("fonts/Manrope-Regular.ttf")
        },
        {
          family: "RelaxAI-ManropeMed",
          url: Utils_default.asset("fonts/Manrope-Medium.ttf")
        }
      ];
    }
    _init() {
      App.addListener("backButton", () => {
        console.log("[App] backButton Listener");
        const ev = new KeyboardEvent("keydown", {
          key: "Backspace",
          keyCode: 8,
          which: 8
        });
        window.dispatchEvent(ev);
      });
    }
    _setup() {
      Router_default.startRouter({
        appInstance: this,
        bootComponent: Boot,
        root: "home",
        routes: [
          {
            path: "home",
            component: HomeSection,
            options: { preventStorage: false }
          },
          {
            path: "home/detail/:id",
            component: Detail,
            options: { preventStorage: false }
          },
          {
            path: "player/:id",
            component: Player,
            options: { preventStorage: false }
          },
          {
            path: "suggest",
            component: SuggestSection,
            options: { preventStorage: false }
          },
          {
            path: "suggest/detail/:id",
            component: Detail,
            options: { preventStorage: false }
          },
          {
            path: "breathe",
            component: BreatheSection,
            options: { preventStorage: false }
          },
          {
            path: "breathe/detail/:id",
            component: Detail,
            options: { preventStorage: false }
          },
          {
            path: "longform",
            component: LongformSection,
            options: { preventStorage: false }
          },
          {
            path: "longform/detail/:id",
            component: Detail,
            options: { preventStorage: false }
          },
          {
            path: "search",
            component: SearchSection,
            options: { preventStorage: false }
          },
          {
            path: "search/detail/:id",
            component: Detail,
            options: { preventStorage: false }
          },
          {
            path: "watchlist",
            component: WatchListSection,
            options: { preventStorage: false }
          },
          {
            path: "watchlist/detail/:id",
            component: Detail,
            options: { preventStorage: false }
          },
          { path: "*", redirect: "home" }
        ]
      });
    }
  };

  // src/index.ts
  function bootstrap(appSettings, platformSettings, appData) {
    return Launch_default(App2, appSettings, platformSettings, appData);
  }
  window.APP_RELAXAI = bootstrap;
})();
